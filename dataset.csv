code
"n, m = map(int,input().split())
count = 0
l = []

for i in range(n):
  for i2 in range(i,n):
    if i != i2:
      l.append([i,i2])

for i in range(m):
  for i2 in range(i,m):
    if i != i2:
      l.append([i,i2])
print(len(l))"
"MOD=10**9+7
UPPERLIMIT=2*10**5
MODMUL=[1, 1]+[0]*(UPPERLIMIT-1)
for i in range(2, UPPERLIMIT+1):
  MODMUL[i]=MODMUL[i-1]*i%MOD
MODDIV=[1]*UPPERLIMIT+[pow(MODMUL[-1], MOD-2, MOD)]
for i in range(UPPERLIMIT, 0, -1):
  MODDIV[i-1]=MODDIV[i]*i%MOD
def MODCOMB(n, r):
  return (((MODMUL[n]*MODDIV[r])%MOD)*MODDIV[n-r])%MOD

N, M=map(int, input().split())

from collections import defaultdict
def PrimeFactorization(x):
  out=defaultdict(int)
  for i in range(2, int(pow(x, 1/2))+1):
    while x%i==0:
      out[i]+=1
      x//=i
  if x>1:
    out[x]+=1
  return out

primenums=PrimeFactorization(M)
ans=1
for x in primenums.values():
  ans*=MODCOMB(N+x-1, N-1)
  ans%=MOD
  
print(ans)"
"T,X=map(int,input().split())
res = T/X
print(res)"
"def is_prime(n):
  if n == 2: return True
  if n < 2 or n % 2 == 0: return False
  return pow(2, n - 1, n) == 1

count = 0
for i in range(int(input())):
  if is_prime(int(input())) : count += 1
print(count)"
"a = input()
a = 48 - a
print a"
"n, k = map(int, input().split())

def cul(x):
    ans = (1 + x)*x/(2*x)
    return ans

p = list(map(cul, list(map(int, input().split()))))
cnt = sum(p[0:k])
ans = cnt
for i in range(k, n):
    cnt += p[i] - p[i - k]
    ans = max(ans, cnt)
print(ans)"
"a = list(map(int, input().split()))
count = 0
while all(x % 2 == 0 for x in a) and count <= 100000:
	b = [(sum(a) - x) // 2 for x in a]
	a = b
	count += 1
print(count if count <= 100000 else -1)"
"# -*- coding: utf-8 -*-


def main():
    a, b, c = map(int, input().split())

    if (a < c < b) or (b < c < a):
        print('Yes')
    else:
        print('No')


if __name__ == '__main__':
    main()
"
"def dfs(parent, connect, passed, N): #深さ優先探索
    cnt = 0
    passed.append(parent) #通った点をメモ
    if len(passed) == N: #全ての点を通過したかの判定
        cnt = 1
    for next_ in connect[parent]:
        if next_ in passed:
            continue
        cnt += dfs(next_, connect, passed, N) #全ての点を通るまで再帰. 戻り値の和で何通りかカウント
    passed.pop() #分岐点に戻る前にメモを1段だけ破棄
    return cnt    

N, M = map(int, input().split())
connect = [[] for _ in range(N)]
for _ in range(M):
    a, b = map(int, input().split())
    connect[a-1].append(b-1)
    connect[b-1].append(a-1)
ans = dfs(0, connect, [], N) #点0からのdfs
print(ans)"
"import math
arr = input().split( )
a = int(arr[0])
b1, b2 = arr[1].split('.')
b = int(b1)*100 + int(b2)
print(a*b//100)"
"n,x,y=map(int,input().split())

mi={i:0 for i in range(1,n)}
for i in range(1,n):
  for j in range(i+1,n+1):
    if i<=x and y<=j:
      mi[x-i+1+j-y]+=1
    elif x<i and y<=j:
      mi[min(i-x+1+j-y,j-i)]+=1
    elif i<=x and j<y:
      mi[min(x-i+1+y-j,j-i)]+=1
    elif x<i and j<y:
      mi[min(i-x+1+y-j,j-i)]+=1
    else:
      mi[j-i]+=1
      
for i in range(1,n):
  print(mi[i])"
"# Author: S Mahesh Raju
# Username: maheshraju2020
# Date: 31/07/2020

from sys import stdin, stdout, setrecursionlimit
from math import gcd, ceil, sqrt
from collections import Counter
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
setrecursionlimit(100000)
mod = 1000000007

h, w = iia()
arr = []
for i in range(h):
    arr.append(list(is1()))
dp = [[0 for i in range(w)] for j in range(h)]
dp[0][0] = 1
for i in range(h):
    for j in range(w):
        if i > 0 and j > 0 and arr[i][j] == '.':
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        elif i > 0 and arr[i][j] == '.':
            dp[i][j] = dp[i - 1][j]
        elif j > 0 and arr[i][j] == '.':
            dp[i][j] = dp[i][j - 1]
print(dp[-1][-1] % mod)"
"import sys

t, x = map(int, sys.stdin.readline().split())

def main():
    return t / x

if __name__ == '__main__':
    ans = main()
    print(ans)"
"n,a,b=map(int,input().split())
ans=0
for i in range(n):
    i+=1
    ii=str(i)
    cnt=0
    for j in ii:
        cnt+=int(j)
    if a<=cnt<=b:
        ans+=int(ii)
print(ans)"
"N,K = map(int,input().split())
S = list(input())
tmp = []
tmp.append(S[0])
for i in  range(1,N):
    if(S[i] != S[i-1]):
        tmp.append(S[i])
G = len(tmp)
G -= 2*K
G = max(G-1,0)

print(N-G-1)"
"n = int(input())
a = list(map(int, input().split()))
ma = max(a)
a = a[:a.index(ma)] + a[a.index(ma)+1:]
l = []
for i in range(n-1):
    l.append([abs(ma-2*a[i]), ""-"" if ma-2*a[i] >= 0 else ""+""])
l.sort()
print(ma,end="" "")
print((ma-l[0][0])//2) if l[0][1] == ""-"" else print((ma+l[0][0])//2)"
"s=list(input())
k=int(input())
for i in range(len(s)):
    if s[i]!=""1"":
        p=i+1
        pnum=int(s[i])
        break
    p=101

if k<p:
    print(1)
else:
    print(pnum)"
"# 与えられた数値の桁数と桁値の総和を計算する.
def calc_digit_sum(num):
    digits = sums = 0
    while num > 0:
        digits += 1
        sums += num % 10
        num //= 10
    return digits, sums


n = int(input())

answer = 0
for num in range(1, n + 1, 2):
    cnt = 0
    for candidate in range(1, num + 1):
        if num % candidate == 0:
            cnt += 1

    if cnt == 8:
        answer += 1

print(answer)
"
"s=input()
t=input()
a=0
f=False

for i in range(len(s)):
	a=s[-1]
	s=s[:-1]
	s=a+s
	
	if s==t:
		f=True
		break
		
if f:
	print('Yes')
else:
	print('No')"
"#!/usr/bin/python3
# import bisect
# from collections import Counter, deque, OrderedDict, defaultdict
from copy import copy, deepcopy # pythonのみ．copyは1次元，deepcopyは多次元．
# from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN
# from functools import reduce
# from heapq import heapify, heappop, heappush
# from itertools import accumulate, permutations, combinations, combinations_with_replacement, groupby, product
# import math
# import numpy as np  # Pythonのみ！
# from operator import xor
# import re
# from scipy.sparse.csgraph import connected_components  # Pythonのみ！
# ↑cf.  https://note.nkmk.me/python-scipy-connected-components/
# from scipy.sparse import csr_matrix
# import statistics # Pythonのみ
# import string
import unittest
from io import StringIO
import sys
sys.setrecursionlimit(10 ** 5 + 10)


def input(): return sys.stdin.readline().strip()


def resolve():

    n = int(input())

    import math

    # cf. https://qiita.com/suecharo/items/14137fb74c26e2388f1f

    def make_prime_list_2(num):
        if num < 2:
            return []

        # 0のものは素数じゃないとする
        prime_list = [i for i in range(num + 1)]
        prime_list[1] = 0  # 1は素数ではない
        num_sqrt = math.sqrt(num)

        for prime in prime_list:
            if prime == 0:
                continue
            if prime > num_sqrt:
                break

            for non_prime in range(2 * prime, num, prime):
                prime_list[non_prime] = 0

        return [prime for prime in prime_list if prime != 0]

    def prime_factorization_2(num):
        """"""numの素因数分解
        素因数をkeyに乗数をvalueに格納した辞書型dict_counterを返す""""""

        if num <= 1:
            return False
        else:
            num_sqrt = math.floor(math.sqrt(num))
            prime_list = make_prime_list_2(num_sqrt)

            dict_counter = {}  # 何度もこの関数を呼び出して辞書を更新したい時はこれを引数にして
            # cf. https://atcoder.jp/contests/arc034/submissions/12251452

            for prime in prime_list:
                while num % prime == 0:
                    if prime in dict_counter:
                        dict_counter[prime] += 1
                    else:
                        dict_counter[prime] = 1
                    num //= prime
            if num != 1:
                if num in dict_counter:
                    dict_counter[num] += 1
                else:
                    dict_counter[num] = 1

            return dict_counter

    def divisor_count(num):
        """"""numの約数の個数を求める""""""
        if num < 0:
            return None
        elif num == 1:
            return 1
        else:
            divisor_num = 1
            dict_fact = prime_factorization_2(num)
            for value in dict_fact.values():
                divisor_num *= (value + 1)
            return divisor_num

    ans = divisor_count(n-1)

    def make_divisors(n):
        divisors = []
        for i in range(1, int(n**0.5)+1):
            if n % i == 0:
                divisors.append(i)
                if i != n // i:  # 平方数の場合n**0.5を1つだけにしてる
                    divisors.append(n//i)

        # divisors.sort() # ソートしたけりゃして
        return divisors

    l = make_divisors(n)

    def main():
        cnt = 0
        for i in l:
            if i==1: continue
            v = copy(n)
            while v % i == 0:
                v /= i
            v%=i
            if v==1: cnt += 1
        return cnt

    print(ans+main()-1)


resolve()"
"x, y = map(str, input().split())
s = ['A', 'B', 'C', 'D', 'E', 'F']
for i in range(6):
    if x == s[i]:
        xi = i
    if y == s[i]:
        yi = i
if xi > yi:
    print('>')
elif xi < yi:
    print('<')
else:
    print('=')"
"H,w,d = map(int, raw_input().split())
mat = [map(int, raw_input().split()) for i in range(H)]

h = {}
cost = {}
for i in range(len(mat)):
	for j in range(len(mat[0])):
		h[mat[i][j]] = (i,j)

import collections
cost = collections.Counter()
def f(uu,vv): return abs(uu[0] -vv[0]) + abs(uu[1] -vv[1]) 
for u in range(1,H*w + 1):
	if u - d >= 1: cost[u] = f(h[u], h[u - d]) + cost[u - d]


def g(u,v, cost,d): return cost[v] - cost[u]# if  in cost else 0) 

for qi in  range(int(raw_input())):
	u,v = map(int, raw_input().split())
	print g(u,v,cost, d)"
"N,K=map(int,input().split())
p_N = [int(i) for i in input().split()]
import heapq
print(sum(heapq.nsmallest(K,p_N)))
"
"import sys

input = sys.stdin.readline


def main():
    N = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    n = sum(B) - sum(A)
    if n < 0:
        print(""No"")
        exit()

    n_need = 0
    for a, b in zip(A, B):
        if a > b:
            n_need += (a - b)
        elif a < b:
            n_need += (b - a) % 2

    ans = ""Yes"" if n_need <= n else ""No""
    print(ans)


if __name__ == ""__main__"":
    main()
"
"# coding: utf-8
import sys
import numpy as np

sr = lambda: sys.stdin.readline().rstrip()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

N, C = lr()
XV = np.array([lr() for _ in range(N)])
right = XV[:, 1]
r_pos = XV[:, 0]
rcum = right.cumsum() - r_pos
r_max_cum = np.maximum.accumulate(rcum)
left = right[::-1]
l_pos = (C - r_pos)[::-1]
lcum = left.cumsum() - l_pos
l_max_cum = np.maximum.accumulate(lcum)

answer = max(0, r_max_cum[-1], l_max_cum[-1])
# i個目で折り返す
for i in range(N-1):
    temp = rcum[i] - r_pos[i]  # 帰りの距離を引く
    temp += l_max_cum[N-2-i]
    if temp > answer:
        answer = temp

for i in range(N-1):
    temp = lcum[i] - l_pos[i]  # 帰りの距離を引く
    temp += r_max_cum[N-2-i]
    if temp > answer:
        answer = temp

print(answer)
"
"N, A, B = map(int, input().split())
print(""Borys"") if (B - A) % 2 else print(""Alice"")
"
"N = int(input())
s, t = input(), input()

v = 0
for i in range(len(s)):
    # print(s[-(i + 1):], t[:i + 1])
    if s[-(i + 1):] == t[:i + 1]:
        v = i + 1
# print('v', v)
ans = N * 2 - v
print(ans)
"
"K, N = list(map(lambda x: int(x), input().split("" "")))
A = list(map(lambda a: int(a), input().split("" "")))

D = [A[i + 1] - A[i] if i < len(A) - 1 else K - A[i] + A[0] for i in range(len(A))]
D.sort()
print(K - D[-1])"
"import sys
import itertools

# \n
def input():
    return sys.stdin.readline().rstrip()


def main():
    N, K = map(int, input().split())
    S = list(input())

    l = []
    down = 0  # ""0""
    up = 0  # ""1""
    flag = int(S[0])
    if not flag:
        l.append(0)
    for i in range(N):

        if int(S[i]) == 1:
            up += 1
            if down:
                l.append(down)
                down = 0
        if int(S[i]) == 0:
            down += 1
            if up:
                l.append(up)
                up = 0
    if up:
        l.append(up)
    else:
        l.append(down)

    if len(l)<=2*K+1:
        print(N)
        exit()
    total = sum(l[:2*K+1])
    ans =total
    flag =1
    csum=list(itertools.accumulate(l))
    for i in range(2,len(l) - 2 * K +1,2):
        right =min(i+2*K,len(l)-1)
        ans = max(ans, csum[right] - csum[i-1])

    print(ans)

if __name__ == ""__main__"":
    main()
"
"n = int(input())
ls = list(map(int,input().split()))
new = sorted(ls)
for i in ls:
    if i < new[int(n/2)]:
        print(new[int(n/2)])
    else:
        print(new[int(n/2)-1])
"
"#!python3

import sys

from bisect import bisect, insort_left

iim = lambda: map(int, input().rstrip().split())

def resolve():
    N = int(input())
    S = list(input())
    Q = int(input())

    c0 = ord('a')
    S1 = [[] for i in range(26)]
    for i, c1 in enumerate(S):
        ci = ord(c1) - c0
        S1[ci].append(i)

    ans = []
    for cmd, i, j in (line.split() for line in sys.stdin):
        i = int(i) - 1
        if cmd == ""1"":
            if S[i] == j:
                continue

            c1 = ord(S[i]) - c0
            s1 = S1[c1]
            s1.pop(bisect(s1, i)-1)
            S[i] = j
            c1 = ord(j) - c0
            insort_left(S1[c1], i)
        elif cmd == ""2"":
            j = int(j) - 1
            num = 0

            for s1 in S1:
                ls = len(s1)
                k = bisect(s1, i-1, 0, ls)

                if k == ls:
                    continue
                if i <= s1[k] <= j:
                    num += 1

            ans.append(num)

    print(*ans, sep=""\n"")

if __name__ == ""__main__"":
    resolve()
"
"n = int(input())
record = [[[0 for r in range(10)] for f in range(3)] for b in range(4)]
for i in  range(n):
  b, f, r, v = [int(x) for x in input().split()]
  record[b-1][f-1][r-1] += v
for b in range(4):
  for f in record[b]:
    print(' '+' '.join([str(x) for x in f]))
  if b != 3:
    print(''.join(['#' for x in range(20)]))"
"a,b,c=map(str,input().split())
print(str.upper(a[0])+str.upper(b[0])+str.upper(c[0]))"
"def popcount(x):
    x = (x & 0x5555555555555555) + (x >> 1  & 0x5555555555555555)
    x = (x & 0x3333333333333333) + (x >> 2  & 0x3333333333333333)
    x = (x & 0x0f0f0f0f0f0f0f0f) + (x >> 4  & 0x0f0f0f0f0f0f0f0f)
    x = (x & 0x00ff00ff00ff00ff) + (x >> 8  & 0x00ff00ff00ff00ff)
    x = (x & 0x0000ffff0000ffff) + (x >> 16 & 0x0000ffff0000ffff)
    x = (x & 0x00000000ffffffff) + (x >> 32 & 0x00000000ffffffff)
    return x
n = int(input())

testimonies = [[] * n for _ in range(n)]
for i in range(n):
    a = int(input())
    for _ in range(a):
        x, y = map(int, input().split())
        testimonies[i].append((x-1, y))

ans = 0
for bits in range(1, 1<<n):
    possible = True
    for i in range(n):
        if not bits >> i & 1:
            continue
        for x, y in testimonies[i]:
            if bits >> x & 1 != y: 
                possible = False
                break
        if not possible:
            break
    if possible:
        ans = max(ans, popcount(bits))
print(ans)"
"# https://atcoder.jp/contests/agc033/tasks/agc033_a

from collections import deque
import sys
sys.setrecursionlimit(10 ** 8)
input = sys.stdin.readline
move = [(1, 0), (-1, 0), (0, 1), (0, -1)]     # 動ける場所の候補


def debug(start, goal, p, t):
    player = p
    debug_grid = list(list(grid[h]) for h in range(H))
    if start != (None, None):
        debug_grid[start[0]][start[1]] = ""S""
    if goal != (None, None):
        debug_grid[goal[0]][goal[1]] = ""G""
    debug_grid[player[0]][player[1]] = ""P""
    print(""~~~~~~~~~ t = "" + str(t+1) + ""  ~~~~~~~~"")
    for debug_h in range(H):
        print("""".join(str(debug_grid[debug_h][debug_w]) for debug_w in range(W)))


def search(grid, next_set, goal=(None,None), visit=set()):
    visit.add(start)                            # スタート地点はすでに訪れている
    while next_set:                             # p = [] になったら止める
        p, t = next_set.popleft()               # 要素を消去して、消去した要素を出力
        h, w = p
        for dh, dw in move:                     # 頂点 p から進める経路の候補から一つ選ぶ
            q = (h + dh, w + dw)
            if q[0] < 0 or q[0] >= H or q[1] < 0 or q[1] >= W:
                continue
            if grid[q[0]][q[1]] == wall:         # 壁があったら進まない
                continue
            if q in visit:                      # 一度訪れていた場合は進まない
                continue
            #### (debug code) ######
            # debug(start, goal, q, t)
            ########################
            if q == goal:                       # ゴールがあるならば、ここで判定
                return t + 1                    # 経路の長さは t + 1 で与えられる
            visit.add(q)                        # 頂点 q に一度訪れた事をメモ (for の前に書くと、ここで選ばれた q が最短であるはずなのに、違う経路でvisit = Trueを踏んでしまう可能性がある)
            next_set.append((q, t + 1))         # p から q へと移動。時刻を 1 進める
    return t



road, wall = ""."", ""#""                         # (進行可能を意味する記号, 進行不可を意味する記号)

H,W = map(int,input().split())                # 左上は(h,w)=(0,0)、右下は(h,w)=(H-1,W-1)

grid = []
next_set = deque()
visit = set()
for h in range(H):
    grid.append(input())
    for w, a in enumerate(grid[-1]):
        if a == ""#"":
            start = (h, w)
            next_set.append((start,0))
            visit.add(start)

print(search(grid, next_set, goal=(None,None), visit=visit))"
"#!/usr/bin/env python3

import sys

DEBUG = False


class SegmentTree:

    # Use 1-based index internally
    def __init__(self, n, merge_func, fillval=sys.maxsize):
        self.n = 1
        while self.n < n:
            self.n *= 2
        self.nodes = [fillval] * (self.n * 2 - 1 + 1)  # +1 for 1-based index
        self.merge_func = merge_func
        self.fillval = fillval
    
    def update(self, idx, val):
        idx += 1  # for 1-based index

        nodes = self.nodes
        mergef = self.merge_func

        idx += self.n - 1
        nodes[idx] = val
        while idx > 1: # > 1 for 1-based index
            idx >>= 1  # parent(idx) = idx >> 1 for 1-based index segment tree
            nodes[idx] = mergef(nodes[idx << 1], nodes[(idx << 1) + 1]) # child(idx) = idx << 1 and idx << 1 + 1
    
    def query(self, l, r):
        l += 1; r += 1  # for 1-based index

        l += self.n - 1
        r += self.n - 1
        acc = self.fillval
        while l < r:
            if l & 1:
                acc = self.merge_func(acc, self.nodes[l])
                l += 1
            if r & 1:
                acc = self.merge_func(acc, self.nodes[r - 1])
                r -= 1
            l >>= 1
            r >>= 1
        return acc

def read(t = str):
    return t(sys.stdin.readline().rstrip())

def read_list(t = str, sep = "" ""):
    return [t(s) for s in sys.stdin.readline().rstrip().split(sep)]

def dprint(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)
    return


def main():
    read()
    s = read()

    a_ord = ord(""a"")
    bit_offsets = {chr(c_ord): c_ord - a_ord for c_ord in range(ord(""a""), ord(""z"") + 1)}

    apps = SegmentTree(len(s), lambda x, y: x | y, 0)
    i = 0
    for c in s:
        apps.update(i, 1 << bit_offsets[c])
        i += 1

    nr_q = read(int)
    for i in range(0, nr_q):
        q = read_list()
        if q[0] == ""1"":
            _, i, c = q  # i_q in the question starts from 1, not 0
            apps.update(int(i) - 1, 1 << bit_offsets[c])
        else:
            _, l, r = q  # l_q and r_q in the question start from 1, not 0
            print(bin(apps.query(int(l) - 1, int(r) - 1 + 1)).count(""1""))  # query in the question includes both edges


if __name__ == ""__main__"":
    main()"
"*k, = map(int, input().split())
print(len(set(k)))"
"n , m , x = map(int, input().split())
a = list(list(map(int, input().split())) for _ in range(n))

c = []
for i in range(n):
    c.append(a[i][0])
    a[i].pop(0)

ans = 1000000000

# bit全探索
for i in range(1 << n):
    score = [0] * m
    tmp = 0
    for j in range(n):
        if (i >> j) % 2 == 1:
            tmp += c[j]
            for k in range(m):
                score[k] += a[j][k]

    if min(score) >= x:
        ans = min(ans , tmp)

if(ans == 1000000000):
    print(-1)
else:
    print(ans)
"
"A,B,C=map(int,input().split())#どれか１つでも偶数ならばans=0
l=[A,B,C]
for i in range(3):
    if l[i]%2==0:
        print(0)
        exit()
#以下すべて奇数の場合）
x=(A//2 +1)*B*C-(A//2)*B*C
y=A*(B//2 +1)*C-A*(B//2)*C
z=A*B*(C//2 +1)-A*B*(C//2)
print(min(x,y,z))"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import accumulate, permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N = INT()
S = input()

ans = 1
for x in Counter(S).values():
	ans *= x+1
	ans %= mod
print((ans-1)%mod)
"
"n=int(input())
S=[input() for _ in range(n)]

ans,acnt,bcnt,abcnt=0,0,0,0
for s in S:
  ans+=s.count('AB')
  if s[-1]=='A' and s[0]=='B': abcnt+=1
  elif s[-1]=='A': acnt+=1
  elif s[0]=='B': bcnt+=1
if abcnt:
  ans+=abcnt-1
  if acnt:
    ans+=1
    acnt-=1
  if bcnt:
    ans+=1
    bcnt-=1
ans+=min(acnt,bcnt)
print(ans)"
"from itertools import combinations_with_replacement
n,m,q = map(int,input().split())
ans = -1
li = [tuple(map(int,input().split())) for i in range(q)]
for K in combinations_with_replacement(range(1,m+1),n):
    s = 0
    for a,b,c,d in li:
        a -= 1
        b -= 1
        if K[b]-K[a] == c:
            s += d
    ans = max(ans,s)
print(ans)"
"import copy
import math
c=[0]*(10**5+1)
for n in range(2,10**5+1):
  for k in range(2, int(math.sqrt(n))+1):
    if n%k==0:
      break
  else:
    c[n]=1
cc=[0]*(10**5+1)
for n in range(1,10**5+1,2):
  if c[n] and c[(n+1)//2]:
    cc[n]=1
#print(*c[:100])
for i in range(1,10**5+1):
  cc[i] += cc[i-1]
#print(*c[:100])
#print(*[(i,cc[i]) for i in range(1,54)])
q=int(input())
for i in range(q):
  l,r=map(int,input().split())
  print(cc[r]-cc[l-1])"
"chars = [c for c in input()]
print('Yes' if chars[2] == chars[3] and chars[4] == chars[5] else 'No')"
"l,r,d= map(int,input().split())
print(sum([1 if t%d==0 else 0 for t in range(l,r+1)]))"
"def fun(a,k,n): ## k different steps can be taken
    if n==1:
        return 0
    dp = [0]*n
    dp[1]=dp[0]+abs(a[0]-a[1])
    for i in range(2,len(a)):
        t = 0
        min_ = float('inf')
        for j in range(i-1,-1,-1):
            if t==k:
                break
            else:
                t+=1
            if dp[j]+abs(a[i]-a[j]) < min_ :
                   min_ = dp[j]+abs(a[i]-a[j])
        dp[i]=min_
    return dp[-1]
from sys import stdin , stdout
n,k = map(int , stdin.readline().split())
a = list(map(int , stdin.readline().split()))
print(fun(a,k,n))"
"import sys
from statistics import *
from collections import *
stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline()

a, b, c = na()
print('Yes' if a + b >= c else 'No')"
"b = str(input())
dic = {'A':'T', 'C':'G', 'G':'C', 'T':'A'}
bz = dic[b]
print(bz)"
"s=list(input())
l=[0]*2019
t=0
ans=0
for i in range(len(s)):
    t=(t+pow(10,i,2019)*int(s[-1-i]))%2019
    l[t]+=1
for i in l:
    ans+=(i*(i-1))//2
print(ans+l[0])"
"import math
K = int(input())
A = [int(_) for _ in input().split()]
l = r = 2
'''
if x children form groups consisting of y children each
 then z children are left
=> z=y*(x//y)
=> y*(math.ceil(z/y))<=x<y*(math.floor(z/y)+1)
'''
#necessary conditions
for a in A[::-1]:
    l = a * math.ceil(l / a)
    r = a * (math.floor(r / a) + 1) - 1
#sufficient conditions
for x in [l, r]:
    for a in A:
        x = a * (x // a)
    if x != 2:
        print(-1)
        exit()
print(l, r)
"
"n,m=map(int,input().split())
l=list(map(int,input().split()))

if n>=m:
  print(0)
else:
  num=n-1
  sl=sorted(l)

  dsl=[abs(sl[i+1]-sl[i]) for i in range(m-1)]

  dsl=sorted(dsl)
  print(sum(dsl[0:len(dsl)-num]))
"
"def resolve():
	n = int(input())
	seq = [0] + list(map(int, input().split())) + [0]
	v = 0
	for i in range(n+1):
		v += abs(seq[i] - seq[i+1])
	for i in range(1, n+1):
		a = abs(seq[i] - seq[i-1]) + abs(seq[i] - seq[i+1])
		b = abs(seq[i - 1] - seq[i+1])
		print(v - abs(a - b))
resolve()"
"N, K = map(int, input().split())
a = [0]*N
for i in range(K):
    d = int(input())
    A = list(map(int, input().split()))
    for l in A:
        a[l-1] = 1
print(a.count(0))
"
"from sys import stdin

a, b = [int(x) for x in stdin.readline().rstrip().split()]
print(a - 2*b if a-2*b > 0 else 0)"
"A, B, C, D = map(int, input().split())

while True:
    C -= B
    if C < 1:
        print('Yes')
        quit()
    A -= D
    if A < 1:
        print('No')
        quit()
"
"N = int(input())
A = list(map(int,input().split()))
isMinus = False
for i in range(N):
    if A[i] < 0:
        isMinus = not isMinus
        A[i] = A[i]*-1

if isMinus:
    print(sum(A)-min(A)*2)
else:
    print(sum(A))
"
"n,a,b=map(int,input().split())

if a+b ==0:
    print(0)
else:
    c = n//(a+b)
    d = n%(a+b)

    if d <= a:
        print(a*c+d)
    else:
        print(a*c+a)"
"input()
S = set(input().split())
input()
T = set(input().split())
print(len(S & T))
"
"n=int(input())
a=list(map(int,input().split()))
ans=0
for i in a:
  while i%2==0:
    i=i//2
    ans+=1
  
print(ans)"
"N, K = map(int, input().split())
A = list(map(int, input().split()))

m = 1000000007

a = [e for e in A if e > 0]
b = [e for e in A if e < 0]
c = [e for e in A if e == 0]
# プラスルート
if len(a) >= K - (min(K, len(b)) // 2) * 2:
    a.sort(reverse=True)
    b.sort()
    result = 1
    i = 0
    j = 0
    k = 0
    while k < K:
        if k < K - 1 and i < len(a) - 1 and j < len(b) - 1:
            x = a[i] * a[i + 1]
            y = b[j] * b[j + 1]
            if y >= x:
                result *= y
                result %= m
                j += 2
                k += 2
            else:
                result *= a[i]
                result %= m
                i += 1
                k += 1
        elif k < K - 1 and j < len(b) - 1:
            y = b[j] * b[j + 1]
            result *= y
            result %= m
            j += 2
            k += 2
        elif i < len(a):
            result *= a[i]
            result %= m
            i += 1
            k += 1
        elif j < len(b):
            result *= b[j]
            result %= m
            j += 1
            k += 1
    print(result)
# 0 ルート
elif len(c) != 0:
    print(0)
# マイナスルート
else:
    a.sort()
    b.sort(reverse=True)
    result = 1
    i = 0
    j = 0
    k = 0
    while k < K:
        if i < len(a) and j < len(b):
            if a[i] <= -b[i]:
                result *= a[i]
                result %= m
                i += 1
                k += 1
            else:
                result *= b[j]
                result %= m
                j += 1
                k += 1
        elif i < len(a):
            result *= a[i]
            result %= m
            i += 1
            k += 1
        elif j < len(b):
            result *= b[j]
            result %= m
            j += 1
            k += 1
    print(result)
"
"from itertools import accumulate 
#acumulate [a[0], a[0]+a[1], a[0]+...]
 
n, k = map(int, input().split())
p = [int(x) - 1 for x in input().split()]
c = list(map(int, input().split()))
ans = -(10 ** 18)
 
for i in range(n):
    pos = i
    scores = []
    while True:
        pos = p[pos]
        scores.append(c[pos])
        if pos == i:
            break
    m = len(scores)
    s = list(accumulate(scores))
    for j in range(min(m, k)):
        x = (k - j - 1) // m
        ans = max(ans, s[j], s[j] + s[-1] * x)
 
print(ans)"
"def main():
    A, B, C, K = map(int, input().split())
    if K&1 == 0:# 偶数
        print(A-B)
    else:
        print(B-A)

if __name__ == ""__main__"":
    main()"
"import sys
a, b = sys.stdin.readline().split()
print(b+a)"
"N = int(input())
A = [int(input()) for _ in range(N)]

count = 0
for i in range(N):
    if i == 0 and A[i] > 0:
        print(-1)
        exit()
    if A[i] == 0:
        continue
    else:
        if A[i] == (A[i-1] + 1):
            count += 1
        elif A[i] > A[i-1] + 1:
            print(-1)
            exit()
        else:
            count += A[i]

print(count)
"
"import math


n, d = map(int, input().split())
x = []
for i in range(n):
    x.append(list(map(int, input().split())))

ans = 0
for i in range(n-1):
    for j in range(i+1, n):
        y = 0
        for k in range(d):
            y += (x[i][k] - x[j][k])**2

        y = math.sqrt(y)
        if y.is_integer():
            ans += 1
print(ans)
"
"import math

def insert_sort(A, n, g):
    cnt = 0
    for i in range(g, n):
        j = i - g
        v = A[i]
        while j >= 0 and A[j] > v:
            A[j+g] = A[j]
            j -= g
            cnt += 1
        A[j+g] = v
    return cnt

def shell_sort(A, n):
    cnt = 0
    
    G = []
    h = 1
    while h <= n:
        G.append(h)
        h = h*3+1
    
    G.reverse()
    
    print(len(G))
    print(*G)
        
    for g in G:
        cnt += insert_sort(A, n, g)
    return cnt

N = int(input())
A = [int(input()) for _ in range(N)]

cnt = shell_sort(A, N)

print(cnt)

for a in A:
    print(a)

"
"n = int(input())
a = list(map(int, input().split()))
maxa = max(a)
mini = [[] for _ in range(n)]
for i, v in enumerate(a):
    r = maxa - v
    mini[i] = [v, abs(v - r)]
mini.sort(key=lambda x: x[1])
if n == 2:
    print(maxa, min(a))
else:
    print(maxa, mini[0][0])
"
"a, b, c = list(map(int,input().split()))

print(min(a+b,b+c,c+a))"
"import sys

input = sys.stdin.readline


def main():
    N, M = map(int, input().split())
    ans = [0]*(M+1)
    for _ in range(N):
        food = list(map(int, input().split()))
        K = food[0]
        for i in range(1, K + 1):
            ans[food[i]] += 1
    print(ans.count(N))


if __name__ == '__main__':
    main()
"
"import sys
import math
import fractions
from collections import deque
from collections import defaultdict
sys.setrecursionlimit(10**7)

H, W = map(int, input().split())
field = []
q = deque()
for i in range(H):
    line = []
    A = input()
    for j in range(W):
        if A[j] == ""."":
            line.append(True)
        else:
            line.append(False)
            q.append(((j, i), 0))
    field.append(line)

dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]

ans = 0

while len(q) != 0:
    (x, y), d = q.popleft()
    ans = max(d, ans)
    for dir in dirs:
        nx = x + dir[0]
        ny = y + dir[1]
        if 0 <= nx <= W - 1 and 0 <= ny <= H - 1 and field[ny][nx]:
            field[ny][nx] = False
            q.append(((nx, ny), d+1))

print(ans)
"
"# -*- coding: utf-8 -*-

def get_input() -> str:
    """"""
    標準入力を取得する.

    Returns:\n
        str: 標準入力
    """"""
    S = input()

    return S


def main(S: str) -> None:
    """"""
    メイン処理.

    Args:\n
        S (str): 文字列(1 <= |S| <= 1000, 英子文字のみ)
    """"""
    # 求解処理
    ans = S
    if S[-1] == ""s"":
        ans += ""es""
    else:
        ans += ""s""

    # 結果出力
    print(ans)


if __name__ == ""__main__"":
    # 標準入力を取得
    S = get_input()

    # メイン処理
    main(S)
"
"'''
ITP-1_5-D
 ?§???????????????°???????????°
goto ?????????C/C++?¨????????????§???????????¨?????§???????????§????????????????????¨????????¶????????????????????????????????????????£?????????????????????° goto CHECK_NUM; ??¨?????????????????????????????¨???????????°??????????????§ CHECK_NUM: ??¨????????????????????????????§?????????????????????????????????£????????°?????????????????????????????????????????¨?????§????????????
?????????goto ???????????±??????????????????????????°?????????????????§?????±??????????????????????????????????????????????????¨?????¨?\¨?????????????????????
?¬????C++?¨???????????????°????????¨?????????????????????????????°????????????????????????????????????????????????goto ????????????????????§????£?????????????????????????
void call(int n){
  int i = 1;
 CHECK_NUM:
  int x = i;
  if ( x % 3 == 0 ){
    cout << "" "" << i;
    goto END_CHECK_NUM;
  }
 INCLUDE3:
  if ( x % 10 == 3 ){
    cout << "" "" << i;
    goto END_CHECK_NUM;
  }
  x /= 10;
  if ( x ) goto INCLUDE3;
 END_CHECK_NUM:
  if ( ++i <= n ) goto CHECK_NUM;
  cout << endl;
}
???Input
???????????´??° nn ?????????????????????????????????
???Output
????¨?????????°???????????\????????´??° nn ????????????????????????????????????????????????
'''
# import
import sys

inputData = int(input())
 
outputData = []
cntVal = 1

while True:
    # CHECK_NUM
    checkVal = cntVal
    if checkVal % 3 == 0:
        outputData.append(str(cntVal))
    else:
        while True:
            # INCLUDE3
            if checkVal % 10 == 3:
                outputData.append(str(cntVal))
                break

            checkVal = int(checkVal / 10)

            # EndChek
            if checkVal != 0: 
                continue
            else: 
                break
    # increment
    cntVal += 1

    # EndChek
    if cntVal <= inputData:
        continue
    else:
        break

# Output 
print("" "" + "" "".join(outputData))"
"n, t = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
l = []
flag = False
for i in range(n):
    if a[i][1] <= t:
        l.append(a[i][0])
        flag = True
if flag:
    print(min(l))
else:
    print('TLE')"
"def main():
    N = 4
    edge = [[] for _ in range(N)]
    for i in range(N-1):
        a, b = (int(i) for i in input().split())
        edge[a-1].append(b-1)
        edge[b-1].append(a-1)
    even, odd = 0, 0
    for e in edge:
        if len(e) % 2 == 1:
            odd += 1
        else:
            even += 1
    if odd == 2 and even == 2:
        print(""YES"")
    else:
        print(""NO"")


if __name__ == '__main__':
    main()
"
"K = int(input())

a = K//50
b = K%50

print (50)
for i in range(49-b):
    print (48 + a -b, end = ' ')
for i in range(b):
    print (48 + a + 50 - (b-1), end = ' ')
print (49 + a - b)"
"from math import sqrt as r
from math import floor as f
X = int(input())
going = True

def judge(X):
    for i in range(3, f(r(X)) + 1, 2):
        if X % i == 0:
            return False
    return True

if X == 2 or X == 3:
    print(X)
    going = False
elif X % 2 == 0:
    X += 1

while going:
    if judge(X):
        print(X)
        break
    X += 2
"
"k,x=[int(_) for _ in input().split()]
print('Yes' if k*500>=x else 'No')"
"A, B, K = map(int, input().split())

j, a = A, B
for i in range(K):
  j = j // 2
  a += j 
  j, a = a, j
  
if K % 2 == 0:
  print(j, a)
else:
  print(a, j)"
"def main():
    a, b, c = map(int, input().split())
    if a < b < c:
        print(""Yes"")
    else:
        print(""No"")

if __name__ == ""__main__"":
    main()"
"X, N = list(map(int, input().split()))

if N == 0:
  print(X)
  exit()

P = list(map(int, input().split()))
up_min = 0
low_min = 0

arr = [0] * 102
for i in P:
  arr[i] = 1
lower = arr[:X]
lower.reverse()
upper = arr[X:]
for i, num in enumerate(lower):
  if num == 0:
    low_min = len(lower) - 1 - i
    break
for i, num in enumerate(upper):
  if num == 0:
    up_min = len(lower) + i
    break

if abs(up_min - X) >= abs(X - low_min):
  print(low_min)
else:
  print(up_min)
"
"a,b = (int(X) for X in input().split())
if b>=a: print(a)
else: print(a-1)"
"n = int(input())
t = [[0 for j in range(10)] for i in range(10)]
for i in range(1,n+1):
    s = str(i)
    t[int(s[0])][int(s[-1])] += 1
ans = 0
for i in range(1,10):
    for j in range(1,10):
        ans += t[i][j]*t[j][i]
print(ans)"
"n, m = map(int, input().split())
root_map = dict()
root_map[1] = set()
root_map[n] = set()

for i in range(m):
    a, b = map(int, input().split())
    if a == 1 or a == n:
        root_map[a].add(b)
    if b == 1 or b == n:
        root_map[b].add(a)

for i in root_map[1]:
    if i in root_map[n]:
        print(""POSSIBLE"")
        break
else:
    print(""IMPOSSIBLE"")
"
"def main():
    S, W = map(int, input().split())

    if S <= W:
        print(""unsafe"")
    else:
        print(""safe"")


if __name__ == ""__main__"":
    main()
"
"S = input()
print(""ABC"" if S == ""ARC"" else ""ARC"")"
"n = int(input())
s = str(input())
r = 0
g = 0
b = 0
for i in range(n):
    if s[i] == ""R"":
        r += 1
    elif s[i] == ""G"":
        g += 1
    else:
        b += 1
p = r*g*b
for i in range(n-2):
    for j in range(int(n/2)+1):
        if i + 2*j >n-1:
            break
        if s[i] != s[i+j] and s[i] != s[i+2*j] and s[i+2*j] != s[i+j]:
            p -= 1
print(p)"
"# -*- coding: utf-8 -*-
""""""
Created on Sun Jun 18 10:01:05 2017

@author: syaga
""""""

if __name__ == ""__main__"":
    N = int(input())
    C = list(input().split())
    D = C[:]

    # Bunbble Sort
    for i in range(0, N):
        for j in range(N-1, i, -1):
            if int(C[j][1]) < int(C[j-1][1]):
                temp = C[j]
                C[j] = C[j-1]
                C[j-1] = temp
    print("" "".join(C))
    print(""Stable"")

    # Selection Sort
    for i in range(0, N):
        minj = i
        for j in range(i, N):
            if int(D[j][1]) < int(D[minj][1]):
                minj = j
        temp = D[i]
        D[i] = D[minj]
        D[minj] = temp
    print("" "".join(D))
    flag = 0
    for (i, j) in zip(C, D):
        if i != j:
            flag = 1
            break
    if flag == 1:
        print(""Not stable"")
    else:
        print(""Stable"")"
"def main():
    n = int(input())
    s = input()
    for i in s:
        mod = (ord(i) - ord('A') + n) % 26
        ans = chr(ord('A') + mod)
        print(ans, end='')
        
if __name__ == '__main__':
    main()"
"from _collections import deque
from _ast import Num


def parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield (number)


input_parser = parser()


def gw():
    global input_parser
    return next(input_parser)


def gi():
    data = gw()
    return int(data)


MOD = int(1e9 + 7)

import numpy
from collections import deque
from math import sqrt
from math import floor
# https://atcoder.jp/contests/arc067/tasks/arc067_a
# C - Factors of Factorial
""""""
need to consider the case that ticket is not enough to lower everything
""""""

N = gi()
A = [0] * N
B = [0] * N
C = [0] * N
sB = [0] * N
sC = [0] * N

for i in range(N):
    A[i] = gi()
A.sort()

for i in range(N):
    B[i] = gi()
B.sort()

nai = 0

for i in range(N):
    while nai < N and A[nai] < B[i]:
        nai += 1
    sB[i] = nai
    if i > 0:
        sB[i] += sB[i - 1]

for i in range(N):
    C[i] = gi()
C.sort()

nbi = 0
for i in range(N):
    while nbi < N and B[nbi] < C[i]:
        nbi += 1
    if nbi:
        sC[i] = sB[nbi - 1]

    if i > 0:
        sC[i] += sC[i - 1]

print(sC[-1])
"
"n,a,b=list(map(int,input().split()))
#2^n-nCa-nCbを求める
#冪乗を求める関数を求める
#2のn乗をmで割ったあまりを求める
def pow(a,n,m):
  if n==0:
    return 1
  else:
    k=pow(a*a%m,n//2,m)
    if n%2==1:
      k=k*a%m
    return k
#次は組み合わせを計算する
#まずは前処理をする
inv=[0 for i in range(200001)]
finv=[0 for i in range(200001)]
inv[1]=1
finv[1]=1
for i in range(2,200001):
  #逆元の求め方p=(p//a)*a+p%a a^(-1)=-(p//a)*(p%a)^(-1)
  inv[i]=(-(1000000007//i)*inv[1000000007%i])%1000000007
  finv[i]=finv[i-1]*inv[i]%1000000007

#nが10^7程度であればnCk=n!*(k!)*((n-k)!)を求めればいい
#nがそれより大きい時は間に合わない。ここでkが小さいことに着目すると
#nCk=n*(n-1).....*(n-k+1)*(k!)^(-1)で求められることがわかる
a_num=1
b_num=1
for i in range(n-a+1,n+1):
  a_num=i*a_num%1000000007
for i in range(n-b+1,n+1):
  b_num=i*b_num%1000000007
print((pow(2,n,1000000007)-1-a_num*finv[a]-b_num*finv[b])%1000000007)

  











"
"import numpy as np

N = int(input())
A = list(map(int,input().split()))

A = np.array(A)

A.sort()

d = {}

for a in A:
    d.setdefault(a,0)
    d[a] += 1



sieve = [True] * (A[-1] + 1)

for a in A:
    if d[a] > 1:
        sieve[a] = False
    for i in range(a + a, A[-1] + 1, a):
        sieve[i] = False

print(sum(1 for a in A if sieve[a]))"
"while 1:
 s=input();l=len(s);n=0
 if'-'==s:break
 for _ in range(int(input())):n+=int(input())
 print((s+s)[n%l:][:l])"
"import sys
input = sys.stdin.readline
N, A, B, C, D = map(int, input().split())
S = list(input())

# A < B < D, A < B < C
# A < D, B < C の間に # が2マス連続にあったらNo
# さらに D < C なら すぬけくんとふぬけくんが入れ替わる必要がある。
# すなわち3マス連続...が続いている必要がある(#が2マス連続ないことも注意)

left = A

if C < D:
    right = D
else:
    right = C
    idx = []
    for i in range(B - 2, D - 1):
        if S[i] == '.' and S[i + 1] == '.' and S[i + 2] == '.':
            idx.append(i)
    if not idx:
        print('No')
        exit()
    # print('idx', idx)
    # print('idx', S[idx[0]:idx[0] + 10])
# print('N, A, B, C, D', N, A, B, C, D)
T = S[left - 1:right + 1]
# print('T', T)
for i in range(len(T) - 1):
    if T[i] == '#' and T[i + 1] == '#':
        print('No')
        exit()

print('Yes')
"
"h,n=map(int,input().split())
magic=[list(map(int,input().split())) for _ in range(n)]
dp=[10**9]*(h+10**5)
#dp[i]:敵の体力をi減らすのに必要な魔力の最小値
dp[0]=0
for i in range(h):
    for damage,cost in magic:
        dp[i+damage]=min(dp[i+damage],dp[i]+cost)
ans=10**9
for i in range(10**5):
    ans=min(ans,dp[i+h])
print(ans)"
"x, y = map(int, input().split())

answer = 0

for a in [x, y]:
    if a == 3:
        answer += 100000
    elif a == 2:
        answer += 200000
    elif a == 1:
        answer += 300000
    else:
        pass
if x == 1 and y == 1:
    answer += 400000

print(answer)
"
"def I(): return int(input())
def LI(): return list(map(int,input().split()))
def MI(): return map(int,input().split())
def LLI(n): return [list(map(int, input().split())) for _ in range(n)]

n = I()
h = [0]+ LI()
#h[i]はi番目の高さ
#0-indexedにしておくと考えにくいので1-indexedにしておく
#dp[i]は足場iにいくのに必要な最小コスト
dp = [0]*(n+1)
#これも1-indexedにしておく
dp[1] = 0
dp[2] = abs(h[2]-h[1])
#2番目の足場に移るのは1番目の足場からいくしかないのでわけて考える
#最初蛙は足場1にいるため最小コストは0としておく
for i in range(3,n+1):
    dp[i] = min(dp[i-2]+abs(h[i]-h[i-2]), dp[i-1]+abs(h[i]-h[i-1]))
print(dp[n])"
"N,M=map(int,input().split())
*X,=map(int,input().split())
X.sort()

count=[0]*(M-1)
i=1
while i<M:
    count[i-1]=X[i]-X[i-1]
    i+=1
count.sort()

print(sum(count[:max(M-N,0)]))"
"n, m, r = map(int, input().split())
rs = list(map(int, input().split()))
rs = [i-1 for i in rs]
d = [[float('inf')] * n for i in range(n)]
for i in range(m):
    x, y, r = map(int, input().split())
    x -= 1
    y -= 1
    d[x][y] = r
    d[y][x] = r

for i in range(n):
    d[i][i] = 0

def warshall_floyd(d):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])
    return d

d = warshall_floyd(d)

ans = float('inf')
from itertools import permutations
for i in permutations(rs):
    di = 0
    for j in range(len(rs) - 1):
        di += d[i[j]][i[j + 1]]
    ans = min(ans, di) 

print(ans)"
"INF = 1 << 60
n = int(input())
ans = INF
for a in range(1, n):
    b = str(n - a)
    a = str(a)
    total_a = 0
    total_b = 0
    for i in a:
        total_a += int(i)
    for i in b:
        total_b += int(i)
    ans = min(ans, total_a + total_b)
print(ans) "
"n = int(input())
result = 100000
for i in range(0,n):
    result = result * 1.05
    if result % 1000 == 0:
        pass
    else:
        result = result-(result % 1000)+ 1000
        result = int(result)
print(result)"
"def mergeArray(a,b,bLength,c,cLength):
    global count
    apos,bpos,cpos=(0,0,0)
    while bpos<bLength and cpos<cLength:
        if b[bpos]<=c[cpos]:
            a[apos]=b[bpos]
            bpos+=1
        else:
            a[apos]=c[cpos]
            cpos+=1
        apos+=1
        count+=1
    
    while bpos<bLength:
        a[apos]=b[bpos]
        apos+=1
        bpos+=1
        count+=1
    
    while cpos<cLength:
        a[apos]=c[cpos]
        apos+=1
        cpos+=1
        count+=1

def mergeSort(a,aLength):
    b=[]
    c=[]
    if aLength>=2:
        b=a[:aLength//2]
        c=a[aLength//2:]
        mergeSort(b,len(b))
        mergeSort(c,len(c))
    mergeArray(a,b,len(b),c,len(c))

count=0
aLength=int(input())
a=list(map(int,input().split()))
mergeSort(a,aLength)
print(*a)
print(count)
"
"abc = list(map(int, input().split()))
abc.sort()
c = abc[2]
ab = abc[0] + abc[1]
if ab % 2 == 0:
    print((c * 2 - ab) // 2)
else:
    c += 1
    ab += 1
    print((c * 2 - ab) // 2 + 1)"
"N = int(input())
p = list(map(int, input().split()))
ans = 0
q = []
for i in range(N):
  if i+1 == p[i]:
    q += [0]
  else:
    q += [1]

for i in range(N):
  if q[i] == 0 and i < N-1:
    q[i], q[i+1] = 1, 1
    ans += 1
  elif q[i] == 0 and i == N-1:
    q[i], q[i-1] = 1, 1
    ans += 1

print(ans)"
"#!/usr/bin/env python3

import sys
# import time
# import math
# import numpy as np
# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall
# import random                                # random, uniform, randint, randrange, shuffle, sample
# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits
# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)
from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).
# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()
# from collections import defaultdict          # subclass of dict. defaultdict(facroty)
# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)
# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj
# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj
# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.
# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference
# from functools import reduce                 # reduce(f, iter[, init])
# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)
# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).
# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).
# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])
# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]
# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]
# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])
# from itertools import combinations, combinations_with_replacement
# from itertools import accumulate             # accumulate(iter[, f])
# from operator import itemgetter              # itemgetter(1), itemgetter('key')
# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)



def main():
    mod = 1000000007                # 10^9+7
    inf = float('inf')              # sys.float_info.max = 1.79...e+308
    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19
    sys.setrecursionlimit(10**6)    # 1000 -> 1000000
    def input(): return sys.stdin.readline().rstrip()
    def ii():    return int(input())
    def mi():    return map(int, input().split())
    def mi_0():  return map(lambda x: int(x)-1, input().split())
    def lmi():   return list(map(int, input().split()))
    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))
    def li():    return list(input())
    
    
    # class MaxHeap:
    #     def __init__(self, seq):
    #         tmp = list(map(lambda x: -x, seq))
    #         heapify(tmp)
    #         self.h = tmp
    #     def push(self, num):
    #         heappush(self.h, - num)
    #     def pop(self):
    #         return -heappop(self.h)

    # n, a, b = mi()
    # hp = MaxHeap([ii() for _ in range(n)])
    # cnt = 0
    # while True:
    #     max_hp = hp.pop()
    #     if max_hp <= cnt * b:
    #         break
    #     else:
    #         hp.push(max_hp - (a - b))
    #         cnt += 1
    # print(cnt)

    def ceil_div_alternative(x, y):
        """"""
        Args:
            x, y (int)
        Returns:
            int
        
        ceil(x / y) を正確に返す (y を何整数倍すると x 以上になるか？の値)

        >>> ceil_div_alternative(4, 2)
        2
        >>> ceil_div_alternative(4, 3)
        2

        > ceil() 、 floor() 、および modf() 関数については、非常に大きな浮動小数点数が 全て 整数そのものになるということに注意してください。
        > 通常、Python の浮動小数点型は 53 ビット以上の精度をもたない (プラットフォームにおける C double 型と同じ) ので、
        > 結果的に abs(x) >= 2**52 であるような浮動小数点型 x は小数部分を持たなくなるのです。
        > 10 ** 15 + 0.2 == 10 ** 15
        > False
        > 10 ** 16 + 0.2 == 10 ** 16
        > True
        
        x / y が大きな浮動小数点数となる場合は ceil ではなく、この関数を使うようにする。
        """"""
        assert (isinstance(x, int) and isinstance(y, int))
        assert (x >= 0 and y > 0)
        return (x + y - 1) // y


    def can_defeat_predicate(hp_list, operation_times, a, b):
        n = len(hp_list)
        start = bisect_right(hp_list, b * operation_times)
        if start == n:
            return True
        else:
            res = [hp_list[i] - b * operation_times for i in range(start, n)]
            cnt = 0
            for elm in res:
                cnt += ceil_div_alternative(elm, a - b)
            return cnt <= operation_times


    def binary_search(hp_list, a, b):
        left = 0    # 絶対に倒せない操作回数
        right = 10**9+1    # 絶対に倒せる操作回数
        while right - left > 1:
            mid = (right + left) // 2
            if can_defeat_predicate(hp_list, mid, a, b):
                right = mid
            else:
                left = mid
        return right



    n, a, b = mi()
    hp = sorted([ii() for _ in range(n)])
    print(binary_search(hp, a, b))



if __name__ == ""__main__"":
    main()
"
"a,b,c=map(int, input().split())

if a == b and a!= c:
    print('Yes')
if b == c and b !=a:
    print('Yes')
if c == a and c != b:
    print('Yes')
if a == b == c:
    print('No')
if a != b and a != c and b != c:
    print('No')"
"n,k = map(int,input().split())
w = [int(input()) for _ in range(n)]
left = max(w)-1
right = sum(w)

while (right - left) > 1:
    mid = (left + right)//2
    count = 1
    c = 0
    for s in w:
        if mid < c + s:
            c = s
            count += 1
        else:
            c += s
    if count <= k:
        right = mid
    else:
        left = mid
print(right)
"
"import math
a,b,x=[int(x) for x in input().rstrip().split()]
S=x/a
if S==a*b:
  print(0)
else:
  if S<=(a*b)/2:
    a1=S/b
    tan=(b**2)/(2*S)
    print(math.degrees(math.atan(tan)))
  else:
    tan=(2*a*b-2*S)/a**2
    print(math.degrees(math.atan(tan)))


"
"
H, W = map(int, input().split())

if H == 1 or W == 1:
    print(1)
elif H % 2 == 0:
    print(H*W//2)
else:
    if W % 2 == 0:
        print(H*W//2)
    else:
        print((H//2)*(W//2) + (H//2+1)*(W//2+1))"
"a=list(map(str,input().split()))
print(a[0][0]+a[0][1]+a[0][2])"
"n = int(input())
s = [0]
l = []
while s:
    p = s.pop()
    if p > n:
        continue
    l.append(p)
    s.append(p * 10 + 3)
    s.append(p * 10 + 5)
    s.append(p * 10 + 7)
ans = 0
for x in l:
    p = str(x)
    if p.count('3') and p.count('5') and p.count('7'):
        ans += 1
print(ans)
"
"n = int(input())
a = [int(i) for i in input().split()]
ans = 0

dp = dict()
dm = dict()

for i,ai in enumerate(a):
    dp[i+ai] = dp.get(i+ai,0)+1
    dm[i-ai] = dm.get(i-ai,0)+1

for wa,i in dm.items():
    ans += i*dp.get(wa,0)

print(ans)
"
"N = int(input())
A = list(map(int, input().split()))

A.sort(reverse=True)

Alice = 0
Bob = 0
for i in range(N):
  temp = A.pop(0)
  if i % 2 == 0:
    Alice += temp
  else:
    Bob += temp

print(str(Alice - Bob))"
"S=input().split()
print(S.index(""0"")+1)"
"n = int(input())

if (n < 1200):
    print(""ABC"")
else:
    print(""ARC"")

"
"#!/usr/bin/env python3
import sys

YES = ""yes""  # type: str
NO = ""no""  # type: str


def solve(S: str):
    print(YES if len(set(S)) == len(S) else NO)
    return


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    S = next(tokens)  # type: str
    solve(S)


if __name__ == ""__main__"":
    main()
"
"def get_divisors(n):
    lower_divisors , upper_divisors = [], []
    i = 1
    while i*i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            upper_divisors.append(n//i)
        i += 1
    return [lower_divisors, upper_divisors]

n = int(input())

up = get_divisors(n)[0]
dn = get_divisors(n)[1]

ans = 11
for a, b in zip(up, dn):
    a = str(a)
    b = str(b)
    f = max(len(a), len(b))
    ans = min(ans, f)

print(ans)"
"import sys

input = sys.stdin.readline
N = int(input())
A = list(map(int, input().split()))
A.sort()
print(A[N-1] - A[0])"
"from math import ceil
N = int(input())
L = [int(input()) for k in range(5)]
print(4+ceil(N/min(L)))
"
"a,b = list(map(int,input().split()))
if a+b >= 10:
  print('error')
else:
  print(a+b)"
"import math
n, k = map(int, input().split())

if k == 1:
    print(n**3)
    exit()
if n == 1:
    print(1*(k==3))
    exit()
    
ans = 0
for i in range(n):
    a = i+1
    if 2*(i+1) % k == 0:
        lb = math.floor((a%k)/k)
        if a%k == 0:
            lb = 1
        ub = math.floor((n-a%k)/k)
        # print(a, (a%k)/k, (n-a%k)/k)
        ans += (ub-lb+1)**2
print(ans)
"
"import math
N = int(input())
X = list(map(int, input().split()))

def average(a):
  return sum(a) / len(a)

avg = average(X)

res = 0
if avg - int(avg) >= 0.5:
  for i in X:
    res += (i - math.ceil(avg)) **2
else:
  for i in X:
    res += (i - math.floor(avg)) ** 2
print(res)"
"#!/usr/bin/env python
# coding: utf-8

# In[1]:


N = int(input())


# In[15]:


def func(i,j,N):
    ans = []
    for x in range(1,N+1):
        x_ = str(x)
        if x_[0] == str(i) and x_[-1] == str(j):
            ans += [x]
    return ans


# In[23]:


ans = 0
for i in range(10):
    for j in range(10):
        ans += len(func(i,j,N))*len(func(j,i,N))
print(ans)


# In[ ]:




"
"import sys

sys.setrecursionlimit(10 ** 6)
INF = float(""inf"")
MOD = 10 ** 9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    H, W = map(int, input().split())
    A = []
    cnt = 0
    for _ in range(H):
        a = list(map(int, input().split()))
        cnt += sum(a)
        A.append(a)

    ans = []
    for h in range(H):
        if h % 2 == 0:
            for w in range(W):
                if h == H - 1 and w == W - 1:
                    continue
                if A[h][w] % 2 == 1:
                    if w == W - 1:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w + 1] += 1
                        ans.append((h, w, h, w + 1))
                else:
                    continue
        else:
            for w in range(W)[::-1]:
                if h == H - 1 and w == 0:
                    continue
                if A[h][w] % 2 == 1:
                    if w == 0:
                        A[h][w] -= 1
                        A[h + 1][w] += 1
                        ans.append((h, w, h + 1, w))
                    else:
                        A[h][w] -= 1
                        A[h][w - 1] += 1
                        ans.append((h, w, h, w - 1))
                else:
                    continue

    print(len(ans))
    for a, b, c, d in ans:
        print(a + 1, b + 1, c + 1, d + 1)


if __name__ == ""__main__"":
    main()
"
"import copy
def change(k):
  if k==0:
    return int(1)
  else:
    return int(0)
t=0
m=0
S=list(map(int,list(input())))
M=copy.copy(S)
T=copy.copy(S)
N=len(S)
for i in range(N):
  if i==0:
    if T[i]==0:
      t+=1
      T[0]=1
    else:
      m+=1
      M[0]=0
  else:
    if T[i]==T[i-1]:
      T[i]=change(T[i])
      t+=1
    if M[i]==M[i-1]:
      M[i]=change(M[i])
      m+=1
print(min(t,m))"
"s = [d for d in input()]
if len(s)>=4:
    if s[0]=='Y' and s[1]=='A' and s[2]=='K' and s[3]=='I':
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")"
"n,m=map(int, input().split())
abl=[list(map(int, input().split())) for _ in range(n)]
cd=[list(map(int, input().split())) for _ in range(m)]

for ab in abl:
    dis=10**18
    num=0
    for i in range(m):
        x2,y2=cd[i]
        if dis>abs(ab[0]-x2)+abs(ab[1]-y2):
            dis=abs(ab[0]-x2)+abs(ab[1]-y2)
            num=i
    print(num+1)
"
"H = int(input())
ans,attack = 1,0
while(H > 1):
  attack += 1
  H //= 2
for i in range(1,attack+1):
  ans += 2**i
print(ans)"
"a = [int(input()) for _ in range(5)]
z,ans = 123,0
for i in a:
    if i%10!=0:z = min(z,i%10)
    ans += 10*((i+10-1)//10)
print(ans+z-10 if (z!=123) or (z==0) else ans)"
"N,A,B = map(int,input().split())
S = input()

countA = 0
countB = 0

for i in range(len(S)):
  if S[i] == 'a':
    if countA+countB < A+B:
      countA += 1
      print(""Yes"")
    else:
      print(""No"")
    
  elif S[i] == 'b':
    if countA+countB < A+B and countB < B:
      countB += 1
      print(""Yes"")
    else:
      print(""No"")
    
  elif S[i] == 'c':
    print(""No"")"
"a, b, c = map(int, input().split())

if any(i % 2 != 0 for i in [a, b, c]):
    print(0)
    exit()

if a == b and b == c:
    print(-1)
    exit()

cnt = 0
a_list = [0]*(1001001)
b_list = [0]*(1001001)
c_list = [0]*(1001001)
a_list[0] = a
b_list[0] = b
c_list[0] = c

for i in range(1, 1001001):
    a_list[i] = (b_list[i-1] + c_list[i-1]) // 2
    b_list[i] = (c_list[i-1] + a_list[i-1]) // 2
    c_list[i] = (a_list[i-1] + b_list[i-1]) // 2
    cnt += 1
    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:
        break

print(cnt)
"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, *H = map(int, read().split())

    ans = 0
    while True:
        changed = changed2 = False
        for i in range(N):
            if H[i] > 0:
                H[i] -= 1
                changed = True
                changed2 = True
            else:
                if changed:
                    ans += 1
                    changed = False
        if changed:
            ans += 1
        if not changed2:
            break

    print(ans)
    return


if __name__ == '__main__':
    main()
"
"a=input().strip().split()
b=[int(i) for i in a]

print(""Yes"" if b[0]+b[1]>=b[2] else ""No"")"
"import re
sin = input()
match = re.match(r""^(dream|dreamer|erase|eraser)+$"",sin)
print(""YES"" if match else ""NO"")"
"n,a,b = map(int,input().split())
mx = a + (n-1)*b
mi = (n-1)*a + b
ans = mx - mi + 1
if n == 1 and a != b or a > b:
  print(0)
else:
  print(ans)"
"import sys
from string import ascii_lowercase as a2z

input = sys.stdin.readline


def main():
    C = input().rstrip()

    i = a2z.index(C)
    ans = a2z[i + 1]
    print(ans)


if __name__ == ""__main__"":
    main()
"
"import sys
n=int(input())
a=[]
b=[]
for i in range(n):
  s=input()
  overall=0
  minimum=0
  current=0
  for j in range(len(s)):
    if s[j]=='(':
      current+=1
    else:
      current-=1
    minimum=min(current,minimum)
  overall=current
  if overall>=0:
    a.append([overall,minimum])
  else:
    b.append([overall,minimum])
finalsum=0
a=sorted(a, key=lambda t:t[1])
a.reverse()
b=sorted(b, key=lambda t:t[0]-t[1])
b.reverse()
for i in a:
  if finalsum+i[1]<0:
    print('No')
    sys.exit()
  finalsum+=i[0]
for i in b:
  if finalsum+i[1]<0:
    print('No')
    sys.exit()
  finalsum+=i[0]
if finalsum==0:
  print('Yes')
else:
  print('No')"
"n = int(input())
A = list(map(int, input().split()))

t = 0
for i in range(n):
    if A[i] % 2 == 1:
        t += 1
if t%2 == 1:
    print(""NO"")
else:
    print(""YES"")"
"import sys,math,collections,itertools
input = sys.stdin.readline

N,M,R=list(map(int,input().split()))
r=list(map(int,input().split()))
ABC = [[float('inf')]*(N+1) for _ in range(N+1)]
#条件のうち、重複経路は最短のみ残す
for _ in range(M):
    a,b,c = map(int,input().split())
    if ABC[a][b]>c:
        ABC[a][b]=c
        ABC[b][a]=c

#各頂点間の最小距離 Warshall-Floyd
dist = [[float('inf')]*(N+1) for _ in range(N+1)]
for k in range(1,N+1):
    for i in range(1,N+1):
        for j in range(1,N+1):
            ABC[i][j] = min(ABC[i][j],ABC[i][k] + ABC[k][j])

rotate = itertools.permutations(r)
ans = float('inf')
for rot in rotate:
    tmp = 0
    flag = 0
    for i in range(len(rot)-1):
        tmp +=ABC[rot[i]][rot[i+1]]
        if tmp>ans:
            flag = 1
            break
    if flag==0:
        ans = min(ans,tmp)
print(ans)
"
"N = int(input())
a_list = list(map(int, input().split()))
print(max(a_list)-min(a_list))"
"*a,=map(int,input().split())
b=[bin(abs(a[i+1]-a[i]))[::-1].find('1') for i in range(2)]
print((max(b) if b[0]*b[1]<0 else min(b))*(1-sum(a)%2))"
"import itertools

def Z(): return int(input())
def ZZ(): return [int(_) for _ in input().split()]

def main():

    N, K = ZZ()
    S = input()
    gr = itertools.groupby(S)
    l = []
    c = 0
    for i, j in gr:
        l.append([int(i), len(list(j))])
        if i == '0': c += 1
    if c <= K:
        print(N)
        return
    output = 0
    left = right = 0
    sum = c = 0
    while left < len(l):

        while right < len(l) and c < K:
            if l[right][0] == 0: c += 1
            sum += l[right][1]
            right += 1
        if right < len(l) and l[right][0] == 1:
            sum += l[right][1]
            right += 1
        output = max(output, sum)
        if right == left:
            right += 1
            left += 1
        else:
            if l[left][0] == 0: c -= 1
            sum -= l[left][1]
            left += 1
            while left < len(l) and c >= K:
                if l[left][0] == 0: c -= 1
                sum -= l[left][1]
                left += 1
    print(output)

    return

if __name__ == '__main__':
    main()
"
"S = sorted(input())
T = sorted(input(), reverse=True)

if S < T:
    print(""Yes"")
else:
    print(""No"")
"
"s = input()

if s[0:3] == 'KIH':
    s = 'A'+s
elif s[0:4] != 'AKIH':
    print('NO')
    exit(0)
# print(s)

if s[4:5] == 'B':
    s = s[0:4]+'A'+s[4:]
elif s[4:6] != 'AB':
    print('NO')
    exit(0)
# print(s)

if s[5:7] == 'BR':
    s = s[0:6]+'A'+s[6:]
elif s[5:7] != 'BA':
    print('NO')
    exit(0)

# print(s)
# print(s[7:8])
# print(s[7:9])
# print(len(s))
if (s[7:9] == 'RA' and len(s) == 9) or (s[7:8] == 'R' and len(s) == 8):
    print('YES')
else:
    print('NO')
"
"n,k,q=list(map(int,input().split()))
a=[0 for _ in range(n)]
for i in range(q):
  x=int(input())
  a[x-1] += 1
w=q-k+1
for i in range(n):
  if a[i] >= w:
    print('Yes')
  else:
    print('No')
"
"from itertools import accumulate

N = int(input())
A = [int(i) for i in input().split()]

B = list(accumulate(A))
p = B[-1]
ans = 10**12
for i in range(N-1):
    ans = min(ans,abs(p-2*B[i]))

print(ans)
"
"#import
#import math
#import numpy as np
N = int(input())
#= input()
#= map(int, input().split())
#= list(map(int, input().split()))
#= [input(), input()]

a = []

# dp[i][0]:Aを選んだ  dp[i][1]:Bを選んだ  dp[i][2]:Cを選んだ 

dp = [[0]*3 for _ in range(N+1)]

for _ in range(N):
    aa = list(map(int, input().split()))
    a.append(aa)

for i in range(1, N+1):
    for j in range(3):
        for k in range(3):
            if j != k:
                dp[i][k] = max(dp[i][k], dp[i-1][j]+a[i-1][k])

print(max(dp[-1]))"
"from collections import Counter, deque
from fractions import gcd
from functools import lru_cache
from functools import reduce
import functools
import heapq
import itertools
import math
import numpy as np
import re
import sys

sys.setrecursionlimit(10000)
INF = float('inf')


def cummax(li, first=-float('inf')):
    """"""
    累積 max
    :param collections.Iterable li:
    :param float first:
    :return:
    """"""
    cm = first
    ret = []
    for v in li:
        cm = max(v, cm)
        ret.append(cm)
    return ret


N, C = list(map(int, input().split()))
X, V = zip(*[list(map(int, input().split())) for _ in range(N)])

X = np.array(X)
V = np.array(V)

# cs1[i]: 時計回りに i 番目まで食べたときの累計カロリー
cs1 = V.cumsum() - X
# 累積 max
cm1 = np.array(cummax(cs1, first=0))

# cs2[i]: 反時計回りに i 番目まで食べたときの累計カロリー
cs2 = V[::-1].cumsum() - (C - X)[::-1]
# 累積 max
cm2 = np.array(cummax(cs2, first=0))
cs2 = cs2[::-1]
cm2 = cm2[::-1]

ans = max(cm1[-1], cm2[0])
# 時計回りに X[L] まで行って折り返したときの最大
for L in range(len(X) - 1):
    ans = max(ans, cm1[L] + cm2[L + 1] - X[L])
# 反時計回りが先の場合
for r in reversed(range(1, len(X))):
    ans = max(ans, cm2[r] + cm1[r - 1] - (C - X[r]))
print(ans)
"
"import sys
import re
import math
import collections
import bisect
import itertools
import fractions
import functools
import copy
import heapq
import decimal
import statistics
import queue

# import numpy as np

sys.setrecursionlimit(10 ** 9)
INF = 10 ** 16
MOD = 10 ** 9 + 7
# MOD = 998244353

ni = lambda: int(sys.stdin.readline())
ns = lambda: map(int, sys.stdin.readline().split())
na = lambda: list(map(int, sys.stdin.readline().split()))
nb = lambda: list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))


# ===CODE===


def main():
    s = list(input())
    l = len(s)
    dp1 = [0 for _ in range(l + 1)]
    dp2 = [0 for _ in range(l + 1)]
    dp1[0] = 1

    for i in range(l):
        if s[i] == ""1"":
            dp1[i + 1] = dp1[i] * 2
            dp2[i + 1] = dp1[i] + dp2[i] * 3
        else:
            dp1[i + 1] = dp1[i]
            dp2[i + 1] = dp2[i] * 3
        dp1[i + 1] %= MOD
        dp2[i + 1] %= MOD

    print((dp1[l] + dp2[l]) % MOD)


if __name__ == '__main__':
    main()
"
"w = input()
alpha = ""abcdefghijklmnopqrstuvwxyz""

check = True
for a in alpha:
  if w.count(a) % 2 == 1:
    check = False
    
print(""Yes"" if check else ""No"")"
"input = input()
W,H,x,y,r = map(int ,input.split())
if x - r < 0 or x + r > W or y - r < 0 or y + r > H:
    print(""No"")
if x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:
    print(""Yes"")
"
"n=int(input())
b=[int(i) for i in input().split()]
ind=1
ans=0
tmp=b[0]
for i in range(n):
    ans+=ind-i
    while ind<n:
        if tmp+b[ind]!=tmp^b[ind]:
            tmp-=b[i]
            break
        else:
            tmp+=b[ind]
            ind+=1
            ans+=1
print(ans)

    








"
"S = str(input())

if S == ""ABC"":
    print(""ARC"")
elif S == ""ARC"":
    print(""ABC"")"
"X,Y = map(int,input().split())
for i in range(X+1):
    a = i*2 + (X-i)*4
    if a == Y:
        print(""Yes"")
        break
if a != Y:
    print(""No"")
"
"A, G = [int(input()) for i in range(2)]
print(2*G - A)"
"n,m,q = map(int,input().split())

lr = [[0 for i in range(n+1)] for j in range(n+1)]


for i in range(m):
    l,r = map(int,input().split())
    lr[l][r] += 1

#pq = [[int(i) for i in input().split()]for j in range(q)]

dp = [[0 for i in range(n+1)] for j in range(n+1)]

for i in range(1,n+1):
    for j in range(i,n+1):
        dp[i][j] = dp[i][j-1]+lr[i][j]

ans_dp = [[0 for i in range(n+1)] for j in range(n+1)]

for i in range(1,n+1):
    for j in range(i,n+1):
        tmp = 0
        for k in range(j-i+1):
            tmp += dp[i+k][j]
        ans_dp[i][j] = tmp

for i in range(q):
    p,q = map(int,input().split())
    print(ans_dp[p][q])
"
"import sys

def main():
    input = sys.stdin.readline
    n = int(input())
    h_list = list(map(int, input().split()))
    l = -1
    r = -1
    result = 0
    while any((h > 0 for h in h_list)):
        for i,height in enumerate(h_list):
            if height > 0:
                if l == -1:
                    l = i
                if i == n-1:
                    r = i
                    break
            else:
                if l == -1:
                    continue
                elif r == -1:
                    r = i - 1
                    break

        if l == 0 and r == 0:
             h_list[0] = h_list[0] - 1
        else:
            for i in range(l,r+1):
                h_list[i] = h_list[i] - 1 
        l = -1
        r = -1
        result += 1
    print(result)
    return


if __name__ == '__main__':
    main()"
"import re
S=input()
print(""YES"" if re.match(""^A?KIHA?BA?RA?$"",S) else ""NO"")"
"N = int(input())

result = [0] * (N + 1)

for i in list(map(int, input().split())):
    result[i] += 1

result.pop(0)

for r in result:
    print(r)
"
"n = int(input())
S = [input() for _ in range(n)]

alp = 'abcdefghijklmnopqrstuvwxyz'
count = [float('inf') for _ in range(len(alp))]

for s in S:
    for i in range(len(alp)):
        count[i] = min(count[i], s.count(alp[i]))

ans = ''
for i in range(len(alp)):
    ans += alp[i] * count[i]
print(ans)"
"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

a.sort()
b.sort()
c.sort()

import bisect
rui=[0]
sm=0
for mid in b:
    ind = bisect.bisect_left(c,mid+1)
    sm+= (n-ind)
    rui.append(sm)

ans=0
for top in a:
    ind = bisect.bisect_left(b,top+1)
    tmp = rui[-1] - rui[ind]
    ans+=tmp
print(ans)"
"a,b = map(int,input().split())
n,m = map(int,input().split())
print(a*b-a*m-b*n+n*m)"
"import sys
input = sys.stdin.readline
from collections import deque


def read():
    H, W = map(int, input().strip().split())
    S = []
    for i in range(H):
        s = list(input().strip())
        S.append(s)
    return H, W, S


def solve(H, W, S):
    n_cells = 0
    for y in range(H):
        for x in range(W):
            if S[y][x] == ""."":
                n_cells += 1
    A = [[-1 for j in range(W)] for i in range(H)]
    A[0][0] = 1
    D = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    q = deque()
    q.append((0, 0))
    while q:
        y, x = q.popleft()
        for dy, dx in D:
            ny, nx = y + dy, x + dx
            if 0 <= ny < H and 0 <= nx < W and S[ny][nx] == ""."" and A[ny][nx] == -1:
                A[ny][nx] = A[y][x] + 1
                q.append((ny, nx))
    shortest = A[H-1][W-1]
    return n_cells - shortest if shortest > 0 else -1


if __name__ == '__main__':
    inputs = read()
    print(solve(*inputs))
"
"def readinput():
    n,k=map(int,input().split())
    s=input()
    return n,k,s

def main(n,k,s):
    ans=s[:k-1]+s[k-1].lower()+s[k:]
    return ans

if __name__=='__main__':
    n,k,s=readinput()
    ans=main(n,k,s)
    print(ans)
"
"import sys
import re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd
from itertools import accumulate, permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N, M = MAP()
P = []
C = []
for i in range(N):
    a, b = MAP()
    P.append([a, b])
for j in range(M):
    c, d = MAP()
    C.append([c, d])

def calculate_manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

for i in range(N):
    min_d = INF
    for j in range(M):
        tmp_d = calculate_manhattan_distance(P[i][0], P[i][1], C[j][0], C[j][1])
        if tmp_d < min_d:
            min_d = tmp_d
            ans_c_id = j + 1
    print(ans_c_id)
"
"#coding:UTF-8

n = input()
a = map(int,raw_input().split())
a.reverse()
for i in range(n):
    print a[i],"
"H,A = (int(x) for x in input().split())
print(H//A+(H%A>0))"
"N = int(input())
dic = {}
for i in range(N):
  a = input()
  dic[a] = dic.get(a, 0) + 1
M = int(input())
for i in range(M):
  b = input()
  dic[b] = dic.get(b, 0) - 1
d = sorted(dic.values(), reverse = True)
print(max(0, d[0]))"
"import sys
input = sys.stdin.readline
n = int(input())
f = [list(map(int,input().split()))for i in range(n)]
p = [list(map(int,input().split()))for i in range(n)]
ans = -float('inf')
for i in range(1,2**10):
    bin = format(i,'b').zfill(10)
    c = [0]*n
    for j in range(n):
        for k in range(10):
            if bin[k] == '1' and f[j][k] == 1:
                c[j] += 1
    r = 0
    for i in range(n):
        r += p[i][c[i]]
    ans = max(ans, r)
print(ans)
"
"import collections
N = int(input())
D = list(map(int, input().split()))
DC = collections.Counter(D)
M = int(input())
T = list(map(int, input().split()))
TC = collections.Counter(T)

for num, count in TC.items():
     if DC[num] < count:
         print('NO')
         exit()
print('YES')
"
"S = input()
ss = str()
for s in S:
  ss = ss + s
  if len(ss)==3:
    print (ss)
    break"
"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf
from itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement
from collections import deque,defaultdict,Counter
from bisect import bisect_left,bisect_right
from operator import itemgetter
from heapq import heapify,heappop,heappush
from queue import Queue,LifoQueue,PriorityQueue
from copy import deepcopy
from time import time
import string
import sys
sys.setrecursionlimit(10 ** 7)
def input() : return sys.stdin.readline().strip()
def INT()   : return int(input())
def MAP()   : return map(int,input().split())
def LIST()  : return list(MAP())

n = INT()
a = LIST()
for i in range(n):
    a[i] -= i + 1
a.sort()
b = a[n//2]
ans = 0
for x in a:
    ans += abs(x - b)
print(ans)"
"n, m = map(int, input().split())
a = list(map(int, input().split()))
a.sort(reverse=True)

# l[i] = (a[j] >= i を満たすjの個数)
l = [n for i in range(a[0]+1)]
for i in range(2, n+1):
    for j in range(a[-i], a[-i+1], -1):
        l[j] = n - i + 1

# 二分探索
# a[i] + a[j] >= x を満たす(i, j)がm組以上存在する最小のxを求める
start = 2 * a[-1]
stop = 2 * a[0]
while start < stop:
    i = (start + stop + 1) // 2
    num = 0
    for j in a:
        if i - j < 0:
            num += n
        elif i - j <= a[0]:
            num += l[i - j]
        else:
            break

    if num >= m:
        start = i
    else:
        stop = i - 1

num = 0
for i in a:
    if start - i < 0:
        num += n
    elif 0 <= start - i <= a[0]:
        num += l[start - i]
    else:
        break

# start <= a[i]+a[j] を満たす a[i]+a[j] を全て足す
ans = 0
for i in a:
    if start - i < 0:
        ans += 2 * i * n
    elif start - i <= a[0]:
        ans += 2 * i * l[start - i]
    else:
        break
ans -= (num - m) * start
print(ans)"
"import sys
a = list(map(int,sys.stdin.readlines()))
for i in range(10):
    for j in range(i+1,10):
        if a[i] < a[j]:
            a[i],a[j] = a[j],a[i]
            
for i in range(3):
    print(a[i])"
"def main():
    s = input()
    n = len(s)
    l, r, ans = 0, n-1, 0
    while l < r:
        if s[l] == s[r]:
            l += 1
            r -= 1
        elif s[l] == ""x"":
            ans += 1
            l += 1
        elif s[r] == ""x"":
            r -= 1
            ans += 1
        else:
            print(-1)
            exit()
    print(ans)


if __name__ == ""__main__"":
    main()
"
"def gcd(a,b):
  if b == 0:return a
  return gcd(b,a%b)
 
a = int(input())
print(360//gcd(360,a))
"
"from fractions import Fraction
import math
N = int(input())
ans = Fraction(4,N)
point = [1,math.floor(N/4)]
for h in range(max(point),3501):
    h_pro = Fraction(1,h)
    check = ans - h_pro
    target = [math.floor(4*h-N/N*h),h]
    for n in range(h,3501):
        check = ans - h_pro
        n_pro = Fraction(1,n)
        check -= n_pro
        if type(check) == ""int"":
            if check ==1:
                print(h, end="" "")
                print(n, end="" "")
                print(1)
                exit()
        elif check.numerator == 1:
            print(h, end="" "")
            print(n, end="" "")
            print(check.denominator)
            exit()"
"# https://atcoder.jp/contests/abc084/tasks/abc084_d
from itertools import accumulate


def get_prime(n):
    if not isinstance(n, int):
        raise TypeError('n is int type.')
    if n < 2:
        return []
    if n == 2:
        return [2]
    prime = [2]
    limit = int(n ** 0.5)
    nums = [i + 1 for i in range(2, n, 2)]
    while True:
        p = nums[0]
        if limit < p:
            return prime + nums
        prime.append(p)
        nums = [e for e in nums if e % p != 0]


primes = set(get_prime(10 ** 5))
like = [0] * 10 ** 5
for i in range(3, 10**5):
    if i in primes and (i + 1) // 2 in primes:
        like[i] = 1

like_accum = list(accumulate(like))

q = int(input())
for _ in range(q):
    l, r = list(map(int, input().split()))
    result = like_accum[r] - like_accum[l-1]
    print(result)
"
"N, K = map(int, input().split())
S = list(map(str, input()))

score = 0
for i in range(N - 1):
    if S[i + 1] == S[i]:
        score += 1
score = min(score + 2 * K, N - 1)

print(score)"
"score = int(input())

if score < 1200:
  print(""ABC"")
else:
  print(""ARC"")"
"n = int(input())
a = list(map(str,input().split()))
a.sort()
ans = 'YES'
for i in range(n-1):
    if a[i] == a[i+1]:
        ans = 'NO'
        break
print(ans)"
"n, s = map(int, input().split())
print(""Yes"" if 500*n >= s else ""No"")"
"n,m=map(int,input().split())
a=[int(input()) for i in range(m)]
d=[1]*(n+1)
for i in range(m):
  d[a[i]]=0
for i in range(2,n+1):
  if d[i]!=0:
    d[i]=d[i-1]+d[i-2]
print(d[n]%(10**9+7))"
"N, M, D = map(int, input().split())
print(""{:.9f}"".format((N-D)*(2 if D else 1)/(N*N)*(M-1)))"
"def main():
    a = int(input())
    b = int(input())
    h = int(input())

    print(int(((a + b) / 2) * h)) 

if __name__ == '__main__':
    main()"
"n,m,x = map(int, input().split())
a_list = list(map(int, input().split()))

former = []
latter = []

for i in range(len(a_list)):
    if a_list[i] < x:
        former.append(a_list[i])
    else:
        latter.append(a_list[i])
print(min(len(former), len(latter)))"
"import sys
sys.setrecursionlimit(10**6)

def iig(vn, en):
    res = [[] for _ in range(vn)]
    for _ in range(en):
        ai, bi = map(lambda x: int(x) - 1, input().split())
        res[ai].append(bi)
        res[bi].append(ai)
    return res

def sep_pc(graph, root=0):
    parent = [-1 for _ in range(n)]
    children = [None for _ in range(n)]
    def f(x, p):
        parent[x] = p
        children[x] = [y for y in graph[x] if y != p]
        for y in graph[x]:
            if y != p:
                f(y, x)
        return
    f(root, -1)
    return parent, children

def itree(n, root=0):
    return sep_pc(iig(n, n - 1), root)

mod = 10**9 + 7

fact_range = 10**5 + 3
facts = [1] * (fact_range + 1)
for i in range(0, fact_range):
    facts[i+1] = facts[i] * (i + 1) % mod

ifacts = [1] * (fact_range + 1)
ifacts[fact_range] = pow(facts[fact_range], mod - 2, mod)
for i in range(fact_range, 0, -1):
    ifacts[i-1] = ifacts[i] * i % mod

n, k = map(int, input().split())
p, c = itree(n)
def dfs(i=0, cur=k, avail=k-1):
    sz = len(c[i])
    if avail <= 0 and sz > 0 or sz > avail:
        return 0
    cur = cur * facts[avail] * ifacts[avail - sz] % mod
    for u in c[i]:
        cur = dfs(u, cur, k - 2)
    return cur
print(dfs())
"
"N=int(input())
D=[map(int, input().split()) for i in range(N)]
x, y = [list(i) for i in zip(*D)]

s=0
l=[]
for i in range(N):
  if x[i]==y[i]:
    s+=1
    if i==N-1:
      l.append(s)
  elif x[i]!=y[i]:
    l.append(s)
    s=0

if max(l)>=3:
  print(""Yes"")
else:
  print(""No"")"
"in_value = int(input())

if in_value >= 30:
  print(""Yes"")
else:
  print(""No"")"
"N,C,K = map(int,input().split())

T = []

for i in range(N):
    T.append(int(input()))
T.sort()
res = 0
cnt = 0
i = 0

while i < N:
    lim = T[i]+K
    while T[i] <= lim and cnt < C:
        i += 1
        cnt += 1
        if N == i:
            break
    res += 1
    cnt = 0
print(res)"
"n,m = map(int,input().split())
s = input()

s_0 = []
for i in range(n+1):
    if(s[i] == '0'):
        s_0.append(i)

# 二分木
import bisect

now = n
ans_rev = []
while(now != 0):
    next_i = bisect.bisect_left(s_0, now-m)
    next = s_0[next_i]
    if(now == next):
        print(-1)
        exit()
    ans_rev.append(now-next)
    now = next

print(' '.join(map(str, ans_rev[::-1])))"
"n = int(input())

odds = [i for i in range(1, n+1, 1) if i%2 != 0]
cnt_lists = []
for j in odds:
    cnt = 0
    for k in range(1, j+1, 1):
        if j%k == 0:
            cnt += 1
    cnt_lists.append(cnt)

ans = cnt_lists.count(8)
print(ans)"
"a,b=input().split()
c,d=input().split()
if a==c:
  print(""0"")
else:
  print(""1"")"
"h, w = map(int, input().split())
a = [i for i in [input() for i in range(h)] if ""#"" in i]
a = [i for i in zip(*a) if ""#"" in i]
for i in zip(*a):
  print("""".join(i))"
"Ss, Ts = input().split()
A, B = map(int, input().split())
Us = input().rstrip()

if Ss == Us:
    A -= 1
elif Ts == Us:
    B -= 1

print(A, B)
"
"rot_set = [
    (1,2,4,3,1), #0
    (0,3,5,2,0), #1
    (0,1,5,4,0), #2
    (0,4,5,1,0), #3
    (0,2,5,3,0), #4
    (1,3,4,2,1)  #5
]

dice_int = list(map(int, input().split()))
q = int(input())
right_face = []

for _ in range(q):
    a, b = map(int, input().split())
    a_idx = dice_int.index(a)
    b_idx = dice_int.index(b)

    for i in range(6):
        for j in range(4):
            if (a_idx, b_idx) == (rot_set[i][j], rot_set[i][j+1]):
                right_face.append(dice_int[i])

for i in range(q):
    print(right_face[i])
"
"S = input()
T = ""CODEFESTIVAL2016""
s = 0
for i,j in zip(S, T):
  if i == j:
    s += 1
print(16-s)"
"R,G,B,N = map(int,input().split())
cnt = 0
for r in range(N//R+1):
    for g in range(N//G+1):
        n = N-r*R-g*G
        if n>=0 and n%B==0:
            cnt += 1
print(cnt)"
"S=input()
i=0
kot=[]
for a in S:
    kot.append(a)
tok=list(reversed(kot))

for a in range(len(kot)):
    if kot[a]==tok[a]:
        i=0
    else:
        print(""No"")
        i=1
        break
if i==0:
    for a in range(int((len(kot)-1)/2)):
        if kot[a]==tok[int((len(kot)-1)/2)-a-1]:
            i=0
        else:
            print(""No"")
            i=1
            break

if i==0:
        for a in range(int((len(kot)-1)/2)):
            if kot[int((len(kot)+3)/2)+a-1]==tok[-a-1]:
                i=0

            else:
                print(""No"")
                i=1
                break

if i==0:
    print(""Yes"")
"
"N=int(input())

answer=0

answer+=(N**2-N)//2

print(answer)"
"def main():
    M = int(input())
    return 24 + (24-M)

if __name__ == '__main__':
    print(main())
"
"import heapq
N,K = map(int, input().split())
L = [[] for _ in range(N)]
h = []
for _ in range(N):
    t,d = map(int, input().split())
    L[t-1].append(d)
    heapq.heappush(h, (-d, t-1))

cnt = 0
for l in L:
    if len(l) > 0:
        cnt += 1

used = [0]*N
h1 = []
h2 = []
num = 0
if K <= cnt:
    while len(h2) < K:
        temp = heapq.heappop(h)
        if used[temp[1]] > 0:
            heapq.heappush(h1, temp)
            continue
        used[temp[1]] += 1
        heapq.heappush(h2, (-temp[0], temp[1]))
        num -= temp[0]
else:
    c2 = 0
    while len(h2) < K:
        temp = heapq.heappop(h)
        if used[temp[1]] > 0:
            if c2 < K-cnt:
                c2 += 1
            else:
                heapq.heappush(h1, temp)
                continue
        used[temp[1]] += 1
        heapq.heappush(h2, (-temp[0], temp[1]))
        num -= temp[0]

cnt = min(K, cnt)
ans = num + cnt**2
while len(h1) > 0 and h2[0][0] < -h1[0][0]:
    t1 = heapq.heappop(h1)
    t2 = heapq.heappop(h2)
    used[t2[1]] -= 1
    used[t1[1]] += 1
    if used[t2[1]] == 0:
        cnt -= 1
    if used[t1[1]] == 1:
        cnt += 1
    num += -t1[0]-t2[0]
    ans = max(ans, num+cnt**2)
    heapq.heappush(h2, (-t1[0], t1[1]))

print(ans)"
"def main():
    N,A,B=map(int,input().split())
    v=list(map(int,input().split()))
    v.sort(reverse=True)
    Amxv=sum(v[:A])
    c=v[A-1]
    m=v[:A].count(c) 
    n=v.count(c)
    fl=[1]*(N+1)
    for i in range(N):
        fl[i+1]=fl[i]*(i+1)
    print(Amxv/A)
    if v[0]-c==0:
        print(sum([fl[n]//(fl[i]*fl[n-i]) for i in range(A,min(B,n)+1)]))
    else:
        print(fl[n]//(fl[m]*fl[n-m]))

if __name__=='__main__':
    main()
    
"
"
def resolve():
    H, W, A, B = map(int, input().split())
    G = [[0] * W for _ in range(H)]

    for _ in range(B):
        print('0' * A + '1' * (W - A))
    for _ in range(H - B):
        print('1' * A + '0' * (W - A))


if __name__ == ""__main__"":
    resolve()"
"N = int(input())
S = [input() for i in range(N)]
d = {}
m = 0
for i in S:
    if i in d:
        d[i] += 1
        if d[i] > m:
            m = d[i]
    else:
        d[i] = 1
        
d = dict(sorted(d.items(), reverse=True))
a = {}
for i in d.keys():
    if m <= d[i]:
        a[i] = 0
a = sorted(a)
for i in a:
    print(i)"
"def main():
    n = int(input())
    s = input()

    wnum = s.count(""W"")
    enum = s.count('E')

    first = enum
    ans = first

    for i in range(n):
        if s[i] == ""E"":
            first -= 1
        if i >= 1:
            if s[i-1] == ""W"":
                first += 1
        if ans > first:
            ans = first
        #print(i, ans, first)
    print(ans)




if __name__ == ""__main__"":
    main()"
"# C - Slimes
def main():
    n = int(input())
    s = input()
    p = ''
    ans = ''

    for v in s:
        if v != p:
            ans += v
            p = v
        else:
            continue
    print(len(ans))

if __name__ == ""__main__"":
    main()"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N = int(input())
dp = [0]*90
dp[0] = 2
dp[1] = 1
for i in range(2, 90):
    dp[i] = dp[i-1]+dp[i-2]

print(dp[N])"
"import itertools
import math
#print(3 & (1 << 0))
def main():
    N = int(input())
    items = [i+1 for i in range(N)]

    locations=[]
    for i in range(N):
        locations.append(list(map(int, input().split())))

    paths =list(itertools.permutations(items))

    sum = 0
    for path in paths: # path = [1,2,3,4,5]
        for i in range(len(path)-1):
            from_idx = path[i] -1
            to_idx = path[i+1] -1
            xdiff= locations[from_idx][0] - locations[to_idx][0]
            ydiff= locations[from_idx][1] - locations[to_idx][1]
            sum = sum + math.sqrt(xdiff**2 + ydiff**2)
    print( sum / len(paths))
main()
"
"N = int(input())
a, b = 1, 1
for i in range(N):
    x, y = map(int, input().split())
    n = max((a + x - 1) // x, (b + y - 1) // y)
    a = n * x
    b = n * y
print(a + b)"
"n = int(input())
s = [input() for i in range(n)]
 
ab = 0
a = 0
b = 0
 
d = 0
for i in s:
	d += i.count('AB')
	if i[0] == 'B' and i[-1] == 'A':
		ab += 1
	elif i[-1] == 'A':
		a += 1
	elif i[0] == 'B':
		b += 1
 
if ab == 0:
	d += min(a,b)
elif a+b == 0:
	d += ab-1
else:
	d += ab+min(a,b)
print (d)"
"a, b = [int(n) for n in input().split()]
print(a*b if 1 <= a <= 9 and 1 <= b <= 9 else '-1')"
"# -*- coding: utf-8 -*-
K, T = map(int, input().split(' '))
A = list(map(int, input().split(' ')))
A = [(-a, i) for i, a in enumerate(A)]

import heapq
heapq.heapify(A)

prev = -1
while len(A) > 1:
    a, i = heapq.heappop(A)
    if i == prev:
        b, j = heapq.heappop(A)
        prev = j

        heapq.heappush(A, (a, i))
        b += 1
        if b != 0:
            heapq.heappush(A, (b, j))

    else:
        prev = i
        a += 1
        if a != 0:
            heapq.heappush(A, (a, i))



print(- A[0][0] - 1)





"
"N = int(input())
l = []
for s in str(N):
    if s == '1':
        l.append('9')
    elif s == '9':
        l.append('1')
    else:
        l.sppend(s)
print(''.join(l))"
"'''input
0
'''
k = input()
arr = []
zz = k%50
for i in range(50-zz):
	arr.append(49-zz)
for i in range(zz):
	arr.append(50)
zzz = k//50
arr = [arr[i]+zzz for i in range(50)]
print 50
for i in range(50):
	print arr[i],
"
"N = int(input())
A = list(map(int, input().split()))
mod = 10**9+7
G = [0]*3
ans = 1
for i in range(N):
    x = 0
    cnt = 0
    for j, g in enumerate(G):
        if g == A[i]:
            x = j if cnt == 0 else x
            cnt += 1
    
    G[x] += 1
    ans *= cnt
    ans = ans % mod

print(ans)"
"while True:
    [h,w] = map(int,input().split())
    if h==0 and w ==0: break
    s = ['#'*w+'\n', (('#' + '.'*(w-2) + '#')[0:w]+'\n')*(h-2), '#'*w+'\n' ]
    t = list(filter(lambda x: x!='', s))
    print(''.join(t[0:h]))"
"N = int(input())
A = sorted(list(map(int,input().split())))

if N%2==0:
  B = [1+2*(n//2) for n in range(N)]
else:
  B = [2*(n//2) for n in range(1,1+N)]

if A==B:
  print(pow(2,N//2,10**9+7))
else:
  print(0)"
"X=int(input())

ans=[0,0,8,7,6,5,4,3,2,1]

print(ans[int(X/200)])

"
"s = input()

left = 0
ans = 0

for x in s:
    if x == 'B':
        left += 1
        continue
    ans += left

print(ans)
"
"N = int(input())
A = [int(i) for i in input().split()]
A = sorted(A, reverse=True)

A += A[1:]
A = sorted(A, reverse=True)

print(sum(A[:N-1]))
"
"import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline    ####
def int1(x): return int(x) - 1
def II(): return int(input())
 
def MI(): return map(int, input().split())
def MI1(): return map(int1, input().split())
 
def LI(): return list(map(int, input().split()))
def LI1(): return list(map(int1, input().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
 
def SMI(): return input().split()
def SLI(): return list(input())
 
def printlist(lst, k=' '): print(k.join(list(map(str, lst))))
INF = float('inf')
 
# from math import ceil, floor, log2
# from collections import deque
# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum  # accumulate
 
def solve():
    S = SLI()
    l = len(S)
    MOD = 1000000007
    dp = [[0]*13 for _ in range(l+1)]
    dp[0][0] = 1
    mul = 1
    S = S[::-1]
    for i in range(l):
        if S[i] == '?':
            for q in range(10):
                for j in range(13):
                    dp[i+1][(q*mul + j)%13] += dp[i][j]
                    dp[i+1][(q*mul + j)%13] %= MOD
        else:
            for j in range(13):
                k = int(S[i])
                dp[i+1][(k*mul + j)%13] += dp[i][j]
                dp[i+1][(k*mul + j)%13] %= MOD
 
        mul = mul * 10 % 13
    # print(dp[-1])
    print(dp[-1][5] % MOD)
 
if __name__ == '__main__':
    solve()"
"x,y,z = map(int,input().split())
print (-(-((x-z)//(y+z))))
"
"h = int(input())
w = int(input())
n = int(input())

x = max(h, w)
cnt = 0
cur = 0

while cur < n:
	cur += x
	cnt+=1

print(cnt)"
"#%%
n = int(input())
a = [0] * n
for i in range(n):
    a[i] = int(input())
a.sort(reverse=True)
ook = []
tii = []
for i in range(0, n//2):
    ook.append(a[i])
for i in range(n//2, n):
    tii.append(a[i])
if n % 2 == 0:
    ans = 2 * (sum(ook) - sum(tii)) - (ook[-1] - tii[0])
    print(ans)
else:
    tmp = tii.pop(0)
    tmp1 = 2 * (sum(ook) - sum(tii)) + (tii[0]) - tmp
    tmp2 = 2 * (sum(ook) - sum(tii)) + tmp - ook[-1]
    print(max(tmp1, tmp2))

"
"while 1:
  x,y = map( int , raw_input().split() )
  if x == 0 and y == 0:
    break
  elif x <= y:
    print ""%d %d"" %(x,y) 
  elif y < x : 
    print ""%d %d"" %(y,x) "
"n, m = map(int, input().split())
cs = [[float('inf')] * n for _ in range(n)]
ns = [[0] * n for _ in range(n)]
for i in range(n):
    cs[i][i] = 0
for _ in range(m):
    a, b, c = map(int, input().split())
    a -= 1
    b -= 1
    cs[a][b] = cs[b][a] = c
    ns[a][b] = b
    ns[b][a] = a
for k in range(n):
    for i in range(n):
        for j in range(n):
            s = cs[i][k] + cs[k][j]
            if s < cs[i][j]:
                cs[i][j] = s
                ns[i][j] = ns[i][k]
used = set()
for i in range(n):
    for j in range(i + 1, n):
        path = [i]
        while path[-1] != j:
            s = path[-1]
            t = ns[s][j]
            path.append(t)
            used.add(tuple(sorted([s, t])))
print(m - len(used))"
"import sys

num = int(sys.stdin.readline().strip())

r0 = int(sys.stdin.readline().strip())
r1 = int(sys.stdin.readline().strip())

max_dis = r1 - r0
min_num = min(r0, r1)

for i in range(0, num-2):
    r = int(sys.stdin.readline().strip())
    max_dis = max(max_dis, r - min_num)
    min_num = min(min_num, r)

print max_dis"
"import numpy as np
from numpy.fft import rfft,irfft
import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
class Polynomial:
    def __init__(self,coefficient=None,dim=0,const=1):
        if coefficient == None:
            self.coefficient = np.zeros(dim+1, np.int64)
            self.coefficient[dim] = const
        else:
            self.coefficient = coefficient

    def __add__(self,other): # +
        f,g = self.coefficient, other.coefficient
        if len(f) > len(g): f,g = g,f

        h = Polynomial(dim=len(g)-1,const=0)
        h.coefficient[len(f):] += g[len(f):]
        h.coefficient[:len(f)] += f + g[:len(f)]
        return h
    
    def __iadd__(self,other): # +=
        h = self.__add__(other)
        self.coefficient = h.coefficient
        return self

    def __mul__(self,other): # *
        f = self.coefficient
        g = other.coefficient
        h = Polynomial()
        h.coefficient = self.fft(f,g)[:len(f)+len(g)-1]
        return h
    
    def __len__(self):
        return len(self.coefficient)

    def __getitem__(self,key):
        return self.coefficient[key]

    def get_coefficient(self,x):
        return self.coefficient[x]


    def fft(self,A,B,fft_len=1<<18):
        x = irfft(rfft(A,fft_len) * rfft(B,fft_len))
        return np.rint(x).astype(np.int64)



def main():
    N,M=mi()
    A=list(mi())
    
    coefficient = [0] * (2*10**5+10)
    for a in A:
        coefficient[a] += 1
    
    f = Polynomial(coefficient=coefficient)
            
    g = f * f
    ans = 0
    handshake = M
    for x in range(len(g)-1,1,-1):
        count = g[x]
        if count <= 0: continue

        if count > handshake:
            ans += handshake * x
        else:
            ans += count * x
 
        handshake = max(handshake-count,0)
        if handshake == 0:
            break

    print(ans)

if __name__ == ""__main__"":
    main()
"
"X = int(input())

eikaku = X if X < 180 else X - 180
cnt = 0

ans = 0
while True:
    ans += 1
    cnt += eikaku
    if cnt % 360 == 0:
        print(ans)
        break"
"def dist(a,b):
    ans = 0
    for i in range(D):
        ans += (b[i] - a[i])**2
    ans **= 0.5

    return ans

N,D = map(int, input().split())
X = [list(map(int, input().split())) for _ in range(N)]

count = 0
for i in range(N-1):
    for j in range(i+1, N):
        if dist(X[i],X[j]).is_integer():
            count += 1

print(count)"
"a,b = map(int, input().split())

c = (a * b) % 2

if c == 0:
    print(""Even"")
elif c == 1:
    print(""Odd"")"
"A, B, N = map(int, input().split())
x = N if B-1 > N else B-1
print(A*x//B-A*(x//B))"
"# -*- coding: utf-8 -*-
import sys 
from heapq import heappush, heappop
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

V,E = map(int, readline().split())
edges = [[] for _ in range(V+1)]

INF = 10**31

for _ in range(E):
    x,y,t = map(int, readline().split())
    edges[x].append((t,y))
    edges[y].append((t,x))
    

def dijkstra(q,dist,prev):
    while q:
        cost, v_from = heappop(q)
        if dist[v_from] < cost:
            continue
        for _cost,v_to in edges[v_from]:
            newcost = cost+_cost
            if newcost < dist[v_to]:
                prev[v_to] = v_from
                dist[v_to] = newcost #最短経路用
                heappush(q,(newcost,v_to))

pp = []
for i in range(1,V+1): 
    for j in range(i+1,V+1):
        dist = [INF]*(V+1) #最短距離用
        dist[i] = 0 #最短経路用
        prev=[None]*(V+1) 
        q = [(0,i)]
        dijkstra(q,dist,prev)
        p = [j]
        while prev[p[-1]]!=None:
            x,y = p[-1],prev[p[-1]]
            if x > y:
                x,y = y,x
            pp.append((x,y))
            p.append(prev[p[-1]])

print(E - len(set(pp)))"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

a, b, n = map(int, readline().split())

if n >= b:
    x = b - 1
else:
    x = n

ans = (a * x) // b - a * (x // b)
print(ans)"
"N = int(input())    

for h in range(1,3501):
    for n in range(h,3501):
        top = N*h*n
        bottom = 4*h*n-N*n-N*h
        if bottom > 0 and top%bottom == 0:
            print(h,n,top//bottom)
            exit()
"
"min2 = lambda x,y: x if x < y else y
H,N = map(int,input().split())


dp = [float('inf')]*(H+1)
dp[0] = 0

for _ in range(N):
    a,b = map(int,input().split())
    for i,v in enumerate(dp):
        j = min2(H,i+a)
        dp[j] = min2(dp[j],v+b)

print(dp[-1])"
"# 3 3 1 1

# 100
# 010
# 001

# 3 3 1 0

# 100
# 100
# 100

# 4 4 2 1
# 1100
# 1100
# 1100
# 0011

# 4 3 1 1

# 1000
# 1000
# 0111

# ……あ。全部0→左側A列を逆転させる→下側B列を逆転させる　で構成可能だ。

h, w, a, b = list(map(int, input().split()))

for _ in range(h-b):
    print('1'*a + '0'*(w-a))
for _ in range(b):
    print('0'*a + '1'*(w-a))
"
"n=int(input())
a=list(map(int , input().split()))
res_o=[0]*n
res_e=[0]*n
res_o[0]=a[0]
res_e[0]=a[0]

o=0
e=0

if res_o[0]<=0:
    o+=1-res_o[0]
    res_o[0]=1
if res_e[0]>=0:
    e+=res_e[0]+1
    res_e[0]=-1

for i in range(1,n):
    res_o[i]=res_o[i-1]+a[i]
    res_e[i]=res_e[i-1]+a[i]
    if i%2==0 and res_o[i]<=0:
        o+=(1-res_o[i])
        res_o[i]=1
    elif i%2==1 and res_o[i]>=0:
        o+=(res_o[i]+1)
        res_o[i]=-1
    if i%2==0 and res_e[i]>=0:
        e+=(1+res_e[i])
        res_e[i]=-1
    elif i%2==1 and res_e[i]<=0:
        e+=(1-res_e[i])
        res_e[i]=1
print(min(e,o))"
"import numpy as np
R=int(input())
circle=float(R*2*np.pi)
print(circle)
"
"a = [int(i) for i in input().split()]
k = int(input())
a.sort()
for i in range(k):
    a[2] *= 2
print(sum(a))"
"from collections import deque


def bellman_ford(start: int, goal: int, graph: list) -> list:
    '''bellman-ford法: 始点startから終点goalへの最小コストを求める
    重み付きグラフgraphは隣接リストで与えられ、辺のコストは負でも良い
    次の3種類のパターンが存在する
        1. 始点startから終点goalにたどり着くことが不可能である
           -> float(""inf"")を返す

        2. 始点startから終点goalにたどり着くことが可能であり、
           パス上に負閉路が存在する
           -> -float(""inf"")を返す

        3. 始点startから終点goalにたどり着くことが可能であり、
           パス上に負閉路が存在しない
           -> 最小コストを返す

    計算量: O(|E||V|)
    '''
    INF = float(""inf"")
    n = len(graph)

    # スタートから到達可能な地点を調べる
    is_reachable = [False] * n
    is_reachable[start] = True
    q = deque([start])
    while q:
        pos = q.popleft()
        for next_pos, _ in graph[pos]:
            if is_reachable[next_pos]:
                continue
            is_reachable[next_pos] = True
            q.append(next_pos)

    # 逆辺で構築したグラフで、ゴールから到着可能な地点を調べる
    reverse_graph = [[] for i in range(n)]
    for pos, edge in enumerate(graph):
        for next_pos, cost in edge:
            reverse_graph[next_pos].append((pos, cost))

    is_rev_reachable = [False] * n
    is_rev_reachable[goal] = True
    q = deque([goal])
    while q:
        pos = q.popleft()
        for next_pos, _ in reverse_graph[pos]:
            if is_rev_reachable[next_pos]:
                continue
            is_rev_reachable[next_pos] = True
            q.append(next_pos)            

    is_on_the_path_from_start_to_goal = [False] * n
    for i in range(n):
        is_on_the_path_from_start_to_goal[i] = is_reachable[i] and is_rev_reachable[i]

    distance = [INF] * n
    distance[start] = 0
    for _ in range(n):
        is_updated = False
        for pos, edge in enumerate(graph):
            for next_pos, cost in edge:
                if not is_on_the_path_from_start_to_goal[next_pos]:
                    continue
                if distance[pos] != INF and distance[pos] + cost < distance[next_pos]:
                    distance[next_pos] = distance[pos] + cost
                    is_updated = True
        if not is_updated:
            return distance[goal]
    # 負閉路が存在する
    return -INF


n, m, p = map(int, input().split())
info = [list(map(int, input().split())) for i in range(m)]

graph = [[] for i in range(n)]
for i in range(m):
    a, b, c = info[i]
    graph[a - 1].append((b - 1, -(c - p)))
ans = bellman_ford(0, n-1, graph)

if ans == -float(""inf""):
    print(-1)
else:
    print(max(-ans, 0))"
"a,b,c = map(int, input().split())

if a%2 == 0 or b%2 == 0 or c%2 == 0:
    print(0)
else:
    li = sorted([a,b,c])
    print(li[0]*li[1])"
"from collections import deque
import numpy as np

nCr = {}


def cmb(n, r):
    if r == 0 or r == n:
        return 1
    if r == 1:
        return n
    if (n, r) in nCr:
        return nCr[(n, r)]
    nCr[(n, r)] = cmb(n-1, r) + cmb(n-1, r-1)
    return nCr[(n, r)]


N, P = map(int, input().split())
A = np.array(list(map(int, input().split())))

li = list(np.mod(A, 2))
zero = li.count(0)
one = li.count(1)

if P == 0:
    combi = [0] + [2 * x for x in range(1, (one + 2) // 2)]
if P == 1:
    combi = [1] + [2 * x + 1 for x in range(1, (one + 1) // 2)]

q = deque(combi)

right = 0
while q:
    c = q.popleft()
    tmp = cmb(one, c)
    right += tmp

print(2**zero * right)"
"N,M = map(int, input().split())
L = [0]*M
R = [0]*M

for i in range (M):
  L[i],R[i] = map(int, input().split())

L_SORT = sorted(L)
R_SORT = sorted(R)

#print(L_SORT)
#print(R_SORT)

L_MAX = L_SORT[M-1]
R_MIN = R_SORT[0]

#print(L_MAX)
#print(R_MIN)


if (R_MIN - L_MAX) < 0:
  print(0)
else:
  print(R_MIN-L_MAX + 1)"
"def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10**7)
    from collections import Counter, deque
    from itertools import combinations, permutations, accumulate, groupby, product
    from bisect import bisect_left,bisect_right
    from heapq import heapify, heappop, heappush
    import math
    #from math import gcd

    #inf = 10**17
    #mod = 10**9 + 7

    n,k,c = map(int, input().split())
    s = input().rstrip()
    left = [0]*n
    day = 0
    temp = 1
    while day < n:
        if s[day] == 'o':
            left[day] = temp
            temp += 1
            day += c
        day += 1

    right = [0]*n
    day = n-1
    temp = k
    while 0 <= day:
        if s[day] == 'o':
            right[day] = temp
            temp -= 1
            day -= c
        day -= 1

    for i in range(n):
        if left[i] == right[i] and left[i] != 0:
            print(i+1)

if __name__ == '__main__':
    main()"
"import math

N = int(input())
A = list(map(int, input().split()))

Sum = 0
mod = (10 ** 9) + 7

for i in range(len(bin(max(A)))-2):
    Sum_1 = 0
    for j in range(N):
        #print(i, j)
        if ((A[j] >> i) & 1):
            Sum_1 += 1

    Sum_0 = N - Sum_1

    Sum = (Sum + ((Sum_0 * Sum_1) % mod * (2 ** i)) % mod) % mod
    # print(Sum_0,Sum_1)

print(Sum)
"
"n, k = map(int, input().split())
a = list(map(int, input().split()))
#from numpy import sign
#import numpy as np
out = float('Inf')
for i in range(0, n - k + 1):
    ans = abs(a[i] - a[i + k - 1]) + min(abs(a[i]), abs(a[i + k - 1]))
    out = min(out, ans)
print(out)"
"a = int(input())
c = a * a
d = a * a * a
print(a+c+d)"
"#!/usr/bin python3
# -*- coding: utf-8 -*-

def main():
    T = input()
    print(T.replace('?','D'))

if __name__ == '__main__':
    main()"
"'''
Created on 2020/08/28

@author: harurun
'''
def main():
  import sys
  pin=sys.stdin.readline
  pout=sys.stdout.write
  perr=sys.stderr.write
  
  X=int(pin())
  i=1
  while i<=X:
    if i*(i+1)>=2*X:
      print(i)
      return 
    i+=1
  return 
main()"
"n = int(input())
a = list(map(int, input().split()))
l = [0] * n

for i in range(n - 1):
    if a[i] > 0:
        l[a[i] - 1] += 1

for i in range(n):
    print(l[i])
"
"N, K = map(int,input().split())

min = 1
max = N -(K-1)
if K == 1:
    print(0)
else:
    print(max-min)"
"import math
N, K = map(int,input().split())
logs = list(map(int,input().split()))
a = 0
b = max(logs)
b_memo = set()
count=0
flg =0
while b-a > 1:
    c = (a+b)//2
    times = []
    for i in logs:
        times.append(math.ceil(i/c)-1)
    if sum(times) > K:
        a = c
    else:
        b = c

print(b)"
"import sys
input = sys.stdin.readline

X, Y = map(int, input().split())

print(int(X + 0.5*Y))"
"D,T,S = map(int, open(0).read().split())
if T * S >= D:
    print('Yes')
else:
    print('No')"
"n=int(input())
res=1
for i in range(n):
    res*=(i+1)
    if res>=10**9+7:
        res%=(10**9+7)
print(res)
"
"import math
from itertools import combinations_with_replacement

n, p = map(int, input().split())
A = list(map(int, input().split()))
odd = []
even = []


def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


for a in A:
    if a % 2 == 0:
        even.append(a)
    else:
        odd.append(a)
even_count = []
for i in range(len(even)+1):
    even_count.append(combinations_count(len(even), i))
odd_odd_count = []
odd_even_count = []
for i in range(len(odd)+1):
    cnt = combinations_count(len(odd), i)
    if i % 2 == 1:
        odd_odd_count.append(cnt)
    else:
        odd_even_count.append(cnt)
ans = 0
if p == 0:
    for i in even_count:
        for j in odd_even_count:
            ans += i*j
else:
    for i in even_count:
        for j in odd_odd_count:
            ans += i*j

print(ans)
"
"a, b, c = [int(x) for x in input().rstrip().split()]
if a == b and b == c:
    print(""Yes"")
else:
    print(""No"")
"
"ABC=list(map(int,input().split()))
five=ABC.count(5)
seven=ABC.count(7)
if (five==2)&(seven==1):
  print(""YES"")
else:
  print(""NO"")"
"from collections import Counter,defaultdict,deque
from heapq import heappop,heappush,heapify
import sys,bisect,math,itertools,fractions
from decimal import Decimal
sys.setrecursionlimit(10**8)
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n,K = inpl()
a = [inpl() for _ in range(n)]
res = INF
a.sort(key=lambda x:x[0])
for j in range(n-1):
    for k in range(j+1,n):
        l = a[j][0]
        r = a[k][0]
        b = [a[j],a[k]]
        cnt = 2
        for _ in range(n):
            if _ == j or _ == k:
                continue
            if l < a[_][0] < r:
                cnt += 1
                b += [a[_]]
        if cnt < K: continue
        b.sort(key=lambda x:x[1])
        for _ in range(cnt-K+1):
            u = max(x[1] for x in b[_:_+K])
            d = min(x[1] for x in b[_:_+K])
            res = min(res, (r-l)*(u-d))
            # print(res)
print(res)
"
"import math
n,x = map(int,input().split())
xl = list(map(int,input().split()))
dis = []
ans = 0
for i in range(n):
  dis.append(abs(x-xl[i]))
for i in range(n):
  ans = math.gcd(ans,dis[i])
print(ans)"
"import os
import sys
import numpy as np

def solve(N, K, S, P, R, T):
    dp = np.zeros((N+1, 3), dtype=np.int64)
    for i in range(1, N+1):
        c = T[i]
        dp[i, 0] = max(dp[i-K, 1], dp[i-K, 2]) + (c == ""r"") * R
        dp[i, 1] = max(dp[i-K, 0], dp[i-K, 2]) + (c == ""s"") * S
        dp[i, 2] = max(dp[i-K, 0], dp[i-K, 1]) + (c == ""p"") * P
    #d = dp.max(1)
    d = np.zeros(N+1, dtype=np.int64)
    for i in range(N+1):
        d[i] = dp[i].max()
    ans = d[-K:].sum()
    return ans


# >>> numba compile >>>
numba_config = [
    [solve, ""i8(i8,i8,i8,i8,i8,string)""],
]
if sys.argv[-1] == ""ONLINE_JUDGE"":
    from numba import njit
    from numba.pycc import CC
    cc = CC(""my_module"")
    for func, signature in numba_config:
        vars()[func.__name__] = njit(signature)(func)
        cc.export(func.__name__, signature)(func)
    cc.compile()
    exit()
elif os.name == ""posix"":
    exec(f""from my_module import {','.join(func.__name__ for func, _ in numba_config)}"")
else:
    from numba import njit
    for func, signature in numba_config:
        vars()[func.__name__] = njit(signature, cache=True)(func)
    print(""compiled!"", file=sys.stderr)
# <<< numba compile <<<


def main():
    N, K = map(int, input().split())
    S, P, R = map(int, input().split())
    T = ""_"" + input()
    ans = solve(N, K, S, P, R, T)
    print(ans)

main()
"
"from collections import Counter
L=list(map(int,input().split()))
A=Counter(L)
print(A.most_common()[-1][0])"
"N = int(input())
S = list(input())
x = 0
max = 0
for i in range(N):
    if S[i] == ""I"":
        x += 1
    else:
        x -= 1
    if x > max:
        max = x
print(max)"
"S = input()
print(""YES"" if S.count(""o"") >= abs(len(S)-7) or len(S) < 8 else ""NO"")"
"x,y,z,k=map(int,input().split())
a,b,c=[list(map(int,input().split())) for i in range(3)]
l=sorted([bb+cc for bb in b for cc in c],reverse=1)[:k]
t=sorted([ll+aa for aa in a for ll in l],reverse=1)
for i in range(k):
    print(t[i])"
"from itertools import accumulate
def myAnswer(N:int,A:list) -> int:
   accum = list(accumulate(A))
   ans = 10**10
   now = accum.pop()
   for a in accum:
      if(abs(now - a - a) < ans):
         ans = abs(now - 2*a)
   return ans

   

def modelAnswer():
   tmp=1
def main():
   N = int(input())
   A = list(map(int,input().split()))
   print(myAnswer(N,A[:]))
if __name__ == '__main__':
   main()
"
"N = int(input())
A = list(map(int, input().split()))
R = [0] * 8
A.sort()
c = 0
for a in A:
    if 1 <= a < 400:
        R[0] = 1
    elif 400 <= a < 800:
        R[1] = 1
    elif 800 <= a < 1200:
        R[2] = 1
    elif 1200 <= a < 1600:
        R[3] = 1
    elif 1600 <= a < 2000:
        R[4] = 1
    elif 2000 <= a < 2400:
        R[5] = 1
    elif 2400 <= a < 2800:
        R[6] = 1
    elif 2800 <= a < 3200:
        R[7] = 1
    else:
        c += 1

if c != 0 and not 1 in R:
    mi = 1
else:
    mi = R.count(1)
ma = R.count(1) + c

print(mi, ma)"
"word = input()
print(word.swapcase())

"
"a, b, c, d = map(int, input().split())

#a<b<c
ba =abs(b-a)
cb =abs(c-b)
ca =abs(c-a)

if ca <= d:
    print(""Yes"")
elif ba <= d and cb<= d:
    print(""Yes"")
else:
    print(""No"")"
"n = int(input())
S = input()
k = S[int(input())-1]
print(*[s if s==k else '*' for s in S], sep='')
"
"n = int(input())
V = list(map(int,input().split()))
Ce = {}
Co = {}
for i in range(n):
    v = V[i]
    if i%2==0:
        if v not in Ce:
            Ce[v] = 0
        Ce[v] += 1
    else:
        if v not in Co:
            Co[v] = 0
        Co[v] += 1
Ce = sorted(list(Ce.items()),key=lambda x:x[1],reverse=True)
Co = sorted(list(Co.items()),key=lambda x:x[1],reverse=True)
if len(Ce)==1 and len(Co)==1 and Ce[0][0]==Co[0][0]:
    m = n//2
else:
    if Ce[0][0]!=Co[0][0]:
        m = n-Ce[0][1]-Co[0][1]
    else:
        m1 = n-Ce[1][1]-Co[0][1]
        m2 = n-Ce[0][1]-Co[1][1]
        m = min(m1,m2)
print(m)"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(pow(10, 6))


def main():
    n, m, p = map(int, input().split())

    nodes = []
    for _ in range(m):
        a, b, c = map(int, input().split())
        nodes.append((a - 1, b - 1, -(c - p)))
    
    d = [float(""inf"") for _ in range(n)]
    pre = [-1 for _ in range(n)]
    d[0] = 0
    for _ in range(n):
        for nod in nodes:
            if d[nod[1]] > d[nod[0]] + nod[2]:
                d[nod[1]] = d[nod[0]] + nod[2]
                pre[nod[1]] = nod[0]

    for i, nod in enumerate(nodes):
        if d[nod[1]] > d[nod[0]] + nod[2]:
            nodes[i] = (nod[0], nod[1], -float('inf'))
    
    d = [float(""inf"") for _ in range(n)]
    pre = [-1 for _ in range(n)]
    d[0] = 0
    for _ in range(n):
        for nod in nodes:
            if d[nod[1]] > d[nod[0]] + nod[2]:
                d[nod[1]] = d[nod[0]] + nod[2]
                pre[nod[1]] = nod[0]

    path = set()
    fr = n - 1
    while pre[fr] != -1:
        if fr in path:
            break
        path.add(pre[fr])
        fr = pre[fr]

    for nod in nodes:
        if d[nod[1]] > d[nod[0]] + nod[2]:
            if nod[0] in path:
                print(-1)
                return

    if d[n - 1] == -float('inf'):
        print(-1)
        return 

    if d[n - 1] > 0:
        print(0)
    else:
        print(-d[n - 1])
    

if __name__ == '__main__':
    main()
"
"n = int(input())
x = list(map(float, input().split(' ')))
y = list(map(float, input().split(' ')))
p1 = 0.0
p2 = 0.0
p3 = 0.0
pm = 0.0
i = 0
while i < n:
    p1 += abs(x[i] - y[i])
    p2 += pow(abs(x[i] - y[i]), 2)
    p3 += pow(abs(x[i] - y[i]), 3)
    pm = max(pm, abs(x[i] - y[i]))
    i += 1
p2 = pow(p2, 0.5)
p3 = pow(p3, 0.333333333333333)
ans = '{0:.8f}'.format(p1) + '\n'
ans += '{0:.8f}'.format(p2) + '\n'
ans += '{0:.8f}'.format(p3) + '\n'
ans += '{0:.8f}'.format(pm)
print(ans)
"
"#52 大文字変換

S = str(input())

swa = S.swapcase()

print(swa)
"
"def main():
  n,m,k=map(int,input().split())
  ab=[list(map(int,input().split())) for _ in range(m)]
  cd=[list(map(int,input().split())) for _ in range(k)]
  friend=[set()for _ in range(n)]
  block=[set()for _ in range(n)]
  for a,b in ab:
    friend[a-1].add(b-1)
    friend[b-1].add(a-1)
  for c,d in cd:
    block[c-1].add(d-1)
    block[d-1].add(c-1)
  # 友達連結内でかつ友達でもブロックでもない。
  # 友達連結グループわけ
  ans=[0]*n
  seen=[0]*n
  for t in range(n):
    if seen[t]==1:
      continue
    member=set()
    todo=[t]
    seen[t]=1
    while todo:
      t=todo.pop()
      member.add(t)
      f=friend[t]
      for fi in f:
        if seen[fi]==0:
          todo.append(fi)
          seen[fi]=1
    mn=len(member)
    for m in member:
      ans[m]=mn-len(block[m].intersection(member))-len(friend[m])-1
  print(' '.join(map(str,ans)))
if __name__=='__main__':
  main()
"
"from math  import gcd
n, m = map(int, input().split())
s = input()
t = input()

g = gcd(n, m)
ans = n*m//g

""""""
最小公倍数の長さで収まらない場合は、何をやってもダメ
""""""
for i in range(g):
    if not s[i*n//g] == t[i*m//g]:
        print(-1)
        exit(0)
print(ans)


"
"s=str(input())
if 'C' in s and 'F' in s:
  if s.find('C')<s.rfind('F'):
    print('Yes')
  else:
    print('No')
else:
  print('No')
  exit()"
"N = int(input())
T,A = map(int, input().split())
H = list(map(int, input().split()))

L = [abs(A - T + h*0.006) for h in H]

print(L.index(min(L)) + 1)"
"N = int(input())
A = int(input())

MASU = N*N
black = MASU - A
print(black)"
"a,s,c=input().split()
print(""A"" + s[0].upper() + ""C"")"
"input_lists = list(input().split(' '))
result = [input_lists[-1]]
result += input_lists[0:-1]
result = ' '.join(result)
print(result)"
"x1,x2,x3,x4,x5,x6 = map(int,(input().split()))
t = input()
x=x1


L=[x1,x2,x3,x4,x5,x6]
n= len(t)
T=[]
M=[]
for i in range(n):
    T.append(t[:1])
    t=t[1:]



for i in T:
    if i is ""S"":
        L = [L[4],L[0],L[2],L[3],L[5],L[1]]
    elif i is ""E"":
        L = [L[3], L[1], L[0], L[5], L[4], L[2]]
    elif i is ""N"":
        L = [L[1], L[5], L[2], L[3], L[0], L[4]]
    else:
        L = [L[2], L[1], L[5], L[0], L[4], L[3]]



print(L[0])"
"H, A = map(int, input().split())

res = H // A
if H % A:
  res += 1
  
print(res)"
"import os, sys, re, math

N = int(input())

print(((N + 1) // 2) / N)
"
"from itertools import accumulate
n=int(input())
w=list(map(int,input().split()))
w=list(accumulate(w))
for i in range(n):
  if w[i]*2==w[-1]:
    print(0)
    break
  elif w[i]*2>w[-1]:
    print(min((w[i]*2-w[-1]),(w[-1]-w[i-1]*2)))
    break"
"_=input()
print(_[::len(_)%3-1])"
"n, k = input().split()
n = int(n)
k = int(k)

if k == 1:
  print(0)
else:
  print(n-k)"
"h, w = list(map(int, input().split()))
s = []
up, down, right, left = [
    [[0 for _ in range(w)] for _ in range(h)] for _ in range(4)]
for _ in range(h):
    s.append(list(input()))

for j in range(w):
    for i in range(h - 1, -1, -1):
        if s[i][j] == ""."":
            if i == h - 1:
                down[i][j] = 1
            else:
                down[i][j] = down[i + 1][j] + 1

for j in range(w):
    for i in range(h):
        if s[i][j] == ""."":
            if i == 0:
                up[i][j] = 1
            else:
                up[i][j] = up[i - 1][j] + 1

for i in range(h):
    for j in range(w - 1, -1, -1):
        if s[i][j] == ""."":
            if j == w - 1:
                right[i][j] = 1
            else:
                right[i][j] = right[i][j + 1] + 1

for i in range(h):
    for j in range(w):
        if s[i][j] == ""."":
            if j == 0:
                left[i][j] = 1
            else:
                left[i][j] = left[i][j - 1] + 1

res = 0
for i in range(h):
    for j in range(w):
        lit = up[i][j] + down[i][j] + right[i][j] + left[i][j] - 3
        res = max(res, lit)
print(res)
"
"N,D = map(int,input().split())
count = 0
for i in range(N):
    x,y = map(int,input().split())
    d = (x**2+y**2)**(1/2)
    if d <= D:
        count += 1
print(count)"
"from collections import Counter
N = int(input())
C = Counter(input())

mod = 10 ** 9 + 7
ans = 1
for v in C.values():
    ans *= (v + 1)  # 使う:v通り、使わない1通り
    ans %= mod

ans -= 1
print(ans % mod)"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solve():
    N = int(input())
    A = list(map(int, input().split()))

    if A[0] != 0:
        if N == 0 and A[0] == 1:
            print('1')
            exit()
        else:
            print('-1')
            exit()

    if N == 0:
        print('1')
        exit()

    v = [0 for _ in range(N + 1)]
    v[N] = A[N]

    for i in range(N - 1, -1, -1):
        up = min(2 ** i, v[i + 1] + A[i])
        v[i] = up

    # print(v)
    for i in range(N):
        up = min(v[i + 1], (v[i] - A[i]) * 2)
        v[i + 1] = up

    # print(v)
    ans = 0
    for i in range(N + 1):
        if v[i] < A[i]:
            print('-1')
            exit()
        ans += v[i]

    # print(v)
    print(ans)


if __name__ == '__main__':
    solve()
"
"N,M=map(int,input().split())
cnt=[0 for i in range(N)]


for i in range(M):
    a,b=map(int,input().split())
    cnt[a-1]+=1
    cnt[b-1]+=1

for i in range(N):
    print(cnt[i])"
"#!/usr/bin/env python

import random

class Dice:
    def __init__(self, top, s, e, w, n, bottom):
        self.top    = top
        self.s      = s
        self.e      = e
        self.w      = w
        self.n      = n
        self.bottom = bottom

    def rotate(self, dist):
        if dist == 'N':
            self.top, self.s, self.n, self.bottom = self.s, self.bottom, self.top, self.n 
        elif dist == 'S':
            self.s, self.bottom, self.top, self.n = self.top, self.s, self.n, self.bottom 
        elif dist == 'E':
            self.top, self.e, self.w, self.bottom = self.w, self.top, self.bottom, self.e 
        elif dist == 'W':
            self.w, self.top, self.bottom, self.e = self.top, self.e, self.w, self.bottom 

if __name__ == '__main__':
    dice = Dice(*map(int, raw_input().split()))

    ref = dict()
    while len(ref)<24:
        ref[(dice.top, dice.s)] = dice.e
        dice.rotate('NSEW'[random.randint(0,3)])

    for _ in range(input()):
        top, s = map(int, raw_input().split())
        print ref[(top, s)]

"
"from collections import*
s,t=Counter(input()),Counter(input())
print(""YNeos""[sorted(s.values())!=sorted(t.values())::2])"
"n = int(input())
a_list = list(map(int,input().split()))
print(max(a_list)-min(a_list))"
"##### 解けた #####

X,t=list(map(int,input().split("" "")))

print(max(X-t,0))"
"import sys

s=list(input())
t=list(input())


start=[-1]*26
end=[-1]*26

for i in range(len(s)):
    a=ord(s[i])-ord('a')
    b=ord(t[i])-ord('a')
    if(start[a]!=-1 or end[b]!=-1):
        if(start[a]!=b or end[b]!=a):
            print(""No"")
            sys.exit()
    start[a]=b
    end[b]=a
print(""Yes"")"
"from collections import deque

class SegmentTree():
    def __init__(self,n,ide_ele,merge_func,init_val):
        self.n=n
        self.ide_ele=ide_ele
        self.merge_func=merge_func
        self.val=[0 for i in range(1<<n)]
        self.merge=[0 for i in range(1<<n)]
        self.parent=[-1 for i in range(1<<n)]
        deq=deque([1<<(n-1)])
        res=[]
        while deq:
            v=deq.popleft()
            res.append(v)
            if not v&1:
                gap=(v&-v)//2
                self.parent[v-gap]=v
                deq.append(v-gap)
                self.parent[v+gap]=v
                deq.append(v+gap)
        for v in res[::-1]:
            if v-1<len(init_val):
                self.val[v-1]=init_val[v-1]
            self.merge[v-1]=self.val[v-1]
            if not v&1:
                gap=(v&-v)//2
                self.merge[v-1]=self.merge_func(self.merge[v-1],self.merge[v-gap-1],self.merge[v+gap-1])

    def update(self,id,x):
        self.val[id]=x
        pos=id+1
        while pos!=-1:
            if pos&1:
                self.merge[pos-1]=self.val[pos-1]
            else:
                gap=(pos&-pos)//2
                self.merge[pos-1]=self.merge_func(self.val[pos-1],self.merge[pos+gap-1],self.merge[pos-gap-1])
            pos=self.parent[pos]

    def cnt(self,k):
        lsb=(k)&(-k)
        return (lsb<<1)-1

    def lower_kth_merge(self,nd,k):
        res=self.ide_ele
        id=nd
        if k==-1:
            return res
        while True:
            if not id%2:
                gap=((id)&(-id))//2
                l=id-gap
                r=id+gap
                cnt=self.cnt(l)
                if cnt<k:
                    k-=cnt+1
                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])
                    id=r
                elif cnt==k:
                    res=self.merge_func(res,self.val[id-1],self.merge[l-1])
                    return res
                else:
                    id=l
            else:
                res=self.merge_func(res,self.val[id-1])
                return res

    def upper_kth_merge(self,nd,k):
        res=self.ide_ele
        id=nd
        if k==-1:
            return res
        while True:
            if not id%2:
                gap=((id)&(-id))//2
                l=id-gap
                r=id+gap
                cnt=self.cnt(r)
                if cnt<k:
                    k-=cnt+1
                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])
                    id=l
                elif cnt==k:
                    res=self.merge_func(res,self.val[id-1],self.merge[r-1])
                    return res
                else:
                    id=r
            else:
                res=self.merge_func(res,self.val[id-1])
                return res

    def query(self,l,r):
        id=1<<(self.n-1)
        while True:
            if id-1<l:
                id+=((id)&(-id))//2
            elif id-1>r:
                id-=((id)&(-id))//2
            else:
                res=self.val[id-1]
                if id%2:
                    return res
                gap=((id)&(-id))//2
                L,R=id-gap,id+gap
                #print(l,r,id,L,R)
                left=self.upper_kth_merge(L,id-1-l-1)
                right=self.lower_kth_merge(R,r-id)
                return self.merge_func(res,left,right)

ide_ele=0

def seg_func(*args):
    res=ide_ele
    for val in args:
        res|=val
    return res

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

import sys

input=sys.stdin.readline

N=int(input())
S=input().rstrip()

init_val=[1<<(ord(S[i])-97) for i in range(N)]
test=SegmentTree(19,ide_ele,seg_func,init_val)

for _ in range(int(input())):
    t,l,r=input().split()
    t,l=int(t),int(l)
    if t==1:
        val=ord(r)-97
        test.update(l-1,1<<val)
    else:
        r=int(r)
        res=test.query(l-1,r-1)
        print(popcount(res))"
"N = int(input())
memo = [1]*(N+1)
for i in range(2,N+1):
    tmp = i
    while tmp <= N:
        memo[tmp] += 1
        tmp += i
ans = 0
for key,val in enumerate(memo):
    ans += key*val
print(ans)"
"while True:
	s = input()
	if s == ""-"":
		break
	m = int(input())
	for n in range(m):
		h = int(input())
		t = s[0:h]
		u = s[h:]
		s = u + t
	print(s)"
"def main():
    a, b, c = map(int, input().split())
    if (a + b + c) >= 22:
        print(""bust"")
    else:
        print(""win"")
main()"
"def resolve():
    import sys
    import itertools
    readline = sys.stdin.readline    # 1行だけ文字列にする

    N, M = map(int, readline().split())
    lst = [set(map(int, readline().split())) for _ in [0] * M]
    d = []
    ans = 0
    for i in range(2, N + 1):
        d.append(i)
    for i in itertools.permutations(d, N - 1):
        cnt = 0
        if {1, i[0]} in lst:
            cnt += 1
            for j in range(N - 2):
                if {i[j], i[j + 1]} in lst:
                    cnt += 1
                    pass
                else:
                    break
        if cnt == N - 1:
            ans += 1
    print(ans)
    

if __name__ == ""__main__"":
    resolve()"
"s = input()
t = input()

n = len(s)
m = len(t)

ans = float(""inf"")
for i in range(n-m+1):
  p = m
  for j in range(m):
    if s[i+j] == t[j]: p -= 1
  if p < ans: ans = p
print(ans)"
"def main():
    N = int(input())
    a, b = divmod(N, 3)
    print(a)
if __name__ == ""__main__"":
    main()"
"data = []
while True:
    in_line = raw_input().split()
    m = int(in_line[0])
    f = int(in_line[1])
    r = int(in_line[2])
    if m == -1 and f == -1 and r == -1:
        break
    if m == -1 or f == -1:
        data.append(""F"")
    elif m + f >= 80:
        data.append(""A"")
    elif m + f >= 65:
        data.append(""B"")
    elif m + f >= 50:
        data.append(""C"")
    elif m + f >= 30:
        if r >= 50:
            data.append(""C"")
        else:
            data.append(""D"")
    else:
        data.append(""F"")
for n in data:
    print n"
"a = int(input())
b  =int(input())
set_ = set([1,2,3])
set_.remove(a)
set_.remove(b)
print(set_.pop())"
"n=int(input());s=['a']
while len(s)>0:
  t=s.pop(-1)
  if len(t)==n:print(t)
  else:
    a=max(ord(i)for i in t)
    for a in range(a+1,96,-1):s.append(t+chr(a))"
"import sys
read=sys.stdin.read
h,w,n=map(int, read().split())
m=max(h,w)
print(n//m+(n%m!=0))"
"i=input;print(['NO','YES'][int(i())==len(set(i().split()))])"
"import sys
import math

def main():
    n = int(input().rstrip())
    r = 1.05
    digit = 3
    a = 100000
    
    for i in range(n):
        a = math.ceil(a*r/10**digit)*10**digit

    print(a)
    
if __name__ == '__main__':
    main()"
"n = int(input())
nums = list(map(int,input().split()))
alice = 0
bob = 0

nums.sort()
while nums:
    alice+=nums.pop()
    if nums:
        bob+=nums.pop()

print(alice-bob)"
"d = int(input())

S = [""Christmas""] + [""Eve""] * (25 - d)
print(*S)
"
"N,K = [int(x) for x in input().split()]
count = [0]*(K+1)
ans = 0
mod = 1000000007
for i in range(K,0,-1):
    kosuu = pow(K//i,N,mod)
    if K // i >= 2:
        for j in range(K//i,1,-1):
            kosuu -= count[j*i]
    ans += i*kosuu
    count[i] = kosuu
print(ans%mod)"
"N=int(input())
*A,=map(int,input().split())

if N%2==0:
    print(' '.join(map(str,A[1::2][::-1]+A[::2])))
else:
    print(' '.join(map(str,A[::2][::-1]+A[1::2])))"
"X = int(input())
print('YES' if X in (3, 5, 7) else 'NO')
"
"h, w = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(h)]
count = 0
ans = []
for i in range(h):
    for j in range(w-1):
        if a[i][j] % 2 == 1:
            a[i][j+1] += 1
            a[i][j] -= 1
            count += 1
            ans.append([i+1, j+1, i+1, j+2])

for i in range(h-1):
    if a[i][w-1] % 2 == 1:
        a[i+1][w-1] += 1
        a[i][w-1] -= 1
        count += 1
        ans.append([i+1, w, i+2, w])
        
print(count)
for i in range(count):
    print(*ans[i])"
"import sys
input = sys.stdin.readline
from bisect import *

H, W, K = map(int, input().split())
S = [input()[:-1] for _ in range(H)]
ans = [[-1]*W for _ in range(H)]
now = 1
l = []

for i in range(H):
    cnt = 0
    
    for j in range(W):
        if S[i][j]=='#':
            cnt += 1
    
    if cnt==0:
        continue
    
    l.append(i)
    c = 0
    
    for j in range(W):
        ans[i][j] = now
        
        if S[i][j]=='#':
            c += 1
            
            if c<cnt:
                now += 1
    
    now += 1
    
for i in range(H):
    if '#' not in S[i]:
        j = bisect_left(l, i)
        
        if j==len(l):
            for k in range(W):
                ans[i][k] = ans[l[-1]][k]
        else:
            for k in range(W):
                ans[i][k] = ans[l[j]][k]

for ans_i in ans:
    print(*ans_i)"
"def main():
    n,k = map(int,input().split())
    A = list(map(int,input().split()))

    left = 0
    right = max(A)

    while abs(right-left)>1:
        cent = (right+left)//2
        
        ct = 0
        for a in A:
            ct+=(a-0.1)//cent
        
        if ct <= k:
            right=cent
        else:
            left=cent
    
    print(right)
main()"
"W = input().rstrip()
lst = []
while True:
    line = input().rstrip()
    if line == ""END_OF_TEXT"":
        break
    lst += line.lower().split()
print(lst.count(W))
"
"import sys
import math  # noqa
import bisect  # noqa
import queue  # noqa


def input():
    return sys.stdin.readline().rstrip()


def main():
    N, X = map(int, input().split())

    a, p = [1], [1]
    for i in range(N):
        a.append(a[i] * 2 + 3)
        p.append(p[i] * 2 + 1)

    def f(N, X):
        if N == 0:
            return 0 if X <= 0 else 1
        elif X <= 1 + a[N - 1]:
            return f(N - 1, X - 1)
        else:
            return p[N - 1] + 1 + f(N - 1, X - 2 - a[N - 1])

    print(f(N, X))


if __name__ == '__main__':
    main()
"
"N = input()

print(""ABC{}"".format(N))
"
"H, A = map(int, input().split())

print(abs(-1*H//A))"
"def main():
	# a,b,k = map(int,input().split())
	# n,k = map(int,input().split())
	s = int(input())
	# a = list(map(int,input().split()))
	# rsp = list(str(input()))
	# l = [list(map(int, input().split())) for _ in range(n-1)]
	# s = list(s)
	
	print(int(s**2))
	
 
 
if __name__ == '__main__':
	main()"
"n = int(input())
A = list(map(int, input().split()))
a = []
for i in range(len(A)):
    a.append([A[i], i])
a.sort(key = lambda x: x[0], reverse = True)
dp = [[0 for i in range(n+1)] for j in range(n+1)]
for i in range(n):
    for l in range(i+1):
        dp[i+1][l] = max(dp[i+1][l], dp[i][l] + a[i][0]*(n-1-(i-l)-a[i][1]))
        dp[i+1][l+1] = max(dp[i+1][l+1], dp[i][l] + a[i][0] * (a[i][1] - l))
ans = 0
for now in dp[n]:
    ans = max(now, ans)
print(ans)


"
"
#!/usr/bin/python
# -*- coding: utf-8 -*-

import numpy as np

def int_mtx(N):
    x = []
    for _ in range(N):
        x.append(list(map(int,input().split())))
    return np.array(x)

N = int(input())

a = int_mtx(N)
visit = [0]*(N+1)
now = 1
visit[now] = 1

ans = 0

for i in range(0,N):
    ans += 1
    now = a[now-1][0]
    if now == 2:
        print(ans)
        exit()
    if visit[now] == 1:
        print(-1)
        exit()
    visit[now] = 1





"
"def main():
    s = input()
    t = input()
    dp = [[0]*(len(s)+1) for i in range(len(t)+1)]
    for i in range(1,len(t)+1):
        for j in range(1,len(s)+1):
            if t[i-1] == s[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    ans = """"
    i = len(t)
    j = len(s)
    while i != 0 and j != 0:
        if t[i-1] == s[j-1]:
            ans = t[i-1] + ans
            i -= 1
            j -= 1
        elif dp[i-1][j] < dp[i][j-1]:
            j -= 1
        else:
            i -= 1
    print(ans)

if __name__ == ""__main__"":
    main()"
"from operator import itemgetter
n = int(input())
s = []
for i in range(n):
    l = list(map(int, input().split()))
    rang = [l[0] - l[1], l[0] + l[1]]
    s.append(rang)
s_sort = sorted(s, key=itemgetter(1))
ans = 0
last = -float(""inf"")
for i in range(n):
    if last <= s_sort[i][0]:
        ans += 1
        last = s_sort[i][1]
print(ans)
"
"a, b, c = input().split()
a = int(a)
b = int(b)
c = int(c)

if a < b and b < c:
    print('Yes')
else:
    print('No')
    
    
"
"def main():
    s = input()
    k = int(input())
    r = '1'
    for i,v in enumerate(s):
        if v != '1':
            r = v
            break
    if i >= k:
        print(1)
    else:
        print(r)
    
if __name__ == ""__main__"":
    main()"
"N = int(input())
A = list(map(int,input().split()))
B = list(map(int,input().split()))
P = sorted([A[i]-B[i] for i in range(N) if A[i]-B[i]>0],reverse=True)
C = [0 for _ in range(N+1)]
for i in range(1,len(P)+1):
    C[i] = C[i-1]+P[i-1]
M = [B[i]-A[i] for i in range(N) if B[i]-A[i]>0]
p = sum(P)
m = sum(M)
if m>p:
    ans = -1
else:
    if len(M)==0:
        ans = 0
    else:
        for i in range(1,len(P)+1):
            if C[i]>=m:
                ans = i
                break
        ans += len(M)
print(ans)"
"h1, m1, h2, m2, k = [int(_) for _ in input().split()]

print((h2 - h1) * 60 + m2 - m1 - k)
"
"N, U, V = map(int, input().split())
AB = [list(map(int, input().split())) for _ in range(N - 1)]

graph = [[] for _ in range(N + 1)]
for A, B in AB:
  graph[A].append(B)
  graph[B].append(A)

INF = 10 ** 15
dist_U = [INF] * (N + 1)
dist_V = [INF] * (N + 1)

def dfs(start, dist):
  stack = [start]
  dist[start] = 0
  
  while stack:
    s = stack.pop()
    for g in graph[s]:
      if dist[g] > dist[s] + 1:
        dist[g] = dist[s] + 1
        stack.append(g)

dfs(U, dist_U)
dfs(V, dist_V)
#print(""dist_U"", dist_U)
#print(""dist_V"", dist_V)

answer = []
for i in range(1, N + 1):
  if dist_U[i] < dist_V[i]:
    answer.append(dist_V[i] - 1)
print(max(answer))"
"s = input()
t = input()
print(sum([1 for a,b in zip(list(s), list(t)) if a != b]))"
"N = int(input())
a = list(map(int, input().split()))
a = sorted(a, reverse=True)
a_m = a[1::2]
ans = 0
for i in range(N):
    ans += a_m[i]
print(ans)"
"A, B, C, D = map(int, input().split())
print('Balanced') if (A + B) == (C + D) else print('Left' if (A + B) > (C + D) else 'Right')"
"S = list(input())
count = 0
t = ''
for i in S:
    if t == i:
        continue
    else:
        t = i
        count += 1
print(count - 1)"
"'''
Created on 2020/08/20

@author: harurun
'''
def main():
  import re
  import sys
  pin=sys.stdin.readline
  pout=sys.stdout.write
  perr=sys.stderr.write
  
  S=pin()[:-1]
  if re.fullmatch(r""[A-Z]*AC[A-Z]*"",S)==None:
    print(""No"")
    return 
  print(""Yes"")
  return 

main()"
"from sys import stdin
from collections import Counter
H,W = [int(x) for x in stdin.readline().rstrip().split()]
c = Counter()

for i in range(H):
    c += Counter(list(input()))

rem0 = 0
rem2 = 0

for i in c.values():
    if i % 4 == 0:
        rem0 += 1
    elif i % 4 == 2:
        rem2 += 1

num_v = len(c.values())

f = True
if H % 2 == 0 and W % 2 == 0:
    if rem0 != num_v:
        f = False

elif H % 2 != 0 and W % 2 != 0:
    
    if len([i for i in c.values() if i % 2 != 0]) != 1:
        f = False
        
    if rem2 > (H-1)/2 + (W-1)/2:
        f = False
    
    if num_v-1 != rem0 + rem2:
        f = False
    
else:
    if H % 2 == 0:
        if rem2 > H/2:
            f = False
        if rem2 + rem0 != num_v:
            f = False
            
    if W % 2 == 0:
        if rem2 > W/2:
            f = False
        if rem2 + rem0 != num_v:
            f = False
    
if f:
    print(""Yes"")
else:
    print(""No"")"
"def COMinit():
    fac[0] = fac[1] = 1
    finv[0] = finv[1] = 1
    inv[1] = 1
    for i in range(2,max):
        fac[i] = fac[i-1]*i%mod
        inv[i] = mod - inv[mod%i]*(mod//i)%mod
        finv[i] = finv[i-1]*inv[i]%mod

def COM(n,k):
    if n < k:
        return 0
    if n < 0 or k < 0:
        return 0
    return fac[n] * (finv[k]*finv[n-k]%mod)%mod

mod = 10**9+7

X, Y = map(int,input().split())

a = X%2 #1の数
b = X//2 #2の数
for i in range(b+1):
    if a*2 + b*1 == Y:
        break
    a += 2
    b -= 1

if a*2 + b*1 != Y:
    print(0)
else:
    max = a+b+1
    fac = [0] * max
    finv = [0] * max
    inv = [0] * max
    COMinit()
    print(COM(a+b,a))
"
"import sys
sys.setrecursionlimit(10**7)
N, M = map(int, input().split())
edge = [[] for _ in range(N)]
for _ in range(M):
    x, y = map(int, input().split())
    edge[x-1].append(y-1)
dp = [0]*N
def f(v):
    if dp[v] != 0:
        return dp[v]
    res = 0
    for i in edge[v]:
        res = max(res, f(i)+1)
    dp[v] = res
    return res
for i in range(N):
    f(i)
print(max(dp))"
"def main():
    k = int(input())
    s = input()
    n = len(s)

    def cmb1(n, r, mod):
        if ( r<0 or r>n ):
            return 0
        r = min(r, n-r)
        return g1[n] * g2[r] * g2[n-r] % mod

    mod = 10**9+7
    N = 2*10**6
    fac = [1]*(N+1)
    finv = [1]*(N+1)
    for i in range(N):
        fac[i+1] = fac[i] * (i+1) % mod
    finv[-1] = pow(fac[-1], mod-2, mod)
    for i in reversed(range(N)):
        finv[i] = finv[i+1] * (i+1) % mod

    def cmb1(n, r, mod):
        if r <0 or r > n:
            return 0
        r = min(r, n-r)
        return fac[n] * finv[r] * finv[n-r] % mod

    def power(a, n, mod):
        bi=str(format(n,""b"")) #2進数
        res=1
        for i in range(len(bi)):
            res=(res*res) %mod
            if bi[i]==""1"":
                res=(res*a) %mod
        return res

    ans = 0
    for i in range(k+1):
        temp = power(25, i, mod)
        temp *= cmb1(i+n-1, n-1, mod)
        temp %= mod
        temp *= power(26, k-i, mod)
        temp %= mod
        ans += temp
    print(ans%mod)

if __name__ == '__main__':
    main()
"
"import itertools

N,C =map(int,input().split())
D = [0]+[[0]+list(map(int,input().split())) for i in range(C)]
c = [list(map(int,input().split())) for i in range(N)]
 
grid = [[],[],[]]
for i in range(N):
  for j in range(N):
    grid[(i+j)%3].append(c[i][j])

s = [[0]*(C+1) for i in range(3)]
 
for i in range(3):
  for j in range(1,C+1,1):
    for k in range(len(grid[i])):
      s[i][j]+=D[grid[i][k]][j]

ans = float(""inf"")
for p in itertools.permutations(list(range(1,C+1)),3):
  tmp = 0
  for i in range(3):
     tmp +=s[i][p[i]]
  ans = min(tmp,ans)

print(ans)"
"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb
from itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement
from collections import deque,defaultdict,Counter
from bisect import bisect_left,bisect_right
from operator import itemgetter
from heapq import heapify,heappop,heappush
from queue import Queue,LifoQueue,PriorityQueue
from copy import deepcopy
from time import time
from functools import reduce
import string
import sys
sys.setrecursionlimit(10 ** 7)
def input() : return sys.stdin.readline().strip()
def INT()   : return int(input())
def MAP()   : return map(int,input().split())
def LIST()  : return list(MAP())

h, w = MAP()
c = []
for i in range(10):
    c.append(LIST())
a = []
for i in range(h):
    a.append(LIST())

chk = True
while chk:
    chk = False
    for i in range(10):
        for j in range(10):
            for k in range(10):
                if c[i][j] > c[i][k]+c[k][j]:
                    c[i][j] = c[i][k]+c[k][j]
                    chk = True

ans = 0
for i in range(h):
    for j in range(w):
        if a[i][j] != -1:
            ans += c[a[i][j]][1]
print(ans)"
"N=int(input())
A=[list(map(int,input().split())) for i in range(N)]
for k in range(N):
  for i in range(N):
    for j in range(N):
      if A[i][j]>A[i][k]+A[k][j]:
        print(-1)
        exit()
INF=10**12
D=[[INF]*N for i in range(N)]
for i in range(N):
  D[i][i]=0
X=[]
for i in range(N):
  for j in range(N):
    if i==j:
      continue
    X.append([A[i][j],i,j])
P=0
X.sort()
for i in range(len(X)):
  for j in range(N):
    if X[i][0]==D[X[i][1]][j]+D[j][X[i][2]] and D[j][X[i][2]]!=0 and D[X[i][1]][j]!=0:
      break
    if j==N-1:
      P+=X[i][0]
  D[X[i][1]][X[i][2]]=X[i][0]
  D[X[i][2]][X[i][1]]=X[i][0]
print(P//2)"
"N = int(input())
march_dict = {
    'M': 0,
    'A': 0,
    'R': 0,
    'C': 0,
    'H': 0
}
for i in range(N):
    S = input()
    s_head = S[0]
    if march_dict.get(s_head) is not None:
        march_dict[s_head] += 1

# march_candidate = [key for key, val in march_dict.items() if val != 0]
import itertools

ans = 0
for C in itertools.combinations(['M', 'A', 'R', 'C', 'H'], 3):
    a = march_dict[C[0]]
    b = march_dict[C[1]]
    c = march_dict[C[2]]
    ans += a * b * c
    # print(ans)
    # print(march_candidate)
print(ans)
"
"A,B,C=map(int,input().split());print(""YNeos""[(A+B<C)::2])"
"#!/usr/bin/env python3
a, b = map(int, input().split())

x = ((b - a) // 2) + a

if abs(a - x) == abs(b - x):
  print(x)
else:
  print('IMPOSSIBLE')
"
"a,b,c,d = map(int, input().split())

i = 0
while a > 0 and c > 0:
    if i%2 == 0:
        c -= b
    else:
        a -= d
    i += 1

if a > c:
    print('Yes')
else:
    print('No')"
"n,a,b = map(int,input().split())
s = input()
kokunai = 0
kaigai = 0

for i in range(n):
    if s[i] == ""a"" and a + b > kokunai + kaigai:
        print(""Yes"")
        kokunai += 1
    elif s[i] == ""b"" and a + b > kokunai + kaigai and b > kaigai:
        print(""Yes"")
        kaigai += 1
    else:
        print(""No"")"
"n,l=map(int,input().split())
arr=list(map(int,input().split()))
psbl=False
pos=0
for i in range(n-1):
    if arr[i]+arr[i+1]>=l:
        psbl=True
        pos=i
        break
if psbl:
    print(""Possible"")
    for i in range(0,pos):
        print(i+1)
    for i in range(n-2,pos,-1):
        print(i+1)
    print(pos+1)
else:
    print(""Impossible"")
"
"def solve():
    mod = 10 ** 9 + 7

    def cmb(n, r):
        def build():
            fs = [1]
            t = 1
            for x in range(1, h * w):
                t = (t * x) % mod
                fs.append(t)

            invs = [1] * (h * w)
            t = pow(t, mod - 2, mod)
            invs[-1] = t
            for x in range(h * w - 2, 0, -1):
                t = (t * (x + 1)) % mod
                invs[x] = t
            return fs, invs

        if r < 0 or r > n:
            return 0
        if r > (n - r):
            return cmb(n, n - r)
        if r == 0:
            return 1
        if r == 1:
            return n

        fs, invs = build()
        return fs[n] * invs[n - r] * invs[r] % mod

    h, w, k = map(int, input().split())
    c = cmb(h * w - 2, k - 2)
    ret = (pow(w, 2) * sum((h - d) * d for d in range(h))
           + pow(h, 2) * sum((w - d) * d for d in range(w))) * c % mod

    return ret


print(solve())"
"n = int(input())
colors = list(map(str, input().split()))

if ""Y"" in colors:
    print(""Four"")
else:
    print(""Three"")"
"#a, b, k = map(int, input().split( ))
import math

 
n = int(input())
a = list(map(int,input().split()))

left = [0] * (n + 1)
right = [0] * (n + 1)
for i in range(n):
    left[i + 1] = (math.gcd(left[i],a[i]))
    right[n - i - 1] = (math.gcd(right[n - i],a[n - 1 - i]))
#print(left, right)

ans = 0
for i in range(n):
  ans = max(ans, math.gcd(left[i],right[i+1]))
print(ans)"
"import sys
import math
import itertools
import bisect
from copy import copy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def i(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def L(): return list(map(int,input().split()))
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
sys.setrecursionlimit(10 ** 9)
INF = 10**9
mod = 10**9+7

N,M = I()
maze1 = [list(s()) for _ in range(N)]
maze2 = [list(s()) for _ in range(M)]
L = [[-1]*N for _ in range(N)]
def dfs(x,y):
    if x == N or y == N:
        return
    if x-i == M or y-j == M:
        return
    if maze1[x][y] != maze2[x-i][y-j]:
        L[i][j] = 0
        return
    dfs(x+1,y)
    dfs(x,y+1)
for i in range(N-M+1):
    for j in range(N-M+1):
        dfs(i,j)
        if L[i][j] == -1:
            print('Yes')
            exit()
print('No')"
"n = int(input())
S = ['']*n
T = []
for i in range(n):
    S[i] = input()
S.sort()
if n == 1:
    print(S[0])
    exit()
cnt = 1
mxcnt = 1
for i in range(n-1):
    if S[i] == S[i+1]:
        cnt += 1
    else:
        cnt = 1
    mxcnt = max(mxcnt,cnt)
cnt = 1
for i in range(n-1):
    if S[i] == S[i+1]:
        cnt += 1
    else:
        cnt = 1
    if cnt == mxcnt:
        T.append(S[i])
if mxcnt == 1:
    T.append(S[-1])
for t in T:
    print(t)"
"K = int(eval(input()))

# すべての要素に1回ずつ操作を行うことは、すべての要素を-1することと同じ。
# N=50,aiがすべてN-1である状態を最終状態として、逆算する。

N = 50
r = K % N
q = K // N
A = []
for i in range(N):
  A.append(N-1 + q + (i<r)*(N-r+1) - (i>=r)*r)
print(N)
print(*A)"
"""""""
半ば強引に二分探査で書いた。
""""""
#入力
n = int(input())
t, a = map(int, input().split())
h = list(map(int, input().split()))
h_not_sorted = h
h = sorted(h)
x = abs((t - a) / 0.006)

#二分探査
l = 0
r = n - 1
x_index = 0
while l + 1 != r :
    middle = (l + r) // 2
    if h[middle] == x:
        x_index = middle
        break
    elif h[middle] < x:
        x_index = middle + 1
        l = middle
    else:
        x_index = middle - 1
        r = middle


#x_indexが両橋の場合とそれ以外で場合わけ。
res = abs(a - (t - 0.006 * h[x_index]))
ans = x_index
flag_r = True 
flag_l = True
if x_index == n - 1:
    flag_r = False
elif x_index == 0:
    flag_l = False
else:
    pass

#x_indexの両橋と比較。x_indexが際数値でない可能性があるため。
if flag_r:
    if abs(a - (t - 0.006 * h[x_index + 1])) < res:
        res = abs(a - (t - 0.006 * h[x_index + 1]))
        ans += 1
if flag_l:
    if abs(a - (t - 0.006 * h[x_index - 1])) < res:
        res = abs(a - (t - 0.006 * h[x_index - 1]))
        ans -= 1

print(h_not_sorted.index(h[ans]) + 1)"
"import sys
import heapq
import math
import fractions
import bisect
import itertools
from collections import Counter
from collections import deque
from operator import itemgetter
def input(): return sys.stdin.readline().strip()
def mp(): return map(int,input().split())
def lmp(): return list(map(int,input().split()))

n,k=mp()
print(n-k+1)"
"# -*- coding: utf-8 -*-
a = list(map(int, input().split()))

ans = 0
for i in a:
    if i == 1:
        ans += 300000
    elif i == 2:
        ans += 200000
    elif i == 3:
        ans += 100000
    
if a[0] == a[1] == 1:
    ans += 400000

print(ans)"
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
a = input()
if a.upper() == a:
  print('A')
else:
  print('a')
"
"# coding: utf-8
# Your code here!
import bisect

N,D,A=map(int,input().split())

log=[]
loc=[]
ene=[]

for _ in range(N):
    X,H=map(int,input().split())
    log.append([X,H])

log.sort(key=lambda x:x[0])

for X,H in log:
    loc.append(X)
    ene.append(H)

syokan=[0]*N

power=0
for i in range(N):
    temp=max(-((-ene[i]+power)//A),0)*A
    power+=temp
    
    rng=bisect.bisect_right(loc,loc[i]+2*D)
    syokan[min(rng-1,N-1)]+=temp
    
    power-=syokan[i]
    #print(syokan)
#print(syokan)
print(sum(syokan)//A)"
"N = int(input())
A = list(map(int,input().split()))
B = [set() for x in range(N)]

ans = 0
for i in range(N):
    j = A[i] - 1
    if j in B[i] or i in B[j]:
        ans += 1
    else:
        B[i].add(j)
        B[j].add(i)

print(ans)
"
"n = int(input())
a = list(map(int,input().split()))
d = {}
ans = ''

for i in range(0,n):
  d[a[i]] = i+1

d_sorted = sorted(d.items(), key=lambda x:x[0])

for i in range(n):
  if ans != '':
    ans = ans + ' '
  ans = ans + str(d_sorted[i][1])

print(ans)"
"n, k = [int(_) for _ in input().split()]
s = []
for i in range(k):
    s.append([int(_) for _ in input().split()])
dp = [0 for i in range(n)]
dp[0] = 1
dp_s = [0 for i in range(n+1)]
dp_s[1] = 1
for i in range(1, n):
    for j in range(len(s)):
        r, l = s[j]
        if i-r >= 0:
            if i-l >= 0:
                dp[i] += dp_s[i-r+1] - dp_s[i-l]
            else:
                dp[i] += dp_s[i-r+1] - dp_s[0]
    dp[i] = dp[i] % 998244353
    dp_s[i+1] += dp_s[i] + dp[i]
    dp_s[i+1] = dp_s[i+1] % 998244353
print(dp[-1])"
"# 2020/08/16
# AtCoder Beginner Contest 030 - A

# Input
h = int(input())
w = int(input())
n = int(input())

# Calc
ans = n // max(h, w)
if n % max(h, w) > 0:
    ans = ans + 1

# Output
print(ans)
"
"#!/usr/bin/env python3
from itertools import accumulate

def main():
    n = int(input())
    a = list(map(int, input().split()))
    a = list(accumulate(a))

    ans = 10**18

    for j in range(2):# 偶数行が正か奇数行が正
        ans2 = 0
        diff = 0
        for i in range(n):
            p = a[i] + diff
            # print(a[i],diff)
            if (i+j) % 2 == 0 and p <= 0:# 正になる
                ans2 += abs(p)+1
                diff += abs(p)+1
            elif (i+j) % 2 == 1 and p >= 0:# 負になる
                ans2 += abs(p)+1
                diff -= abs(p)+1

        ans = min(ans, ans2)
    print(ans)

if __name__ == ""__main__"":
    main()
"
"from collections import deque
mod = 10**9 + 7
N = int(input())
C = [int(input()) for i in range(N)]
dq = deque()
dq.append(C[0])
for c in C:
    if c != dq[-1]:
        dq.append(c)
C = list(dq)
N = len(C)
dp = [0]*(N+1)
dp[0] = 1
acc = [0]*(2*pow(10,5)+1)
for i in range(1,N+1):
    dp[i] = dp[i-1]
    dp[i] += acc[C[i-1]]
    dp[i] %= mod
    acc[C[i-1]] += dp[i-1]
    acc[C[i-1]] %= mod
ans = dp[N]
print(ans)"
"MAX = 600000
MOD = 10 ** 9 + 7
fac = [0] * MAX
ifac = [0] * MAX
fac[0] = 1
for i in range(1,MAX):
    fac[i] = (fac[i-1] * i) % MOD
ifac[MAX-1] = pow(fac[MAX-1],MOD-2,MOD)
for i in reversed(range(1,MAX)):
    ifac[i-1] = (ifac[i] * i) % MOD

def combinations(n, k):
    if k < 0 or n < k:
        return 0
    else:
        return (fac[n] * ifac[k] * ifac[n-k]) % MOD

ans = 0
S = int(input())
for i in range(1,1000):
    ans += combinations((S+i-1)-i*3,i-1)
    ans %= MOD
print(ans)

"
"from collections import Counter
n = int(input())
a=[int(i) for i in input().split()]
a = Counter(a)
cnt = 0
for key in a.keys():
    val = a[key]
    if key>val:
        cnt += val
    else:
        cnt += abs(val-key)
print(cnt)"
"n = int(input())
s = sorted([int(input()) for _ in range(n)])

sumNum = sum(s)
if sumNum % 10 != 0:
  print(sumNum)
  exit()
else:
  ans = 0
  for i in s:
    if (sumNum - i) % 10 != 0:
      ans = max(ans, sumNum - i)
  print(ans)"
"n = int(input())
s = list(input())

dp = [[0]*(n+1) for i in range(n+1)]
for i in range(n-1,-1,-1):
    for j in range(n-1,-1,-1):
        if s[i] == s[j]:
            dp[i][j] = dp[i+1][j+1] +1
        
ans = 0
for i in range(n-1):
    for j in range(i+1,n):
        ans = max(ans,min(dp[i][j],j-i))

print(ans)"
"n = int(input())
if n == 1: print(""Hello World"")
else:
    answer = 0
    for x in range(2):
        answer += int(input())
    print(answer)"
"a,b=map(int,input().split())
if a%b==0:
  print(-1)
else:print(a)"
"a, b = map(int, input().split())
A=''
B=''
for i in range(b):
    A+=str(a)
for i in range(a):
    B+=str(b)
if A<=B:
    print(A)
else:
    print(B)
"
"if __name__ == ""__main__"":
    stack =[]
    ope = {""+"": lambda a, b: b + a, ""-"": lambda a, b: b - a, ""*"": lambda a, b: b * a}
    for x in input().split():
        if x in ope:
            stack.append(ope[x](stack.pop(),stack.pop()))
        else:
            stack.append(int(x))
    print(stack[-1])"
"n = int(input())
w_l = [ input() for _ in range(n) ]
memo = set()
b_w = w_l[0][0]
ans = 'Yes'
for w in w_l:
    if b_w == w[0]:
        if w not in memo:
            memo.add(w)
            b_w = w[-1]
            continue
    ans = 'No'
    break
print(ans)"
"x,a,b=map(int,input().split())	

l_1=abs(x-a)
l_2=abs(x-b)

if l_1<l_2:
  print('A')
else:
  print('B')"
"S = raw_input()
n = int(raw_input())

for i in range(n):
    command = (raw_input()).split("" "")
    if command[0] == ""print"":
        a = int(command[1])
        b = int(command[2])
        print S[a:b+1]
    elif command[0] == ""reverse"":
        a = int(command[1])
        b = int(command[2])
        T = S[a:b+1]
        S = S[0:a] + T[::-1] + S[b+1:]
    else:
        a = int(command[1])
        b = int(command[2])
        S = S[0:a] + command[3] + S[b+1:]"
"# Coding is about expressing your feeling, and
# there is always a better way to express your feeling_feelme
import sys
import math
# sys.stdin=open('input.txt','r')
# sys.stdout=open('output2.txt','w')
from sys import stdin,stdout
from collections import deque,defaultdict
from math import ceil,floor,inf,sqrt,factorial,gcd,log2
from copy import deepcopy
ii1=lambda:int(stdin.readline().strip())
is1=lambda:stdin.readline().strip()
iia=lambda:list(map(int,stdin.readline().strip().split()))
isa=lambda:stdin.readline().strip().split()
mod=int(1e9 + 7)

n,h=iia()
arr=iia()
count=0
for i in range(n):
    if arr[i]>=h:
        count+=1
print(count)
"
"A, B, M = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

min_price = min(a) + min(b)
for _ in range(M):
    x, y, c = map(int, input().split())
    discount_price = a[x-1] + b[y-1] - c
    if min_price > discount_price:
        min_price = discount_price
        
print(min_price)
"
"N=int(input())
list=[]
for i in range(N):
  a,b=map(int,input().split())
  list.append((b,a))
list.sort()
acc=0
for i in range(N):
  acc+=list[i][1]
  if acc>list[i][0]:
    print('No')
    exit()
print('Yes')"
"N = int(input())
P = [int(input()) for _ in [0]*N]
m = [0]*N
for i,p in enumerate(P): m[p-1] = i
ans = 0
c = 0
j=-1
for i in m:
    c = (c+1) if j<i else 1
    j=i
    ans = max(ans,c)
print(N-ans)"
"n,k = map(int,input().split())
a = list(map(int,input().split()))
si = [0 for i in range(n+1)]
p = [1 for i in range(n)]
import copy 
for q in range(min(k,50)):
    v = 0
    s = copy.deepcopy(si)
    for i in range(n):
        if a[i] != 0:
            s[max(i-a[i],0)] += 1
            s[min(i+a[i]+1,n)] -= 1
            a[i] = 0
        else:
            a[i] = 1
    for i in range(n):
        v += s[i]
        a[i] += v
for i in range(n):
    print(a[i], end = ' ')"
"N = int(input())
a,b,c = [],[],[]
for n in range(N):
  a_,b_,c_ = map(int, input().split())
  a.append(a_)
  b.append(b_)
  c.append(c_)
do_a = [a[0]] #do a in n-th day
do_b = [b[0]] #same
do_c = [c[0]]

for day in range(1,N):
  do_a.append(a[day] + max(do_b[day-1], do_c[day-1]))
  do_b.append(b[day] + max(do_a[day-1], do_c[day-1]))
  do_c.append(c[day] + max(do_a[day-1], do_b[day-1]))
print(max(do_a[N-1],do_b[N-1], do_c[N-1]))"
"#import numpy as np
#import math
#from decimal import *
#from numba import njit

#@njit
def main():
    (N, M) = map(int, input().split())
    neighbor = [[] for _ in range(N+1)]
    for _ in range(M):
        (A,B) = map(int, input().split())
        neighbor[A] += B,
        neighbor[B] += A,

    guide = [0 for _ in range(N+1)]

    # 1の部屋から幅優先で道しるべを置く
    
    # 探索候補
    target = [1]
    checked = [1]
    while len(target) > 0:
        # 候補の先頭から取る
        n = target.pop(0)
        # nから伸びる行き先
        dests = neighbor[n]
        # すでに道しるべがあるものは除く
        dests = filter(lambda d: guide[d] == 0, dests)
        # 道しるべを置く
        for d in dests:
            guide[d] = n
            checked += d,
            # 探索候補の末尾に追加
            target += d,

    print('Yes')
    for i in range(2,N+1):
        print(guide[i])

main()
"
"from fractions import gcd

N = int(input())
arr = list(map(int, input().split()))

left = [0 for _ in range(N+1)]
right = [0 for _ in range(N+1)]

for i in range(N):
  left[i+1] = gcd(left[i],arr[i])
  right[-i-2] = gcd(right[-i-1], arr[-i-1])

ans = 1
for i in range(N):
  result = gcd(left[i], right[i+1])
  ans = max(ans, result)

print(ans)"
"import itertools as it

n = int(input())
lst = []
for i in range(n):
	x, y = list(map(int, input().split()))
	lst.append([x, y])
perm = list(it.permutations(lst))

cost = []
for i in perm:
	temp = 0
	for j in range(len(i)-1):
		temp += (((i[j][0] - i[j+1][0])**2) + ((i[j][1] - i[j+1][1])**2))**0.5
	cost.append(temp)

print(sum(cost) / len(cost))"
"A,B,C,D=map(int,input().split())
while A>0 and C>0:
  C=C-B
  A=A-D
  if C<=0:
    print('Yes')
    break
  if A<=0:
    print('No')
    break"
"#!/usr/bin/env python3
#AGC1 A

import sys
import math
from bisect import bisect_right as br
from bisect import bisect_left as bl
sys.setrecursionlimit(1000000000)
from heapq import heappush, heappop,heappushpop
from collections import defaultdict
from itertools import accumulate
from collections import Counter
from collections import deque
from operator import itemgetter
from itertools import permutations
mod = 10**9 + 7
inf = float('inf')
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))

n = I()
l = LI()
l.sort()
ans = 0
for i in range(0,2*n,2):
    ans += l[i]
print(ans)
"
"Row = int(input())
List = []
for i in range (Row):
  List.append(list(map(int, input().split())))
res=0
for i in range(Row):
  res += List[i][1]-List[i][0]+1
print(res)"
"n = int(input())
d = list(map(int, input().split()))
d.sort()
print(len(range(d[n//2-1],d[n//2])))"
"from bisect import bisect_left
n = int(input())
L = list(map(int, input().split()))
L.sort()
ans = 0

for i in range(n):
    for j in range(i+1, n):
        ans += bisect_left(L, L[i]+L[j])-j-1
print(ans)
"
"N = int(input())
An = list(map(int, input().split()))
dp = [0 for x in range(N+10)]
dp[0] = 1000
for i in range(1, N):
    stock = dp[i-1] // An[i-1]
#     print(dp[i-1], An[i-1], stock)
    money = dp[i-1]
    money -= stock * An[i-1]
    money += stock * An[i]
#     print(money)
    dp[i] = max(dp[i-1], money)
print(dp[N-1])  "
"import sys


stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


def main():
    s = ni()
    d = {}
    d[s] = 1
    ans = 1
    while True:
        ans += 1
        if s % 2 == 0:
            s = s // 2
        else:
            s = 3 * s + 1
        if s in d:
            print(ans)
            return
        else:
            d[s] = 1


if __name__ == '__main__':
    main()
"
"a,b,c,d = map(int,input().split())
val = [None]*4
val = [a*c,a*d,b*c,b*d]

top = a*c

for i in range(1,4):
    if top < val[i]:
        top = val[i]

print(top)"
"def merge(a, left, mid, right):
    INF = int(1e+11)
    l = a[left:mid]
    r = a[mid:right]
    l.append(INF)
    r.append(INF)
    i = 0
    j = 0

    ans = 0

    for k in range(left, right):
        ans += 1
        if l[i] <= r[j]:
            a[k] = l[i]
            i += 1
        else:
            a[k] = r[j]
            j += 1
    
    return ans


def merge_sort(a, left, right):
    ans = 0
    if left + 1 < right:
        mid = (left + right) // 2
        ans += merge_sort(a, left, mid)
        ans += merge_sort(a, mid, right)
        ans += merge(a, left, mid, right)
    return ans


def print_list_split_whitespace(s):
    for x in s[:-1]:
        print(x, end="" "")
    print(s[-1])

n = int(input())
s = [int(x) for x in input().split()]

ans = merge_sort(s, 0, len(s))

print_list_split_whitespace(s)
print(ans)
"
"n = int(input())
arr_a = list(map(int, input().split()))

mod = 10**9 + 7
memo = {}

for i in range(n):
    if i == 0:
        memo[n-i-1] = 0
    else:
        memo[n-i-1] = (memo[n-i] + arr_a[n-i]) % mod

ans = 0
for i in range(n):
    ans += arr_a[i] * memo[i]
    ans = ans % mod

print(ans)
"
"import numpy as np

x = int(input())

t = np.arange(100000)
ans = np.where(t*(t + 1)//2 >= x)[0][0]

print(ans)"
"#!/usr/bin/env python3
W, a, b = map(int, input().split())

a_l = a
a_r = a + W
b_l = b
b_r = b + W

if b_r < a_l:
    print(abs(b_r - a_l))
elif a_r < b_l:
    print(abs(a_r - b_l))
else:
    print(0)
"
"from sys import stdin
def main():
    #入力
    readline=stdin.readline
    s=readline().strip()

    mod=10**9+7
    n=len(s)
    dp=[[0]*4 for _ in range(n+1)]
    dp[0][0]=1
    for i in range(1,n+1):
        #i文字目を選ばない
        for j in range(4):
            if s[i-1]!=""?"":
                dp[i][j]+=dp[i-1][j]
            else:
                dp[i][j]+=dp[i-1][j]*3

        #i文字目を選ぶ
        if s[i-1]==""A"":
            dp[i][1]+=dp[i-1][0]
        elif s[i-1]==""B"":
            dp[i][2]+=dp[i-1][1]
        elif s[i-1]==""C"":
            dp[i][3]+=dp[i-1][2]
        elif s[i-1]==""?"":
            dp[i][1]+=dp[i-1][0]
            dp[i][2]+=dp[i-1][1]
            dp[i][3]+=dp[i-1][2]

        for j in range(4):
            dp[i][j]%=mod
            
    print(dp[n][3])
if __name__==""__main__"":
    main()"
"while(True):
    input = raw_input().split()
    a = int(input[0])
    b = int(input[2])
    if input[1] == ""?"":
        break
    elif input[1] == ""+"":
        print a + b
    elif input[1] == ""-"":
        print a - b
    elif input[1] == ""*"":
        print a * b
    elif input[1] == ""/"":
        print a / b"
"cost = int(input())
itien = int(input())
if itien >= cost % 500:
  print(""Yes"")
else:
  print(""No"")"
"while True:
  a, op, b = input().split()
  a, b = int(a), int(b)
  if op == '?':
    quit()
  else:
    if op == '+':
      result = a+b
    elif op == '-':
      result = a-b
    elif op == '*':
      result = a*b
    elif op == '/':
      result = int(a/b)
    print(result)"
"import math
A,B,C,D = map(int,input().split())

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

lcm = lcm(C,D)

u_b_ans = (B//C + B//D) - B//lcm
u_a_ans = ((A-1)//C + (A-1)//D) - (A-1)//lcm

print(B-A+1 - u_b_ans + u_a_ans)
"
"s=input()
a=ord(""a"")
for i in range(26):
  if chr(a+i) in s:
    pass
  else:
    print(chr(a+i))
    break
else:
  print(""None"")"
"# coding: utf-8
import sys
#from operator import itemgetter
sysread = sys.stdin.buffer.readline
read = sys.stdin.buffer.read
#from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
#from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque

INF = 1 << 50

def dfs(n,seq):
    if seq[n:] in ['dreamer', 'dream', 'erase', 'eraser']:
        return True

    if seq[n:n+7] == 'dreamer':
        if dfs(n+5, seq):
            return True
        elif dfs(n+7, seq):
            return True
        else:
            return False

    elif seq[n:n+5] == 'dream':
        return dfs(n+5, seq)

    elif seq[n:n+6] == 'eraser':
        return dfs(n+6, seq)

    elif seq[n:n+5] == 'erase':
        return dfs(n+5, seq)
    else:
        return False


def run():
    S = input()
    if dfs(0,S):
        print('YES')
    else:
        print('NO')


if __name__ == ""__main__"":
    run()"
"n, x = map(int, input().split())

dp = [1]*(n+1)
res = 0

for i in range(1,n+1):
    dp[i] = dp[i-1]*2+3

for j in range(n,1,-1):
    if dp[j] ==x:
        res += (dp[j]+1) //2
        x =0        
    elif dp[j-1]+2 <= x :
        res += 1 + (dp[j-1]+1)//2
        x -= dp[j-1]+2
    elif dp[j-1]+1 ==x:
        res += (dp[j-1]+1)//2
        x = 0
    else:
        x -=1
    
    if x ==0:
        break
        
if x ==5:
    res += 3
elif x ==0:
    pass
else:
    res +=x-1

print(res)
"
"N = int(input())
B = list(map(int, input().split()))
#flag = True
ans = B[0]
before = B[0]
for k in range(N-1):
  if before > B[k]:
    ans -= before
    ans += B[k]+B[k]
    before = B[k]
  else:
    ans += B[k]
    before = B[k]
print(ans)
#print('Yes')
#print('No')"
"N = int(input())
C = {(i,j):0 for i in range(1,10) for j in range(1,10)}
num = list(range(1,10))
for k in range(1,N+1):
    k = str(k)
    i = int(k[0])
    j = int(k[-1])
    if i in num and j in num:
        C[(i,j)] += 1
cnt = 0
for i in range(1,10):
    for j in range(1,10):
        cnt += C[(i,j)]*C[(j,i)]
print(cnt)"
"def myAnswer(N:int) -> int:
   N -=1
   return N * (N + 1) // 2

def modelAnswer():
   return
def main():
   N = int(input())
   print(myAnswer(N))
if __name__ == '__main__':
   main()"
"#!/usr/bin/env python3
import sys
from itertools import chain

# from itertools import combinations as comb
# form bisect import bisect_left, bisect_right, insort_left, insort_right
# from collections import Counter
# import numpy as np

YES = ""Yes""  # type: str


def solve(N: int, M: int, A: ""List[int]"", B: ""List[int]""):
    routes = [set() for _ in range(N)]
    marks = [None for _ in range(N)]
    for a, b in zip(A, B):
        a = a - 1
        b = b - 1
        routes[a].add(b)
        routes[b].add(a)

    marks[0] = -1
    cur_rooms = [0]
    count = 1
    while count < N:
        new_cur_rooms = []
        for cur_room in cur_rooms:
            next_rooms = list(routes[cur_room])
            for next_room in next_rooms:
                if marks[next_room] is None:
                    marks[next_room] = cur_room
                    new_cur_rooms.append(next_room)
                    count += 1
        cur_rooms = new_cur_rooms

    answer = ""Yes\n"" + ""\n"".join((str(n + 1) for n in marks[1:]))

    return answer


def main():
    tokens = chain(*(line.split() for line in sys.stdin))
    # N, M, A, B = map(int, line.split())
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: ""List[int]""
    B = [int()] * (M)  # type: ""List[int]""
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
    answer = solve(N, M, A, B)
    print(answer)


if __name__ == ""__main__"":
    main()
"
"
S=list(map(int,input().split()))
S.sort()
all=0
all += (S[0]+10*S[2]+S[1])
print(all)"
"N, K, *V = map(int, open(0).read().split())

# i: 操作回数
# j: 取り出す個数
# k: 左から取り出す範囲 [0, k)
ans = 0
for i in range(K + 1):
    for j in range(min(N + 1, i + 1)):
        for k in range(j + 1):
            right = N - j + k
            tmp = V[:k] + V[right:]
            tmp.sort()
            ans = max(ans, sum(tmp) - sum([t for t in tmp if t < 0][: i - j]))
print(ans)
"
"x,n=map(int, input().split())
a=list(map(int, input().split()))

for y in range(x+1):
  for b in[-1,1]:
    c=x+y*b
    if a.count(c)==0:
      print(c)
      exit(0)
"
"n = int(input())
an = list(map(int, input().split()))
bn = list(map(int, input().split()))
cn = list(map(int, input().split()))

satisfy = 0
for i in range(n):
    satisfy += bn[an[i] - 1]

for i in range(n - 1):
    if an[i] + 1 == an[i + 1]:
        satisfy += cn[an[i] - 1]

print(satisfy)"
"import sys
def input(): return sys.stdin.readline().rstrip()
 
def main():
    n=int(input())
    if n%2==1:
        print(0)
    else:
        m=n//2
        ans=0
        for i in range(1,30):
            ans+=m//(5**i)
        print(ans)

 
if __name__=='__main__':
    main()"
"import numpy as np

n, m, c = map(int, input().split())
b = np.array([int(i) for i in input().split()])
a = np.array([[int(i) for i in input().split()] for _ in range(n)])

res = 0
for aa in a:
    if np.sum(aa*b)+c > 0:
        res += 1
print(res)
"
"class DisjointSet:
    def __init__(self,n):
        self.rank = [0]*n
        self.parent = [i for i in range(n)]
        self.siz = [1]*n

    def same(self,x,y): 
        return self.findSet(x) == self.findSet(y)

    def unite(self,x,y): 
        return self.link(self.findSet(x), self.findSet(y))

    def link(self,x,y):
        if self.rank[x] > self.rank[y]: 
            self.parent[y] = x
            self.siz[x] += self.siz[y]
        else:
            self.parent[x] = y
            self.siz[y] += self.siz[x]
            if self.rank[x] == self.rank[y]: self.rank[y] += 1

    def findSet(self,x):
        if x != self.parent[x]: 
            self.parent[x] = self.findSet(self.parent[x])
        return self.parent[x]

    def size(self,x):
        return self.siz[self.findSet(x)]

n,m = map(int,input().split())
brg = [[int(i)-1 for i in input().split()] for _ in range(m)]
cnt = n*(n-1)//2
ans = [0]*m
ds = DisjointSet(n)
for i in range(m)[::-1]:
    ans[i] = cnt
    a,b = brg[i]
    if not ds.same(a,b):
        cnt -= ds.size(a)*ds.size(b)
        ds.unite(a,b)
print(""\n"".join(map(str,ans)))"
"n,*a=map(int,open(0).read().split())
a.sort()
s=[0]*n
s[0]=a[0]
for i in range(1,n):
  s[i]=s[i-1]+a[i]
ans=1
for i in range(1,n)[::-1]:
  if s[i-1]>=(a[i]+1)//2:
    ans+=1
  else:
    break
print(ans)"
"from bisect import bisect_left,bisect_right

TO_ACII = 97

N = int(input())
S = [""0""] + list(input())
Q = int(input())

ABC = [[]for i in range(0,26,1)]#該当文字a:0 b:1 ...z:26 が何文字目に出てきたかを保持する配列

for i in range(1,N+1,1):
    ABC[ord(S[i])-TO_ACII].append(i)

ans = []
for i in range(0,Q,1):
    q = list(input().split())
    if q[0]==""1"":#文字変更
        changed = S[int(q[1])]
        ABC[ord(changed)-TO_ACII].pop(bisect_left(ABC[ord(changed)-TO_ACII],int(q[1])))
        ABC[ord(q[2])-TO_ACII].insert(bisect_left(ABC[ord(q[2])-TO_ACII],int(q[1])),int(q[1]))
        S[int(q[1])]=q[2]
    else:
        tmpans = 0
        for i in range(0,26,1):

            if bisect_right(ABC[i],int(q[1])-1)<len(ABC[i]) and int(q[2]) >= ABC[i][bisect_right(ABC[i],int(q[1])-1)]:
                tmpans+=1
        ans.append(tmpans)

for i in range(0,len(ans),1):
    print(ans[i])
"
"# -*- coding: utf-8 -*-
import sys 
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
N = int(readline())
print('ACL'*N)"
"N = int(input())
P = [int(input()) for i in range(N)]
print(int(sum(P) - (max(P) / 2)))
"
"# ABC080D - Recording
def main():
    N, C, *STC = map(int, open(0).read().split())
    recorders = [[0] * (10 ** 5 + 1) for _ in range(C + 1)]
    for s, t, c in zip(*[iter(STC)] * 3):
        recorders[c][s - 1 : t] = [1] * (t - s + 1)
    ans = max(sum(sliced) for sliced in zip(*recorders))
    print(ans)


if __name__ == ""__main__"":
    main()"
"# import numpy as np
import sys, math, heapq
from itertools import permutations, combinations
from collections import defaultdict, Counter, deque
from math import factorial, gcd
from bisect import bisect_left, bisect_right

sys.setrecursionlimit(10 ** 7)
MOD = 10 ** 9 + 7
input = lambda: sys.stdin.readline()[:-1]
pl = lambda x: print(*x, sep=""\n"")

N = int(input())
A = list(map(int, input().split()))

if N == 0:
    if A[0] == 1:
        print(1)
        exit()
    else:
        print(-1)
        exit()
if N != 0 and A[0] > 0:
    print(-1)
    exit()

rcA = [0] * (N)
rcA[-1] = A[-1]
for i in range(1, N):
    rcA[-i - 1] = rcA[-i] + A[-i - 1]
# print(rcA)

cnt = 1
node = 1
for a, rca in zip(A, rcA):
    min_node = node - a
    max_node = 2 * (node - a)
    if rca < min_node or min_node < 0:
        print(-1)
        exit()
    node = min(max_node, rca)
    # print(node)
    cnt += node
if node != A[-1]:
    print(-1)
    exit()
print(cnt)"
"a,b,x=map(int,input().split())
if a%x!=0:
  a+=x-a%x

if a==b and a==0:
  print(1)
elif a==b and a==x:
  print(1)
elif a>=b:
  print(0)
else:
  print(b//x-a//x+1)"
"S = input()

N = len(S)

for i in range(N-2, 0, -2):
    h = i // 2
    if S[:h] == S[h:i]:
        
        print(i)
        break"
"a,b = map(int, input().split())

if a<= 8 and b<= 8 and (a+b)<=16:
  print(""Yay!"")
else:
  print("":("")"
"from math import ceil
s = int(input())
print(0, 0, 10 ** 9, 1, abs(s - ((10 ** 9) * ceil(s / 10 ** 9))), ceil(s / 10 ** 9))"
"S = input()
arr = [""x"" for i in range(len(S))]
print("""".join(arr))"
"#
# Written by NoKnowledgeGG @YlePhan
# ('ω')
#
#import math
#mod = 10**9+7
#import itertools
#import fractions
#import numpy as np
#mod = 10**4 + 7
""""""def kiri(n,m):
  r_ = n / m
  if (r_ - (n // m)) > 0:
    return (n//m) + 1
  else:
    return (n//m)""""""

"""""" n! mod m 階乗
mod = 1e9 + 7
N = 10000000
fac = [0] * N
def ini():
  fac[0] = 1 % mod
  for i in range(1,N):
    fac[i] = fac[i-1] * i % mod""""""

""""""mod = 1e9+7
N = 10000000
pw = [0] * N
def ini(c):
  pw[0] = 1 % mod
  for i in range(1,N):
    pw[i] = pw[i-1] * c % mod""""""

""""""
def YEILD():
  yield 'one'
  yield 'two'
  yield 'three'
generator = YEILD()
print(next(generator))
print(next(generator))
print(next(generator))
""""""
""""""def gcd_(a,b):
  if b == 0:#結局はc,0の最大公約数はcなのに
    return a
  return gcd_(a,a % b) # a = p * b + q""""""
""""""def extgcd(a,b,x,y):
  d = a
  if b!=0:
    d = extgcd(b,a%b,y,x)
    y -= (a//b) * x
    print(x,y)
  else:
    x = 1
    y = 0
  return d""""""
# 最大公約数 と 最小公倍数
""""""def gcd(a,b):
  if b == 0:
    return a
  return gcd(b, a % b)
def lcm(a,b):
  g = gcd(a,b)
  return (a * b) // g""""""
# 二分探索
""""""import bisect # 二分探索
print(A,bisect.bisect_left(A,4))
print(C,n - bisect.bisect_right(C,4))
print(sum(bisect.bisect_left(A,b) * (n-bisect.bisect_right(C,b)) for b in B))""""""

def readInts():
  return list(map(int,input().split()))
mod = 10**9 + 7

def main():
  n = int(input())
  F = [readInts() for _ in range(n)]
  P = [readInts() for _ in range(n)]
  
  max_score = -float('inf')
  
  for i in range(1, 2**10):
    op_num = [0] * n
    for j in range(10):
      if i & 1 << j:
        for n_i in range(n):
          op_num[n_i] += F[n_i][j]
    max_score = max(max_score, sum([p_i[op_num_i] for p_i, op_num_i in zip(P,op_num)]))
  print(max_score)
if __name__ == '__main__':
  main()"
"N, K = map(int, input().split())
S = input()

print(S[:K-1], end='')

if K == N:
    print(S[K-1].lower())
else:
    print(S[K-1].lower(), end='')
    print(S[K:])"
"class SwappingTwoNumbers:
    def output(self, n):
        n.sort()
        print ""%d %d"" % (n[0], n[1])

if __name__ == ""__main__"":
    stn = SwappingTwoNumbers();
    while True:
        n = map(int, raw_input().split())
        if n[0] == 0 and n[1] == 0:
            break
        stn.output(n)"
"import sys
num = []
for i in sys.stdin:
    H, W = i.split()
    if H == W == '0':
        break
    num.append((int(H), int(W)))

for cnt in range(len(num)):
    for h in range(num[cnt][0]):
        for w in range(num[cnt][1]):
            print('#',end='')
        print()
    print()"
"import sys
import copy
import math
import bisect
import pprint
import bisect
from functools import reduce
from copy import deepcopy
from collections import deque

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

if __name__ == '__main__':
    a = [int(i) for i in input().split()]

    if a[0] >8 or a[1]>8:
        print("":("")
    else:
        print(""Yay!"")

"
"n=int(input())
ans=0
for i in range(n):
  x,u=input().split()
  x=float(x)
  if u==""BTC"":
    x=x*380000
  ans=ans+x
print(ans)
"
"import sys
import queue


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(20000000)
MOD = 10 ** 9 + 7


def main():
    L = list(input())

    pow = [0] * (len(L) + 1)
    pow[0] = 1
    for i in range(1, len(L) + 1):
        pow[i] = pow[i - 1] * 3 % MOD
    N = len(L)
    if L[-1] == ""0"":
        answer = 1
    else:
        answer = 3
    for i in range(1, N):
        if L[N - i - 1] == ""1"":
            answer = answer * 2 + pow[i]
            answer %= MOD
        else:
            continue
    print(answer)


if __name__ == ""__main__"":
    main()
"
"a,b,c=map(int,input().split())
s=(c-a-b)*(c-a-b)-4*a*b
if s>0 and c-a-b>0:
  print('Yes')
else:
  print('No')"
"import bisect
def main2():
    N = int(input())
    L = list(map(int, input().split()))
    L = sorted(L)

    ans = 0
    for i in range(len(L) - 2):
        for j in range(i + 1, len(L) - 1):
            ab = L[i] + L[j]
            r = bisect.bisect_left(L, ab)
            l = j + 1
            ans += r - l

    print(ans)

if __name__ == ""__main__"":
    main2()"
"import sys 
input = sys.stdin.readline

n = int(input())
p = [float(x) for x in input().split()]

dp = [[0]*(n + 1) for _ in range(n + 1)]
dp[0][0] = 1

ans = 0

for i in range(1, n + 1):
    p_i = p[i - 1]
    for j in range(n + 1):
        dp[i][j] = dp[i - 1][j] * (1 - p_i)
        if j - 1 >= 0:
            dp[i][j] += dp[i - 1][j - 1] * (p_i)
        if i == n and j > (i - j):
            ans += dp[i][j]

print(ans)
"
"xy=list(map(int,input().split()))
print(xy[2]-(xy[3]-xy[1]), xy[3]-(xy[0]-xy[2]), xy[0]-(xy[3]-xy[1]), xy[1]-(xy[0]-xy[2]))
"
"S = input()
S += '0'
max = 0
count = 0
for i in range(len(S)) :
    if S[i] == 'A' or S[i] =='C' or S[i] =='G' or S[i] =='T' :
        count += 1 
    else :
        if count > max :
            max = count
            count = 0

print(max)"
"import math
r = input()
area = r * r * math.pi * 1.0
cir = 2 * r * math.pi * 1.0
print '%f %f' % (area, cir)"
"n = int(input())
h =list(map(int, input().split()))

if n==1:
    print('Yes')
    exit(0)
if n==2:
    if h[0] >= h[1]-1:
        print('Yes')
        exit(0)
    else:
        print('No')
        exit(0)

h[0] -=1

for i in range(1, n-1):
    if h[i-1] == h[i] and h[i] <=h[i+1]:
        continue
    elif h[i-1] == h[i] and h[i] >h[i+1]:
        print('No')
        exit(0)

    elif h[i] <= h [i+1]+1:
        h[i] -= 1
    elif h[i] > h [i+1]+1:
        print('No')
        exit(0)


print('Yes')"
"S = input()
n = len(S)
ans = 'NO'
for i in range(n):
  j = i+n-7
  Q = S[:i] + S[j:]
  if Q == 'keyence':
    ans = 'YES'
print(ans)"
"n = int(input())
for i in range(1,n+1):
   x = i
   if x % 3 == 0:
        print('', i, end='')
   else:
        while True:
            if x % 10 == 3:
                print('', i, end='')
                break
            x //= 10
            if x == 0:
                break
print()"
"import sys
from itertools import islice, tee


def resolve(in_):
    A = int(next(in_))
    B = int(next(in_))
    C = int(next(in_))
    X = int(next(in_))

    ans = 0
    for a in range(A + 1):
        for b in range(B + 1):
            for c in range(C + 1):
                if a * 500 + b * 100 + c * 50 == X:
                    ans += 1

    return ans


def main():
    answer = resolve(sys.stdin.buffer)
    print(answer)


if __name__ == '__main__':
    main()
"
"import sys
input = sys.stdin.buffer.readline


X = [int(i) for i in input().strip().split()]
print(X.index(0) + 1)
"
"import sys
input = sys.stdin.readline

def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))

def main():
    mod=10**9+7
    N=I()
    d=LI()
    d.sort()
    a=d[N//2-1]
    b=d[N//2]
    ans=b-a
    print(ans)

main()
"
"n,q = map(int,input().split())
s=input()
a=[0]*n
for i in range(n-1):
    a[i+1]=a[i]+(1 if s[i:i+2]==""AC"" else 0)

for i in range(q):
    l,r=map(int,input().split())
    print(a[r-1]-a[l-1])"
"n, k = map(int, input().split())
if 1 <= n <= 100 and 1<= k <= 100:
    if 0 == n % k:
        print(0)
    else:
        print(1)
else:
    print('hoge!')"
"raw_data = input()                   
data = raw_data.replace('?', 'D')    
print(data)"
"input()
A = list(map(int, input().split()))

sum_list = sum(A)
sum_of_product = 0

for i in A:
    sum_list -= i
    sum_of_product = ((sum_list * i) % (10 ** 9 + 7) + sum_of_product) % (10 ** 9 + 7)

print(sum_of_product)"
"import sys
from itertools import accumulate
from bisect import bisect_left

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, H, *AB = map(int, read().split())
    A = AB[::2]
    B = AB[1::2]

    Amax = max(A)
    B = [b for b in B if b >= Amax]
    B.sort(reverse=True)
    B = list(accumulate(B))

    i = bisect_left(B, H)
    if i < len(B):
        ans = i + 1
    else:
        ans = len(B) + (H - B[-1] + Amax - 1) // Amax

    print(ans)
    return


if __name__ == '__main__':
    main()
"
"n, m = [int(x) for x in input().split()]

a = sorted([[int(x) for x in input().split()] for _ in range(n)], key=lambda x: x[0])

result = 0
for x in a:
  cnt = min(m, x[1])
  result += x[0] * cnt
  m -= cnt
print(result)"
"import sys
input = sys.stdin.readline
from collections import *

S = input()[:-1]

if 'AC' in S:
    print('Yes')
else:
    print('No')"
"#!/usr/bin/env python
#coding: UTF-8

import sys

while True:
	hight,width = map (int,raw_input().split())
	if hight+width == 0:
		break
	else:
		for h in range(hight):
			if h%2 == 0:
				for w in range(width):
					if w%2 == 0:
						sys.stdout.write(""#"")
					else:
						sys.stdout.write(""."")
				print """"
			else:
				for w in range(width):
					if w%2 == 0:
						sys.stdout.write(""."")
					else:
						sys.stdout.write(""#"")
				print """"
		print """""
"import sys,queue,math,copy
input = sys.stdin.readline
MOD = 10**9 + 7
LI = lambda : [int(x) for x in input().split()]
N = int(input())
A = LI()
c =[0,0,0]
cnt = [0 for _ in range(N)]
for i in range(N):
    cnt[i] = c.count(A[i])
    if cnt[i] == 0: break
    c[c.index(A[i])] += 1
ans = 1
for i in range(N):
    ans = (ans * cnt[i]) % MOD
print (ans)"
"import sys
n=int(input())
for i in range(n+1):
    if int(i*1.08)==n:
        print(i)
        sys.exit()
print("":("")"
"import sys
def input(): return sys.stdin.readline().rstrip()
def main():
    a, b = input().split()
    a = int(a)
    b = int(b[0]+b[2:4])
    print(a*b//100)

if __name__=='__main__':
    main()"
"from collections import defaultdict

N, K = map(int, input().split())
Items = [tuple(map(int, input().split())) for _ in range(N)]
Items.sort(reverse=True, key=lambda x: x[1])
Kinds = defaultdict(int)
ans = 0
k = 0
Candidates = []
for i, (t, d) in enumerate(Items):
    if i < K:
        ans += d
        if t not in Kinds:
            k += 1
        else:
            Candidates.append(d)
        Kinds[t] += 1
        if i == K - 1:
            ans += k ** 2
            a = ans
    else:
        if Kinds[t]:
            continue
        if not Candidates:
            break
        else:
            x = Candidates.pop()
            a -= x
            a -= k ** 2
            k += 1
            a += d
            a += k ** 2
            Kinds[t] -= 1
            ans = max(ans, a)
print(ans)"
"import bisect
N = int(input())
A = []
for i in range(N):
    a = int(input()) * (-1)
    b = bisect.bisect_right(A,a)
    if b == len(A):
        A.append(a)
    else:
        A[b] = a
print(len(A))"
"n=int(input())
if n==1:
    print('Yes')
    print(2)
    print(1,1)
    print(1,1)
    exit()
if n==2:
    print('No')
    exit() 
a=[[1]]
i=1
for j in range(1,n):
    a.append(list(range(i,i+j)))
    if n==i+j-1:
        break
    elif i+j>n:
        print('No')
        exit()
    i+=j
print('Yes')
m=len(a)
for i in range(m-1):
    for j in range(i+1+(i<1),m):
        a[i].append(a[j][i])
print(m)
for b in a:
    print(len(b),*b)"
"import sys

def swap(a, i, j):
    tmp = a[j]
    a[j] = a[i]
    a[i] = tmp
    return a

def list_to_string(a):
    s = """"
    for n in a:
        s += str(n) + "" ""
    return s.strip()

num = int(sys.stdin.readline().strip())

array = map(lambda x: int(x), sys.stdin.readline().strip().split("" ""))

flag = True
swap_num = 0

while flag:
    flag = False
    for i in reversed(range(1, len(array))):
        if array[i] < array[i - 1]:
            swap(array, i, i-1)
            flag = True
            swap_num += 1
            
print list_to_string(array)
print str(swap_num)"
"import collections, copy

h, w = map(int, input().split())
maze = []
maze.append(""#"" * (w + 2))
for i in range(h):
    maze.append(""#"" + input() + ""#"")
maze.append(""#"" * (w + 2))
dis = []
for i in range(h + 2):
    temp = [-1] * (w + 2)
    dis.append(temp)

def search(x, y):
    dis2 = copy.deepcopy(dis)
    move = [[-1, 0], [1, 0], [0, 1], [0, -1]]
    queue = collections.deque([[x, y]])
    dis2[x][y] = 0
    while queue:
        test = queue.popleft()
        for i in move:
            place = [test[0] + i[0], test[1] + i[1]]
            if maze[place[0]][place[1]] == ""."":
                if dis2[place[0]][place[1]] == -1:
                    dis2[place[0]][place[1]] = dis2[test[0]][test[1]] + 1
                    queue.append(place)
    return max([max([dis2[i][j] for j in range(w + 2)]) for i in range(h + 2)])

ans = 0
for i in range(h):
    for j in range(w):
        if maze[i + 1][j + 1] == ""."":
            dist = search(i + 1, j + 1)
            ans = max(ans, dist)
print(ans)"
"residence = [[[0 for r in range(10)] for f in range(3)] for b in range(4)]
n = int(input())
sep = ""#""*20
s = """"
for i in range(n):
    b,f,r,v = map(int,input().split())
    residence[b-1][f-1][r-1] += v

for i in residence:
    for j in i:
        s += "" ""+"" "".join(map(str,j)) + ""\n""

    s += sep+""\n""

print(s.rstrip(sep+""\n""))"
"a=input()
s=input()
print((a<'32')*'red' or s)"
"#D問題
import heapq
N = int(input())
AB = [[] for i in range(N)]
for i in range(N-1):
    a,b = map(int,input().split())
    a-=1
    b-=1
    AB[a].append(b)
    AB[b].append(a)
    
C = list(map(int,input().split()))
C.sort(reverse=True)

var = [0 for i in range(N)]
var[0] = C[0]
Q = []
heapq.heappush(Q,0)
ind = 1

for i in range(N-1):
    q = heapq.heappop(Q)
    for j in AB[q]:
        if var[j] == 0:
            var[j] = C[ind]
            ind+=1
            heapq.heappush(Q,j)
            
print(sum(C)-C[0])
for v in var:
    print(v,end="" "")
"
"x = int(input())

if (x == 3) or (x == 5) or (x == 7):
    print(""YES"")
else:
    print(""NO"")"
"N = int(input())
A = list(map(int, input().split()))

cnt = len([i for i in A if i < 0])
PA = list(map(abs, A))

if cnt % 2 == 0:
    print(sum(PA))
else:
    print(sum(PA) - min(PA) * 2)"
"sx = input()
x = int(sx)

ans = 1001001001
for i in range(len(sx)-2):
    t = int(sx[i:i+3])
    a = abs(753 - t)
    ans = min(ans, a)
    
print(ans)"
"N,x = map(int,input().split())
a=list(map(int,input().split()))
cnt=0
b=[0]*N

#0,2
b[0]=a[0] if a[0]<=x else x
cnt+= a[0]-b[0]

for i in range(1,N):
  b[i] = a[i] if b[i-1]+a[i]<=x else max(0,x-b[i-1])
  cnt += a[i]-b[i]
  
#print(b)
print(cnt)"
"A,B,C,D,E,F = map(int,input().split())

concentration = 0
ans = [A*100,0]

water = []
for a in range(F//(A*100) + 1):
  for b in range(((F-a*A*100)//(B*100))+1):
    water.append((a*A+b*B)*100)
    
water = sorted(list(set(water)))

sugar = []
for c in range(F//C + 1):
  for d in range(((F - c*C)//D)+1):
    sugar.append(c*C+d*D)
sugar = sorted(list(set(sugar)))


for wa in water:
  for su in sugar:
    if wa + su <= F:
      if su <= (wa/100)*E:
        if wa != 0:
          if concentration < su/(su+wa):
            concentration = su/(su+wa)
            ans = [su+wa,su]

print("" "".join(map(str,ans)))"
"S = input()

if(S == 'RRR'):
  print(3)
elif(S=='RRS' or S=='SRR'):
  print(2)
elif(S == 'SSS'):
  print(0)
else:
  print(1)"
"a,b=map(int,input().split())

ans=(a+b)//2

if ans==(a+b)/2:
    print(ans)
else:
    print('IMPOSSIBLE')"
"S = input().strip()

ans = float(""inf"")

for i in range(26):
    tmp = 0
    current = 0
    for s in S:
        if s == chr(ord('a') + i):
            tmp = max(tmp, current)
            current = 0
        else:
            current += 1

    tmp = max(tmp, current)
    ans = min(ans, tmp)

print(ans)

"
"import sys
s = input()
if not s.islower():
    sys.exit()
if len(s) < 0 or len(s) > 10 ** 5:
    sys.exit()

print(s[::2])"
"li = [list(map(int, input().split())) for i in range(2)]
if li[0][0] != li[1][0] :
    print(1)
else :
    print(0)
"
"N, *A = map(int, open(0).read().split())

import collections

c = collections.Counter(A)

print(sum([1 for x in c.values() if x%2==1]))"
"""""""
UnionFindにはいろいろな実装があるが, 本問ではparents配列にノード数を保持する実装だと非常に簡単に解ける. 
以下のようにしてノード数を保持する.
自身が子のとき, 親ノード番号を格納する.
自身が根のとき, ノード数を負の数で格納する.
つまり,　負の数のときは自身が根であり, その絶対値がその木のノード数を表す.
初期化時は、すべてのノードを−1で初期化する.
""""""

N,M = map(int,input().split())

#UnionFind木の実装
#-1で初期化し、併合のたびに-1していく
par = [-1] * N  #親
rank = [0] * N #木の深さ

#木の根を求める
def find(x):
    #par[x]が負のとき(自分が代表のとき)、自身を返す
    if par[x] < 0:
        return x
    else:
        return find(par[x])

#xとyの属する集合を併合
def unite(x,y):
    x = find(x)
    y = find(y)
    #もとから同じ集合のときは何もしない
    if (x == y):
        return
    #x側を常に小さくする
    if par[x] > par[y]:
            x, y = y, x
    
    #x側に併合する、その際xの代表にノード数を加算する
    par[x] += par[y]
    par[y] = x
    

#xとyが同じ集合に属するかどうか
def same(x,y):
    return find(x) == find(y)

for i in range(M):
    x,y = map(int,input().split())
    x -= 1; y -= 1
    unite(x,y)


ans = min(par)

print(abs(ans))
"
"N = int(input())
A = input().split()
ans = 'YES' if len(A) - len(set(A)) == 0 else 'NO'
print(ans)"
"import numpy as np
import sys
read = sys.stdin.read


D = int(input())
CS = np.array(read().split(), np.int32)
C = CS[:26]
S = CS[26:].reshape((-1, 26))
del CS

last = np.zeros((26, ))
ans = []

def getContestType_at_d(d):
    s = -10000000
    for i in range(26):
        mask = np.ones((26, ))
        mask[i] = 0
        tmp = S[d][i] - np.sum(C * (d + 1 - last) * mask)
        if s < tmp:
            s = tmp
            t = i

    last[t] = d + 1

    return t + 1, s


for d in range(D):
    s = -10000000
    for i in range(26):
        mask = np.ones((26, ))
        mask[i] = 1
        score = S[d][i] - np.sum(C * (d + 1 - last) * mask)
        if s < score:
            s = score
            t = i

    last[t] = d + 1
    ans.append(t + 1)


print('\n'.join(map(str, ans)))"
"r,d,x=map(int,input().split())
l=[]
for i in range(10):
    x = r*x-d
    print(x,""\n"")"
"import sys
from collections import defaultdict as dd
sys.setrecursionlimit(10 ** 7)
input = sys.stdin.buffer.readline
N, M = map(int, input().split())
nums = list(map(int, input().split()))
ms = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]
dp = [0] * (N + 1)
for i in range(N):
  for n in nums:
    if i + ms[n] > N: continue
    if i != 0 and dp[i] == 0: continue
    dp[i + ms[n]] = max(dp[i] * 10 + n, dp[i + ms[n]])
print(dp[N])"
"def main():
    nums = list(map(int, input().split()))

    res = 0

    while len(set(nums)) != 1:
        maxIdx = nums.index(max(nums))
        minIdx = nums.index(min(nums))

        if nums[maxIdx] - nums[minIdx] >= 2:
            nums[minIdx] += 2
            res += 1
        else:
            nums[minIdx] += 1
            nums[nums.index(min(nums))] += 1

            res += 1
    
    print(res)


if __name__ == '__main__':
    main()"
"print(""AB""+""CD""[int(input())>999])"
"# https://atcoder.jp/contests/agc007/tasks/agc007_a
import sys
sys.setrecursionlimit(1 << 25)
read = sys.stdin.readline
ra = range
enu = enumerate


def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))
# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと


def read_ints(): return list(map(int, read().split()))


def read_map_as(H, replace={'#': 1, '.': 0}, pad=None):
    '''
    文字列のmapを置換して読み込み。デフォでは#→1,.→0
    '''
    if pad is None:
        ret = []
        for _ in range(H):
            ret.append([replace[s] for s in read()[:-1]])
            # 内包表記はpypyでは若干遅いことに注意
            # #numpy使うだろうからこれを残しておくけど
    else:  # paddingする
        ret = [[pad] * (W + 2)]  # Wはどっかで定義しておくことに注意
        for _ in range(H):
            ret.append([pad] + [replace[s] for s in read()[:-1]] + [pad])
        ret.append([pad] * (W + 2))

    return ret


MOD = 10**9 + 7
INF = 2**31  # 2147483648 > 10**9
# default import
from collections import defaultdict, Counter, deque
from operator import itemgetter, xor, add
from itertools import product, permutations, combinations
from bisect import bisect_left, bisect_right  # , insort_left, insort_right
from functools import reduce

# 常に右、下に動いていたなら、経路は一つに決まる。
# →#をたどってそれ以外に#があるかを判別すれば良い
H, W = read_ints()
A = read_map_as(H)
i, j = 0, 0
A[i][j] = 0
while i != H - 1 or j != W - 1:
    if i + 1 < H and j + 1 < W and A[i + 1][j] and A[i][j + 1]:
        print('Impossible')
        exit()
    ni = i
    nj = j
    if i + 1 < H and A[i + 1][j]:
        ni = i + 1
    if j + 1 < W and A[i][j + 1]:
        nj = j + 1
    if ni == i and nj == j:
        print('Impossible')
        exit()
    A[ni][nj] = 0  # 簡単のために0を埋めておく
    i, j = ni, nj

res = reduce(add, reduce(add, A))
# print(*A, sep='\n')
# print(res)
print('Possible' if res == 0 else 'Impossible')
"
"[[print(""{}x{}={}"".format(i,j,i*j))for j in range(1,10)]for i in range(1,10)]
"
"# # Make IO faster
# import sys
# input = sys.stdin.readline

# # get single (or) multiple str
# X = input()

# # get single int
# N = int(input())
# # get multiple int (e.g., 2)
# X, Y = map(int, input().split())
# # get multiple int (e.g., 2) for N lines
# XY = [list(map(int, input().split())) for _ in range(N)]

# from IPython import embed; embed(); exit();

# 全部入り
import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import accumulate, permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce
import numpy as np
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

A, B = MAP()

ans = 0
for i in range(A, B + 1):
    if str(i)[0] == str(i)[4] and str(i)[1] == str(i)[3]:
        ans += 1
print(ans)
"
"while True:
    n,x = map(int,input().split())
    if n == x == 0:
        break
    
    d = 0
    for i in range(1,n+1):
        for j in range(i+1,n+1):
            k = x-(i+j)
            if k >= 1 and k<= n and k > j:
                d += 1
    
    print(d)
        
    
"
"import math

N,M=map(int,input().split())

if (N==0 or N==1) and (M==0 or M==1):
  print(0)
elif (N==0 or N==1) and (M!=0 and M!=1):
  print(int(math.factorial(M)/math.factorial(M-2)/math.factorial(2)))
elif (M==0 or M==1) and (N!=0 and N!=1):
  print(int(math.factorial(N)/math.factorial(N-2)/math.factorial(2)))
else:
  print(int(math.factorial(N)/math.factorial(N-2)/math.factorial(2)+math.factorial(M)/math.factorial(M-2)/math.factorial(2)))
"
"INF = 10**12

def warshall_floyd(d,n):
    #d[i][j]: iからjへの最短距離
    for k in range(n):
        for i in range(n):
            for j in range(n):
                d[i][j] = min(d[i][j],d[i][k] + d[k][j])
    return d


def main():

    n,m,l = map(int, input().split())
    d = [ [INF]*(n) for _ in range(n) ]
    for _ in range(m):
        a,b,c = map(int, input().split())
        d[a-1][b-1] = c
        d[b-1][a-1] = c

    warshall_floyd(d, n)

    d2 = [ [INF]*(n) for _ in range(n) ]
    for i in range(n):
        for j in range(n):
            if d[i][j] <= l:
                d2[i][j] = 1

    warshall_floyd(d2,n)
    ans = []
    q = int(input())
    for _ in range(q):
        s,t = map(int, input().split())
        dist = d2[s-1][t-1]
        if dist == INF: dist = 0
        ans.append(dist-1)

    for a in ans:
        print(a)

if __name__ == ""__main__"":
    main()"
"# -*- coding: utf-8 -*-

import sys
import os
import math


while True:
    N = int(input())
    if N == 0:
        break
    scores = list(map(float, input().split()))
    n = len(scores)
    mean = sum(scores) / n

    variance = 0
    for score in scores:
        variance += (score - mean) ** 2
    variance /= n

    print(math.sqrt(variance))"
"n = int(input())
s = str(input())

r = 0
for i in range(len(s)):
  if s[i] == 'R':
    r += 1

if r > (n-r):
  print('Yes')
else:
  print('No')"
"k = int(input())

num=[1,2,3,4,5,6,7,8,9]

if k<10:
    print(num[k-1])
    exit()

ans=9

def hantei():
    global ans
    ans+=1
    if ans==k:
        print(num[-1])
        exit()

for i in range(10**10):

    hitoketa=num[0]%10

    if hitoketa==0:
        num.append(10*num[0]+0)
        hantei()
        num.append(10*num[0]+1)
        hantei()
        num.pop(0)

    elif hitoketa==9:
        num.append(10*num[0]+8)
        hantei()
        num.append(10*num[0]+9)
        hantei()
        num.pop(0)

    else:
        num.append(10*num[0]+(hitoketa-1))
        hantei()
        num.append(10*num[0]+(hitoketa))
        hantei()
        num.append(10*num[0]+(hitoketa+1))
        hantei()
        num.pop(0)"
"N = int(input())
A = list(map(int,input().split()))
d = {}
for a in A:
    if a in d:
        d[a] += 1
    else:
        d[a] = 1
#print(d)
s = 0
for k in d:
    s += d[k] * (d[k] - 1) // 2
#print(""s="",s)
for i in range(N):
    t = d[A[i]]
    #print(""t="",t)
    print(s - t * (t - 1) // 2 + (t - 1) * (t - 2) // 2)"
"N, M = map(int, input().split())
A = list(map(int, input().split()))
A.sort(reverse=True)

match = [10**18, 2, 5, 5, 4, 5, 6, 3, 7, 6]

# 作れる数字の個数
dp = [-10**18] * (N + 1)
dp[0] = 1

for i in range(N):
    for a in A:
        m = match[a]
        if i + m <= N and dp[i + m] < dp[i] + 1:
            dp[i + m] = dp[i] + 1

ans = []
while N > 0:
    for a in A:
        m = match[a]
        if N - m >= 0 and dp[N - m] + 1 == dp[N]:
            ans.append(a)
            N -= m
            break

ans.sort(reverse=True)

print(''.join(map(str, ans)))
"
"n,m = map(int,input().split())
x = n-m
'''確率pの事象を達成するまで試行する時の期待値eは1/pとなることを考える。本件はp=(1/2)^mであることから、期待値eは2^mとなり得る
'''
print((((1900*m)+(100*x))*2**m))"
"W = input()

ok = [True] * 26

for w in W:
    idx = ord(w) - ord(""a"")
    ok[idx] = not ok[idx]

print(""Yes"" if all(ok) else ""No"")"
"def lucas_dp(n):
    memo = [None] * (n + 1)
    memo[0] = 2
    memo[1] = 1
    for i in range(2, n+1):
        memo[i] = memo[i - 1] + memo[i - 2]
    return memo[n]  

n = int(input())
lucas = lucas_dp(n)
print(lucas)
"
"a,b,c,d=map(int,input().split())
if (b<0 and c>0) or (a>0 and d<0):
  print(max(a*c,a*d,b*c,b*d))
else:
  print(max(0,a*c,a*d,b*c,b*d))"
"t=input()

tla=list(t)
tlb=list(t)
pd1=0
pd2=0

for i in range(len(tla)):
  if tla[i]==""?"":
    if i==0:
      pass
    elif i==len(tla)-1:
      tla[i]=""D""
    elif tla[i-1]==""P"":
      tla[i]=""D""
    elif tla[i+1]==""D"":
      tla[i]=""P""
    elif tla[i+1]==""?"":
      tla[i]=""P""
    else:
      tla[i]=""D""
  if tla[i]==""D"":
    if i==0:
      pass
    elif tla[i-1]==""P"":
      pd1+=1
d1=tla.count('D')
s1=d1+pd1

for i in range(len(tlb)):
  if tlb[i]==""?"":
    tlb[i]=""D""
  if tlb[i]==""D"":
    if i==0:
      pass
    elif tlb[i-1]==""P"":
      pd2+=1
d2=tlb.count('D')
s2=d2+pd2

if s1>s2:
  print(''.join(tla))
else:
  print(''.join(tlb))"
"a, b = map(int, raw_input().split())
print int(a / b)
print int(a % b)
print format(float(a) / b, "".12f"")"
"n=int(input())
bop=list(map(int,input().split()))
hq=sum(bop)

for i in range(1,n):
  		hq=min(hq, abs(sum(bop[:i])-sum(bop[i:n])))

print(hq)"
"a,v,b,w,t=map(int,open(0).read().split())
print('YNEOS'[v-w<abs(a-b)/t::2])"
"n=int(input())
l=[]
for i in range(int(n**0.5)+1):
  l.append(i**2)
print(max(l))
"
"N = int(input())
A,B = [int(i) for i in input().split()]
P = [int(i) for i in input().split()]
am = 0
ab = 0
bu = 0
for i in range(N):
    if P[i]<=A:
        am+=1
    if A+1<=P[i]<=B:
        ab +=1
    if B+1<=P[i]:
        bu+=1

print(min(am,ab,bu))"
"x = int(input())
print(x//3)"
"n = int(input())
A = list(map(int, input().split()))
c = [0]*100000
ans = 0
for a in A:
    c[a] += 1

for i in range(1, 99999):
    cnt = c[i-1] + c[i] +c[i+1]
    ans = max(ans, cnt)

print(ans)"
"N = int(input())

# 初期化
G = [[] for i in range(10 ** 6 + 1)]  # グラフ
U = [None] * (10 ** 6 + 1)  # 入次数
D = [0] * (10 ** 6 + 1)  # 根からの距離


# 変換用
def x(i, j):
    return j + 1000 * i


# グラフを構築
for i in range(1, N + 1):
    A = list(map(int, input().split()))
    for j in range(N - 2):
        fv1, fv2 = min(i, A[j]), max(i, A[j])
        tv1, tv2 = min(i, A[j + 1]), max(i, A[j + 1])
        G[x(fv1, fv2)].append(x(tv1, tv2))
        U[x(fv1, fv2)] = 0
        U[x(tv1, tv2)] = 0


# 入次数をカウント
for i in range(10 ** 6 + 1):
    for v in G[i]:
        U[v] += 1

# トポロジカルソート
U_zero_nodes = []
for i in range(10 ** 6 + 1):
    if U[i] is None:
        continue

    if U[i] == 0:
        U_zero_nodes.append(i)


topological_order = []
while U_zero_nodes:
    n = U_zero_nodes.pop()
    topological_order.append(n)

    for v in G[n]:
        U[v] -= 1
        if U[v] == 0:
            U_zero_nodes.append(v)


# 不可能判定
if len(topological_order) != N * (N - 1) // 2:
    print(-1)
    exit()


# 最長経路を計算
for t_n in topological_order:
    for v in G[t_n]:
        D[v] = max(D[v], D[t_n] + 1)
print(max(D) + 1)
"
"K, N = map(int, input().split())
Alst = list(map(int, input().split()))
zero = Alst[0] + K
M = 0
now = Alst[0]
for i in Alst:
    dis = i - now
    if dis > M:
        M = dis
    now = i

last = zero - now
if last > M:
    M = last

print(K - M)"
"
def resolve():
    A, B = list(map(int, input().split()))
    print(A+B if A+B<10 else ""error"")
    


if '__main__' == __name__:
    resolve()"
"import sys
from collections import Counter

if sys.platform in ['ios','win32','darwin']:
	sys.stdin=open('Untitled.txt')
input = sys.stdin.readline
def INT(): return int(input())
def MAP(): return [int(s) for s in input().split()]

N = INT()
A = MAP()

C = Counter(A).most_common()
# print(C)

double = 0
for c in C:
	num, cnt = c
	# print(cnt)
	if cnt % 2 == 0:
		double += 1

if double % 2:
	print(len(C)-1)
else:
	print(len(C))"
"from sys import stdin
def LI(): return list(map(int,stdin.readline().rstrip().split()))

tmp = LI()

k,s = [tmp.pop(0) for i in range(2)]

c=0
for i in range(k,-1,-1):
    if i<=s:
        for j in range(k,-1,-1):
            if 0<=s-i-j and s-i-j<=k:
                c += 1

print(c)"
"import sys
mapin = lambda: map(int, sys.stdin.readline().split())
listin = lambda: list(map(int, sys.stdin.readline().split()))
inp = lambda: sys.stdin.readline()
A,B,C,D = mapin()
l = A + B;r = C + D
if l < r:print(""Right"")
elif l > r:print(""Left"")
else:print(""Balanced"")"
"N = int(input())
S = input()
 
oE = S.count(""E"")
Wo = 0

L = []
for i in range(N):
    if i == 0:
        if S[i] == ""E"":
            oE -= 1
    else:
        if S[i-1] == ""W"":
            Wo += 1
        if S[i] == ""E"":
            oE -= 1
    L.append(Wo + oE)
    if Wo + oE == 0:
        break
print(min(L))"
"def readinput():
    n=int(input())
    x=input()
    return n,x

poptbl=[0]*(2*10**5+1)
def popcount(x):
    global poptbl
    #if poptbl[x]!=0:
    #    return poptbl[x]
    
    poptbl[x]=bin(x).count('1')
    return poptbl[x]

ftbl=[0]*(2*10**5+1)
def f(x):
    global ftbl

    #if ftbl[x]!=0:
    #    return ftbl[x]
    
    #print('f(x), x: {}'.format(x))
    if x==0:
        return 0
    else:
        ans=f(x%popcount(x))+1
        #print(ans)
        ftbl[x]=ans
        return ans    

def main():
    n=int(input())
    x=input()
    m=x.count('1')
    #print('m: {}'.format(m))
    xint=int(x,2)
    #print('xint: {}'.format(xint))
    if m!=1:
        xmodm1=xint%(m-1)
    else:
        xmodm1=1
    xmodp1=xint%(m+1)
    pow2mod1=[0]*n
    pow2mod2=[0]*n
    pow2mod1[0]=1
    pow2mod2[0]=1
    for i in range(1,n):
        if m!=1:
            pow2mod1[i]=pow2mod1[i-1]*2 % (m-1)
        pow2mod2[i]=pow2mod2[i-1]*2 % (m+1)

    ans=[]
    #b=2**(n-1)
    for i in range(n):
        if x[i]=='1':
            if m==1:
                a=0
                ans.append(a)
            else:
                xx=( xmodm1 + (m-1) -pow2mod1[n-i-1] )%(m-1)
                #ans.append(f(xx)+1)
                a=f(xx)+1
                ans.append(a)
        else:
            xx=( xmodp1 + pow2mod2[n-i-1] )%(m+1)
            #ans.append(f(xx)+1)
            a=f(xx)+1
            ans.append(a)
        #b=b//2
        print(a)
    return ans

if __name__=='__main__':
    #n,x=readinput()
    ans=main()
    #for a in ans:
    #    print(a)

"
"road = []

road += input().split()
road += input().split()
road += input().split()

from collections import Counter

c = Counter(road)

flag = True
for k, v in c.items():
    if v > 2:
        flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
"
"s = str(input())
C = 0
F = 0
for i in s:
    if C == 0 and i == 'C':
        C = 1
    elif C == 1 and i == 'F':
        F = 1
if F == 1:
    print('Yes')
else:
    print('No')"
"def main():
    N = int(input())

    ma = 0
    tot = 0
    while tot < N:
        ma += 1
        tot += ma

    skip = tot - N
    ans = {x for x in range(1, ma + 1) if x != skip}

    print(*ans, sep='\n')


if __name__ == '__main__':
    main()
"
"# solution
import io
import math

nim = int(input())
mike = int(input())
counter = 1
for i in range(nim):
    if counter < mike:
        counter*=2
    else:
        counter+=mike
print(counter)"
"N,Q=map(int,input().split())
S=input()
L=[0]*N
p=S[0]
for i in  range(1,N):
  L[i]+=L[i-1]
  if p+S[i]=='AC':
    L[i]+=1
  p=S[i]
for _ in range(Q):
  i,j=map(int,input().split())
  print(L[j-1]-L[i-1])
"
"from collections import Counter

N = int(input())
A = list(map(int,input().split()))
c = Counter(A)
sticks = []
for i in c:
    s = c[i]
    if s >= 4:
        sticks.append(i)
    if s >= 2:
        sticks.append(i)
if len(sticks) < 2:
    print(0)
else:
    sticks.sort(reverse=True)
    print(sticks[0]*sticks[1])
 




"
"import sys
import math
import bisect

def main():
    A = list(map(int, input().split()))
    B = []
    for i in range(3):
        for j in range(3):
            for k in range(3):
                if j != i and k != i and k != j:
                    val = abs(A[j] - A[i]) + abs(A[k] - A[j])
                    B.append(val)
    print(min(B))

if __name__ == ""__main__"":
    main()
"
"import sys
sys.setrecursionlimit(2147483647)
INF=float(""inf"")
MOD=10**9+7 # 998244353
input=lambda:sys.stdin.readline().rstrip()
def resolve():
    n,x,y=map(int,input().split())
    x-=1; y-=1
    E1=[[] for _ in range(n)]
    E2=[[] for _ in range(n)]
    for _ in range(n-1):
        u,v=map(int,input().split())
        u-=1; v-=1
        E1[u].append(v)
        E1[v].append(u)
    E2=E1

    # E2 において、y-rooted tree とみて、depth,par を計算
    par=[None]*n # x の必勝頂点を判定するのに必要
    par[y]=y
    depth2=[None]*n
    depth2[y]=0
    Q=[y]
    while(Q):
        v=Q.pop()
        for nv in E2[v]:
            if(depth2[nv] is not None): continue
            depth2[nv]=depth2[v]+1
            par[nv]=v
            Q.append(nv)

    # E1の辺で、E2での距離が 3 以上のものは必勝
    win=[0]*n
    for v in range(n):
        for nv in E1[v]:
            if(par[v]==nv or par[nv]==v or par[v]==par[nv] or par[par[v]]==nv or par[par[nv]]==v): continue
            win[nv]=win[v]=1

    # E1 において、x-rooted tree とみて探索
    # depth1 < depth2 -> 以降も探索できる
    # depth1 = depth2 -> そこで捕まる
    ans=depth2[x]
    depth1=[None]*n
    depth1[x]=0
    Q=[x]
    while(Q):
        v=Q.pop()
        if(win[v]): # 探索できる状態 & 必勝頂点にいれば勝ち
            print(-1)
            return
        for nv in E1[v]:
            if(depth1[nv] is not None): continue
            depth1[nv]=depth1[v]+1
            ans=max(ans,depth2[nv])
            if(depth1[nv]<depth2[nv]): Q.append(nv)

    print(ans-1)
resolve()"
"import math
N = int(input())
a = list(map(int,input().split()))
if min(a) >= 0:
    print(N-1)
    for i in range(N-1):
        print((i+1),(i+2))
elif max(a) < 0:
    print(N-1)
    for i in range(N-1):
        print((N-i),(N-i-1))
else:
    if abs(max(a)) >= abs(min(a)):
        print(2*N-1)
        mindex = a.index(max(a))
        for i in range(N):
            print(mindex+1,i+1)
        for j in range(N-1):
            print((j+1),(j+2))
    else:
        print(2*N-1)
        mindex = a.index(min(a))
        for i in range(N):
            print(mindex+1,i+1)
        for j in range(N-1):
            print((N-j),(N-j-1))"
"def main():
    l = int(input())
    print((l / 3) ** 3)


if __name__ == ""__main__"":
    main()"
"n = int(input())
s = input() #sys.stdin.readlineは最後が改行


lan0 = []
lan1 = []

if s[0]=='#':
    lan0.append(0)

cnt0=0
cnt1=0

for i in range(n):
    if s[i] == '.':
        if cnt1 > 0:
            lan1.append(cnt1)
            cnt1=0
            cnt0=1
        else:
            cnt0+=1
    if s[i] == '#':
        if cnt0 > 0:
            lan0.append(cnt0)
            cnt0=0
            cnt1=1
        else:
            cnt1+=1

if cnt0>0:lan0.append(cnt0)
if cnt1>0:lan1.append(cnt1)



from itertools import accumulate
acc0 = list(reversed(lan0))
acc0 = list(accumulate(acc0))
acc0.reverse()
acc0 = acc0+[0] +[0]


acc1 = [0] + lan1
acc1 = list(accumulate(acc1))
acc1 = [0]+acc1

ans = n
for i in range(len(acc1)):
    ans = min(ans,acc0[i]+acc1[i])

print(ans)
"
"from collections import defaultdict
d = defaultdict(int)
n = int(input())
cnt = 0
for _ in range(n):
  s = """".join(sorted(input()))
  cnt += d[s]
  d[s] += 1
print(cnt)"
"def main():
    n = int(input())
    # n, m = map(int, input().split())
    a = list(map(int, input().split()))
    # s = input()
    # h = [int(input()) for _ in rane(n)]

    while True:
        currentmin = 10**10
        currentminIndex = 0
        for i in range(n):
            if currentmin > a[i] and a[i] != 0:
                currentmin = a[i]
                currentminIndex = i
        for i in range(n):
            if i != currentminIndex:
                a[i] = a[i] % currentmin
        count = 0
        for i in range(n):
            if a[i] != 0:
                count += 1
        if count == 1:
            break

    print(max(a))


if __name__ == '__main__':
    main()

"
"h, w, n= [int(input()) for i in range(3)]
k = max(h, w)
ans = (n+k-1)//k
print(ans)"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10**9 + 7
#from decimal import *

N = INT()
S = input()

b = [0]*(N+1)
w = [0]*(N+1)

tmp_b = 0
for i in range(N):
	if S[i] == ""#"":
		tmp_b += 1
	b[i+1] = tmp_b


tmp_w = 0
for i in range(N-1, -1, -1):
	if S[i] == ""."":
		tmp_w += 1
	w[i] = tmp_w

ans = min([b[i]+w[i] for i in range(N+1)])
#print(b)
#print(w)
print(ans)
"
"s = input()

L = ['R', 'U', 'D']
M = ['L', 'U', 'D']

lens = len(s)
cnt = 0

for i in range(lens):
    if (i+1)%2 == 1 and s[i] in L:
        cnt += 1
    elif (i+1)%2 == 0 and s[i] in M:
        cnt += 1

if cnt == lens:
    print('Yes')
else :
    print('No')
        
"
"N = int(input())

ans = 0
MOD = 10**9+7

ans = 10**N-2*9**N+8**N
ans %= MOD
print(ans)"
"def main():
    N = int(input())
    p = []
    for i in range(N):
        p.append(int(input()))
    p.sort()
    last = p[-1]
    print(sum(p)-last+(last//2))
main()  "
"from collections import defaultdict

h, w = map(int, input().split())
dd = defaultdict(int)
for _ in range(h):
    string = input()
    for s in string:
        dd[s] += 1
        
one = 0
two = 0
for _, value in dd.items():
    if value % 2 == 1:
        one += 1
        value -= 1
    if value % 4 == 2:
        two += 1
        
if h % 2 == 0 and w % 2 == 0:
    if one == two == 0:
        print(""Yes"")
    else:
        print(""No"")
elif h % 2 == 1 and w % 2 == 1:
    if one > 1:
        print(""No"")
    elif two > h // 2 + w // 2:
        print(""No"")
    else:
        print(""Yes"")
else:
    if h % 2 == 0:
        tmp = h // 2
    else:
        tmp = w // 2
    if one > 0:
        print(""No"")
    elif two > tmp:
        print(""No"")
    else:
        print(""Yes"")
"
"N = int(input())
min = 100000000000000
for i in range(1, N):
  A = str(i)
  B = str(N - i)
  ref = 0
  for a in A:
    ref += int(a)
  for b in B:
    ref += int(b)
  if ref < min:
    min = ref
print(min)"
"def MAP(): return map(int, input().split())
def LIST(): return list(MAP())
 
N = int(input())
count = [[0 for _ in range(10)] for _ in range(10)]
for i in range(1, N + 1):
    string_i = str(i)
    initial = int(string_i[0])
    end = int(string_i[-1])
    count[initial][end] += 1
ans = 0
for i in range(1, 10):
    for j in range(1, 10):
        ans += count[i][j] * count[j][i]
print(ans)"
"n, k = map(int, input().split())
print((n % k) & 1)"
"def main():
  N = int(input())
  A = list(map(int,input().split()))
  tmp = 1
  for i in range(N):
    if A[i] % 2 == 0:
      tmp *= 2  
  print(3**N - tmp)
main()  "
"def main():
	N = int(input())
	A = list(map(int, input().split()))

	is_increasing = True
	is_first = True
	ans = 1

	for i in range(1, N):
		if is_first == True:
			if A[i - 1] < A[i]:
				is_increasing = True
				is_first = False
			elif A[i - 1] > A[i]:
				is_increasing = False
				is_first = False
		else:
			if is_increasing == True and A[i - 1] > A[i]:
				ans += 1
				is_first = True
			elif is_increasing == False and A[i - 1] < A[i]:
				ans += 1
				is_first = True

	print(ans)



 
if __name__ == ""__main__"":
  	main()"
"N, x = map(int, input().split())
a = list(map(int, input().split()))

a = sorted(a)

M = []
cn = 0

for i in range(N):
    x = x - a[i]


    
    if x >= 0 and i != N-1: 
        cn = cn + 1
    elif x < 0:
        print(cn)
        break
    elif i == N-1:
        if x == 0:
            cn = cn + 1
            print(cn)
            break
        else:
            print(cn)
            break"
"import math
base = 100000
r = 0.05
n = int(raw_input())
if n <= 100:
    for i in range(1, n+1):
        base = base + (base * r)
        now = int(math.ceil(base / 1000))
        base = now * 1000
    print ""{}"".format(base)"
"x,y=map(int,input().split())
if x==0:
  if y<0:
    print(-1*y+1)
  else:
    print(y)
    
elif x>0:
  if -1*x<y<x:
    if y<=0:
      print(y+x+1)
    else:
      print(x-y+2)
  elif x<y:
    print(y-x)
  else:
    print(-1*y-x+1)
    
else:
  if x<y<-1*x:
    if y<=0:
      print(y-x)
    else:
      print(-1*y-x+1)
  elif y<x:
    print(-1*y+x+2)
  else:
    print(y+x+1)
"
"N = int(input())
A = [int(i) for i in input().split()]

A.reverse()
ans = []

for i in range(0,N,2):
    ans.append(A[i])

A.reverse()

for i in range(N%2,N,2):
    ans.append(A[i])

[print(i,end=' ') for i in ans]
"
"import sys
import bisect
n = int(input())
A = list(map(int,input().split()))
A.sort()
m = A[-1]
if n == 2:
    print(A[-1],A[0])
    sys.exit()
i = bisect.bisect_left(A,m//2)
if i == 0:
    print(m,A[0])
else:
    if m - A[i] < A[i-1]:
        print(m,A[i-1])
    else:
        print(m,A[i])"
"S = input()

code_list = []
for code in S:
    code_list.append(code)

answer = code_list[0] != code_list[1] != code_list[2] != code_list[3]

if answer:
    print( ""Good"" )
else:
    print( ""Bad"" )"
"n=input()
cnt=0
for i in range(3):
    if n[i]==""7"":
        cnt+=1

if cnt==0:
    print(""No"")
else:
    print(""Yes"")"
"n, k = map(int, input().split())
for i in range(1, 100):
  if k ** (i - 1) <= n < k ** i:
    print(i)
    exit()"
"N = int(input())
A = list(map(int, input().split()))

result = [0] * N

for a in A:
  result[a-1] += 1
  
for i in range(N):
  print(result[i])
"
"import sys
sys.setrecursionlimit(2*10**9)

N,Q=map(int, input().split())

adj_list = [[] for _ in range(N)]
counter = [0 for _ in range(N)]
reached = [0 for _ in range(N)]

for _ in range(N-1):
    a,b = map(int,input().split())
    a-=1
    b-=1
    adj_list[a].append(b)
    adj_list[b].append(a)

def df(current, score):
    next_nodes = adj_list[current]
    reached[current]=1
    for node in next_nodes:
        if reached[node]==0:
            counter[node]+=score
            df(node, counter[node])

for _ in range(Q):
    p,x=map(int, input().split())
    counter[p-1]+=x
df(0, counter[0])
print(*counter)
"
"s=list(map(int,input().split()))
if s[0]==s[1]:
  a=2
elif s[1]==s[2]:
  a=0
else:
  a=1
print(s[a])"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")



n,m = map(int, input().split())
from collections import defaultdict
ns = defaultdict(set)
for i in range(m):
    x,y,z = map(int, input().split())
    x -= 1
    y -= 1
    ns[x].add(y)
    ns[y].add(x)
    
seen = [False]*n
ans = 0
for start in range(n):
    if seen[start]:
        continue
    q = [(start, -1)]
    seen[start] = True
    val = None
    while q:
        u, prev = q.pop()
        for v in ns[u]:
            if v==prev:
                continue
            if seen[v]:
                val = 1
            else:
                seen[v] = True
                q.append((v, u))
    if val is None:
        val = 1
    ans += val
print(ans)"
"N = int(input())
L = [0]
M = list(range(1 , N + 1))
a = 1
for i in range(1 , N):
  for j in range(1 ,i + 1):
    a = a * j
  L.append(a)
  a = 1
list.sort(L,reverse = True)
P = list(map(int,input().split()))
Q = list(map(int,input().split()))
con_P = 0
con_Q = 0
for k in range(0 , N - 1):
  if k != N - 2:
    con_P += L[k] * (M.index(P[k]))
    M.remove(P[k])
  else:
    con_P += L[k] * (M.index(P[k]) + 1)
    
M = list(range(1 , N + 1))

for l in range(0 , N - 1):
  if l != N - 2:
    con_Q += L[l] * (M.index(Q[l]))
    M.remove(Q[l])
  else:
    con_Q += L[l] * (M.index(Q[l]) + 1)
ans = con_P - con_Q
if ans < 0:
  print(-ans)
else:
  print(ans)

"
"from collections import Counter

n = int(input())
D = list(map(int, input().split()))
m = int(input())
T = list(map(int, input().split()))

C = Counter(D)

for t in T:
    if C[t]:
        C[t] -= 1
    else:
        print(""NO"")
        exit()
print(""YES"")"
"def main():
    A, B = map(int, input().split())
    return (A+B) % 24

if __name__ == '__main__':
    print(main())"
"S = int(input())
print(""Christmas""+"" Eve""*(25-S))
"
"n = int(input())
aa = list(sorted(map(int, input().split())))
x = max(aa)
y = aa[0]
for i in range(1, n - 1):
    if abs(x / 2 - y) > abs(x / 2 - aa[i]):
        y = aa[i]
print(""{} {}"".format(x, y))
"
"N, T = map(int, input().split())
t = list(map(int, input().split()))
lastOn = t[0]
ans = 0
for i in range(1,N):
    ti = t[i]
    ans += min(T, ti-lastOn)
    lastOn = ti
ans += T
print(ans)
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

S = int(input())
mod = 10**9+7

pos = {0: 1}
neg = {0: 1}
for i in range(1, 10**4):
    pos[i] = (pos[i-1]*i)%mod
    neg[i] = pow(pos[i], mod-2, mod)

cnt = 1
ans = 0
while 3*cnt<=S:
    rest = S-3*cnt
    ans += pos[rest+cnt-1]*neg[rest]*neg[cnt-1]
    ans %= mod
    cnt += 1

print(ans)"
"S = input()
cnt_a = 0
cnt_b = 0
cnt_c = 0
for s in S:
    if s == 'a':
        cnt_a += 1
    elif s == 'b':
        cnt_b += 1
    else:
        cnt_c += 1
if abs(cnt_a - cnt_b) <= 1 and abs(cnt_b - cnt_c) <= 1 and abs(cnt_c - cnt_a) <= 1:
    print('YES')
else:
    print('NO')
"
"N = int(input())

def factorize(N):
    res = {}
    for i in range(2, N):
        if i**2 > N: break
        if N % i != 0: continue
        num = 0
        while N % i == 0:
            N = int(N/i)
            num += 1
        res[i] = num
    if N>1: res[N] = 1
    return res

MOD = 10**9+7
table = [0]*(N+1)
for i in range(2, N+1):
    res = factorize(i)
    for p in res.keys():
        table[p] += res[p]
        table[p] %= MOD

ans = 1
for n in table:
    if n > 0: 
        ans *= (1+n)
        ans %= MOD

print(ans)"
"N, M = map(int, input().split())

if N * 2 > M:
    print(M // 2)
elif N * 2 == M:
    print(N)
else:
    count = N
    M -= 2 * N
    count += (M // 4)
    print(count)
"
"from sys import stdin

def main():
    input = stdin.readline
    n = int(input())
    a = list(map(int, input().split()))
    p = []
    for i in reversed(range(n)):
        if a[i]:
            p.append(i + 1)
            u = 1
            v = i + 1
            while u * u <= v:
                if v % u == 0:
                    a[u - 1] ^= 1
                    if u != v // u:
                        a[v // u - 1] ^= 1
                u += 1
    if len(p) > 0:
        print(len(p))
        print(*p)
    else:
        print(0)
main()"
"n = int(input())
A = list(map(int, input().split()))
A = [a - 1 for a in A]
count = 0
for i, a in enumerate(A):
	if A[a] == i:
		count += 1
print(count//2)"
"N,T = [int(i) for i in input().split()]
t = [int(i) for i in input().split()]
pt = 0
tt = 0
for i in range(N):
    tt += min(T, t[i] - pt)
    pt = t[i]
print(tt + T)"
"n, k = map(int, input().split())
a = 0
b = 0
for i in range(1, n+1):
    if i % k == 0:
        a += 1
    elif i % k == k / 2:
        b += 1
result = a**3 + b**3
print(result)"
"# coding: utf-8
import sys

sr = lambda: sys.stdin.readline().rstrip()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

# 重なるところに注意
A, B, K = lr()
answer = [x for x in range(A, min(A+K, B+1))] + [x for x in range(max(B-K+1, A), B+1)]
answer = sorted(set(answer))
print('\n'.join(map(str, answer)))"
"import sys


def input():
    return sys.stdin.readline().strip()
# sys.setrecursionlimit(100000)


def main():
    n = int(input().strip())
    B = [int(i) for i in input().strip().split()]
    ans = []
    ptr = len(B)
    while ptr > 0:
        if B[ptr - 1] == ptr:
            ans.append(B.pop(ptr - 1))
            ptr = len(B)
        else:
            ptr -= 1
    if len(ans) == n:
        for i in ans[::-1]:
            print(i)
    else:
        print(-1)

    return


if __name__ == ""__main__"":
    main()
"
"#19:36
n,k = map(int,input().split())
mod = 10 ** 9 + 7
peer = [[] for _ in range(n)]
for _ in range(n-1):
  a,b = map(int,input().split())
  a -= 1
  b -= 1
  peer[a].append(b)
  peer[b].append(a)
now = [0]
pst = [[] for _ in range(n)]
seen = [0 for _ in range(n)]
seen[0] = 1
while now:
  last = now
  now = []
  for x in last:
    for y in peer[x]:
      if seen[y] == 0:
        seen[y] = 1
        now.append(y)
        pst[x].append(y)
#print(pst)
for i in range(n):
  if i == 0:
    ans = k
    for j in range(len(pst[0])):
      ans *= k-1-j
      ans %= mod
    continue
  for j in range(len(pst[i])):
    ans *= k-2-j
    ans %= mod
print(ans)"
"s=input()
s=s[:-1]

if len(s)%2==1:
    s=s[:-1]
while len(s)>=0:
    l=len(s)//2
    if s[:l]==s[l:]:
        break
    s=s[:-1]
    s=s[:-1]
print(len(s))
"
"n = int(input())
n2 = n
i = 1
while True:
    if (n2 > 26**i):
        n2 = n2 - 26**i
        i = i + 1
    else:
        break

lst = []

for j in range(i - 1):
    k = j + 1
    n = n - 26**k
n = n - 1
for j in range(i):
    k = i - j - 1
    x = n//(26**k)
    lst.append(x)
    n = n - 26**k*x
for j in range(len(lst)):
    if (j != len(lst) - 1):
        print(chr(int(97 + lst[j])), end = '')
    else:
        print(chr(int(97 + lst[j])))
"
"x=int(input())

c=100
i=0
while True:
    i+=1
    c=c+c//100
    if x<=c:
        print(i)
        exit()
"
"N  =int(input())
c = 0
for i in range(N):
  c += (N-1)//(i+1)
print(c)  
  
"
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
c=list(map(int,input().split()))
a.sort()
b.sort()
c.sort()
y=[]
import bisect
for i in range(n):
	y.append(bisect.bisect_left(a,b[i]))
ans=0
q=[]
for i in range(n):
	p=bisect.bisect_left(b,c[i])
	q.append(p)
k=sum(y[0:q[0]])
for i in range(n-1):
	ans+=k
	if q[i+1]!=q[i]:
		k+=sum(y[q[i]:q[i+1]])
ans+=k
print(ans)

"
"n = int(input())
ls = list(map(int, input().split()))
rsw = [0]*1005
for i in ls:
    rsw[i] += 1
for i in range(1,1005):
    rsw[i] = rsw[i-1] + rsw[i]
res = 0
for i in range(n):
    for j in range(i+1,n):
        a = ls[i]
        b = ls[j]
        low = abs(a-b)
        high = a+b
        tmp = rsw[min(high,1004)-1] - rsw[low]
        if low < a < high:
            tmp -= 1
        if low < b < high:
            tmp -= 1
        res += tmp
print(res//3)"
"X = input()
ans = len(X)
c = 0

for x in X:
    if x == 'S':
        c += 1
    else:
        if c > 0:
            ans -= 2
            c -= 1
print(ans)"
"import sys
input = sys.stdin.readline

def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))

def main():
    mod=10**9+7
    N=I()
    A=LI()
    cnt=0
    now=1
    
    for i in range(N):
        if A[i]==now:
            now+=1
        else:
            cnt+=1
            
    if cnt==N:
        cnt=-1
    print(cnt)
        

main()
"
"from collections import deque

n,m = map(int,input().split())


grafo = [[] for i in range(n+1)]

num_adj = [0] * (n+1)

for i in range(m):
    u, v = map(int,input().split())
    grafo[u].append(v)
    num_adj[v] += 1

q = deque()

for i in range(1, n+1):
    if num_adj[i] == 0:
        q.append(i)

dp = [0] * (n + 1)

while q:
    n = q.popleft()
    for s in grafo[n]:
        num_adj[s] -= 1

        if num_adj[s] == 0:
            q.append(s)
            dp[s] = dp[n] + 1

print(max(dp))
"
"import sys
input = sys.stdin.readline

a, b = map(int, input().split())
print(""Even"" if (a*b) % 2 == 0 else ""Odd"")"
"import datetime as dt
S=input()
s=dt.datetime.strptime(S,'%Y/%m/%d')
A='2019/04/30'
a=dt.datetime.strptime(A,'%Y/%m/%d')
if s<=a:
    print('Heisei')
else:
    print('TBD')
"
"N, M = map(int, input().split())
task = []
for i in range(1, M + 1):
    task.append(""A_"" + str(i))

task = map(int, input().split())
task_total = sum(task)

if task_total <= N:
    print(N - task_total)

else:
    print(-1)
"
"n = int(input())
a_lst = list(map(int, input().split()))
a_lst.sort()

if a_lst[0] == 0:
    answer = 0
else:
    answer = 1
    for i in range(n):
        a = a_lst[i]
        answer *= a

        if answer > 10 ** 18:
            answer = -1
            break

print(answer)"
"node = set([1,2,3,4])
for _ in range(3):
  a,b = map(int,input().split())
  node = node.intersection(set([a,b]))
  
print('NO' if len(node) else 'YES')"
"n = int(input())
X = [list(input().split()) for i in range(n)]

ans = 0
for i in range(len(X)):
  if X[i][1] == ""JPY"":
    ans += float(X[i][0])
  else:
    ans += 380000.0 * float(X[i][0])
    
print(ans)"
"n,q = map(int, input().split())
s=input()
a=[0]*n
for i in range(1,n):
    a[i]+=a[i-1]
    if s[i-1]=='A' and s[i]=='C':
        a[i]+=1
for i in range(q):
    l,r=map(int, input().split())
    print(a[r-1]-a[l-1])
"
"a,b = map(int, input().split())

if abs(a-b)%2!=0: print('IMPOSSIBLE')
else: print(int((a+b)/2))"
"def examD():
    H, W, N = LI()
    ab = set()
    for _ in range(N):
        a, b = list(map(int,input().split()))
        ab.add((a-1,b-1))
    check = set()
    for c in ab:
        for i in range(-1,2):
            for j in range(-1,2):
                if 1<=c[0]+i<H-1 and 1<=c[1]+j<W-1:
                    check.add((c[0]+i,c[1]+j))
#    print(check)
#    print(ab)
    ansC = [0]*10
    for c in check:
        cur = int(0)
        for i in range(-1,2):
            for j in range(-1,2):
                if (c[0]+i,c[1]+j) in ab:
                    cur += 1
        ansC[cur] +=1
    ansC[0] = (H-2)*(W-2)-sum(ansC)
    for v in ansC:
        print(v)


import sys
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def S(): return sys.stdin.readline().strip()
mod = 10**9 + 7
inf = float('inf')

examD()
"
"n = int(input())
a = sorted(list(map(int,input().split())))
c0 = a.count(0)
ans = 'No'
if c0==n:
    ans = 'Yes'
if len(set(a))==2:
    c = a.count(a[-1])
    if c==n*2/3 and c0==n/3:
        ans = 'Yes'
if len(set(a))==3:
    s = 0
    f = True
    for i in set(a):
        s ^= i
        if a.count(i)!=n/3:
            f = False
    if f and s==0:ans='Yes'
print(ans)
"
"n,m=map(int,input().split())
a=list(map(int,input().split()))
for i in range(n):
  a[i]=a[i]*-1
import heapq
heapq.heapify(a)
for i in range(m):
  t=(heapq.heappop(a))*-1
  heapq.heappush(a,(t//2)*-1)
print(sum(a)*-1)"
"N,M = map(int,input().split())

# parent(親)
par = [i for i in range(N+1)]
# rank(深さ)
rank = [0 for i in range(N+1)]
# 同グループの頂点数
size = [1 for i in range(N+1)]

# 木の根を求める
def root(x):
    if par[x] == x:             # 根の時
        return x
    else:
        par[x] = root(par[x])   # 経路圧縮
        return par[x]

# xとyの属する集合を併合(ランク有)
def unite(x,y):
    x = root(x)
    y = root(y)
    if x == y:
        return
    if rank[x] < rank[y]:
        par[x] = y              # xの親をyに
        size[y] += size[x]      # yの頂点数+=xの頂点数
    else:
        par[y] = x              # yの親をxに
        size[x] += size[y]      # xの頂点数+=yの頂点数
        if rank[x] == rank[y]:
            rank[x] += 1

for _ in range(M):
    x,y,z = map(int,input().split())
    unite(x,y)
ans = 0
for i in range(1,N+1):
    if par[i] == i:
        ans += 1
print(ans)"
"#ABC080B
n = input()
print(""Yes"" if int(n) %sum(map(int,n)) == 0 else ""No"")"
"S = input()
stack = []
cnt = 0
for s in S:
    if not stack:
        stack.append(s)
    elif stack[-1] != s:
        stack.pop()
        cnt += 2
    else:
        stack.append(s)
print(cnt)"
"if __name__ == ""__main__"":
    a, b, c, d = map(int, input().split())

    if abs(a-b) <= d and abs(b-c) <= d:
        print('Yes')
    elif abs(a-c) <= d:
        print('Yes')
    else:
        print('No')
"
"S = input()
ret = 0
for i in range(len(S)):
    for j in range(i, len(S)):
        f = True
        for k in S[i:j + 1]:
            if k not in (""ACGT""):
                f = False
                break
        if f:
            ret = max(ret, (j + 1) - i)
print(ret)"
"def main():
    n, x, t = map(int, input().split())
    print(((n-1)//x+1)*t)


main()
"
"def main():
    N = int(input())
    MOD = 10**9 + 7
    memo = [{} for i in range(N+1)]

    def is_ok(last4):
        for i in range(4):
            t = list(last4)
            if i >= 1:
                t[i-1], t[i] = t[i], t[i-1]
            if """".join(t).count(""AGC"") >= 1:
                return False
        return True

    def dfs(cur, last3):
        if last3 in memo[cur]:
            return memo[cur][last3]
        if cur == N:
            return 1
        ret = 0
        for c in ""AGCT"":
            if is_ok(last3 + c):
                ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD
        memo[cur][last3] = ret
        return ret

    print(dfs(0, ""TTT""))


if __name__ == '__main__':
    main()
"
"n, k = map(int, input().split());
if n % k == 0: print(0)
else: print(1)"
"N = int(input())
A = list(map(int, input().split()))

b = 0
for a in A:
    b ^= a
for a in A:
    print(b^a, end="" "")
print("""")
"
"def main():
    n, m, c = map(int, input().split())
    b_lst = list(map(int, input().split()))
    a_lst = [0] * n
    for i in range(n):
        a_lst[i] = list(map(int, input().split()))

    count = 0
    for i in range(n):
        ab = 0
        for j in range(m):
            ab += a_lst[i][j] * b_lst[j]
        abc = ab + c

        if abc > 0:
            count += 1

    print(count)


if __name__ == '__main__':
    main()"
"import bisect
import collections
import functools
import heapq
import math
from collections import deque
from collections import defaultdict
MOD = 10**9+7

N = int(input())
A = [0]*N
B = [0]*N
C = [[0]*2 for _ in range(N)]
zero = 0
no_inf = 0
inf = 0
for i in range(N):
    A[i],B[i] = map(int,(input().split()))
    if A[i] == 0 and B[i] == 0:
        C[i] = (0,0)
        zero += 1
    elif A[i] == 0:
        C[i] = (0,0)
        no_inf += 1
    elif B[i] == 0:
        C[i] = (0,0)
        inf += 1
    elif B[i] > 0:
        g = math.gcd(A[i],B[i])
        C[i] = (A[i]//g,B[i]//g)
    else:
        g = math.gcd(A[i],B[i])
        C[i] = (-A[i]//g,-B[i]//g)

d = defaultdict(int)

for i in range(N):
    if C[i] != (0,0):
        d[C[i]] += 1

ans = 1
for k in d.keys():
    if k[0] > 0:
        if (-k[1],k[0]) in d:
            ans *= pow(2,d[k],MOD) + pow(2,d[(-k[1],k[0])],MOD) -1
            d[k],d[(-k[1],k[0])] = 0,0
        else:
            ans *= pow(2,d[k],MOD)
    else:
        if (k[1],-k[0]) in d:
            ans *= pow(2,d[k],MOD) + pow(2,d[(k[1],-k[0])],MOD) -1
            d[k],d[(k[1],-k[0])] = 0,0
        else:
            ans *= pow(2,d[k],MOD)

ans *= pow(2,no_inf,MOD) + pow(2,inf,MOD) -1
print((ans+zero-1)%MOD)"
"import sys
import numpy as np
from collections import deque,defaultdict

inp=lambda v,w:v[0]*w[0]+v[1]*w[1]
isprop = lambda a,b: a[0]*b[1]==a[1]*b[0]
cwsum = lambda l:[sum([x[0] for x in l]), sum([x[1] for x in l])]
chmin = lambda a,b:(a,b)[b<a]
# cwsum = lambda l:np.sum(l,axis=0)
            
def main():
    N,Ma,Mb=map(int,input().split())
    infty=10**9
    ch=[list(map(int,input().split())) for _ in range(N)]
    p=[(-1)*Mb,Ma]
    # cand=[v[2] for v in ch if inp(p,v[:2])==0]
    # if cand:
        # m1=min(cand)
    # else:
        # m1=infty
    # ncand=[v for v in ch if inp(p,v[:2])!=0] #p方向への射影
    pch=[[inp(v[:2],p),v[2]] for v in ch]
    X=N*max([abs(w[0]) for w in pch])
    dp=[[infty]*(2*X+1) for _ in range(N)]
    for i in range(N):
        for j in range(2*X+1):
            if i==0 and j==X+pch[0][0]:
                dp[i][j]=pch[0][1]
            elif i>0 and j==X+pch[i][0]:
                dp[i][j]=chmin(dp[i-1][j],pch[i][1])
            elif i>0 and j>=pch[i][0] and j<=2*X+pch[i][0]:
                dp[i][j]=chmin(dp[i-1][j],dp[i-1][j-pch[i][0]]+pch[i][1])
            elif i>0:
                dp[i][j]=dp[i-1][j]
    #  print(ch)
    #  print(pch)
    #  print(dp)
    if dp[N-1][X]==infty:
        print(-1)
    else:
        print(dp[N-1][X])

if __name__=='__main__':
    main()
"
"import math
#import numpy as np
import queue
from collections import deque,defaultdict
import heapq
from sys import stdin,setrecursionlimit
#from scipy.sparse.csgraph import dijkstra
#from scipy.sparse import csr_matrix
ipt = stdin.readline
setrecursionlimit(10**7)

def main():
    h,w,a,b = map(int,ipt().split())
    mod = 10**9+7

    #nCrをmodで割った余りを求める。Nに最大値を入れて使用。
    N = 2*10**5
    g1 = [1, 1] # 元テーブル
    g2 = [1, 1] #逆元テーブル
    inverse = [0, 1] #逆元テーブル計算用テーブル
    def cmb(n,r,mod):
        if r<0 or r>n :
            return 0
        r = min(r,n-r)
        return g1[n]*g2[r]*g2[n-r]%mod
    for i in range(2,N+1):
        g1.append((g1[-1]*i)%mod)
        inverse.append((-inverse[mod % i]*(mod//i))%mod)
        g2.append((g2[-1]*inverse[-1])%mod)

    ans = cmb(h+w-2,h-1,mod)
    for i in range(max(a,b)):
        ans = (ans-cmb(b+h-a-1,b-1-i,mod)*cmb(a+w-b-1,a-1-i,mod)%mod)%mod
    print(ans)



    return

if __name__ == '__main__':
    main()
"
"# C - K-th Substring

s = str(input())
K = int(input())

str_list = set()
for i in range(len(s)+1):
    for j in range(i+1, i+K+1):
        if j > len(s):
            break
        str_list.add(s[i:j])

str_list = list(str_list)
str_list.sort()
print(str_list[K-1])

"
"n = int(input())
a = 0
for i in range(n+1):
    if i%3== 0: continue
    elif i%5 == 0:continue
    elif i%3 ==0 and i %5 ==0:continue
    else: a+=i

print(a)"
"import math
A, B = list(map(int, input().split()))
ans = -1
low = math.floor(min(A//0.08, B//0.1))
hig = math.ceil(max((A+1)//0.08, (B+1)//0.1))
for i in range(low, hig):
   a = math.floor(i * 0.08)
   b = math.floor(i * 0.1)
   if A == a and B == b:
     ans = i
     break
print(ans)"
"def digit_sum(x):
    res = 0
    while x > 0:
        res += x % 10
        x //= 10
    return res


N = int(input())
ans = N
for i in range(1, N):
    A = i
    B = N - i
    ans = min(ans, digit_sum(A) + digit_sum(B))
print(ans)
"
"A, B = map(int, input().split())
ans = max(max(A, B) * 2 - 1, A + B)
print(ans)"
"N = int(input())
H = list(map(int, input().split()))
n = 0
ans = 1

for i in range(N-1):
  if H[i+1] >= H[n]:
    ans += 1
    n = i+1

print(ans)"
"a,b,m=map(int,input().split())
al=list(map(int,input().split()))
bl=list(map(int,input().split()))
xyc=[list(map(int,input().split())) for _ in range(m)]

ans=min(al)+min(bl)
for i in range(m):
    tmp=0
    tmp=al[xyc[i][0]-1]+bl[xyc[i][1]-1]-xyc[i][2]
    ans=min(ans,tmp)
print(ans)"
"import sys
from itertools import permutations

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    M, K = map(int, readline().split())

    if M == 0:
        if K == 0:
            print(0, 0)
            return
        else:
            print(-1)
            return
    elif M == 1:
        if K == 0:
            print(0, 0, 1, 1)
            return
        else:
            print(-1)
            return
    elif K >= pow(2, M):
        print(-1)
        return

    vec = [i for i in range(pow(2, M)) if i != K]
    ans = vec + [K] + vec[::-1] + [K]

    print(' '.join(map(str, ans)))
    return


if __name__ == '__main__':
    main()
"
"age = int(input().rstrip())

if age == 1:
  print('Hello World')
elif age == 2:
  print(int(input().rstrip()) + int(input().rstrip()))"
"N = 10
H, W = map(int, input().split())
g = [list(map(int, input().split())) for _ in range(N)]
A = [list(map(int, input().split())) for _ in range(H)]
for h in range(N):
    for w in range(N):
        if g[h][w] == 0:
            g[h][w] = float('inf')

for k in range(N):
    for i in range(N):
        for j in range(N):
            g[i][j] = min(g[i][j], g[i][k]+g[k][j])

ans = 0
for h in range(H):
    for w in range(W):
        if abs(A[h][w]) != 1:
            ans += g[A[h][w]][1]

print(ans)
"
"M,D= list(map(int,input().split()))
ans=0
if D < 10:
   print(0)
   exit()
for i in range(1,M+1):
   for j in range(10,D+1):
      s=str(j)
      if i == int(s[0])*int(s[1]) and int(s[0])>=2 and int(s[1])>=2:
         ans+=1
print(ans)"
"def main():
    N, K = map(int, input().split())
    x = [0] * N
    y = [0] * N

    for i in range(N):
        x[i], y[i] = map(int, input().split())

    ans = float('inf')
    for i in range(N):
        for j in range(N):
            for k in range(N):
                for l in range(N):
                    if x[i] < x[j] and y[k] < y[l]:
                        cnt = 0
                        lx = x[i]
                        rx = x[j]
                        by = y[k]
                        uy = y[l]

                        for n in range(N):
                            if lx <= x[n] and x[n] <= rx and by <= y[n] and y[n] <= uy:
                                cnt += 1

                        if cnt >= K:
                            ans = min(ans, (rx - lx) * (uy - by))

    print(ans)

main()"
"MAX = 10 ** 5
def sieve(n):
    f = [False] * (n + 1)
    res = []
    for i in range(2, n+1):
        if f[i]:
            continue
        res.append(i)
        for j in range(2 * i, n+1, i):
            f[j] = True
    return res

pn = sieve(MAX)
acc = [0] * (MAX + 1)
for p in pn:
    if p % 2 == 1 and (p + 1) // 2 in pn:
        acc[p] = 1
for i in range(2, MAX+1):
    acc[i] += acc[i-1]
Q = int(input())
for _ in range(Q):
    l, r = map(int, input().split())
    print(acc[r] - acc[l-1])
"
"n=int(input())
lst=[None]*n
for i in range(n):
    a,b,c=map(int,input().split())
    lst[i]=[a,b,c]
lst=sorted(lst,key=lambda x:x[2],reverse=True)
for i in range(101):
    for j in range(101):
        switch=0
        x,y,z=lst[0]
        height=z+abs(i-x)+abs(j-y)
        for k in range(1,n):
            x,y,z=lst[k]
            if z==0:
                if abs(i-x)+abs(j-y)<height:
                    switch=1
                    break
            elif abs(i-x)+abs(j-y)+z!=height:
                switch=1
                break
        if switch==0:
            print(i,j,height)"
"from bisect import bisect_left

S = input()
T = input()
N = len(S)
NN = len(T)
S = [ord(S[i]) - 97 for i in range(N)]
T = [ord(T[i]) - 97 for i in range(NN)]

ind = [[] for _ in range(26)]
cnt = [0] * 26
for i in range(N):
    s = S[i]
    ind[s].append(i)
    cnt[s] += 1

part = 0
i = 0
j = -1
cond = 0
while i < NN:
    obj = T[i]
    if cnt[obj] == 0:
        cond = 1
        break

    tmp = bisect_left(ind[obj], j)
    if tmp == cnt[obj]:
        j = ind[obj][0]
        part += 1
        i += 1
        continue
    if ind[obj][tmp] == j:
        tmp += 1

    if tmp == cnt[obj]:
        j = ind[obj][0]
        part += 1
    else:
        j = ind[obj][tmp]

    i += 1


if cond:
    ans = -1
else:

    ans = N * part + (j + 1)

print(ans)"
"N = int(input())
print('Yes' if sum(4 * x + 7 * y == N for x in range(N//4 + 1) for y in range(N//7 + 1)) > 0 else 'No')"
"import bisect, collections, copy, heapq, itertools, math, string, sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = float('inf')
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    S = SS()
    T = SS()
    l = len(S)
    S2 = S * 2

    ans = 'No'
    for i in range(l):
        if S2[i:i+l] == T:
            ans = 'Yes'
            break

    print(ans)

if __name__ == '__main__':
    resolve()
"
"C1 = input()
C2 = input()

C3 = C1[::-1]

if C3 == C2:
    print(""YES"")
else:
    print(""NO"")"
"month, day = map(int, input().split())
takahashi_days = month
if day >= month:
    print(takahashi_days)
elif month > day:
    print(takahashi_days -1)"
"h, w = map(int, input().split())
n = int(input())
a = list(map(int, input().split()))

color = []
for i in range(n):
    for j in range(a[i]):
        color.append(i + 1)

ans = [[0 for i in range(w)] for j in range(h)]

cnt = 0
for i in range(h):
    if i % 2 == 0:
        for j in range(w):
            ans[i][j] = color[cnt]
            cnt += 1
    else:
        for j in range(w):
            ans[i][w-1-j] = color[cnt]
            cnt += 1

for i in range(h):
    for j in range(w):
        if j == w - 1:
            print(ans[i][j])
        else:
            print(ans[i][j], end="" "")
"
"# coding: utf-8
# Your code here!
[n,x,t] = input().split()
n = int(n)
x = int(x)
t = int(t)

i = 1
while True:
    if i*x >= n:
        break
    i += 1
    
print(i*t)"
"s=input()
con=len(s)
ans=['x']*con
ANS=''
for i in ans:
    ANS+=i
print(ANS)"
"Q, H, S, D = map(int, input().split())
N = int(input()) * 4
L = [[8*Q, 1, Q], [4*H, 2, H], [2*S, 4, S], [D, 8, D]]
L.sort()
ans = 0
for l in L:
  s, t = N // l[1], N % l[1]
  ans += s * l[2]
  N = t
print(ans)"
"a, b = map(int, input().split())

if a == 1:
    a = 14

if b == 1:
    b = 14



if a < b:
    print(""Bob"")
elif b < a:
    print(""Alice"")
else:
    print(""Draw"")
"
"N = int(input())
a = list(map(int, input().split()))
Sum = 1
mod = 1000000007

a.sort()
data = []
if N % 2 == 0:
    for i in range(int(N / 2)):
        data.append(1 + i * 2)
        data.append(1 + i * 2)
else:
    data.append(0)
    for i in range(1, N // 2 + 1):
        data.append(i * 2)
        data.append(i * 2)

if a == data:
    for i in range(N // 2):
        Sum *= 2
        Sum %= mod
    print(Sum)
else:
    print(0)
"
"N = int(input())
r_list = []
for i in range(N):
  item = input().split()
  item[1] = int(item[1])
  item.insert(0, i + 1)
  r_list.append(item)

r_list.sort(key = lambda x: x[2], reverse = True)
r_list.sort(key = lambda x: x[1])
for item in r_list:
  print(item[0])"
"# https://atcoder.jp/contests/abc167/tasks/abc167_d
# コンテスト中は周期性を用いたが、今回はdoublingで解いてみる

import sys
sys.setrecursionlimit(1 << 25)
read = sys.stdin.readline
ra = range
enu = enumerate


def exit(*argv, **kwarg):
    print(*argv, **kwarg)
    sys.exit()


def mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))
# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと


def ints(): return list(map(int, read().split()))


MOD = 10**9 + 7
INF = 2**31  # 2147483648 > 10**9
# default import
from collections import defaultdict, Counter, deque
from operator import itemgetter, xor, add
from itertools import product, permutations, combinations
from bisect import bisect_left, bisect_right  # , insort_left, insort_right
from functools import reduce

N, K = ints()
A = mina(*ints())
# 10^18のは60bitで表せるのでnxt tableをつくるのに最大1.2 * 10^7 ぐらい。ギリ間に合いそう


nxt = [[-1] * N for _ in ra(K.bit_length())]  # [k][v]...vから2^k回移動したノード
# 初期化
for v, nx in enu(A):
    nxt[0][v] = nx

# テーブル埋め
for k in ra(K.bit_length() - 1):
    for v in ra(N):
        nxt[k + 1][v] = nxt[k][nxt[k][v]]

# 答えの取得
now = 0  # はじめは0地点にいる
for k in ra(K.bit_length()):
    if (K >> k) & 1:
        # kbit目が立ってたらこの回数分だけ移動
        now = nxt[k][now]
print(now + 1)
"
"import itertools
import os
import sys

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10 ** 9)
INF = float(""inf"")
IINF = 10 ** 18
MOD = 10 ** 9 + 7
# MOD = 998244353


# 色のパターン 30*29*28 == 24360
# 全部試すだけ

N, C = list(map(int, sys.stdin.buffer.readline().split()))
D = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(C)]
S = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(N)]

D = np.array(D, dtype=int)
S = np.array(S, dtype=int) - 1

md = np.zeros((N, N), dtype=int)
md += np.arange(N, dtype=int)
md += np.arange(N, dtype=int)[:, None]
md %= 3

# s += D[S[md == 0], colors[0]].sum()
# s += D[S[md == 1], colors[1]].sum()
# s += D[S[md == 2], colors[2]].sum()

# costs[d][c]: md == d の場所を c に変えるときのコスト
costs = [[0] * C for _ in range(3)]
for d in range(3):
    for c in range(C):
        # md == d の場所を c に変えるときのコスト
        costs[d][c] = D[S[md == d], c].sum()

ans = INF
for colors in itertools.permutations(range(C), r=3):
    ans = min(ans, costs[0][colors[0]] + costs[1][colors[1]] + costs[2][colors[2]])
print(ans)
"
"r, c = map(int, input().split())
arr = []
for i in range(r):
    arr.append(list(map(int, input().split())))

for line in arr:
    line.append(sum(line))
    
arr.append([sum([line[i] for line in arr]) for i in range(c  + 1)])

for line in arr:
    print(*line)"
"n, k = map(int, input().split())
lst = list(map(int, input().split()))

dp = [0] * (k+1) #dp[i]は石の数が残りi個のときに手番プレイヤーが勝利できるか

for i in range(1, k+1):
    flg = 0
    for j in lst:
        if i - j >= 0:
            if not dp[i-j]: #一度でも0(False)があればflg1(True)
                flg = 1
                break
    if flg:
        dp[i] = 1
            
if dp[k]:
    print('First')
else:
    print('Second')"
"s = input()
ints = [ord(i) - ord('a') for i in s]
K = int(input())
n = len(s)
i = 0
while i < n:
    if ints[i] != 0 and 25 - ints[i] + 1 <= K:
        K -= 25 - ints[i] + 1
        ints[i] = 0
    i += 1

K %= 26
ints[-1] = (ints[-1] + K) % 26
s_ = ''
for i in ints:
    s_ += chr(i + ord('a'))

print(s_)
"
"SX,SY,TX,TY=map(int,input().split())
x=TX-SX
y=TY-SY
print(''.join(['U'*y,'R'*x,'D'*y,'L'*x,'L','U'*(y+1),'R'*(x+1),'D','R','D'*(y+1),'L'*(x+1),'U']))"
"import sys

k,s = map(int,sys.stdin.readline().split(' '))

result = 0

for x in range(k+1):
    for y in range(min(s-x+1,k+1)):
        if (s-x-y)<=k:
            result+=1
        
print(result)"
"a,b=input().split()
a=int(a)
b=int(b)
c=list(map(int,input().split()))
d=0
e=0
for i in range(a):
  if d+c[i]<=b:
    d=d+c[i]
    e=e+1
  else:
    break
print(e+1)"
"while(1):
	num = list(map(int,input()))
	
	if num[0] == 0:
		break
	print(sum(num[:]))"
"n=int(input())
p=list(map(int,input().split()))
m=0
d=[0]*n
t=set()
for i in range(n):
    if p[i]==i+1:
        d[i]=i+1
        m+=1
    if i!=0 and d[i]==1+d[i-1] and i-1 not in t:
        t.add(i)
print(m-len(t))"
"import sys
import heapq
import math


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())

    l = ""A""
    s = set()

    for i in range(N):

        w = input()
        if w[0] != l and i!=0:
            print(""No"")
            exit()
        if w in s:
            print(""No"")
            exit()
        l = w[-1]
        s.add(w)

    print(""Yes"")


if __name__ == ""__main__"":
    main()
"
"import sys
def MI(): return map(int,sys.stdin.readline().rstrip().split())

a,b,c = MI()

if c < a+b:
    print('No')
else:
    print('Yes' if 4*a*b < (c-a-b)**2 else 'No')
"
"n = int(input())
a = list(map(int, input().split()))

s = 0
for x in a:
    k = 0
    while x % 2 == 0:
        k += 1
        x //= 2
    s += k

print(s)"
"# coding:utf-8
x = int(input())
r = 0
for k in range(360):
    r += x
    if r % 360 == 0:
        break
print(k + 1)
"
"a,b=map(int,input().split())
if abs(a-b) > 1:
  print(':(')
else:print('Yay!')"
"N=int(input())
A=[int(i) for i in input().split()]
S=0
for i in range(1,N):
    if A[i-1]>A[i]:
        S+=A[i-1]-A[i]
        A[i]=A[i-1]
print(S)"
"from math import *
from decimal import *
a,b,c=map(int,input().split())
if 4*a*b<(c-a-b)**2 and c-a-b>0:
    print(""Yes"")
else:
    print(""No"")"
"# import math
# import decimal
# import queue
# import bisect
# import heapq
# import time
# import itertools

mod = int(1e9+7)

def main():
    n = list(map(int,input().split()))
    n.sort()
    if n[0] == 1 and n[1] == 4 and n[2] == 7 and n[3] == 9:
        print('YES')
    else:
        print('NO')
    return

if __name__=='__main__':
    main()
"
"N = int(input())
cost = 800 * N
cnt = N // 15 * 200
print(cost - cnt)"
"import sys
input = sys.stdin.readline
N, M = map(int, input().split())
A = [0]*M
B = [0]*M
C = [0]*M
for i in range(M):
    A[i], B[i] = map(int, input().split())
    for c in [int(i) for i in input().split()]:
        C[i] |= 1 << (c - 1)

dp = [[float(""inf"")] * 2 ** N for _ in range(2)]
dp[0][0] = 0
for i, c in enumerate(C):
    for bit in range(2 ** N):
        if c & bit == bit:
            dp[1][bit] = min(dp[1][bit], dp[0][bit], A[i])
        else:
            dp[1][bit] = min(dp[1][bit], dp[0][bit])
        dp[1][c | bit] = min(dp[0][c | bit], dp[0][bit] + A[i], dp[1][c | bit])
    dp[0], dp[1] = dp[1], dp[0]
print(dp[0][-1] if dp[0][-1] < float(""inf"") else - 1)"
"h, w, a, b = map(int, input().split())
for i in range(h):
  s = [0]*a+[1]*(w-a)
  t = [1]*a+[0]*(w-a)
  if i < b:
    print("""".join(map(str, s)))
  else:
    print("""".join(map(str, t)))"
"n=int(input())
x,y=0,0
t=0
for i in range(n):
    T,X,Y=map(int,input().split())
    if((T-t)>=(abs(X-x)+abs(Y-y)) and (T-t)%2==(abs(x-X)+abs(Y-y))%2):
        x=X
        y=Y
        t=T
    else:
        print(""No"")
        exit()
print(""Yes"")
"
"# https://atcoder.jp/contests/abc103/tasks/abc103_d

import sys
input = sys.stdin.readline

N, M = map(int, input().split())
schedule = []
for i in range(M):
    start, end = map(int, input().split())
    schedule.append((start, end))               # schedule = (始点、終点)

schedule = sorted(schedule, key=lambda x: x[1])
ans = 0
end = -10**12                                   # 始点の最小値

for i in range(M):
    if end <= schedule[i][0]:                   # 重複が OK ならば等号を加える
        end = schedule[i][1]                    # 終点でソートされているので、自動的に可能な中で最速の終点が選ばれている
        ans += 1

print(ans)"
"H,W = map(int, input().split())
s = [input() for _ in range(H)]

import sys
for j in range(1,H-1):
    for i in range(1,W-1):
        if s[j][i] =='#':
            if s[j][i-1] == '#':
                pass
            elif s[j-1][i] == '#':
                pass
            elif s[j][i+1] == '#':
                pass
            elif s[j+1][i] == '#':
                pass
            else:
                print('No')
                sys.exit()
print('Yes')
"
"import itertools
import os
import sys

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(2147483647)
INF = float(""inf"")
IINF = 10 ** 18

H, W, N = list(map(int, sys.stdin.readline().split()))
AB = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]

hist = set()


def count(h, w):
    ret = 0
    for dh, dw in itertools.product([-1, 0, 1], repeat=2):
        ret += (h + dh, w + dw) in hist
    return ret


def ok(a=1, b=1):
    return 1 < a < H and 1 < b < W


ans = [0] * 10
ans[0] = (H - 2) * (W - 2)
for a, b in AB:
    hist.add((a, b))
    for dh, dw in itertools.product([-1, 0, 1], repeat=2):
        if not ok(a + dh, b + dw):
            continue
        c = count(a + dh, b + dw)
        ans[c] += 1
        ans[c - 1] -= 1
print('\n'.join(map(str, ans)))
"
"A=list()
B=list()
n,m=map(int,input().split())
if m==0:
  print([0, 10, 100][n - 1])
  exit()
for i in range(m):
  a,b=map(int,input().split())
  A.append(a)
  B.append(b)
  if a==1 and b==0 and n!=1:
    print(-1)
    exit()
for i in range(1000):
  c=str(i)
  if len(c)==n:
    for j in range(m):
      if c[A[j]-1]!=str(B[j]):
        break
      if j==m-1:
        print(i)
        exit()
print(-1)"
"from collections import Counter
N=int(input())
S=input()
mod = 10**9+7
d = Counter(S)
ans = 0
for i in S:
    tmp = 1
    d[i] -=1
    for k,v in d.items():
        if i!=k and v:
            tmp *=(v+1)
            tmp%=mod
    ans += tmp
    ans %=mod
print(ans)"
"S = input()

n = S.count('N')
s = S.count('S')
w = S.count('W')
e = S.count('E')
d = 0
if n > 0:
  d += 1
if s > 0:
  d -= 1
if w > 0:
  d += 2
if e > 0:
  d -= 2
  
if d == 0:
  ans = 'Yes'
else:
  ans = 'No'

print(ans)"
"#!/usr/bin/env python3
import math
n = int(input())
print(int(n/2) * math.ceil(n/2))"
"import math
n=int(input())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
a=[1,2,3,4]
for i in a:
	num=0
	if i==1:
		for j in range(len(x)):
			num+=abs(x[j]-y[j])
		print(num)
			
	elif i==2 or i==3:
		for j in range(len(x)):
			num+=(abs(x[j]-y[j]))**i
		num=math.pow(num,1/i)
		print(num)
	
	else:
		b=[]
		for j in range(len(x)):
			b.append(abs(x[j]-y[j]))
		print(float(max(b)))
		
	
			
		
		
"
"A, B =  map(int, input().split())
print(max(A-B, 0))"
"s=input()
n=len(s)
if n>9 or n<5:
    print(""NO"")
else:
    ans=""NO""
    if n==5:
        if s==""KIHBR"":
            ans=""YES""
    elif n==6:
        if s==""AKIHBR"" or s==""KIHABR"" or s==""KIHBAR"" or s==""KIHBRA"":
            ans=""YES""
    elif n==7:
        if s==""AKIHABR"" or s==""AKIHBAR"" or s==""AKIHBRA"" or s==""KIHABAR"" or s==""KIHABRA"" or s==""KIHBARA"":
            ans=""YES""
    elif n==8:
        if s==""KIHABARA"" or s==""AKIHBARA"" or s==""AKIHABRA"" or s==""AKIHABAR"":
            ans=""YES""
    else:
        if s==""AKIHABARA"":
            ans=""YES""
    print(ans)
"
"a, b, c = map(int, input().strip().split())

if a % 2 == 0 or b % 2 == 0 or c % 2 == 0:
    print(0)
else:
    ans = min([a * b, b * c, c * a])
    print(ans)
"
"A, B, M = map(int, input().split())
an = list(map(int, input().split()))
bn = list(map(int, input().split()))
ans = min(an)+min(bn)
for i in range(M):
    x, y, c = map(int, input().split())
    ans = min(ans, an[x-1] + bn[y-1] - c)
print(ans)
"
"S = input()
ans = S.count('+') - S.count('-')
print(ans)"
"import sys

sys.setrecursionlimit(10**7)
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #空白あり
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #空白なし
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())  #空白あり
def LS2(): return list(sys.stdin.readline().rstrip())  #空白なし


N,R = MI()
print(R if N >= 10 else R+100*(10-N))
"
"K = int(input())
S = str(input())

SK = S[0: (K)]

if len(S) <= K:
    print(S)
else:
    print(SK + '...')"
"n = int(input())
md = {'M':0, 'A':0 , 'R':0, 'C':0, 'H':0}
for _ in range(n):
    s = input()
    if s[0] in md:
        md[s[0]] += 1

vs = []
for v in md.values():
    vs.append(v)

ans = 0
for i in range(5):
    for j in range(i+1,5):
        for k in range(j+1,5):
            ans += vs[i]*vs[j]*vs[k]

print(ans)"
"import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
def main():
    N,M=mi()

    def divisors(n):
        res = []
        for i in range(1, int(n**0.5)+1):
            if n % i == 0:
                res.append(i)
                if i != n // i:
                    res.append(n//i)

        return res

    D = divisors(M)
    ans = 1
    for d in D:
        X = M // d
        if X-N+1 > 0:
            ans = max(ans,d)
    
    print(ans)




if __name__ == ""__main__"":
    main()"
"import sys
import itertools
# import numpy as np
import time
import math
from heapq import heappop, heappush
from collections import defaultdict
from collections import Counter
from collections import deque
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())
N, M, L = map(int, input().split())
dist = [[INF] * N for _ in range(N)]
for i in range(M):
    a, b, c = map(int, input().split())
    if c > L:
        continue
    a -= 1
    b -= 1
    dist[a][b] = c
    dist[b][a] = c
Q = int(input())

for k in range(N):
    for i in range(N):
        for j in range(N):
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
fuel = [[INF] * N for _ in range(N)]
for i in range(N):
    for j in range(N):
        fuel[i][j] = 1 if dist[i][j] <= L else INF
for k in range(N):
    for i in range(N):
        for j in range(N):
            if fuel[i][j] > fuel[i][k] + fuel[k][j]:
                fuel[i][j] = fuel[i][k] + fuel[k][j]
for i in range(Q):
    s,t = map(int, input().split())
    if fuel[s - 1][t - 1] != INF:
        print(fuel[s - 1][t - 1] - 1)
    else:
        print(-1)"
"
import numpy as np
from scipy.sparse.csgraph import floyd_warshall
from scipy.sparse import csr_matrix
def resolve():
    INF = 10 ** 18
    N, M, L = map(int, input().split())
    G = [[INF] * N for _ in range(N)]
    for _ in range(M):
        a, b, c = map(int, input().split())
        a -= 1
        b -= 1
        G[a][b] = G[b][a] = c

    G = csr_matrix(G)
    dist = floyd_warshall(G, directed=False)

    G2 = np.full((N, N), np.inf)  # 値をINFにした配列
    np.fill_diagonal(G2, 0)  # G[i][i]は動いていない状態なのでコスト0
    G2[dist <= L] = 1

    dist2 = floyd_warshall(G2, directed=False)

    Q = int(input())
    for _ in range(Q):
        a, b = map(lambda x: int(x) - 1, input().split())
        if dist2[a][b] == np.inf:
            print(-1)
        else:
            print(int(dist2[a][b]) - 1)


if __name__ == ""__main__"":
    resolve()
"
"a,b,c=map(int,input().split());print(['No','Yes'][max(a,b,c)==((a+b+c)-max(a,b,c))])"
"import sys
sys.setrecursionlimit(10**6)
n, m = map(int, input().split())
xy = []
for _ in range(m):
    x, y, _ = map(int, input().split())
    xy.append((x-1, y-1))

class UnionFind():
    def __init__(self, n):
        self.li = list(range(n))
    def root(self, x):
        if self.li[x]==x:
            return x
        self.li[x] = self.root(self.li[x])
        return self.li[x]
    def unite(self, x, y):
        rx = self.root(x)
        ry = self.root(y)
        if rx==ry:
            return
        self.li[ry] = rx
    def same(self, x, y):
        return self.root(x)==self.root(y)

uf = UnionFind(n)
for x, y in xy:
    uf.unite(x, y)
for i in range(n):
    uf.root(i)
print(len(set(uf.li)))"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
b=[0]*n
c=[0]*n
cnt=0
while cnt<min(k,101):
  cnt+=1
  for i in range(n):
    b[max(0,i-a[i])]+=1
    if i+a[i]<n-1:
      b[i+a[i]+1]-=1
    c[0]=b[0]
  for j in range(n-1):
    c[j+1]=c[j]+b[j+1]
  a=c
  b=[0]*n
  c=[0]*n
print(*a)"
"import numpy as np
n,*a = map(int,open(0).read().split())
a = np.array(a)
mod = 10**9+7
ans = 0
for i in range(61):
  b = np.count_nonzero(a>>i&1)
  ans += b*(n-b)*1<<i
print(ans%mod)"
"S=input()
T=input()
from collections import*
cs=Counter(S)
ct=Counter(T)
csv=sorted(cs.values())
ctv=sorted(ct.values())
print('YNeos'[csv!=ctv::2])"
"from itertools import accumulate, tee


def pairwise(iterable):
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)


a, b = map(int, input().split())

towers = list(accumulate(range(1, 1000)))

for p, n in pairwise(towers):
    if n - p == b - a:
        print(p - a)
        break
"
"A, B, C, D = int(input()), int(input()), int(input()), int(input())
fare = 0
if A <= B : fare += A
else : fare += B
if C <= D : fare += C
else : fare += D
print(fare)"
"# -*- coding: utf-8 -*-
import sys
from collections import deque, defaultdict
from math import sqrt, factorial
# def input(): return sys.stdin.readline()[:-1] # warning not \n
# def input(): return sys.stdin.buffer.readline().strip() # warning bytes
# def input(): return sys.stdin.buffer.readline().decode('utf-8')


def solve():
    n, m = [int(x) for x in input().split()]
    a = [int(x) for x in input().split()]
    a.sort()
    ans = a[-1] - a[0]
    b = []
    for i in range(m-1):
        b.append(a[i+1] - a[i])
    b.sort(reverse=True)
    for i in range(min(len(b), n-1)):
        ans -= b[i]
    print(ans)
        

t = 1
# t = int(input())
for case in range(1,t+1):
    ans = solve()


""""""


""""""
"
"import sys
input=sys.stdin.readline

n,k=map(int,input().split())
h=list(map(int,input().split()))

dp=[None]*n
dp[0]=0
dp[1]=abs(h[1]-h[0])

for i in range(2,n):
    kouho=[]
    for j in range(1,k+1):
        if i-j>=0:
            kouho.append(dp[i-j]+abs(h[i-j]-h[i]))
    dp[i]=min(kouho)

print(dp[-1])"
"import math
from math import gcd
INF = float(""inf"")

import sys
input=sys.stdin.readline
import itertools
from collections import Counter

def main():
    n = int(input())
    p = list(map(int, input().split()))
    min = p[0]
    cnt = 0
    for i in p:
        if i <= min:
            cnt += 1
            min = i
        else:
            pass
    print(cnt)


if __name__==""__main__"":
    main()
"
"N, K, C = map(int, input().split())
S = input()

L = [0]*K
R = [0]*K
lpiv = 0
rpiv = N-1
for i in range(K):
    while S[lpiv] == 'x':
        lpiv += 1
    while S[rpiv] == 'x':
        rpiv -= 1
    L[i] = lpiv
    R[i] = rpiv
    lpiv += C+1
    rpiv -= C+1

ans = 0
for i in range(K):
    if L[i]==R[K-i-1]:
        print(L[i]+1)
"
"from collections import defaultdict
import itertools
d = defaultdict(int)
x='MARCH'
for i in range(5):
  d[x[i]]=i+1
x=[0]*5
N=int(input())
for i in range(N):
  S=input()
  a=d[S[0]]
  if a>0:
    x[a-1]+=1
ans=0
for i,j,k in itertools.combinations([i for i in range(5)], 3):
  ans+=x[i]*x[j]*x[k]
print(ans)"
"n,x=[int(x) for x in input().split()]
l=[int(x) for x in input().split()]
d=0
cnt=1
for i in range(n):
  d=d+l[i]
  if d<=x:
    cnt+=1
print(cnt)"
"def solve(m, A):
    if A[0] == m: return True
    if len(A)==1: return False
    if m < A[0] : return solve(m, A[1:])
    if solve(m-A[0], A[1:]):
        return True
    return solve(m, A[1:])

if __name__=='__main__':
    n=int(input()) 
    A=list(map(int,input().split()))
    q=int(input()) 
    Q=list(map(int,input().split()))
    for m in Q:
        if   m > sum(A): print('no')
        elif solve(m,A): print('yes') 
        else           : print('no') "
"def main():
    N = int(input())
    X = []
    Y = []

    for _ in range(N):
        x, y = (int(i) for i in input().split())
        X.append(x + y)
        Y.append(x - y)

    ans = max(max(X) - min(X), max(Y) - min(Y))
    print(ans)


if __name__ == '__main__':
    main()
"
"w, a, b = map(int, input().split())
if a <= b:
    print(b - w - a if b - w - a > 0 else 0)
else :
    print(a - w - b if a - w - b > 0 else 0)"
"# https://atcoder.jp/contests/abc163/tasks/abc163_b

n, m = map(int, input().split())
a = list(map(int, input().split()))
day = sum(a)
if day <= n:
    print(n-day)
else:
    print('-1')"
"#グラフのパスを全探索する関数(再帰)
def dfs(now_node, depth):#deptt:今まで列挙した頂点数
    if seen[now_node]:#探索済みであった場合はreturn
        return 0
    if depth == N:#全ての頂点を通っていた場合、1を返す
        return 1
    seen[now_node] = True  #今から探索するノードを探索済みにする
    connect_nodes = graph[now_node]
    ans = 0
    for node in connect_nodes:#全ての遷移先をチェックする
        ans += dfs(node, depth+1)
    seen[now_node] = False  # 探索済みフラグを折る(ポイント)
    return ans

N, M = map(int, input().split())
edges = [list(map(int, input().split())) for i in range(M)]#辺の集合
graph =[[] for i in range(N+1)]#隣接リスト
for edge in edges:
    graph[edge[0]].append(edge[1])
    graph[edge[1]].append(edge[0])

#訪問済みかどうかを表すリストを用意
seen = [False for i in range(N+1)]
seen[0] = True

print(dfs(1, 1))"
"N, A, B = map(int, input().split())
x = tuple(map(int, input().split()))
k = B//A

res = 0
for i in range(N-1):
    if x[i+1]-x[i] > k:
        res += B
    else:
        res += (x[i+1]-x[i])*A
print(res)"
"N = input()
print(['No','Yes'][N==N[::-1]])"
"N=int(input())
H=list(map(int,input().split()))
count=0
maxcount=[0]*N
for i in range(N-1):
  if(H[i]>=H[i+1]):
    count+=1
  else:
    count=0
  maxcount[i]=count

print(max(maxcount))"
"n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]


def match2int(x, y):
    x, y = min(x, y), max(x, y)
    return (2 * n - 1 - x) * x // 2 + y - x - 1


match_sm = n * (n - 1) // 2

adj = [[] for _ in range(match_sm)]
in_deg = [0] * match_sm
for i, li in enumerate(a):
    for j, k in zip(li, li[1:]):
        j -= 1
        k -= 1
        match1 = match2int(i, j)
        match2 = match2int(i, k)
        adj[match1].append(match2)
        in_deg[match2] += 1

cnd = [i for i, e in enumerate(in_deg) if e == 0]
day = 0
while cnd:
    nxt_cnd = []
    for u in cnd:
        for v in adj[u]:
            in_deg[v] -= 1
            if in_deg[v] == 0:
                nxt_cnd.append(v)

    cnd = nxt_cnd
    day += 1

if in_deg.count(0) != match_sm:
    day = -1

print(day)
"
"import math


def abs(num):
    if num < 0:
        return -num
    return num


def main():
    abhm = [int(_x) for _x in input().split()]
    HL = abhm[0]
    ML = abhm[1]
    H = abhm[2]
    M = abhm[3]

    radian = 2.0 * math.pi * abs(M / 60.0 - (H + M / 60.0) / 12.0)

    length = math.sqrt(HL * HL + ML * ML - 2 * HL * ML * math.cos(radian))
    print(length)


main()
"
"w, h, n = map(int, input().split())
x1 = [0]
x2 = [w]
y1 = [0]
y2 = [h]

for i in range(n):
  x, y, a = map(int, input().split())
  if a == 1:
    x1.append(x)
  elif a == 2:
    x2.append(x)
  elif a == 3:
    y1.append(y)
  elif a == 4:
    y2.append(y)

left = max(x1)
right = min(x2)
bottom = max(y1)
top = min(y2)

ans =max(0, right - left)*max(0, top - bottom)
print(ans)"
"n = int(input())

amari = 0
made = 0
cnt = 0
for i in range(1, n+1):
    cnt += i
    if cnt >= n:
        made = i
        amari = cnt - n
        break

ans = []
for i in range(1, made+1):
    if i == amari:
        continue
    ans.append(str(i))
print(""\n"".join(ans))
"
"n, *aa = map(int, open(0).read().split())

from collections import Counter

ans = 0

for k, count in Counter(aa).items():
    if count<k:
        ans += count
    else:
        ans += count-k

print(ans)"
"def blackarea(n , a):

    return n * n - a

def main():
    n = int(input())
    a = int(input())
    print(blackarea(n , a))

if __name__ == '__main__':
    main()"
"N = int(input())
*A, = map(int, input().split())
a = set(A)
print(len(a)-(1-len(a)%2))"
"N=int(input())
N_26=[]

while N>0:
    N-=1
    N_mod=N%26
    N=N//26
    N_26.append(chr(97+N_mod))
print("""".join(list(reversed(N_26))))
"
"a, b = (int(x) for x in input().split())
if a % 3 == 0 or b % 3 == 0 or (a + b) % 3 == 0:
    print('Possible')
else:
    print('Impossible')
"
"a,b,c = map(int,input().split())
if (a==b and a==c and b==c) or (a!=b and b!=c and a!=c):
  print(""No"")
else:
  print(""Yes"")"
"while True:
    h,w = map(int,raw_input().split())
    if h==0 and w==0:
        break
    sside="""" #square side
    inside=""""
    for x in xrange(1,w+1):
        sside += ""#""
        if x==1 or x==w:
            inside += ""#""
        else:
            inside += "".""
    for x in xrange(1,h+1):
        if x==1 or x==h:
            print sside
        else:
            print inside
    print"
"A,B=map(int,input().split(' '))
S=input()
if S[A] == '-' and all(c in '0123456789' for c in S[:A]) and all(c in '0123456789' for c in S[A+1:]):
  print('Yes')
else:
  print('No')"
"r, D, x_2000 = map(int, input().split())

x = [x_2000] * 11

for i in range(10):
  x[i+1] = r * x[i] - D
  
print(*x[1:], sep='\n')"
"def main():
 n,k = map(int,input().split())
 if n % k == 0:
     print(0)
 else:
     print(1)
main()"
"n,k=map(int,input().split())
l=sorted([int(s) for s in input().split()])
print(sum(l[k*(-1):]))"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

n,k = map(int,readline().split())
ans = 0
if k == 0:
    print(n**2)
    exit()
for b in range(1,n+1):
    if b <= k:
        continue
    #a=nとして考えて良い。
    ans += n//b*(b-k)
    ans += max(0,n%b-(k-1))

print(ans)


"
"import collections
n,k=map(int,input().split())
a=list(map(int,input().split()))
m=[0]
for i in range(n):
  m.append((m[-1]+a[i]))
for i in range(n+1):
  m[i]-=i
  m[i]%=k

ans=0
dict=collections.defaultdict(int)
for i in range(1,n+1):
  x=m[i]
  if i<=k-1:
    dict[m[i-1]]+=1
  else:
    dict[m[i-1]]+=1
    dict[m[i-k]]-=1
  ans+=dict[x]
print(ans)"
"N = int(input())

# A*B=Nとなるような1以上9以下の整数(A, B)が存在するかどうか全探索を行う
ans = 'No'
for i in range(1, 10):
  for j in range(1, 10):
    if i*j == N:
      ans = 'Yes'
      break
      
print(ans)"
"import math
A, B, C = list(map(lambda n: int(n), input().split("" "")))
 
print(""YES"") if C % math.gcd(A,B) == 0 else print(""NO"")"
"s = input()
t = input()
s = ''.join(sorted(s))
t = ''.join(sorted(t, reverse=True))
if s>=t:
    print('No' , flush=True)
else:
    print('Yes' , flush=True)
"
"n, a, b = map(int, input().split())

N = n//(a+b)
m = n%(a+b)

print(N*a+min(m,a))"
"def resolve():
    N, x = list(map(int, input().split()))
    a = list(map(int, input().split()))
    dist = []

    ans = 0
    a.sort()

    for i, con in enumerate(a):
        if i == len(a)-1:
            dist.append(x - sum(dist))

        if sum(dist) + con <= x:
            dist.append(con)
        else:
            dist.append(0)

    for i in range(len(a)):
        if a[i] == dist[i]:
            ans += 1
    print(ans)
    return
resolve()"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    S1 = readline().strip()
    S2 = readline().strip()
    
    if S1 == S2[::-1]:
        print('YES')
    else:
        print('NO')
    
    return


if __name__ == '__main__':
    main()
"
"mod = 1000000007
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split()))

    ans = 0
    for i in range(1, N):
        if A[i] == A[i-1]:
            A[i] = 0
            ans += 1
    print(ans)


if __name__ == '__main__':
    main()
"
"import bisect, collections, copy, heapq, itertools, math, string, sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = float('inf')
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    N, X = LI()
    x = LI()

    d = list(set([abs(i - X) for i in x]))
    gcd = d[0]
    for i in d:
        gcd = math.gcd(i, gcd)

    print(gcd)

if __name__ == '__main__':
    resolve()
"
"import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import deque
n = int(input())
a = list(map(int,input().split()))
b = deque()

# print(a)
rev = False
for i in a:
    if rev:
        b.appendleft(i)
    else:
        b.append(i)
    rev = not rev

if rev:
    b.reverse()

for i in b:
    print(i)
"
"N=int(input())
A=list(map(int,input().split()))
h=0
for i in range(1,N):
  if A[i-1]<=A[i]:
    h+=0
  if A[i-1]>A[i]:
    h+=A[i-1]-A[i]
    A[i]=A[i-1]
print(h)"
"def main():
    s = input()
    n = len(s)
    mod = 10 ** 9 + 7
    dp = [[0 for _ in range(13)] for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        if s[i - 1] == ""?"":
            for now in range(10):
                for before in range(13):
                    ind = (now + 10 * before) % 13
                    dp[i][ind] += dp[i - 1][before]
                    dp[i][ind] %= mod
        else:
            for before in range(13):
                ind = (int(s[i - 1]) + 10 * before) % 13
                dp[i][ind] += dp[i - 1][before]
                dp[i][ind] %= mod
    print(dp[n][5])


if __name__ == '__main__':
    main()
"
"(a,b) = map(int,raw_input().split())
if a<b : print ""a < b""
elif a>b : print ""a > b""
else : print ""a == b"""
"n, m = map(int, input().split())
A = list(map(int, input().split()))
BC = [list(map(int, input().split())) for _ in range(m)]

A.sort()
BC.sort(key=lambda k: -k[1])

stack = []
cnt = 0
for b, c in BC:
  for _ in range(b):
    stack.append(c)
    cnt += 1
    if cnt > n:
      break

for i in range(min(n, len(stack))):
  if A[i] < stack[i]:
    A[i] = stack[i]
  else:
    break
    
print(sum(A))"
"n,k=map(int,input().split())
l=[i for i in range(1,k+1)][::-1]
mod=10**9+7
m=[0]*(k+1)
for i in l:
  a=k//i
  m[i]=pow(a,n,mod)
  for j in range(i*2,k+1,i):
    m[i]-=m[j]
ans=0
for i in range(k+1):
  ans+=m[i]*i
  ans%=mod
print(ans%mod)"
"a,b = map(int,input().split())
if a < 0 and b > 0:
    print(""Zero"")
elif a == 0 or b == 0:
    print(""Zero"")
elif a > 0:
    print(""Positive"")
else:
    n_c = b-a+1
    if n_c % 2 == 0:
        print(""Positive"")
    else:
        print(""Negative"")"
"S = list(input())
l = len(S)
if S == list('zyxwvutsrqponmlkjihgfedcba'):
    print(-1)
else:
    if l != 26:
        for i in range(26):
            if not chr(i+97) in S:
                S.append(chr(i+97))
                break
        print(''.join(S))
    else:
        li = []
        for i in range(26):
            c = S.pop()
            li.append(c)
            for x in li:
                if x>c:
                    S.append(x)
                    print(''.join(S))
                    break
            else:
                continue
            break    "
"N, K = list(map(int, input().split()))
H = list(map(int, input().split()))

H.sort()
remain = max(0, N-K)
H = H[:remain]

print(sum(H))
"
"#!/usr/bin/env python
# coding: utf-8

# In[27]:


N,M = map(int, input().split())
xy = []
b = [1]*N
p = [False]*N
p[0] = True
for _ in range(M):
    x,y = map(int, input().split())
    b[x-1] -= 1
    b[y-1] += 1
    if p[x-1]:
        p[y-1] = True
    if b[x-1] == 0:
        p[x-1] = False


# In[28]:


ans = 0
for j in p:
    if j:
        ans += 1
print(ans)


# In[ ]:




"
"s = input()
rl = []
start = 0
for i in range(len(s)):
    if i == len(s) - 1 or s[i] == ""L"" and s[i + 1] == ""R"":
        rl.append(s[start: i + 1])
        start = i + 1

ans = [0] * len(s)
start = 0
for i in range(len(rl)):
    x = rl[i].index(""L"")
    ans[start + x] = x // 2 + (len(rl[i]) - x - 1) // 2 + 1
    ans[start + x - 1] = (x - 1) // 2 + (len(rl[i]) - x) // 2 + 1
    start += len(rl[i])
print(*ans)"
"x, a, b = map(int, raw_input().split())

if abs(a-x) > abs(b-x):
  print('B')
else:
  print('A')"
"A,B,K=map(int,input().split())

mamax=max(A,B)
count=0
for i in range(mamax,0,-1):
    if(A%i==0 and B%i==0):

        count=count+1
        if(count==K):
            print(i)
            exit()
"
"import heapq
n,m = map(int,input().split())
a = list(map(int,input().split()))
a = list(map(lambda x:x*(-1),a))
heapq.heapify(a)
for i in range(m):
    x = heapq.heappop(a)*(-1)//2
    heapq.heappush(a,(x*(-1)))
print(sum(a)*(-1))"
"n=int(input())
a=list(map(int,input().split()))

odd=0
even=0

for aa in a:
    if aa%2==0:
        even+=1
    else:
        odd+=1

#odd+odd=even
#even+even=even

#もし奇数がペアが作れない場合,NO
if odd%2==1 and ( odd>2 or even>0):
    print(""NO"")
else:
    print(""YES"")
"
"from math import ceil
from decimal import Decimal, getcontext
getcontext().prec = 100
N = int(input())
TA = [tuple(map(int, input().split())) for _ in range(N)]

T = 1
A = 1
for i in range(N):
    x, y = TA[i]
    n = max(ceil(Decimal(T)/Decimal(x)), ceil(Decimal(A)/Decimal(y)))
    T = n*x
    A = n*y
print(T+A)"
"import string
import sys

table = {c: 0 for c in string.ascii_lowercase}

for raw in sys.stdin.read():
    c = raw.lower()
    if c in string.ascii_lowercase:
        table[c] += 1

for key in string.ascii_lowercase:
    print('{:s} : {:d}'.format(key, table[key]))"
"D,T,S=map(int,input().split())
if 1<=D<=10000 and 1<=T<=10000 and 1<=S<=10000:
  if (D/S)>T:
    print(""No"")
  else:
    print(""Yes"")"
"p = input()
num = int(input())
for i in range(num):
    order = list(map(str,input().split()))
    a = int(order[1])
    b = int(order[2])
    if order[0] == 'print':
        print(p[a:b+1])
    elif order[0] == 'replace':
        rep = order[3]
        p = p[:a] + rep + p[b+1:]
    else:
        p = p[:a] + p[a:b+1][::-1] + p[b+1:]

"
"n = int(input())
print(int(sum([k*(n//k+1)*(n//k)/2 for k in range(1,n+1)])))"
"import sys


class Node():
    def __init__(self,  key=None, prev=None, next=None):
        self.key = key
        self.prev = prev
        self.next = next


class DoublyLinkedList():
    def __init__(self):
        self.head = Node()
        self.head.next = self.head
        self.head.prev = self.head

    def insert(self, x):
        node = Node(key=x, prev=self.head, next=self.head.next)
        self.head.next.prev = node
        self.head.next = node

    def search(self, x):
        node = self.head.next
        while node is not self.head and node.key != x:
            node = node.next
        return node

    def delete_key(self, x):
        node = self.search(x)
        self._delete(node)

    def _delete(self, node):
        if node is self.head:
            return None
        node.prev.next = node.next
        node.next.prev = node.prev

    def deleteFirst(self):
        self._delete(self.head.next)

    def deleteLast(self):
        self._delete(self.head.prev)

    def getKeys(self):
        node = self.head.next
        keys = []
        while node is not self.head:
            keys.append(node.key)
            node = node.next
        return "" "".join(keys)


L = DoublyLinkedList()
n = int(input())
for i in sys.stdin:
    if 'insert' in i:
        x = i[7:-1]
        L.insert(x)
    elif 'deleteFirst' in i:
        L.deleteFirst()
    elif 'deleteLast' in i:
        L.deleteLast()
    elif 'delete' in i:
        x = i[7:-1]
        L.delete_key(x)
    else:
        pass
print(L.getKeys())

"
"import heapq
n , m = map(int,input().split())
kouho = [[] for i in range(m)]
for i in range(n):
    a , b = map(int,input().split())
    if a <= m:
        kouho[a-1].append(-b)
ans = 0
p = []
heapq.heapify(p)

for i in range(m):

    for j in kouho[i]:
        heapq.heappush(p,j)
    if p:
        ans -= heapq.heappop(p)
print(ans)"
"A, B, K = map(int, input().split())

if K > (B - A) // 2:
    for i in range(A, B + 1):
        print(i)
else:
    for i in range(A, A + K):
        print(i)
    for i in range(B - K + 1, B + 1):
        print(i)"
"S =input()
S_list = list(map(int,S.split()))
S_list = [i - 1 for i in S_list]

if  S_list[0] == S_list[1] :
    result = ""Draw""
elif (S_list[0] - S_list[1]) * S_list[1] >0 or S_list[0] == 0:
    result = ""Alice""
else:
    result = ""Bob""
print(result)
"
"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

N,M = list(map(int,input().split()))
Network = UnionFind(N)

out=0
for i in range(M):
    a,b = list(map(int,input().split()))
    Network.union(a-1,b-1)
print(-1*min(Network.parents))"
"n, a, b = map(int, input().split())

if n * a >= b:
  ans = b
elif n * a < b:
  ans = n *a
  
print(ans)"
"A, B, K = map(int, input().split())
L_1 = set([i for i in range(A, min(A+K, B+1))])
L_2 = set([i for i in range(max(A, B-K+1), B+1)])
L = sorted(L_1|L_2)
for l in L:
  print(l)"
"#!/usr/bin/env python3

import sys
# import time
# import math
# import numpy as np
# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall
# import random                                # random, uniform, randint, randrange, shuffle, sample
# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits
# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)
# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).
# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()
# from collections import defaultdict          # subclass of dict. defaultdict(facroty)
# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)
# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj
# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj
# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.
# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference
# from functools import reduce                 # reduce(f, iter[, init])
# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)
# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).
# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).
# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])
# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]
# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]
# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])
# from itertools import combinations, combinations_with_replacement
# from itertools import accumulate             # accumulate(iter[, f])
# from operator import itemgetter              # itemgetter(1), itemgetter('key')
# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)



def main():
    mod = 1000000007                # 10^9+7
    inf = float('inf')              # sys.float_info.max = 1.79...e+308
    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19
    sys.setrecursionlimit(10**6)    # 1000 -> 1000000
    def input(): return sys.stdin.readline().rstrip()
    def ii():    return int(input())
    def mi():    return map(int, input().split())
    def mi_0():  return map(lambda x: int(x)-1, input().split())
    def lmi():   return list(map(int, input().split()))
    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))
    def li():    return list(input())
    
    
    n = ii()
    scores = [ii() for _ in range(n)]
    scores.sort()
    
    if sum(scores) % 10 != 0:
        print(sum(scores))
    else:
        dec = sum(scores)
        for elm in scores:
            if elm % 10 != 0:
                dec = elm
                break
        print(sum(scores) - dec)


if __name__ == ""__main__"":
    main()
"
"n, k = map(int,input().split())
s = list(input())

cl = 0
cr = 0
a = []
ans = 0
if s[0] == '1':
    ck = 0
    ans = 1
else:
    ck = 1
    a.append([0,0])
while True:
    while ck <= k and cr < n-1:
        cr += 1
        if s[cr-1] == '1' and s[cr] == '0':
            if ck < k:
                ck += 1
                a.append([cr, cr])
            else:
                break
        elif s[cr-1] == '0' and s[cr] == '1':
            a[-1][1] = cr
        ans = max(ans, cr - cl + 1)
    if cr < n-1:
        tl, tr = a.pop(0)
        cl = tr
        cr -= 1
        ck -= 1
    else:
        break
print(ans)"
"N=int(input())

alist=[]
for _ in range(N):
  a=int(input())
  alist.append(a)
alist.sort()
#print(alist)

if N%2==0:
  answer=0
  for i in range(N//2-1):
    a=alist.pop()
    answer+=2*a
  answer+=alist.pop()
  answer-=alist.pop()
  for i in range(N//2-1):
    a=alist.pop()
    answer-=2*a
    
  print(answer)
else:
  ans1=0
  alist_copy=alist[:]
  for i in range(N//2-1):
    a=alist_copy.pop()
    ans1+=2*a
  ans1+=alist_copy.pop()
  ans1+=alist_copy.pop()
  for i in range(N//2):
    a=alist_copy.pop()
    ans1-=2*a
    
  ans2=0
  alist_copy=alist[:]
  for i in range(N//2):
    a=alist_copy.pop()
    ans2+=2*a
  ans2-=alist_copy.pop()
  ans2-=alist_copy.pop()
  for i in range(N//2-1):
    a=alist_copy.pop()
    ans2-=2*a
    
  print(max(ans1,ans2))"
"s = list(input())
if s.count('A') == 3 or s.count('B') == 3:
  print('No')
else:
  print('Yes')"
"import sys

sys.setrecursionlimit(10 ** 7)
f_inf = float('inf')
mod = 998244353


def resolve():
    n = int(input())
    D = list(map(int, input().split()))
    MAX_L = max(D) + 1
    cnt = [0] * MAX_L

    for d in D:
        cnt[d] += 1

    if cnt[0] != 1 or D[0] != 0:
        print(0)
        exit()

    res = 1
    for i in range(1, MAX_L):
        if cnt[i] == 0:
            print(0)
            break
        res *= pow(cnt[i - 1], cnt[i], mod)
        res %= mod
    else:
        print(res)


if __name__ == '__main__':
    resolve()
"
"N=2*10**5+1
mod=10**9+7
f=[None]*N
fi=[None]*N
f[0]=1
for i in range(1,N):
  f[i]=i*f[i-1]%mod
for i in range(N):
  fi[i]=pow(f[i],mod-2,mod)
def com(n,k):
  return f[n]*fi[n-k]%mod*fi[k]%mod
def hcom(n,k):
  return com(n+k-1,n-1)
n,k=map(int,input().split())
ans=1
for i in range(1,min(k+1,n)):
  ans=(ans+com(n,i)*hcom(n-i,i)%mod)%mod
print(ans)"
"def exc(cookies, turn):
    exccs = 0
    subturn = (turn + 1) % 2
    if (cookies[turn] % 2) == 0:
        exccs = cookies[turn] //2
    else:
        exccs = (cookies[turn] - 1) // 2
    
    cookies[subturn] += exccs
    cookies[turn] = exccs

    return cookies

a, b, k = map(int, input().split())
cookies = [a, b]

for i in range(k):
    turn = i % 2
    cookies = exc(cookies, turn)

print(""{} {}"".format(cookies[0], cookies[1]))"
"import sys
input = sys.stdin.readline

X, Y, A, B, C = map(int, input().split())
P = sorted(list(map(int, input().split())), reverse=True)
Q = sorted(list(map(int, input().split())), reverse=True)
R = sorted(list(map(int, input().split())), reverse=True)

ans = sum(P[:X]) + sum(Q[:Y])
x = X-1
y = Y-1
for z in range(C):
    if x < 0:
        if R[z] > Q[y]:
            ans += R[z] - Q[y]
            y -= 1
    elif y < 0:
        if R[z] > P[x]:
            ans += R[z] - P[x]
            x -= 1
    else:
        if R[z] > P[x] >= Q[y]:
            ans += R[z] - Q[y]
            y -= 1
        elif R[z] > Q[y] > P[x]:
            ans += R[z] - P[x]
            x -= 1
        elif P[x] >= R[z] > Q[y]:
            ans += R[z] - Q[y]
            y -= 1
        elif Q[y] >= R[z] > P[x]:
            ans += R[z] - P[x]
            x -= 1
print(ans)
"
"import sys
def input(): return sys.stdin.readline().strip()

def resolve():
    s=set(input())
    ans='No'
    if s==set('NSWE') or s==set('NS') or s==set('WE'):
        ans='Yes'
    print(ans)
resolve()"
"K = int(input())
c = ''

for i in range(1,K+1):
    c += 'ACL'

print(c)
"
"N, M = map(int, input().split())
A = list(map(int, input().split()))

ans = N-sum(A)
if ans < 0:
    ans = -1
print(ans)"
"while True:
    [h, w] = map(int, (input().split()))
    if h==0 and w==0:
        break
    else:   
        print(""#""*w+""\n""+(""#""+"".""*(w-2)+""#\n"")*(h-2)+""#""*w+""\n"")"
"S=input()
List = list(S)
res=""""

def responseB(moji):
  if moji == """":
    return moji
  else:
    moji = moji[0:len(moji)-1]
    return moji

for i in range(len(S)):
  if not List[i] == ""B"":
    res += List[i]
  else:
    res = responseB(res)
print(res)"
"N=int(input())
S=list(map(int,input().split()))
D=[]
goukei=0

for i in range(N):
    goukei+=S[i]
    D.append(goukei)

T=[]    
for i in range(N-1):
    T.append(abs((goukei-D[i])-D[i]))
    
print(min(T))"
"# ABC079 C問題 Train Tickets
""""""
切符に４つの0以上9以下の整数A,B, C, Dが整理番号として順にかかれている。
Aop1Bop2Cop3D = 7　となるように、op1,2,3,に'+'または'-'を入れて式を作る。
答が存在しない入力は与えられず、また答が複数ある場合はどれを出力してもよい。
＜制約＞
0 <= A,B,C,D<=9
入力は整数
答が存在しない入力は与えられない
""""""
n = list(int(x) for x in input())
op_cnt = len(n) - 1 #隙間の数

l = []
for i in range(1 << op_cnt):
    op = ['-'] * op_cnt
    for j in range(op_cnt):
        if ((i >> j) & 1):
            op[op_cnt - j -1] = '+'
            l.append(op)

for operators in l:
    expression = f""{n[0]}{operators[0]}{n[1]}{operators[1]}{n[2]}{operators[2]}{n[3]}""
    if eval(expression) == 7:
        print(f""{expression}=7"")
        break




"
"if __name__ == '__main__':
	
	A = list(map(int,input().split()))
	print(max(A)-min(A))"
"a,b,c = map(str,(input().split("","")))
print(a,b,c)"
"_, _, *S = open(0).read().split()
print("""".join(sorted(S)))"
"x,y = input().split()
X = int(x)
Y = int(y)

A = X
count = 0
while Y >= A:
  A = A*2
  count += 1

print(count)"
"from sys import stdin
input = stdin.readline

S = input().strip()
P = ''
for s in S:
    if s == 'B':
        if P != '':
            P = P[:-1]
    else:
        P = P + s
print(P)"
"n,m,k=map(int,input().split())

par=[i for i in range(n)]
size=[1 for i in range(n)]


def find(x):
  if par[x]==x:
    return x
  else:
    par[x]=find(par[x])
    return par[x]
def union(a,b):
  x=find(a)
  y=find(b)
  if x!=y:
    if size[x]<size[y]:
      par[x]=par[y]
      size[y]+=size[x]
    else: 
      par[y]=par[x]
      size[x]+=size[y]
  else:
    return

graph=[[] for i in range(n)]

for i in range(m):
    a,b=map(int,input().split())
    union(a-1,b-1)
    graph[a-1].append(b-1)
    graph[b-1].append(a-1)

for i in range(k):
    a,b=map(int,input().split())
    if find(a-1)==find(b-1):
        graph[a-1].append(b-1)
        graph[b-1].append(a-1)

ans=[]

for i in range(n):
    cnt=size[find(i)]
    xxx=list(set(graph[i]))
    cnt-=len(xxx)
    cnt-=1
    ans+=[str(cnt)]


print(' '.join(ans))"
"_ = input()
l = list(map(int, input().split(' ')))
print('APPROVED' if all([(a % 2 == 1 or a % 3 == 0 or a % 5 == 0) for a in l]) else 'DENIED')
"
"l = list(map(int, input().split()))
n = l[0]  # no of things he has to make
x = l[1]  # no of things he can make at a time
t = l[2]  # time taken for each set to be made = t
# 20 12 6 = 12
count = 0
while n > 0:
    n -= x
    count += t
print(count)
"
"l ='abcdefghijklmnopqrstuvwxyz'

c = input()

x = l.index(c)

print(l[x + 1])"
"import sys
import heapq
from decimal import Decimal

input = sys.stdin.readline

n, k, q = map(int, input().split())
point_list = [0]*n
S = []

for _ in range(q):
    ai = int(input())
    point_list[ai-1] += 1

for point in point_list:
    if k - (q - point) > 0:
        print(""Yes"")
    else:
        print(""No"")
"
"s=str(input())
s=list(s)
ans=[0]*len(s)
t=0
r=0
l=0
for i in range(len(s)-1):
  if s[i]==""L"" and s[i+1]==""R"":
    for j in range(t,i+1):
      if s[j]==""R"" and s[j+1]==""L"":
        if (i+1-t)%2==0:
          ans[j]=ans[j]+(i+1-t)//2
          ans[j+1]=ans[j+1]+(i+1-t)//2
        else:
          if t%2==j%2:
            ans[j]=ans[j]+(i+1-t)//2+1
            ans[j+1]=ans[j+1]+(i+1-t)//2
          else:
            ans[j+1]=ans[j+1]+(i+1-t)//2+1
            ans[j]=ans[j]+(i+1-t)//2
        t=i+1
        break
for j in range(t,len(s)):
  if s[j]==""R"" and s[j+1]==""L"":
    if (len(s)-t)%2==0:
      ans[j]=ans[j]+(len(s)-t)//2
      ans[j+1]=ans[j+1]+(len(s)-t)//2
    else:
      if t%2==j%2:
        ans[j]=ans[j]+(len(s)-t)//2+1
        ans[j+1]=ans[j+1]+(len(s)-t)//2
      else:
        ans[j+1]=ans[j+1]+(len(s)-t)//2+1
        ans[j]=ans[j]+(len(s)-t)//2
print("" "".join(map(str,ans)))"
"#coding:utf-8
import math

r=float(input())
print(""%.6f""%(math.pi*r**2)+"" %.6f""%(2*math.pi*r))"
"D, *I = map(int, open(0).read().split())
C, S, T = I[:26], list(zip(*[iter(I[26:-D])] * 26)), I[-D:]

last = [0] * 26
ans = 0
for d, i in enumerate(T, 1):
    ans += S[d - 1][i - 1]
    last[i - 1] = d
    ans -= sum(c * (d - l) for c, l in zip(C, last))
    print(ans)"
"A = input()
B = input()
C = input()

now = A[:1]
A = A[1:]

while(1):
    if(now == 'a'):
        if(len(A) == 0):
            print(""A"")
            exit()
        now = A[:1]
        A = A[1:]
    elif(now == 'b'):
        if(len(B) == 0):
            print(""B"")
            exit()
        now = B[:1]
        B = B[1:]
    else:
        if(len(C) == 0):
            print(""C"")
            exit()
        now = C[:1]
        C = C[1:]
"
"#k = int(input())
#s = input()
#a, b = map(int, input().split())
#s, t = map(str, input().split())
#l = list(map(int, input().split()))
#l = [list(map(int,input().split())) for i in range(n)]
#a = [input() for _ in range(n)]

n,k = map(int, input().split())
a = list(map(int, input().split()))

d = [0]*(n+1)

for i in range(n):
    d[a[i]] += 1

d.sort()

print(sum(d[:n-k+1]))
"
"#!/usr/bin/env python3
from collections import defaultdict, Counter
from itertools import product, groupby, count, permutations, combinations
from math import pi, sqrt
from collections import deque
from bisect import bisect, bisect_left, bisect_right
from string import ascii_lowercase
from functools import lru_cache
import sys
sys.setrecursionlimit(10000)
INF = float(""inf"")
YES, Yes, yes, NO, No, no = ""YES"", ""Yes"", ""yes"", ""NO"", ""No"", ""no""
dy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]
dy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]


def inside(y, x, H, W):
    return 0 <= y < H and 0 <= x < W


def ceil(a, b):
    return (a + b - 1) // b


def sum_of_arithmetic_progression(s, d, n):
    return n * (2 * s + (n - 1) * d) // 2


def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


def lcm(a, b):
    g = gcd(a, b)
    return a / g * b


def solve():
    N, K = map(int, input().split())

    MOD = (10**9) + 7
    ans = 0
    for i in range(K, N + 2):
        ans += sum_of_arithmetic_progression(N, -1, i) - sum_of_arithmetic_progression(0, 1, i) + 1
        ans %= MOD

    print(ans)


def main():
    solve()


if __name__ == '__main__':
    main()
"
"import sys
import numpy as np

sys.setrecursionlimit(10 ** 8)
ini = lambda: int(sys.stdin.readline())
inl = lambda: [int(x) for x in sys.stdin.readline().split()]
ins = lambda: sys.stdin.readline().rstrip()
debug = lambda *a, **kw: print(""\033[33m"", *a, ""\033[0m"", **dict(file=sys.stderr, **kw))


def solve():
    N, H = inl()
    a = [None] * N
    b = [None] * N
    mi = None
    ma, mb = 0, 0
    for i in range(N):
        a[i], b[i] = inl()
        if a[i] > ma:
            mi = i
            ma = a[i]

    bm = max(b[mi], a[mi])
    am = a[mi]

    bb = []
    for i in range(N):
        bb.append((b[i], i))
    bb.sort(reverse=True)

    cnt = 0
    for i in range(N):
        if H <= 0:
            break
        x, j = bb[i]
        debug(H, x, j)
        if x < am:
            break
        H -= x
        cnt += 1
    if H > 0:
        k = (H + am - 1) // am
        cnt += k
        H -= k * am
        assert H <= 0

    return cnt


print(solve())
"
"print(""Yes"" if input().startswith(""YAKI"") else ""No"")
"
"import itertools

N = int(input())

l = []

for i in itertools.permutations(list(range(1,N+1))):
    l.append(i)

P = tuple(map(int,input().split()))
Q = tuple(map(int,input().split()))

a = 1
b = 1

for i in l:
    if i < P:
        a += 1

for i in l:
    if i < Q:
        b += 1

print(abs(a-b))"
"#!/usr/bin/env python3

import sys

DEBUG = False

def read(t):
    return t(sys.stdin.readline().rstrip())


def read_list(t, sep = "" ""):
    return [t(s) for s in sys.stdin.readline().rstrip().split(sep)]


def dprint(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)
    return


def main():
    a, b = read_list(int)
    print(max([a + b, a - b, a * b]))


if __name__ == ""__main__"":
    main()
"
"a=int(input())
ans=input()

if a < 3200:
    ans = 'red'

print(ans)"
"def resolve():
    X = int(input())
    if X >= 2100:
        print(""1"")
    else:
        if X%100 > (X//100)*5:
            print(""0"")
        else:
            print(""1"")
resolve()"
"def cal(A,B,C,D,E,F):
    div = [0 for _ in range(4)]
    div[0] = F // (100 * A)
    div[1] = F // (100 * B)
    if B % A == 0:
        div[1] = 0
    div[2] = (F * E) // ((100 + E) * C)
    div[3] = (F * E) // ((100 + E) * D)
    if D % C == 0:
        div[3] = 0

    concent,concent_max = -1.0,[0,0]
    for i2 in range(div[1]+1):
        for i1 in range(div[0]+1):
            for j2 in range(div[3]+1):
                for j1 in range(div[2]+1):
                    if 100 * (A * i1 + B * i2) + (C * j1 + D * j2) <= F \
                    and (C * j1 + D * j2) <= E * (A * i1 + B * i2) \
                    and ((i1 != 0) or (i2 != 0)):
                        if concent < (C * j1 + D * j2) / (A * i1 + B * i2):
                            concent = (C * j1 + D * j2) / (A * i1 + B * i2)
                            concent_max = [C * j1 + D * j2 , (A * i1 + B * i2) * 100]
                    else:
                        break

    return concent_max

def main():
    A,B,C,D,E,F = map(int,input().split())

    concent_max = cal(A,B,C,D,E,F)
    print(concent_max[0] + concent_max[1],concent_max[0])

if __name__ == ""__main__"":
    main()
"
"a = input()
if a == ""Sunny"":
  print(""Cloudy"")
elif a == ""Cloudy"":
  print(""Rainy"")
else:
  print(""Sunny"")"
"n = input()
print(n ** 3)"
"s = input()
alphabets = [0] * 26
for i in range(len(s)):
  a = ord(s[i])
  alphabets[a-97] += 1
flag = True
for x in alphabets:
  if x % 2 != 0:
    flag = False
if flag:
  print('Yes')
else:
  print('No')"
"line = raw_input()
n, k = [int(s) for s in line.split(' ')]
print 0 if n % k == 0 else 1
"
"x, k, d = map(int, input().split())

x = abs(x)

if x - k * d > 0:
    ans = x - k * d
else:
    if (k - x // d) % 2 == 0:
        ans = x - d * (x // d)
    else:
        ans = abs(x - d * (x // d) - d)

print(ans) 
"
"import bisect,collections,copy,itertools,math,string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def main():
    n = I()
    ans = 0
    if n<10:
        ans = n
    else:
        keta = len(str(n))
        top = int(str(n)[0])
        down = int(str(n)[1:])
        if top == 1:
            if down == 10**(keta-1)-1:
                ans = 1+(keta-1)*9
            else:
                ans = (keta-1)*9
        else:
            if down == 10**(keta-1)-1:
                ans = top+(keta-1)*9
            else:
                ans = top-1+(keta-1)*9
    
    print(ans)

main()            
"
"
""""""
Writer: SPD_9X2
https://atcoder.jp/contests/abc163/tasks/abc163_e

dpか？
なにを基準にdpすればよい？
まとめられる状態は？
小さいことを考えると貪欲かなぁ
かいてみるか

挿入dp?
前から決めていけば、累積和で減る量がわかる
&増える寄与も計算できる
O(N**2)

全探索はむり

======答えを見ました======
今より右に行く、左に行くの集合に分けたとすると
大きい奴をより左にする方が最適
よって、途中まで単調減少、途中から単調増加が最適であるとわかる

dp[大きい方からi番目まで見た][左にl個つめた] = 最大値
で解ける

""""""


N = int(input())

A = list(map(int,input().split()))
ai = []
for i in range(N):
    ai.append([A[i],i])
ai.sort()
ai.reverse()

ans = 0

dp = [ [float(""-inf"")] * (N+1) for i in range(N+1) ]
dp[0][0] = 0

for i in range(N):

    na,nind = ai[i]

    for l in range(i+1):

        r = N-1-(i-l)
        dp[i+1][l+1] = max(dp[i+1][l+1] , dp[i][l] + na*abs(nind-l) )
        dp[i+1][l]   = max(dp[i+1][l] , dp[i][l] + na*abs(nind-r) )

print (max(dp[N]))
"
"import math
N = int(input())
A = [list(map(int,input().split())) for _ in range(N-1)]
for i in range(N):
    t = 0
    for C,S,F in A[i:]:
        if t < S:
            t = S+C
        else:
            t = math.ceil((t-S)/F)*F+S+C
    print(t)"
"import sys
import math
import itertools
import bisect
from copy import copy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def i(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def L(): return list(input().split())
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
sys.setrecursionlimit(10 ** 9)
INF = 10**9
mod = 10**9+7

N,R = I()
if N < 10:
    print(R+(10-N)*100)
else:
    print(R)"
"N=int(input())
l=0
r=0
for i in range(1,N+1):
  s=i*(i+1)//2
  if s>=N:
    l=i
    r=s-N
    break
ans=list(range(1,l+1))
if r!=0:
  ans.remove(r)
print(*ans,sep='\n')"
"def main():
  s = input()
  if int(s[0:4])<=2018:
    print( ""Heisei"" )
  elif int(s[0:4])==2019:
    if int(s[5:7])<=4:
      print( ""Heisei"" )
    else:
      print( ""TBD"" )
  else:
      print( ""TBD"" )
  
main()"
"def main():
    inside_rate, outside_rate = map(int, input().split())
    correction = 0
    if inside_rate < 10:
        correction = 100 * (10 - inside_rate)
    print(outside_rate + correction)
main()"
"import numpy as np
n,m,x = map(int, input().split())
li = []
for i in range(n):
    c_A = list(map(int, input().split()))
    li.append(c_A)

li = np.array(li)
cost = 10**7
for i in range(2**n):
    c_s = np.array([0]*(m+1))
    for j in range(n):
        if ((i>>j)&1):
            c_s += li[j]
    if np.all(c_s[1:]>=x):
        cost = min(cost,c_s[0])
if cost==10**7:
    print(-1)
else:
    print(cost)"
"N= int(input())
A= list(input())
B= list(input())
C= list(input())
ans=0
import collections
for i in range(N):
   l=[A[i],B[i],C[i]]
   l=collections.Counter(l).most_common()
   ans+=3-l[0][1]
print(ans)"
"from itertools import permutations


def warshallfloyd(N, DIST):  # ワーシャルフロイド法:全頂点対最短経路 O(n**3)
    # DIST:隣接行列
    for k in range(N):
        for i in range(N):
            for j in range(N):
                DIST[i][j] = min(DIST[i][j], DIST[i][k] + DIST[k][j])
    return DIST


h, w = map(int, input().split())
c = [list(map(int, input().split())) for _ in range(10)]
a = [list(map(int, input().split())) for _ in range(h)]

ans, dist = 0, warshallfloyd(10, c)
for ai in a:
    for aij in ai:
        if aij != -1:
            ans += dist[aij][1]
print(ans)
"
"from sys import stdin
import sys
import math
from functools import reduce
import itertools

n,k = [int(x) for x in stdin.readline().rstrip().split()]
h = [int(x) for x in stdin.readline().rstrip().split()]

if k<n:
    h.sort()
    print(sum(h[:n-k]))
else:
    print(0)"
"H, W = map(int, input().split())
Maze = [[1 if a == ""#"" else 0 for a in input()] for _ in range(H)]

DP = [[float('inf')] * W for _ in range(H)]

if Maze[0][0] == 1:
    DP[0][0] = 1
else:
    DP[0][0] = 0

for i in range(H):
    for j in range(W):
        if Maze[i][j] == 1:
            if i + 1 < H:
                DP[i+1][j] = DP[i][j]
            if j + 1 < W:
                DP[i][j+1] = min(DP[i][j+1], DP[i][j])
        if Maze[i][j] == 0:
            if i + 1 < H:
                if Maze[i+1][j] != 1:
                    DP[i + 1][j] = DP[i][j]
                else:
                    DP[i + 1][j] = DP[i][j] + 1
            if j + 1 < W:
                if Maze[i][j + 1] != 1:
                    DP[i][j + 1] = min(DP[i][j + 1], DP[i][j])
                else:
                    DP[i][j + 1] = min(DP[i][j + 1], DP[i][j]+1)

print(DP[H-1][W-1])
"
"n, m = map(int,input().split())
lst = [-1 for i in range(n + 1)]
lst[0] = 0
def find(x):
    if(lst[x] < 0):
        return(x)
    else:
        return(find(lst[x]))
def unit(x, y):
    xr = find(x)
    yr = find(y)
    if (xr == yr):
        pass
    else:
        if (xr > yr):
            x, y = y, x
            xr, yr = yr, xr
        lst[xr] = lst[xr] + lst[yr]
        lst[yr] = xr

for i in range(m):
    a, b = map(int,input().split())
    unit(a, b)

print(-(min(lst)))
    
"
"A,B,C=map(int,input().split())
print(C-(A-B) if A-B<=C else 0)"
"n=int(input())
alist=[]
maxa=0
nextmax=0
maxindex = 573945
for i in range(n):
    tmpa=int(input())
    if tmpa >= maxa:
        nextmax = maxa
        maxa = tmpa
        maxindex = i
    elif tmpa >= nextmax:
        nextmax = tmpa

for j in range(n):
    if j == maxindex:
        print(nextmax)
    else:
        print(maxa)



"
"import sys
import re
import math
import collections
import decimal
import bisect
import itertools
import fractions
import functools
import copy
import heapq
import decimal
import statistics
import queue

# import numpy as np

sys.setrecursionlimit(10 ** 9)
INF = 10 ** 16
MOD = 10 ** 9 + 7
# MOD = 998244353

ni = lambda: int(sys.stdin.readline())
ns = lambda: map(int, sys.stdin.readline().split())
na = lambda: list(map(int, sys.stdin.readline().split()))


# ===CODE===

def main():
    n, k = ns()
    a = na()

    dp = [False] * (k + 1)

    for i in range(k + 1):
        for ai in a:
            if i + ai < k + 1:
                dp[i + ai] |= not dp[i]
            else:
                break

    print(""First"" if dp[k] else ""Second"")


if __name__ == '__main__':
    main()
"
"A = int(input())
B = int(input())
C = int(input())
D = int(input())
N = min(A,B)
L = min(C,D)
print(N+L)"
"N=int(input())
if N > 2:
  print(N//3)
else:
  print(0)
"
"n,h = map(int,input().split())
a = [0] * n
b = [0] * n
for i in range(n):
    a[i],b[i] = map(int,input().split())

ama = max(a)
b.sort(reverse=True)
c = 0
i = 0
while(h > 0):
    if(i >= n):break
    if(b[i] > ama):
        c += 1
        h -= b[i]
        i += 1
    else:
        break
h = max(0,h)
c += h // ama
if(h % ama != 0):c += 1
print(c)"
"import sys

N, K = map(int, sys.stdin.readline().split())
print(N - K + 1)"
"import collections
import sys
input = sys.stdin.readline


def main():
    N = int(input())
    S = [input().rstrip() for _ in range(N)]
    c = collections.Counter(S).most_common()
    max_freq = None
    max_S = []
    for s, freq in c:
        if max_freq is None:
            max_freq = freq
            max_S.append(s)
        elif freq == max_freq:
            max_S.append(s)
        else:
            break
    print('\n'.join(sorted(max_S)))


if __name__ == ""__main__"":
    main()
"
"import sys
def input(): return sys.stdin.readline().rstrip()
import numpy as np
def main():
    n,k,s=map(int,input().split())
    ans=np.array([0]*n)
    ans[:k]+=s
    if s!=10**9:
        ans[k:]+=10**9
    else:
        ans[k:]+=10**9-1
    print(*ans)

if __name__=='__main__':
    main()"
"N = int(input())
for i in range(N//4+1):
  for j in range(N//7+1):
    if 4*i + 7*j ==N:
      print('Yes')
      exit()
print('No')"
"def gcd(a, b):
    if (a == 0):
        return b
    return gcd(b%a, a)

def lcm(a, b):
    return (a*b)//gcd(a, b)
    
n = int(input())

numbers = list(map(int, input().split()))

l = numbers[0]
for i in range(1, n):
    l = lcm(l, numbers[i])

ans = 0

for i in range(n):
    ans += l//numbers[i]

MOD = 1000000007
print(ans%MOD)
"
"import string
import sys
import math

#??????????????\????????????ip?????\??????
ip = sys.stdin.readlines()
ip_list = {}

#?????????????????§?????????
for i in range(len(ip)):
    ip_list[i] = ip[i].strip(""\n"").split()

for i in range(1,len(ip)):
    for j in range(3):
        #?????????????????????
        for t in range(3):
            for k in range(3):
                if int(ip_list[i][t]) > int(ip_list[i][k]):
                    tmp = ip_list[i][t]
                    ip_list[i][t] = ip_list[i][k]
                    ip_list[i][k] = tmp  
                    
for i in range(1,len(ip)):   
    if int(ip_list[i][0])**2 == int(ip_list[i][1])**2 + int(ip_list[i][2])**2:
        print(""YES"")
    else:
        print(""NO"")"
"import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
def main():
    W,H,x,y = mi()

    ans = '{:.10f}'.format(W*H/2)
    ans2 = 1 if x==W/2 and y==H/2 else 0
    print(ans,ans2)
    




if __name__ == ""__main__"":
    main()"
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
pairs = []
for _ in range(m):
    a, b = map(int, input().split())
    a, b = a-1, b-1
    pairs.append((a, b))

pairs.sort(key=lambda x: x[1])  # 右端の値でソート
current_right = 0
ans = 0
for (l, r) in pairs:
    if l >= current_right:
        current_right = r
        ans += 1
print(ans)
"
"n = int(input())
DifMax = -9999999999999

R = [int(input())]
RMin = R[0]
for i in range(1, n):
  if RMin > R[i-1]:
      RMin = R[i-1]
  R.append(int(input()))
  if DifMax < R[i] - RMin:
    DifMax = R[i] - RMin

print(DifMax)"
"n=int(input())
s=list(input())
mod=10**9+7
from collections import Counter
c=Counter(s)
ans=1
for k in c.keys():
    ans*=(c[k]+1)%mod
    ans%=mod
print((ans+mod-1)%mod)"
"a = input()

for i in range(3):
    if a[i] ==""1"":
        a = a[:i]+""9""+a[i+1:]
    elif a[i] ==""9"":
        a = a[:i]+""1""+a[i+1:]

print(a)"
"#! /usr/bin/env python3
import sys
sys.setrecursionlimit(10**9)


INF=10**20
def solve(A: int, P: int):
    ans = 3*A+P
    ans //= 2

    print(ans)
    return

def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    A = int(next(tokens))  # type: int
    P = int(next(tokens))  # type: int
    solve(A, P)



if __name__ == ""__main__"":
    main()
"
"x,y=input().split()
if x=='A':
  a=10
elif x=='B':
  a=11
elif x=='C':
  a=12
elif x=='D':
  a=13
elif x=='E':
  a=14
elif x=='F':
  a=15
else:
  a=int(x)
if y=='A':
  b=10
elif y=='B':
  b=11
elif y=='C':
  b=12
elif y=='D':
  b=13
elif y=='E':
  b=14
elif y=='F':
  b=15
else:
  b=int(y)
if a>b:
  print('>')
elif a<b:
  print('<')
else:
  print('=')"
"n = int(input())
st = input()
if st[:n//2] == st[n//2:]: print(""Yes"")
else: print(""No"")"
"# Review problem

from collections import defaultdict
import sys
sys.setrecursionlimit(10**7)
N, K = map(int, input().split())
graph = [[] for i in range(N+1)]
for _ in range(N-1):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
visited = [0 for i in range(N+1)]
dis = [0 for i in range(N+1)]
parent = [-1 for i in range(N+1)]
parent[1] = -1
visited[1] = True
mod = 10**9+7


def bfs(node):
    for child in graph[node]:
        if visited[child] == False:
            visited[child] = True
            parent[child] = node
            dis[child] = dis[node]+1
            bfs(child)


bfs(1)

par_data = defaultdict(int)
for i in range(1, N+1):
    x = parent[i]
    par_data[x] += 1
ans = K
for parent in par_data.keys():
    if parent > 0:
        X = par_data[parent]
        if parent == 1:
            for i in range(X):
                ans = ans*(K-1-i)
                ans %= mod
                if ans==0:
                  print(0)
                  exit()
        else:
            for i in range(X):
                ans = ans*(K-2-i)
                ans %= mod
                if ans==0:
                  print(0)
                  exit()
print(ans)"
"N = input()
n = len(N)

if n == 1:
  print(N)
elif N[1:] == '9'*(n-1):
  print(9*(n-1)+int(N[0]))
else:
  print(9*(n-1)+int(N[0])-1)"
"S = input()
from collections import defaultdict
dic = defaultdict(int)

for s in S:
    dic[s] += 1
print('Yes' if len(dic)==2 and dic[s[0]]==2 else 'No')"
"import sys

input_list = sys.stdin.readlines() 
N, s = map(str.strip, input_list)

red_hat_counter = 0
blue_hat_counter = 0

for s_char in s:
  if s_char == ""R"":
    red_hat_counter += 1
  else:
    blue_hat_counter += 1

if red_hat_counter > blue_hat_counter :
  print(""Yes"")
else:
  print(""No"")"
"n = int(input())
h = list(map(int, input().split()))
cnt = 0
mx = 0
for i in range(n-1) :
    if h[i+1] <= h[i] :
        cnt += 1
    else :
        mx = max(mx, cnt)
        cnt = 0
mx = max(mx, cnt)
print(mx)
"
"s = input()
t = input()
n, m = len(s), len(t)

for i in range(n - m, -1, -1):
    match = True
    for j in range(m):
        if s[i + j] != '?' and s[i + j] != t[j]:
            match = False
            break
    if match:
        print(s[:i].replace('?', 'a') + t + s[i + m:].replace('?', 'a'))
        exit()
print(""UNRESTORABLE"")
"
"import math
N = float(input())
if(N%2==0):
  print(1/2)
else:
  print((math.floor(N/2)+1)/N)"
"D = [int(_) for _ in input().split()]

def solve(D):
    N = D[0]
    M = D[1]
    K = D[2]
    
    for i in range(N+1):
        for j in range(M+1):
            if (i*(M-j) + (N-i)*j) == K:
                return ""Yes""

    return ""No""

print(solve(D))"
"N, K =map(int, input().split())
A=list(map(int, input().split()))

def gcd(a, b):
	while b:
		a, b = b, a%b
	return a

g=0
max_a=0
for a in A:
	g=gcd(g, a)
	max_a=max(max_a, a)

if K%g==0 and K<=max_a:
	print(""POSSIBLE"")
else:
	print(""IMPOSSIBLE"")"
"N = int(input())
X = list(map(int, input().split()))
X_sorted = sorted(X)
pre_med_index = (N // 2) - 1
pos_med_index = N // 2
import bisect

for i in range(N):
    if X[i] <= X_sorted[pre_med_index]:
        print(X_sorted[pos_med_index])
    else:
        print(X_sorted[pre_med_index])
"
"n,m,d = [int(i) for i in input().split()]
x = 2
if d == 0 :x=1
print((n-d)*x*(m-1)/(n*n))"
"num = input().split()
num_i = [int(s) for s in num]

a,b,c = num_i
min_1 = a+b
min_2 = b+c
min_3 = c+a

min_a1 = min(min_1, min_2)
min_a = min(min_a1, min_3)
print(min_a)"
"from collections import deque
import sys
input = sys.stdin.readline

n = int(input())
l = deque()

for _ in range(n):
    op = input().strip().split()
    if op[0] == ""insert"":
        l.appendleft(op[1])
    elif op[0] == ""delete"":
        if op[1] in l:
            l.remove(op[1])
    elif op[0] == ""deleteFirst"":
        l.popleft()
    elif op[0] == ""deleteLast"":
        l.pop()
print("" "".join(l))

"
"N = input()
for i in N:
  if i == '9':
    print('Yes')
    exit()
print('No')"
"from math import floor, ceil, sqrt, factorial, log, gcd
from itertools import accumulate, permutations, combinations, product, combinations_with_replacement
from bisect import bisect_left, bisect_right
from collections import Counter, defaultdict
from heapq import heappop, heappush, heappushpop
import sys
INF = float('inf')
mod = 10**9+7


def lcm(a, b): return a * b / gcd(a, b)

# 1 2 3
# a, b, c = LI()


def LI(): return list(map(int, sys.stdin.buffer.readline().split()))

# a = I()


def I(): return int(sys.stdin.buffer.readline())

# abc def
# a, b = LS()


def LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()

# a = S()


def S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')

# 2
# 1
# 2
# [1, 2]


def IR(n): return [I() for i in range(n)]

# 2
# 1 2 3
# 4 5 6
# [[1,2,3], [4,5,6]]


def LIR(n): return [LI() for i in range(n)]

# 2
# abc
# def
# [abc, def]


def SR(n): return [S() for i in range(n)]

# 2
# abc def
# ghi jkl
# [[abc,def], [ghi,jkl]]


def LSR(n): return [LS() for i in range(n)]

# 2
# abcd
# efgh
# [[a,b,c,d], [e,f,g,h]]


def SRL(n): return [list(S()) for i in range(n)]


def main():
    n = I()
    lst = LI()
    ans = lst[0]
    for i in range(1, n):
        ans = gcd(ans, lst[i])
    print(ans)


if __name__ == ""__main__"":
    main()
"
"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
sA = sum(a)
sB = sum(b)

# Ai ≤ Bi: Ai++ができるので，問題なし
#  - このとき (Bi - Ai) // 2回数は j として選んでOK
#
# Ai > Bi: i以外を選んで，Biを嵩上げする必要がある
# - 選んだjは A[j] + 2 ≤ B[j] が必要
# - Biは1ずつしか増えないので，これは-d回必要
#


diff = [b[i] - a[i] for i in range(n)]
count = 0
for d in diff:
    if d > 0: # Ai ≤ Bi
        count += d // 2  # 余る分
    else:     # Ai ≥ Bi
        count -= -d      # 嵩上げ

# 余る分が多ければ，嵩上げできる
if count >= 0:
    print(""Yes"")
else:
    print(""No"")"
"x = int(input())
print(""Yes"" if x >= 30 else ""No"")"
"S = input()
N = len(S)

ans = 0
i = 0
while i < N and S[i]=='>':
    i += 1
ans += i*(i+1)//2

arr = [i]
while i < N:
    while i < N and S[i]=='<':
        i += 1
    arr.append(i)
    if i==N: break
    while i < N and S[i]=='>':
        i += 1
    arr.append(i)

arr = [b-a for a,b in zip(arr,arr[1:])]
for a,b in zip(arr[::2],arr[1::2]):
    if a<b: a,b = b,a
    ans += a*(a+1)//2
    ans += b*(b-1)//2
if len(arr)%2:
    ans += arr[-1]*(arr[-1]+1)//2

print(ans)"
"m,d=map(int,input().split())
ans=0
for i in range(2,m+1):
  for j in range(22,d+1):
    s=str(j)
    if int(s[1])<2:
      continue
    if i==int(s[0])*int(s[1]):
      ans+=1
print(ans)"
"(a, b, c) = (int(i) for i in input().split())
count = 0
for i in range(a, (b + 1)):
    if c % i == 0:
        count = count + 1
print(count)"
"import sys

stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


a, p = nm()
p = p + a * 3
print(p // 2)
"
"n = int(input())
a = list(map(int,input().split()))
b = list(map(int,input().split()))
cnt = 0
for i in range(n):
    if a[i] >= b[i]:
        cnt += b[i]
    else:
        cnt += a[i]
        b[i] -= a[i]
        cnt += min(b[i],a[i+1])
        a[i+1] -= min(b[i],a[i+1])
print(cnt)"
"N, T = map(int, input().split())

ans = float('inf')

for i in range(N):
    c, t = map(int, input().split())
    if t <= T:
        ans = min(ans, c)
            
if ans == float('inf'):
    print('TLE')
else:
    print(ans)"
"import math
def better(l, ans):
    for i in range(2, n):
        ans[i] = min(ans[i - 1] + abs(l[i]-l[i - 1]), ans[i - 2] + abs(l[i]-l[i - 2]))
    return ans
n = int(input())
l = list(map(int, input().split()))
ans = [0] * n
ans[1] = abs(l[1]-l[0])
print(better(l, ans)[len(ans)-1])"
"import math

ans = 0
S = input()
l = len(S)
ans = l * (l-1) //2 + 1
alpha = {}
for c in S:
    if c not in alpha:
        alpha[c] = 0
    ans -= alpha[c]
    alpha[c] += 1
print(ans)
"
"n = int(input())
abl = [tuple(map(int, input().split())) for _ in range(n)]
abl.sort()

a_max = abl[-1][0]
b_min = abl[-1][1]
ans = a_max + b_min
print(ans)"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")


n,k,l = list(map(int, input().split()))
from collections import defaultdict
ns0 = defaultdict(list)
ns1 = defaultdict(list)
for i in range(k):
    p,q = map(int, input().split())
    p-=1;q-=1
    ns0[p].append(q)
    ns0[q].append(p)
for i in range(l):
    p,q = map(int, input().split())
    p-=1;q-=1
    ns1[p].append(q)
    ns1[q].append(p)
def sub(ns):
    seen = [None]*n
    num = 1
    for i in range(n):
        if seen[i] is not None:
            continue
        q = [i]
        seen[i] = num
        while q:
            u = q.pop()
            for v in ns[u]:
                if seen[v] is not None:
                    continue
                seen[v] = num
                q.append(v)
        num += 1
    return seen

s1 = sub(ns0)
s2 = sub(ns1)

import gc
del ns0, ns1
gc.collect()

d1 = [None]*(max(s1)+1)
d2 = [None]*(max(s2)+1)
def update(d,ind,i):
    if d[ind] is None:
        d[ind] = set([i])
    else:
        d[ind].add(i)
for i in range(n):
    update(d1,s1[i],i)
    update(d2,s2[i],i)
#     d1[s1[i]].add(i)
#     d2[s2[i]].add(i)
d = {}
ans = [None]*n
for i in range(n):
    u,v = s1.pop(), s2.pop()
    if (u,v) not in d:
        d[u,v] = len(d1[u] & d2[v])
    ans[-(i+1)] = d[u,v]
write("" "".join(map(str, ans)))"
"n=int(input())
x=0
for i in range(n):
    if i==0:
        continue
    elif n//i==n/i:
        x+=(n//i)-1
    else:
        x+=n//i
     
print(x)"
"string=list(input())
n=len(string)
s=set()
ans=10**4

for target in string:
    if target in s:
        continue
    
    cnt=0
    tmp_max=0
    for i in string:
        if i!=target:
            cnt+=1
        else:
            tmp_max=max(tmp_max,cnt)
            cnt=0
    tmp_max=max(tmp_max,cnt)
    ans=min(ans,tmp_max)
        
print(ans)"
"a_len = int(input())
a_ar = sorted([int(n) for n in input().split("" "")])
b_len = int(input())
b_ar = [int(n) for n in input().split("" "")]
dp = [0 for n in range(2001)]
for a in a_ar:
    new_dp = dp[:]
    new_dp[a] = 1
    for i,d in enumerate(dp):
        if d and i + a <= 2000:
            new_dp[i + a] = 1
        elif i + a > 2000:
            break
    dp = new_dp
for b in b_ar:
    if dp[b]:
        print(""yes"")
    else:
        print(""no"")"
"import sys


def input(): return sys.stdin.readline().strip()
def I(): return int(input())
def LI(): return list(map(int, input().split()))
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def S(): return input()
def LS(): return input().split()


INF = float('inf')


n, a, b, c, d = LI()
a, b, c, d = a - 1, b - 1, c - 1, d - 1
s = S()

# 連続した岩がないか
for i in range(a + 1, max(c, d) - 1):
    if s[i:i + 2] == '##':
        print('No')
        sys.exit()

if c < d:
    print('Yes')
    sys.exit()

else:
    # どこかで a が b を追い越す必要がある
    # b がどこに居ても追い越せるための 3マス連続の空きマスがあるか
    for i in range(b, d + 1):
        if s[i - 1:i + 2] == '...':
            print('Yes')
            sys.exit()
    print('No')
"
"def yakusu(n):
    a = []
    for i in range(1, int(n*0.5)+1):
        if n % i == 0:
            a.append(i)
    a.append(n)
    return a

A, B = map(int, input().split())
b = yakusu(B)
if A in b:
    print(A + B)
else:
    print(B - A)"
"n=int(input())
a=list(map(int,input().split()))

f=0
b=sum(a)
m=abs(a[0]-sum(a[1:]))
for i in range(n-1):
    f+=a[i]
    b-=a[i]
    m=min(m,abs(f-b))
print(m)"
"A, B, C = map(int, input().split())
K = int(input())

for _ in range(K):
    if A >= B:
        B *= 2
    elif B >= C:
        C *= 2

if A < B < C:
    print('Yes')
else:
    print('No')
"
"n = int(input())
vn = list(map(int, input().split()))
cn = list(map(int, input().split()))
ans = 0

for i in range(n):
    if vn[i] - cn[i] > 0:
        ans += vn[i] - cn[i]

print(ans)"
"contest = input().split()
print(""A"" + contest[1][0] + ""C"")"
"s = list(map(int, input().split()))
n = int(input()) * 100
ss = [s[0] * 4, s[1] * 2, s[2], s[3] // 2]
ll = [25, 50, 100, 200]
cost = 0
while n > 0:
    if n >= 200:
        pass
    elif n >= 100:
        ss = ss[:3]
        ll = ll[:3]
    elif n >= 50:
        ss = ss[:2]
        ll = ll[:2]
    else:
        ss = ss[:1]
        ll = ll[:1]
    ssm = ss.index(min(ss))
    cnt = n // ll[ssm]
    cost += s[ssm] * cnt
    n -= ll[ssm] * cnt
print(cost)"
"N = int(input())
l = []
for _ in range(N):
  s, t = input().split()
  t = int(t)
  l.append([s, t])
X = input()

ans = 0
found = False
for s in l:
  if found:
    ans += s[1]
    continue
  if s[0] == X:
    found = True
    
print(ans)"
"n, k = map(int, input().split())
c = 0

for i in range(1,n + 1):
	if i % 2 != 0:
		c += 1

if k <= c:
	print(""YES"")
else:
	print(""NO"")"
"cin = open(0).read().strip().split('\n')
n = int(cin[0])
v = [list(map(lambda x: int(x)-1, a.split(' ')[2:])) for a in cin[1:]]

import queue
q = queue.Queue()
q.put(0)

dist = [-1]*n
dist[0] = 0
seen = [False]*n
while not q.empty():
    num = q.get()
    seen[num] = True
    for a in v[num]:
        if dist[a] != -1: continue
        dist[a] = dist[num] + 1
        q.put(a)

for idx, num in enumerate(dist):
    print(idx+1, num)
"
"#! env python
# -*- coding: utf-8 -*-

import os
import sys

# ac_py.main.py
# Date: 2020/06/07
# Filename: main.py 

__author__ = 'acto_mini'
__date__ = ""2020/06/07""


def main():
    a, b = map(int, input().split())
    if (a * b) % 2:
        print(""Odd"")
    else:
        print(""Even"")


if __name__ == '__main__':
    main()
"
"import sys, re

def echo(A):
    for i, a in enumerate(A):
        if i < len(A) - 1:
            sys.stdout.write('%d ' % a)
        else:
            sys.stdout.write('%d\n' % a)

def insertionSort(A, N):
    echo(A)
    for i in range(1, N):
        v = A[i]
        j = i - 1
        while j >= 0 and A[j] > v:
            A[j + 1] = A[j]
            j -= 1
        A[j + 1] = v
        echo(A)


n = int(raw_input())
a_text = raw_input()
splits = re.split(' ', a_text)
a = []
for i, s in enumerate(splits): 
    if s:
        a.append(int(s))

insertionSort(a, n)"
"s = list(input())
l = len(s)

ans = 0

for bit in range(2 ** (l-1)):
    f = s[0]
    for i in range(l-1):
        if ((bit >> i) & 1):
            f += '+'
        f += s[i+1]

    ans += sum(map(int, f.split(""+"")))
print(ans)"
"n=int(input())
a=list(map(int,input().split()))
p=[0 for i in a]
p[0]=2*sum(a[::2])-sum(a)
for i in range(n-1):
    p[i+1]=2*a[i]-p[i]
print(*p)"
"# -*- coding: utf-8 -*-
""""""
Created on Fri Sep 18 07:10:00 2020

@author: liang
""""""


# -*- coding: utf-8 -*-
""""""
Created on Fri Sep 18 00:26:07 2020

@author: liang
""""""

""""""
コーナーケース１:
    重複があるとき　not coprime
    ただし、1の重複は除く
""""""
import math
C = 10**6
N = int(input())
judge = [False]*(C+1)
A = [int(x) for x in input().split()]

f = True
for a in A:
    if judge[a] == True and a != 1:
        f = False
    judge[int(a)]=True


#print(judge[:10])
def solve(f):
    
    ans = A[0]
    #線形探索 O(N)
    for i in range(N):
        ans = math.gcd(ans,A[i])
    #print(""ans"",a)
    if ans != 1:
        return ""not coprime""
    
    flag = True
    #エラトステネスの篩 O(N log N)
    for i in range(2,C+1):
        count = 0
       #if d[i] == True:
        for j in range(i,C+1,i):
            if judge[j] == True:
                count += 1
            if count == 2:
                flag = False
                break
        #        d[j] = False
        if not flag:
            break
    
    if flag == True and f == True:
        return ""pairwise coprime""
    
    return ""setwise coprime""

print(solve(f))
#print(len(A))"
"def gcd(a, b):
	if a < b:
		tmp = a
		a = b
		b = tmp
	
	r = a % b
	while r != 0:
		a = b
		b = r
		r = a % b

	return b

if __name__ == '__main__':
	l = list(map(int, input().split()))
	x = l[0]
	y = l[1]

	ans = gcd(x, y)
	print(ans)"
"import sys
N, *AB = [int(x) for x in input().split()]
As, Bs, Ag, Bg = map(lambda x : x - 1, AB)
S = input()
for (s, g) in [(As, Ag), (Bs, Bg)]:
    if '##' in S[s : g + 1]:
        print(""No"")
        sys.exit()

if Bg < Ag:  # AがBを飛び越える必要がある
    if '...' not in S[Bs - 1 : Bg + 2]:
        print(""No"")
        sys.exit()

print(""Yes"")"
"n,m=map(int,input().split())

def find(x):
    if par[x]<0:
        return x
    else:
        par[x]=find(par[x])
        return par[x]

def union(x,y):
    x,y=find(x),find(y)
    if x!=y:
        if x>y:
            x,y=y,x
        par[x]+=par[y]
        par[y]=x
M=[]
for i in range(m):
    x,y=map(int,input().split())
    M.append([x-1,y-1])

ans=0

for i in range(m):
    X=M[:i]+M[i+1:]
    par = [-1] * n
    for x in X:
        union(x[0],x[1])
    if [p<0 for p in par].count(1)>1:
        ans+=1
print(ans)
"
"import sys
sys.setrecursionlimit(10**5+100)

N,M=map(int,input().split())
G=[[] for _ in range(N)]
for _ in  range(M):
    xi,yi=map(int,input().split())
    G[xi-1].append(yi-1)

dp=[-1]*N #各ノードを始点とした時の最長経路

def rec(v):
    if dp[v]!=-1:
        return dp[v]
    
    res=0

    for nv in G[v]:
        res=max(res,rec(nv)+1)
    
    dp[v]=res
    return res

ans=0
for v in range(N):
    ans=max(ans,rec(v))
print(ans)"
"A, B, C, D = map(int, input().split())
areaA = A*B
areaB = C*D
result = areaA if (areaA > areaB) else areaB
print(result)
"
"
def resolve():
    N = int(input())
    S = input()
    left, right, cnt = 0,0,0

    for s in S:
        if s == ""("":
            cnt += 1
        else:
            cnt -= 1
        if cnt < 0:
            right += 1
            cnt = 0

    if cnt>0:
        left = cnt

    ans = ""(""*right + S + "")""*left
    print(ans)

if __name__ == ""__main__"":
    resolve()"
"a,b,x=map(int,input().split())
print(""YES"" if a<=x and x-a<=b else ""NO"")"
"def selectionSort(a):
    count = 0
    for i in range(len(a)):
        mini = i
        for j in range(i,len(a)):
            if a[j] < a[mini]:
                mini = j
        if i != mini:
            ret = a[i]
            a[i] = a[mini]
            a[mini] = ret
            count += 1
    print("" "".join(map(str,a)))
    print(count)
n = int(input())
a = list(map(int,input().split()))
selectionSort(a)"
"H, N = map(int,input().split())
A = list(map(int,input().split()))
if H > sum(A):
    print('No')
else:
    print('Yes')"
"s = input()
print(s.replace(s[3], '8', 1))"
"s = input()


boin = ['a', 'i', 'u', 'e', 'o']

if s in boin:
    print(""vowel"")
else:
    print(""consonant"")
"
"a, b, k = map(int, input().split())

if (a >= k):
    aa = a - k
    bb = b
else:
    aa = 0
    bb = max(0, b - (k - a))

print(aa, bb)
"
"A = int(input())
print((A//2)*((A+1)//2))"
"def main():
  N = int(input())
  S = input()
  
  cnt = 0
  
  for i in range(N-2):
    if S[i] == 'A':
      if S[i+1] == 'B':
        if S[i+2] == 'C':
          cnt += 1
  print(cnt)
  
  
main()"
"n = int(input())
l = [list(map(int, input().strip().split())) for i in range(n)]
cnt = 0
for i in l:
    cnt += len([j for j in range(i[0], i[1]+1)])
print(cnt)"
"import math

def koch(d,x1,y1,x2,y2):
    if d == 0:
        return

    xs = (2*x1+x2)/3
    ys = (2*y1+y2)/3
    xt = (x1+2*x2)/3
    yt = (y1+2*y2)/3

    xu = (xt-xs)*math.cos(math.pi/3) - (yt-ys)*math.sin(math.pi/3) + xs
    yu = (xt-xs)*math.sin(math.pi/3) + (yt-ys)*math.cos(math.pi/3) + ys


    koch(d-1,x1,y1,xs,ys)
    print(xs,ys)
    koch(d-1,xs,ys,xu,yu)
    print(xu,yu)
    koch(d-1,xu,yu,xt,yt)
    print(xt,yt)
    koch(d-1,xt,yt,x2,y2)
    
n = int(input())
print(0.00000000,0.00000000)
koch(n,0.0,0.0,100.0,0.0)
print(100.00000000,0.00000000)"
"a, b = [int(i) for i in input().split()]

ans = 0
ans += a - 1
if b >= a:
    ans += 1
print(ans)
"
"import math
a, b = map(str, input().split())
a2 = int(a)
b2 = int(b.replace('.', ''))
print(int((a2 * b2)//100))"
"a = input().split()
if -1000 > int(a[0]):
    print('')
elif 1000 < int(a[0]):
    print('')    
elif -1000 > int(a[1]):
    print('')
elif 1000 < int(a[1]):
    print('')    
elif int(a[0]) < int(a[1]):
    print('a < b')
elif int(a[0]) > int(a[1]):
    print('a > b')
elif int(a[0]) == int(a[1]):
    print('a == b')
"
"N, K = map(int, input().split())

ans = 0
for a in range(1, N + 1):
    r = N % a
    ans += (N // a) * max(a - K, 0) + min(r, max(0, r + 1 - K))
print(ans)
"
"def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a

def resolve():
    N = int(input())
    a = list(map(int, input().split()))
    ans = 0
    for i in a:
        ans += prime_factorize(i).count(2)

    print(ans)

    return

resolve()"
"s=input()

if len(s)==2:
    print(s)
else:
    for i in [2,1,0]:
        print(s[i], end="""")
    print("""")"
"n,x=map(int,input().split())
l=list(map(int,input().split()))
haneru=0
cnt=1
for i in l:
  haneru+=i
  if haneru<=x:
    cnt+=1
    
  else:
    break
    
print(cnt)"
"from collections import defaultdict


def main():
    counter = defaultdict(int)
    H, W = list(map(int, input().split(' ')))
    for _ in range(H):
        A = input()
        for a in A:
            counter[a] += 1
    if H % 2 == W % 2 == 0:
        # 全ての個数が4の倍数ならOK
        for cnt in counter.values():
            if cnt % 4 != 0:
                print('No')
                return
        print('Yes')
    elif H % 2 == 0 and W % 2 == 1:
        non_quad_chars = 0
        for cnt in counter.values():
            if cnt % 4 == 1 or cnt % 4 == 3:
                print('No')
                return
            elif cnt % 4 == 2:
                non_quad_chars += 1
        if 2 * non_quad_chars <= H and (H - 2 * non_quad_chars) % 4 == 0:
            print('Yes')
        else:
            print('No')
    elif H % 2 == 1 and W % 2 == 0:
        non_quad_chars = 0
        for cnt in counter.values():
            if cnt % 4 == 1 or cnt % 4 == 3:
                print('No')
                return
            elif cnt % 4 == 2:
                non_quad_chars += 1
        if 2 * non_quad_chars <= W and (W - 2 * non_quad_chars) % 4 == 0:
            print('Yes')
        else:
            print('No')
    else:
        center_filled = False
        non_quad_chars = 0
        for cnt in counter.values():
            if cnt % 4 == 1 or cnt % 4 == 3:
                if center_filled:
                    print('No')
                    return
                center_filled = True
                if (cnt - 1) % 4 == 2:
                    non_quad_chars += 1
            elif cnt % 4 == 2:
                non_quad_chars += 1
        if 2 * non_quad_chars <= H + W - 2 and (H + W - 2 - 2 * non_quad_chars) % 4 == 0:
            print('Yes')
        else:
            print('No')


if __name__ == '__main__':
    main()"
"from functools import reduce
from fractions import gcd
import math
import bisect
import itertools
import sys
input = sys.stdin.readline
INF = float(""inf"")


# 処理内容
def main():
    X = int(input())
    print(10 - X // 200)
    


if __name__ == '__main__':
    main()"
"a, b, c, d = map(int, input().split())
n = a + b - c - d 
if n < 0:
        print('Right')
elif n == 0:
        print('Balanced')
else:
        print('Left')"
"n=int(input())
print(0)
a=input()
d={}
if a==""Vacant"":
    exit(0)
elif a==""Male"":
    d[""Male""] = 1
    d[""Female""] = 2
else:
    d[""Male""] = 2
    d[""Female""] = 1
print(n-2)
a=input()
if a==""Vacant"":
    exit(0)
elif d[a]==2:
    print(n-1)
    exit(0)

M=n-2
m=0

while M-m>=2:
    x=(M+m+1)//2

    print(x)
    a=input()
    if a==""Vacant"":
        exit(0)

    if (x+d[a])%2==1:
        m=x
    else:
        M=x
        
    x=(M+m+1)//2

print(M)
a=input()
if a==""Vacant"":
    exit(0)
print(m)
a=input()
if a==""Vacant"":
    exit(0)
"
"r = int(input())
g = int(input())
goal = g * 2 - r
print(goal)
"
"s=input()
p=True
t=""""
l=s
while p==True:
    p=False
    f=l[0:8]
    if f==""dreamera"":
        t +=""dream""
        l=l[5:]
        p=True
    f=l[0:7]
    if p==False and f==""dreamer"":
        t += ""dreamer""
        l=l[7:]
        p=True
    f=l[0:6]
    if p==False and f==""eraser"":
        t+=""eraser""
        l=l[6:]
        p=True
    f=l[0:5]
    if p==False and f==""erase"":
        t+=""erase""
        l=l[5:]
        p=True
    if p==False and f==""dream"":
        t+=""dream""
        l=l[5:]
        p=True
if s==t:
    print(""YES"")
else:
    print(""NO"")"
"
N = int(input())
p = list(map(int, input().split()))

cnt = 0

for i in range(len(p)):
    if p[i] == i+1:
        if p[i] == N:
            p[i-1], p[i] = p[i], p[i-1]
        else:
            p[i], p[i+1] = p[i+1], p[i]
        cnt += 1

print(cnt)
"
"#19
r,g,b,n = map(int,input().split())
cnt = 0

for i in range(n//r+1):
    for j in range(n//g+1):
        if r*i+g*j>n:
            break
        elif (n-(r*i+g*j))%b == 0:
            cnt += 1

print(cnt)"
"import sys
from collections import defaultdict, deque, Counter
import math
 
# import copy
from bisect import bisect_left, bisect_right
# import heapq
 
# sys.setrecursionlimit(1000000)
 
# input aliases
input = sys.stdin.readline
getS = lambda: input().strip()
getN = lambda: int(input())
getList = lambda: list(map(int, input().split()))
getZList = lambda: [int(x) - 1 for x in input().split()]
 
INF = 10 ** 20
MOD = 10**9 + 7
divide = lambda x: pow(x, MOD-2, MOD)
 

def makebin(arr):
    ret = 0
    for num in arr:
        ret += 2 ** (num - 1)

    return ret

def main():
    n, m = getList()
    dp = [INF] * (2 ** n)
    dp[0] = 0
    for i in range(m):
        a, b = getList()
        tgt = getList()
        kagi = makebin(tgt)
        for i, d in enumerate(dp):
            if d != -1:
                dp[i|kagi] = min(dp[i|kagi], d + a)
        # print(dp, kagi)

    if dp[-1] == INF:
        print(-1)
        return 
    print(dp[-1])
    # print(0&1)?






 
if __name__ == ""__main__"":
    main()
   "
"n = int(input())
a = list(map(int,input().split()))
mid = sum(a) / len(a)
b = float('inf')
for i, j in enumerate(a):
  sa = abs(mid - j)
  if(sa < b):
    b = sa
    ans = i
print(ans)
"
"n = int(input())
x = list(map(int, input().split()))

import numpy as np
ary = np.array(x)
ranks = ary.argsort()
rank_dict = {index:rank for rank,index in enumerate(ranks, start=1)}

MID=n//2
upper = x[ranks[MID]]
lower = x[ranks[MID-1]]
for i in range(n):
    rank = rank_dict[i]
    if rank <= MID:
        print(upper)
    else:
        print(lower)"
"#
# 　　  ⋀_⋀　 
#　　  (･ω･)  
# .／ Ｕ ∽ Ｕ＼
#  │＊　合　＊│
#  │＊　格　＊│ 
#  │＊　祈　＊│ 
#  │＊　願　＊│ 
#  │＊　　　＊│ 
#      ￣
#
import sys
sys.setrecursionlimit(10**6)
input=sys.stdin.readline
from math import floor,ceil,sqrt,factorial,log #log2ないｙｐ
from heapq import heappop, heappush, heappushpop
from collections import Counter,defaultdict,deque
from itertools import accumulate,permutations,combinations,product,combinations_with_replacement
from bisect import bisect_left,bisect_right
from copy import deepcopy
inf=float('inf')
mod = 10**9+7
def pprint(*A): 
    for a in A:     print(*a,sep='\n')
def INT_(n): return int(n)-1
def MI(): return map(int,input().split())
def MF(): return map(float, input().split())
def MI_(): return map(INT_,input().split())
def LI(): return list(MI())
def LI_(): return [int(x) - 1 for x in input().split()]
def LF(): return list(MF())
def LIN(n:int): return [I() for _ in range(n)]
def LLIN(n: int): return [LI() for _ in range(n)]
def LLIN_(n: int): return [LI_() for _ in range(n)]
def LLI(): return [list(map(int, l.split() )) for l in input()]
def I(): return int(input())
def F(): return float(input())
def ST(): return input().replace('\n', '')
def main():
    N=I()
    TA=LLIN(N)
    C=1
    D=1
    for t,a in TA:
        n = max((C+t-1)//t , (D+a-1)//a)
        # n = (max(int(ceil(C/t)),int(ceil(D/a))))
        C,D = n*t,n*a
    ans = C+D
    print(int(ans))
if __name__ == '__main__':
    main()"
"from collections import Counter

N = int(input())
a = list(input().split())
seq = [int(a[i]) for i in range(N)]
Cons = Counter(seq)

num = list(Cons.items())
count = 0

for i in range(len(num)):
    dif = int(num[i][1]) - int(num[i][0])
    count += (dif if dif >= 0 else int(num[i][1]))

print(count)"
"N,M = map(int,input().split())
A = [input().strip() for _ in range(N)]
B = [input().strip() for _ in range(M)]
ind = 0
for i in range(N-M+1):
    for j in range(N-M+1):
        flag = 0
        for k in range(M):
            for l in range(M):
                if B[k][l]!=A[i+k][j+l]:
                    flag = 1
                    break
            if flag==1:break
        if flag==0:
            ind = 1
            break
    if ind==1:break
if ind==1:
    print(""Yes"")
else:
    print(""No"")"
"n = int(input()[-1])

if n in [2, 4, 5, 7, 9]:
    print(""hon"")
elif n == 3:
    print(""bon"")
else:
    print(""pon"")"
"import sys
input=sys.stdin.readline

a,c=map(int,input().split())
ans=a+c/2
print(int(ans))"
"# ALDS1 : Dictionary

def main():
    n = input()
    dic = {}
    for i in xrange(n):
        command, ope = raw_input().split()
        if command == ""insert"":
            dic[ope] = 1
        elif command ==""find"":
            if ope in dic:
                print ""yes""
            else:
                print ""no""

if __name__ == '__main__':
    main()"
"import math

if __name__ == ""__main__"":
    D, G = map(int, input().split())
    p_c_l = [list(map(int, input().split())) for _ in range(D)]
    _min = sum([p_c[0] for p_c in p_c_l])
    for i in range(2 ** D):
        count = 0
        total = 0
        bins = '{:0={}b}'.format(i, D)
        incomplete_index = int(bins.rfind('0'))
        for index, _bin in enumerate(bins):
            if _bin == '0':
                continue
            total += 100 * (index + 1) * p_c_l[index][0] + p_c_l[index][1]
            count += p_c_l[index][0]
        if incomplete_index == -1:
            break
        remaining = G - total
        if remaining <= 0:
            if count < _min:
                _min = count
            continue
        incomplete_p = 100 * (incomplete_index + 1)
        incomplete_ans_num = math.ceil(remaining / incomplete_p)
        incomplete_p_num = p_c_l[incomplete_index][0]
        if incomplete_ans_num >= incomplete_p_num:
            continue
        count += incomplete_ans_num
        if count < _min:
            _min = count

    print(_min)
"
"K = int(input())
odd = (K + 1) // 2
even = K - odd
print(odd * even)
"
"s = []
for e in input().split():
    s.append(e if e.isdigit() else str(eval(s.pop(-2)+e+s.pop())))
print(*s)"
"import itertools
N, M, Q = map(int, input().split())
a = [0] * Q
b = [0] * Q
c = [0] * Q
d = [0] * Q
for i in range(Q):
    a[i], b[i], c[i], d[i] = map(int, input().split())

cc = [i for i in range(1, M+1)]
ans = 0

for A in itertools.combinations_with_replacement(cc, N):
    A = list(A)
    t = 0
    for i in range(Q):
        if A[b[i]-1] - A[a[i]-1] == c[i]:
            t += d[i]
    ans = max(ans, t)

print(ans)"
"n = int(input())
L = []

for x in range(3,n+1):
    if x % 3 == 0:
        L.append(x)
    else:
        i = x
        while i != 0:
            if i % 10 == 3:
                L.append(x)
                break
            else : i /= 10

print """",

while L != []:
    print L.pop(0),"
"n = int(input())
xy = [list(map(int, input().split())) for _ in range(n)]
xy.sort()
vectors = set()
for i in range(n-1):
    for j in range(i+1, n):
        xi, yi = xy[i]
        xj, yj = xy[j]
        if xj-xi == 0 and yj-yi == 0:
            continue
        unit_vector = (xj-xi, yj-yi)
        vectors |= {unit_vector}
ans = n
for vector in vectors:
    cnt = 0
    for i in range(n-1):
        for j in range(i+1, n):
            xi, yi = xy[i]
            xj, yj = xy[j]
            if vector == (xj-xi, yj-yi):
                cnt += 1
    ans = min(ans, n-cnt)
print(ans)
"
"import sys

sys.setrecursionlimit(10**7)


def dfs(s, to, ans, p=-1):
    for v in to[s]:
        if v == p: continue
        ans[v] += ans[s]
        dfs(v, to, ans, s)


def main():
    N, Q = map(int, input().split())
    to = [[] for _ in range(N)]
    ans = [0] * N

    for _ in range(N - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        to[a].append(b)
        to[b].append(a)
    
    for _ in range(Q):
        p, x = map(int, input().split())
        ans[p-1] += x
    dfs(0, to, ans)
    
    print(*ans)


if __name__ == ""__main__"":
    main()
"
"a,b = input().split()
x = int(a+b)
flag = 0
for i in range(400):
    if i**2==x:
        flag = 1
        break
if flag==1:
    print(""Yes"")
else:
    print(""No"")"
"N,A,B=map(int,input().split())

if A<B:
    if N>2:
        ans=(B-A)*(N-2)+1
    elif N==2:
        ans=1
    else:
        ans=0
elif A==B:
    if N>=1:
        ans=1
    else:
        ans=0
else:
    ans=0

print(ans)"
"import bisect

s = input()
t = input()

d = dict()

for i, ch in enumerate(s):
    if ch in d:
        d[ch].append(i)
    else:
        d[ch] = [i]

ret = 0
cindex = -1

for ch in t:
    if ch not in d:
        print(-1)
        exit()
    else:
        ls = d[ch]
        index = bisect.bisect_right(ls, cindex)
        index = 0 if (index == len(ls)) else index
        if cindex < ls[index]:
            ret += (ls[index] - cindex)
            cindex = ls[index]
        else:
            ret += len(s) + ls[index] - cindex
            cindex = ls[index]

print(ret)
"
"a=sorted(map(int,input().split("" "")))
print(a[0]+a[1])"
"def i():
	return int(input())
def i2():
	return map(int,input().split())
def s():
	return str(input())
def l():
	return list(input())
def intl():
	return list(int(k) for k in input().split())

n = i()
if n == 1:
	print(""Hello World"")
else:
	a = i()
	b = i()
	print(a+b)"
"import sys
X,A,B=map(int,sys.stdin)
print((X-A)%B)
"
"cnt = 0
n = int(input())
lst = list(map(int, input().split()))
for i in range(n):
    for j in range(n-1,i,-1):
        if lst[j] < lst[j-1]:
            lst[j-1:j+1] = lst[j], lst[j-1]
            cnt += 1
print(*lst)
print(cnt)"
"ans = ''

for i in range(3):
   ans += input()[i]

print(ans)"
"n=int(input())
l=list(map(int,input().split()))
cs1=0
s1=0
for i,a in enumerate(l):
    cs1+=a
    if i%2==0:
        if cs1>=0:
            s1+=abs(cs1)+1
            cs1=-1
    else:
        if cs1<=0:
            s1+=abs(cs1)+1
            cs1=1
cs2=0
s2=0
for i,a in enumerate(l):
    cs2+=a
    if i%2==0:
        if cs2<=0:
            s2+=abs(cs2)+1
            cs2=1
    else:
        if cs2>=0:
            s2+=abs(cs2)+1
            cs2=-1
print(min(s1,s2))
"
"# import sys
# input = sys.stdin.readline
import itertools

# 持っているビスケットを叩き、1枚増やす
# ビスケット A枚を 1円に交換する
# 1円をビスケット B枚に交換する
def main():
    h, w = input_list()
    count = 0
    for _ in range(h):
        s = list(input())
        count += s.count('#')
    if h+w-1 == count:
        print('Possible')
    else:
        print('Impossible')

def input_list():
    return list(map(int, input().split()))


def input_list_str():
    return list(map(str, input().split()))


if __name__ == ""__main__"":
    main()
"
"W, H, x, y, r = map(int, input().split())
if x - r < 0 or x + r > W or y - r < 0 or y + r > H:
    print('No')
else:
    print('Yes')
"
"def resolve():
  n, a, b, c, d = map(int, input().split())
  a -= 1
  b -= 1
  c -= 1
  d -= 1
  s = input()

  # a と c の間に ## があったらだめ
  for i in range(a, c):
    if s[i] == '#' and s[i+1] == '#':
      print('No')
      return
  # b と d の間に ## があったらだめ
  for i in range(b, d):
    if s[i] == '#' and s[i+1] == '#':
      print('No')
      return
  # a が b を飛び越えないと行けない場合  b - d の間に ... がないとだめ
  if b < c and d < c:
    flag = False
    for i in range(b-1, d):
      if s[i] == '.' and s[i+1] == '.' and s[i+2] == '.':
        flag = True
    if not flag:
      print('No')
      return
  print('Yes')

  return

if __name__ == ""__main__"":
  resolve()
"
"from collections import defaultdict
def f(s):
  return int(s) - 1

N, K = map(int, input().split())
P = list(map(f, input().split()))
C = list(map(int, input().split()))

loop = []

first = -1
x = -1
loop_mem = []
cnt = 0
score = 0

rem = set(range(N))

while len(rem) > 0:
  if first < 0:
    first = rem.pop()
    x = first
  loop_mem.append(x)
  if x != first:
    rem.remove(x)
  cnt += 1
  score += C[x]
  if first != P[x]:
    x = P[x]
  else:
    loop.append((loop_mem, cnt, score))
    first = -1
    loop_mem = []
    cnt = 0
    score = 0

ans = -1e10
for loop_mem, cnt, score in loop:
  imax = [-1e10 for _ in range(cnt)]
  imax[0] = 0
  for x in loop_mem:
    tmp = 0
    for j in range(1, cnt):
      tmp += C[x]
      imax[j] = max(imax[j], tmp)
      x = P[x]
  for j in range(2, cnt):
    imax[j] = max(imax[j-1], imax[j])
  if score <= 0:
    ans = max(ans, imax[-1])
  else:
    M = K // cnt
    m = K % cnt
    if M >= 1:
      tmp = max(score * M + max(imax[m], 0), score * (M-1) + imax[-1])
    else:
      tmp = imax[m]
    ans = max(ans, tmp)

print(ans)
"
"n = int(input())
s = set()

for i in range(1,int(n**0.5)+1):
    if n//i == n%i:
        s.add(i)
    x = (n-i)//i
    if x and n//x == n%x:
        s.add(x)
print(sum(list(s)))

"
"A,B,K=map(int,input().split())
print([n for n in range(1,min(A,B)+1) if A%n==B%n==0][-K])"
"a=input()
b=input()
if(a==b[0:len(b)-1] and len(b)-len(a)==1):
    print('Yes')
else:
    print('No')"
"board, dp = [], []
bingo = False

for _ in range(3):
    board.append(list(map(int, input().split()))) 
    dp.append([0, 0, 0])

N = int(input())

for _ in range(N):
    num = int(input())

    for r in range(3):
        for c in range(3):
            if num == board[r][c]:
                dp[r][c] = 1

for i in range(3):
    if dp[i][0] == dp[i][1] == dp[i][2] == 1 or dp[0][i] == dp[1][i] == dp[2][i] == 1:
        bingo = True
        print(""Yes"")
        break

if not bingo:
    if dp[0][0] == dp[1][1] == dp[2][2] == 1 or dp[0][2] == dp[1][1] == dp[2][0] == 1:
        print(""Yes"")
    else:
        print(""No"")

"
"N = int(input())
A = [0]*N
B = [0]*N
for i in range (N):
    A[i],B[i] = map(int, input().split())
ctr = 0
for i in range (N-1, -1, -1):
    k = (A[i] + ctr) % B[i]
    if k != 0:
        ctr += B[i] - k
print(ctr)"
"# -*- coding: utf-8 -*-
from fractions import Fraction
from collections import Counter
import math

import sys
# sys.setrecursionlimit(10**6)
# buff_readline = sys.stdin.buffer.readline
buff_readline = sys.stdin.readline
readline = sys.stdin.readline

INF = 2**62-1


def read_int():
    return int(buff_readline())


def read_int_n():
    return list(map(int, buff_readline().split()))


def read_float():
    return float(buff_readline())


def read_float_n():
    return list(map(float, buff_readline().split()))


def read_str():
    return readline().strip()


def read_str_n():
    return readline().strip().split()


def error_print(*args):
    print(*args, file=sys.stderr)


def mt(f):
    import time

    def wrap(*args, **kwargs):
        s = time.time()
        ret = f(*args, **kwargs)
        e = time.time()

        error_print(e - s, 'sec')
        return ret

    return wrap


class Mod:
    def __init__(self, m):
        self.m = m

    def add(self, a, b):
        return (a + b) % self.m

    def sub(self, a, b):
        return (a - b) % self.m

    def mul(self, a, b):
        return ((a % self.m) * (b % self.m)) % self.m

    def div(self, a, b):
        return self.mul(a, pow(b, self.m-2, self.m))

    def pow(self, a, b):
        return pow(a, b, self.m)


def fract(a, b):
    if a == 0 and b == 0:
        return (0, 0)
    if b == 0:
        return (1, 0)
    f = Fraction(a, b)
    return f.numerator, f.denominator


@mt
def slv(N, AB):
    adb = Counter()
    for a, b in AB:
        k = fract(a, b)
        adb[k] += 1
    M = Mod(1000000007)
    ans = 1
    done = {(0, 0)}
    for k, v in adb.items():
        if k in done:
            continue
        a, b = k
        kk = fract(-b, a)
        done.add(k)
        done.add(kk)

        n = adb[kk]
        t = M.sub(M.pow(2, v) + M.pow(2, n), 1)
        ans = M.mul(ans, t)
    ans = M.add(ans, adb[(0, 0)])
    return M.sub(ans, 1)


def main():
    N = read_int()
    AB = [read_int_n() for _ in range(N)]
    print(slv(N, AB))


if __name__ == '__main__':
    main()
"
"N,X=map(int,input().split())
L=list(map(int,input().split()))
d=0
i=0
ans=0


while d<=X:
    ans+=1
    d+=L[i]
    i+=1
    if i==N:
        if d<=X:
            ans+=1
        break


print(ans)
"
"N=int(input())
A=list(map(int,input().split()))
B=list(map(int,input().split()))
if sum(A)<sum(B):
    print(-1)
else:
    a=0
    s=0
    l=[]
    for i in range(N):
        if A[i]<B[i]:
            a+=1
            s+=B[i]-A[i]
        else:
            l.append(A[i]-B[i])
    l.sort(reverse=1)
    for i in range(len(l)):
        if s<=0:
            break
        s-=l[i]
        a+=1
    print(a)"
"import queue

q = queue.Queue()
bool = True


def bfs():
    q.put(0)
    while not q.empty():
        now = q.get()
        for i in nodes[now]:
            if dist[i] != -1:
                continue
            dist[i] = dist[now] + 1
            q.put(i)
            ans[i] = now
    # bool = False


N, M = map(int, input().split())
nodes = [[] for i in range(N)]
idxStock = []
for i in range(M):
    a, b = map(int, input().split())
    nodes[a - 1].append(b - 1)
    nodes[b - 1].append(a - 1)

dist = [-1] * N
ans = [-1] * N
bfs()
if bool:
    print(""Yes"")
    for i in range(1, N):
        print(ans[i] + 1)
else:
    print(""No"")
"
"n=int(input())
*l,=map(int, input().split())
solv=0
max=max(l) +1
count=[0 for i in range(max)]
for i in l:
    for j in range(i,max,i):
        count[j] += 1
for k in l:
    if count[k] == 1:
        solv += 1
print(solv)"
"n = int(input())
a = []
b = []
for _ in range(n):
  A, B = map(int, input().split())
  a.append(A)
  b.append(B)
x = 0
for i in range(1, n+1):
  a[-i] += x
  if a[-i]%b[-i] != 0: x += b[-i] - a[-i]%b[-i]
print(x)"
"s = input()

cnt = 0
for i in s:
    if (i == 'o'):
        cnt += 1
print('YES' if len(s) - cnt <= 7 else 'NO')
"
"numbers = raw_input()
input_numbers = raw_input().split()
print("" "".join(input_numbers[::-1]))"
"H,N=map(int,input().split())
list=[]
for i in map(int,input().split()):
    list.append(i)
if H - sum(list) <= 0:
    print('Yes')
else:
    print('No')


"
"from operator import mul
from functools import reduce
def comb2(n,r):
    r = min(n - r, r)
    if r == 0: return 1
    over = reduce(mul, range(n, n - r, -1))
    under = reduce(mul, range(1, r + 1))
    return over // under
def comb3(n, r):
    if n - r < r: r = n - r
    if r == 0: return 1
    if r == 1: return n

    numerator = [n - r + k + 1 for k in range(r)]
    denominator = [k + 1 for k in range(r)]

    for p in range(2,r+1):
        pivot = denominator[p - 1]
        if pivot > 1:
            offset = (n - r) % p
            for k in range(p-1,r,p):
                numerator[k - offset] /= pivot
                denominator[k] /= pivot

    result = 1
    for k in range(r):
        if numerator[k] > 1:
            result *= int(numerator[k])

    return result


import sys
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
mod = 10**9 + 7
inf = float('inf')
ans = int(0)

N, M, K = LI()

cou = int(0)
#maxL = N + M -2
L = int(0)
#距離i+1の組み合わせ

#for i in range(maxL):
for j in range(N):
    L += (N - j - 1) * (M ** 2) * (j + 1)
for j in range(M):
    L += (M - j - 1) * (N ** 2) * (j + 1)
#    for j in range(i+2):
#        if i>1 and i+1>j>0:
#            L[i] += max((N-j)*(M-(1+i)+j),0)*(i+1)*2
#        else:
#            L[i] += max(((N - j) * (M - (1 + i) + j)), 0) * (i + 1)

cou = comb3(N*M-2,K-2)%mod

ans = cou *L%mod

print(ans)"
"import sys
from collections import deque
input = sys.stdin.readline


def main():
    N, M = map(int, input().split())
    edge = [[] * N for _ in range(N)]
    new_edge = [[] * N for _ in range(N)]
    for _ in range(M):
        u, v = map(int, input().split())
        u -= 1
        v -= 1
        edge[u].append(v)
        
    S, T = map(int, input().split())
    S -= 1
    T -= 1
    d = [[float('inf')] * 3 for _ in range(N)]
    q = deque([])
    q.append((S,0))
    d[S][0] = 0
    while q:
        v,l = q.popleft()
        nl = (l + 1) % 3
        for nv in edge[v]:
            if d[nv][nl] != float('inf'):
                continue
            q.append((nv,nl))
            d[nv][nl] = d[v][l] + 1
    if d[T][0] == float('inf'):
        print(-1)
    else:
        print(d[T][0] // 3)
            



if __name__ == ""__main__"":
    main()"
"D,T,S=map(int,input().split())
print('Yes' if S*T>=D else 'No')
"
"n, k = map(int, input().split())
kk = 0
if n%2 != 0:
    kk = (n+1)//2
else:
    kk = n//2

if k <= kk:
    print(""YES"")
else:
    print(""NO"")
"
"def main():
    x, y = map(int, input().split())

    if x in [1, 3, 5, 7, 8, 10, 12] and y in [1, 3, 5, 7, 8, 10, 12]:
        print(""Yes"")
    elif x in [4, 6, 9, 11] and y in [4, 6, 9, 11]:
        print(""Yes"")
    elif x in [2] and y in [2]:
        print(""Yes"")
    else:
        print(""No"")


if __name__ == ""__main__"":
    main()
"
"s = input()

n = len(s) // 2
if ""hi""*n == s:
  print(""Yes"")
else:
  print(""No"")"
"N,M,K=map(int,input().split())
def cmb(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    r = min(r, n-r)
    return g1[n] * g2[r] * g2[n-r] % mod
mod=10**9+7
g1=[1,1]
g2=[1,1]
inverse=[0,1]
for i in range(2,N*M+1):
    g1.append((g1[-1]*i)%mod)
    inverse.append((-inverse[mod%i]*(mod//i))%mod)
    g2.append((g2[-1]*inverse[-1])%mod)
ans=0
for i in range(1,N):
  ans+=i*(N-i)*M*M
for j in range(1,M):
  ans+=j*(M-j)*N*N
ans*=cmb(N*M-2,K-2,mod)
print(ans%mod)"
"a,b=map(int,input().split())
x=max(a,b)
y=min(a,b)

z=max(x-1,y)
print(x+z)"
"a, b, c = map(int, input().split())
a, b = b, a
a, c = c, a
print(f'{a} {b} {c}')"
"import sys

for line in sys.stdin:
    datas =line.split()
    if (len(datas)):
        v = int(datas[0]) + int(datas[1])
        print(len(str(v)))
    else:
        break"
"from sys import stdin
a, b= [int(_) for _ in stdin.readline().rstrip().split()]
if a > 0:
    print(""Positive"")
elif a <= 0 and b >= 0:
    print(""Zero"")
elif (b - a) % 2:
    print(""Positive"")
else:
    print(""Negative"")"
"a = [x for x in range(1, 6)]
b = [int(x) for x in input().split()]

for i in range(5):
    if a[i] != b[i]:
        print(i+1)
"
"import sys
import math
input = sys.stdin.readline

N, K = map(int, input().split())
A = list(map(int, input().split()))

S = sum(A)
L = []
for s in range(1, S+1):
    if s > math.sqrt(S) + 1:
        break
    if S % s == 0:
        L.append(S//s)
        L.append(s)
L.sort(reverse = True)

for l in L:
    T = [a%l for a in A]
    T.sort()
    ans = False
    R = []
    r = 0
    for t in T:
        r += t
        R.append(r)
    #print(l, R)
    for i in range(N):
        #print(i, R[-1])
        if R[i] > K:
            break
        if R[N-1] == l*(N-i-1):
            ans = True
            break
        
    if ans:
        print(l)
        break
"
"#
# abc065 b
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
3
1
2""""""
        output = """"""2""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""4
3
4
1
2""""""
        output = """"""-1""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""5
3
3
4
2
4""""""
        output = """"""3""""""
        self.assertIO(input, output)


def resolve():
    N = int(input())
    a = [0] + [int(input()) for _ in range(N)]
    A = [0] * (N+1)

    p = 1
    ans = 0
    while True:
        A[p] += 1
        if A[p] == 2:
            ans = ""-1""
            break
        ans += 1
        p = a[p]
        if p == 2:
            break

    print(ans)


if __name__ == ""__main__"":
    # unittest.main()
    resolve()
"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 7)

n = int(input())
d, x = map(int, input().split())
ans = x
for _ in range(n):
    a = int(input())
    ans += ((d + a - 1) // a)

print(ans)
"
"#!/usr/bin/env python3

from collections import defaultdict


def II(): return int(input())
def MII(): return map(int, input().split())
def LII(): return list(map(int, input().split()))

def main():
    N, M = MII()

    d = defaultdict(int)

    py = []
    for i in range(M):
        P, Y = MII()
        py.append((i, P, Y))
    py = sorted(py, key=lambda x: x[2])
    

    ans = [''] * M
    for i, j, k in py:
        d[j] += 1
        ans[i] = f'{j:06d}{d[j]:06d}'
    
    print('\n'.join(ans))


if __name__ == '__main__':
    main()
"
"# coding: utf-8
n, x = map(int,input().split())
A = list(map(int,input().split()))
S = sum(A)
for i in range(n-1):
    s = A[i+1] + A[i]
    if s > x:
        if A[i+1] >= s-x:
            A[i+1] -= (s-x)
        else:
            t = s-x-A[i+1]
            A[i+1] = 0
            A[i] -= t
print(S - sum(A))"
"n,m=map(int,input().split())
x=100*n+1800*m
p=2**(-m)
print(int(x/p))"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")


s = input()
if s[-1]==""s"":
    s += ""es""
else:
    s += ""s""
print(s)"
"# https://atcoder.jp/contests/code-festival-2016-quala/tasks/codefestival_2016_qualA_c
# 辞書最小にしたい
# 前から貪欲 (OK)
# 実装が分からない

from bisect import bisect_left
from string import ascii_lowercase

s = input()
k = int(input())

ac = list(ascii_lowercase) + ['a']
dmap = {}
for i in range(len(ac) - 1):
    # dmap[ac[i]] = min(i, len(ac) - i - 1)
    dmap[ac[i]] = len(ac) - i - 1
dmap['a'] = 0

ans = list(s)
output = []

for idc, c in enumerate(ans):
    if k >= dmap[c]:
        output.append('a')
        k -= dmap[c]
    else:
        output.append(c)

k %= 26
# 最後に残ったkをすすめる
new_char = chr(ord(output[-1]) + k)
output[-1] = new_char
print("""".join(output))"
"n, m = map(int, input().split())
err = False
ans = list('*' * n)

for _ in range(m):
    si, ci = map(int, input().split())
    if ans[si - 1] == '*' or ans[si - 1] == str(ci):
        ans[si - 1] = str(ci)
    else:
        err = True

if ans[0] == '0' and n != 1:
    err = True

if ans[0] == '*':
    if n == 1:
        ans[0] = '0'
    else:
        ans[0] = '1'

if err:
    print(-1)
else:
    print(''.join(ai if ai != '*' else '0' for ai in ans))
"
"ma = lambda :map(int,input().split())
lma = lambda :list(map(int,input().split()))
tma = lambda :tuple(map(int,input().split()))
ni = lambda:int(input())
yn = lambda fl:print(""Yes"") if fl else print(""No"")
import collections
import math
import itertools
import heapq as hq

N = ni()
mx = 3501
for w in range(1,mx):
    for h in range(1,mx):
        t1=N*w*h
        t2=4*w*h-N*h-N*w
        if t2<=0:continue
        if t1%t2==0:
            print(h,w,t1//t2)
            exit()
"
"x,k,d=list(map(int,input().split()))
#print(x,k,d)
result=abs(x)-k*d
swithn=0

if result<0:
    if k%2==1:
        x-=d
    result=min(x%(2*d),-x%(2*d))
print(result)"
"import sys
input = sys.stdin.readline
 
N,K=map(int,input().split())
mod=10**9+7
 
L=[i for i in range(K+1)]
 
for i in range(1,K):
    for j in range(i*2,K+1,i):
        L[j]-=L[i]
 
ANS=0
for i in range(1,K+1):
    ANS=(ANS+pow(K//i,N,mod)*L[i])%mod
 
print(ANS)"
"a, b, c = map(int, input().split())
if a + b + 1 >= c:
  ans = b + c
else:
  ans = b + a + b + 1
print(ans)"
"S = int(input())
A = [S]
Count = 1
while True:
    Count += 1
    if A[-1]%2==0:
        Next = A[-1]//2
        if Next in A:
            print(Count)
            break
        else:
            A.append(Next)
    else:
        Next = 3*A[-1]+1
        if Next in A:
            print(Count)
            break
        else:
            A.append(Next)"
"def union(parent,size,a,b):
    x=find(parent,a)
    y=find(parent,b)
    if x!=y:
        if size[x]<size[y]:
            parent[x]=y 
            size[y]=size[x]+size[y]
        else:
            parent[y]=x 
            size[x]=size[x]+size[y]
    return parent,size 
def find(parent, a):
    while a != parent[a]:
            parent[a]=parent[parent[a]]
            a=parent[a]
    return a
n,q=map(int,input().split())
size=[1]*n
ans=0 
l=[int(i) for i in input().split()]
parent=[i for i in range(n)]
for i in range(q):
    a,b=map(int,input().split())
    parent,size=union(parent,size,a-1,b-1)
for i in range(n):
    if find(parent,i)==find(parent,l[i]-1):
        ans+=1 
print(ans)"
"string = input()
num = int(input())
o = 0
for _ in range(num):
    source = input().split(' ')
    if source[0] == 'print':
        print(string[int(source[1]):int(source[2]) + 1])
    elif source[0] == 'replace':
        string = string[:int(source[1])] + source[3] + string[int(source[2]) + 1:]
    else:
        string = string[:int(source[1])] + string[int(source[1]):int(source[2]) + 1 ][::-1] + string[int(source[2]) + 1:]
"
"a = int(input())
b = int(input())
c = int(input())
x = int(input())

cnt = 0

for a_idx in range(a + 1):
  for b_idx in range(b + 1):
    for c_idx in range(c + 1):
      total = 500 * a_idx + 100 * b_idx + 50 * c_idx
      if (total == x): cnt += 1

print(cnt)"
"import bisect,collections,copy,heapq,itertools,math,numpy,string
import sys
sys.setrecursionlimit(10**7)

A,B=list(map(int,input().split()))
C = math.gcd(A,B)

def factorization(n):
    arr = [[1,1]]
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])

    if temp!=1:
        arr.append([temp, 1])

    return arr

Cfac = factorization(C)
print(len(Cfac))
"
"K,X = map(int, open(0).read().split())
if 500 * K >= X:
    print('Yes')
else:
    print('No')"
"n,m = map(int,input().split())
print(n*m-n-m+1)"
"from sys import stdin
import sys
import math
from functools import reduce
import functools
import itertools
from collections import deque,Counter
from operator import mul
import copy
# ! /usr/bin/env python
# -*- coding: utf-8 -*-
import heapq

n = int(input())
a = list(map(int, input().split()))

p = [i-a[i] for i in range(n)]
q = [a[i]+i for i in range(n)]

pp = Counter(p)
qq = Counter(q)

ans = 0
for d in pp.items():
    ans += d[1] * qq[d[0]]

print(ans)






"
"n = int(input())
t = [0]
x = [0]
y = [0]
for i in range(n):
  t_, x_, y_ = map(int, input().split())
  t.append(t_)
  x.append(x_)
  y.append(y_)

for j in range(n):
  dt = t[j+1] - t[j]
  dx = abs(x[j+1] - x[j])
  dy = abs(y[j+1] - y[j])
  if dx+dy>dt or dt%2!=(dx+dy)%2:
    print('No')
    exit()
    
print('Yes')"
"a, b, c = map(int,input().split(' '))
k = int(input())

while k > 0:
    if c <= b:
        c *= 2
    elif b <= a:
        b *= 2
    k -= 1
    
    if a < b and b < c:
        print('Yes')
        break
else:
    print('No')
"
"X, A = input().split()
X=int(X)
A=int(A)

if X<A:
  print(0)
else:
  print(10)"
"from collections import defaultdict
h, w, m = map(int, input().split())
targets = defaultdict(int)
targets_count_yoko = defaultdict(int)
targets_count_tate = defaultdict(int)
for _ in range(m):
    y, x = map(int, input().split())
    y -= 1
    x -= 1
    targets_count_yoko[x] += 1
    targets_count_tate[y] += 1
    targets[(y, x)] = -1

max_row = max(targets_count_yoko.values())
max_line = max(targets_count_tate.values())
y_idx = defaultdict(bool)
x_idx = defaultdict(bool)
max_count_x = 0
max_count_y = 0
for i in range(w):
    if targets_count_yoko[i] == max_row:
        x_idx[i] = True
        max_count_x += 1
for i in range(h):
    if targets_count_tate[i] == max_line:
        y_idx[i] = True
        max_count_y += 1


ans = max_line + max_row
kumi = max_count_x*max_count_y
for key_y, key_x in targets.keys():
    if y_idx[key_y] and x_idx[key_x]:
        kumi -= 1
    if kumi == 0:
        break

if kumi == 0:
    print(ans-1)
else:
    print(ans)

"
"import sys
input = sys.stdin.readline

N, M = map(int, input().split())
S = list(map(int, input().split()))
T = list(map(int, input().split()))
mod = 10**9+7
dp = [[1] * (M+1) for _ in range(N+1)]
for i in range(1, N+1):
    for j in range(1, M+1):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]) % mod
        if S[i-1] == T[j-1]:
            dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % mod
print(dp[N][M])
"
"from itertools import accumulate
N = int(input())
W = list(map(int, input().split()))
S = list(accumulate(W))
print(min(abs(S[-1]-s-s) for s in S[:-1]))"
"s = input()
if s[0] == str(9) or s[1] == str(9):
  print(""Yes"")
else:
  print(""No"")"
"import math

a,b,c=map(int,input().split())
if(a==b):
    print(c)
elif(a==c):
    print(b)
else:
    print(a)"
"import sys
n = int(input())
sort_list = list(map(int,input().split()))

cnt = []
def merge(A, left,mid,right):
    n1 = mid -left
    n2 = right - mid
    L = [i for i in A[left : left + n1]]
    R = [i for i in A[mid : mid + n2]]
    L.append(sys.maxsize)
    R.append(sys.maxsize)

    i = 0
    j = 0
    c = 0
    for k in range(left,right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i + 1
        else:
            A[k] = R[j]
            j = j + 1
        c += 1

    cnt.append(c)

def mergesort(A,left,right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergesort(A,left,mid)
        mergesort(A,mid,right)
        merge(A,left,mid,right)

mergesort(sort_list, 0, len(sort_list))
print(' '.join([str(i) for i in sort_list]))
print(sum(cnt))

"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-

m = []
for i in range(0,10):
    m.append(int(input()))

for i in range(0,3):
    print(list(reversed(sorted(m)))[i])"
"s, t = input().split()
print(f""{t}{s}"")"
"import sys
input = sys.stdin.readline

n, m = [int(x) for x in input().split()]
g = [[] for _ in range(n)]

for _ in range(m):
    l, r, d = [int(x) for x in input().split()]
    g[l - 1].append((r - 1, d))
    g[r - 1].append((l - 1, -d))

d = [None] * n
visited = [0] * n

for i in range(n):
    if visited[i] != 0:
        continue
    stack = [i]
    d[i] = 1
    while stack:
        u = stack.pop()
        visited[u] = 1
        for v, d_ in g[u] :
            if d[v] is None:
                d[v] = d[u] + d_
                stack.append(v)
            else:
                if d[v] != d[u] + d_ :
                    print(""No"")
                    sys.exit()
print(""Yes"")
"
"a = raw_input().split("" "")
a.sort()
print ""%s %s %s"" % (a[0],a[1],a[2])"
"import sys

def resolve():
    N, K = list(map(int, input().split("" "")))
    A = list(map(int, input().split("" "")))
    res = 0
    covered = 0
    while True:
        if covered >= N:
            break
        if res == 0:
            covered = K
        else:
            covered += K - 1
        res += 1
    print(res)

if '__main__' == __name__:
    resolve()"
"n,k = map(int,input().split())
s = list(map(int,input().strip()))

data = [[],[]]
key = 1
cnt = 0
for i in range(n):
    if s[i] == key:
        cnt += 1
    
    else:
        data[key].append(cnt)
        key ^= 1
        cnt = 1
        
    if i == n-1:
        data[key].append(cnt)
    
if len(data[0]) == len(data[1]):
    data[1].append(0)

m = len(data[0])


if m <= k:
    print(n)
    exit()

tmp = data[1][0]
for i in range(k):
    tmp += data[0][i]
    tmp += data[1][i+1]

ans = tmp

for i in range(k,m):
    tmp -= data[0][i-k]
    tmp -= data[1][i-k]
    tmp += data[0][i]
    tmp += data[1][i+1]
    ans = max(ans,tmp)

print(ans)"
"X, A, B = int(input()), int(input()), int(input())
ans = (X-A)%B
print(ans)"
"N=int(input())
T,A=map(int,input().split())
H=[-1000]+list(map(int,input().split()))


M=10**10
X=0
for i in range(1,N+1):
    B=abs(1000*(T-A)-6*H[i])
    if B<=M:
        M=B
        X=i
print(X)
    
"
"N=int(input())
A=list(map(int,input().split()))

M=1000050

dp=[0 for i in range(M)]

ans=0
for x in A:
    if dp[x]!=0:
        dp[x]=2
        continue
    for i in range(x,M,x):
        dp[i]+=1

for x in A:
    if dp[x]==1:
        ans+=1

print(ans)
"
"import sys
import itertools
sys.setrecursionlimit(1000000000)
from heapq import heapify,heappop,heappush,heappushpop
import math
import collections


s = input()
n = len(s)-2
ans = s[0] + str(n) + s[-1]
print(ans)"
"n=int(input())
a=[int(input()) for i in range(n)]
c=sorted(a)
b=max(a)
for i in range(n):
  if a[i]==b:
    print(c[n-2])
  else:
    print(b)"
"_ = input()
S = input()
newS = S.replace(""ABC"", """")
print((len(S) - len(newS)) // 3)"
"n=int(input())
p=[int(input()) for i in range(n)]
l=[-1 for i in range(n)]
for i in range(n):
  l[p[i]-1]=i
ans=[]
ct=1
for i in range(n-1):
  if l[i]<l[i+1]:
    ct+=1
  else:
    ans.append(ct)
    ct=1
ans.append(ct)
ct=1
print(n-max(ans))"
"n = int(input())
s = input()
t = input()
for i in range(n+1):
    k = s[:i] + t
    if k[:n] == s:
        print(n+i)
        break"
"s=input()
x=[""eraser"",""erase"",""dreamer"",""dream"",]
t=[]
flag=0
for i in range(4):
    if x[i] in s:
        s=s.replace(x[i],""1"")
S=len(s)

for j in range(S) :
    if s[j]!=""1"":
        print(""NO"")
        flag+=1
        break

if flag==0:
    print(""YES"")"
"s=input()
yy = [""%02d"" % i for i in range(100)]
mm = [""%02d"" % i for i in range(1, 13)]
yymm = s[:2] in yy and s[2:] in mm
mmyy = s[:2] in mm and s[2:] in yy
print([""NA"",""MMYY"",""YYMM"",""AMBIGUOUS""][yymm*2+mmyy])
"
"h = int(input())
print(48-h)"
"n = int(input())
dishes = []
for _ in range(n):
    a, b = map(int, input().split())
    dishes.append((a+b, a, b))

dishes.sort(key=lambda x: -x[0])

ans = 0
for i in range(n):
    if i % 2 == 0:
        ans += dishes[i][1]
    else:
        ans -= dishes[i][2]

print(ans)"
"def main():
    N = int(input())
    v = list(map(int, input().split()))
    c = list(map(int, input().split()))
    ans = 0
    for i in range(N):
        if v[i] > c[i]:
            ans += (v[i] - c[i])
    print(ans)
main()

"
"n,k,s = map(int,input().split())
x = [0]*n
for i in range(k):
    x[i] = s
if s == 1000000000:
    for i in range(k,n):
        x[i] = s-1
else:
    for i in range(k,n):
        x[i] = s+1
for i in x:
    print(i,end = "" "")"
"n,m=map(int,input().split())
x=list(map(int,input().split()))
if n>=m:
    print(0)
    exit()

x=sorted(x)
l=[0]*(m-1)
for i in range(m-1):
    l[i]=x[i+1]-x[i]
    
l=sorted(l)[::-1]
dist=x[m-1]-x[0]-sum(l[:n-1])
print(dist)"
"S = input()

pre = """"
for s in S:
    if pre == s:
        print(""Bad"")
        exit()
    pre = s

print(""Good"")
"
"s = list(input())

ans = float('inf')
for i in range(len(s)-2):
    now = sum(t * 10**i for i, t in enumerate(list(map(int, s[i:i+3]))[::-1]))
    ans = min(ans, abs(now - 753))
print(ans)"
"def cost(x):
    cost = (x - ave)**2
    return cost


n = input()
a = list(map(int, input().split()))
ave = round(sum(a)/int(n))
print(sum(list(map(cost, a))))"
"from collections import defaultdict
import numpy as np
from itertools import permutations, combinations
n=int(input())
d=defaultdict(int)
def factorization(n):
    temp = n
    for i in range(2, int(n**0.5)+1):
        if temp%i==0:
            while temp%i==0:
                d[i]+=1
                temp //= i

    if temp!=1:
        d[temp]+=1
for i in range(2,n+1):
    factorization(i)
d=np.array(list(d.values()))
ans=0
ans+=len(d[d>=74])
d1=d[d>=2]
d2=d[d>=4]
for x,y in permutations(d1,2):
    if y>=24:
        ans+=1
for x,y in permutations(d2,2):
    if y>=14:
        ans+=1
ans1=0
for x,y,z in permutations(d1,3):
    if y>=4 and z>=4:
        ans1+=1
print(ans+ans1//2)"
"a,b,c,k=map(int,input().split())
num=a-b
if k%2==1:
    print((-1)*num)
else:
    print(num)"
"N = int(input())
if N % 2 == 0:
    print(N * (N-2) // 2)
    for i in range(1,N):
        for j in range(i+1, N+1):
            if i + j != N + 1:
                print(i, j)
else:
    print((N - 1) ** 2 // 2)
    for i in range(1, N-1):
        for j in range(i+1, N):
            if i + j != N:
                print(i, j)
    for i in range(1, N):
        print(i, N)"
"N,M,K = map(int,input().split())
MOD = 998244353

MAXN = N+5
fac = [1,1] + [0]*MAXN
finv = [1,1] + [0]*MAXN
inv = [0,1] + [0]*MAXN
for i in range(2,MAXN+2):
    fac[i] = fac[i-1] * i % MOD
    inv[i] = -inv[MOD%i] * (MOD // i) % MOD
    finv[i] = finv[i-1] * inv[i] % MOD

def comb(n,r):
    if n < r: return 0
    if n < 0 or r < 0: return 0
    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD

ans = 0
for i in range(K+1):
    if i==N: break
    n = N-i
    ans += M * pow(M-1,n-1,MOD) * comb(N-1,i)
    ans %= MOD
print(ans)"
"n,m = map(int,input().split())
memo2 = [False for i in range(n)]
memo = [0 for i in range(n)]
count1,count2 = 0,0
for i in range(m):
    p,l = input().split()
    p = int(p)-1
    if memo2[p]:
        continue
    else:
        if l == 'WA':
            memo[p]+=1
        else:
            memo2[p] = True
            count2 += 1
            count1+=memo[p]
print(count2,count1)"
"a = int(input())
print('ABC' if a<1200 else 'ARC')
"
"def main():
    N, D = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(N)]
    cnt = 0
    for a in A:
        if (a[0]**2 + a[1]**2)**0.5 <= D:
            cnt += 1
    print(cnt)


if __name__ == '__main__':
    main()"
"a, b, c = map(int, input().split())
print(c // a * b)"
"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

N, M = MI()

a = N * (N - 1) // 2
b = M * (M - 1) // 2

print(a + b)"
"# import bisect
# from collections import Counter, defaultdict, deque
# import copy
# from heapq import heappush, heappop, heapify
# from fractions import gcd
# import itertools
# from operator import attrgetter, itemgetter
# import math

import sys

# import numpy as np

ipti = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)

def main():
    a, p =list(map(int,ipti().split()))
    p += a*3
    print(p//2)

if __name__ == '__main__':
    main()"
"N = int(input())
A = sorted(list(map(int, input().split())))
dp = {}
quota = 0
res = 0
size = 0
streak = 1
for i in range(N-1):
  a = A[i]
  size += a
  if A[i+1] <= size*2:
    streak += 1
  else:
    streak = 1

print(streak)
"
"def main():
    a, b, c = map(int, input().split())
    if 21 < (a + b + c):
        print('bust')
    else:
        print('win')
    
main()"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

from math import ceil
a, b = mapint()
print(ceil((a+b)/2))"
"s = input()
print(""Bad"" if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] else ""Good"")"
"A=[0]*3
for i in range(3):
  A[i]=int(input())
#print(A)
ans=int((A[0]+A[1])*A[2]/2)
print(ans)"
"N=int(input())

A=[0]*N
B=[0]*N
for i in range(N):
    a,b=map(int, input().split())
    A[i]=a
    B[i]=b
count=0
#print(A,B)
for i in range(N-1,-1,-1):
    X=(A[i]+count)%B[i]
    if X!=0:
        res=B[i]-(A[i]+count)%B[i]
        count+=res

print(count)"
"class UnionFind():
    def __init__(self, n):
        self._n = n
        self._table = [-1]*n
        self._rank = [0]*n

    def _root(self, x):
        stack = []
        while self._table[x] >= 0:
            stack.append(x)
            x = self._table[x]
        for y in stack:
            self._table[y] = x
        return x
    
    def unite(self, x, y):
        x, y = self._root(x), self._root(y)
        if x == y:
            return
        elif self._rank[x] > self._rank[y]:
            self._table[x] += self._table[y]
            self._table[y] = x
        else:
            self._table[y] += self._table[x]
            self._table[x] = y
            if self._rank[x] == self._rank[y]:
                self._rank[y] += 1
    
    def find(self, x, y):
        return self._root(x) == self._root(y)

    def count(self, x):
        return -self._table[self._root(x)]
    
    def __str__(self):
        return str(list(self))
    def __repr__(self):           
        return repr(list(self))
    def __iter__(self):
        return (self._root(i) for i in range(n))

n, m, *AB = map(int, open(0).read().split())
ans = 0
for i in range(m):
    uf = UnionFind(n)
    for j, (a, b) in enumerate(zip(AB[::2], AB[1::2])):
        if i == j:
            continue
        uf.unite(a-1, b-1)
    ans += len(set(uf)) != 1
print(ans)"
"import math
import sys
import collections
import bisect
readline = sys.stdin.readline


def main():
    n = int(readline().rstrip())
    s = readline().rstrip()
    cnt = 0
    for i in range(1000):
        x = str(i).zfill(3)
        a = s[:-1].find(x[0])
        if a != -1:
            b = s[a + 1: -1].find(x[1])
            if b != -1:
                c = s[a + b + 2:].find(x[2])
                if c != -1:
                    cnt += 1

    print(cnt)


if __name__ == '__main__':
    main()
"
"# coding:UTF-8
import sys


def resultSur97(x):
    return x % (10 ** 9 + 7)


if __name__ == '__main__':
    # ------ 入力 ------#
    nl = list(map(int, input().split()))     # スペース区切り連続数字

    x = nl[0]
    sList = [input() for _ in range(x)]

    # ------ 処理 ------#
    sListSorted = sorted(sList)
    out = """"
    for s in sListSorted:
        out += s

    # ------ 出力 ------#
    print(""{}"".format(out))
    # if flg == 0:
    #     print(""YES"")
    # else:
    #     print(""NO"")
"
"X, Y = map(int, input().split())

x = 2*X-1/2*Y
y = -X + 1/2*Y

if x.is_integer() and y.is_integer() == True:
  if x >= 0 and y >= 0:
    print('Yes')
  else:
    print('No')
else:
  print('No')"
"
def main():
    n, a, b = map(int, input().split()) 

    ab_diff = abs(a-b)
    if ab_diff%2 == 0:
        print(ab_diff//2)
        return
    
    a_edge_diff = min(abs(a-1),abs(n-a))
    b_edge_diff = min(abs(b-1),abs(n-b))
    # near_diff = min(a_edge_diff, b_edge_diff)
    if a_edge_diff <= b_edge_diff:
        print(a_edge_diff+1+ (ab_diff-1)//2)
    else:
        print(b_edge_diff+1+ (ab_diff-1)//2)

if __name__ == ""__main__"":
    main()"
"n = int(input())
n1 = n//2
s = input()
s1 = s[n1:]
s2 = s[:n1]
if n % 2 != 0:
    print('No')
else:
    if s1 == s2:
        print('Yes')
    else:
        print('No')"
"a, b, c = list(map(int, input().split()))
n = b % a
if a * c <= b:
  print(c)
else:
  print(int((b - n) / a))"
"import sys
input = sys.stdin.readline

def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))

def main():
    mod=10**9+7
    N=I()
    if N%2==1:
        print(0)
        exit()
    
    ans=0
    
    for i in range(1,100):
        a=2*pow(5,i)
        ans+=N//a
        
    print(ans)
        
    
    

main()
"
"a,b,c,d = input()
print(""Yes"" if (a==b and b==c) or (b==c and c ==d) else ""No"")"
"n = input()
print('Yes' if '7' in n else 'No')"
"H, W, K = map(int, input().split())
grid = [input() for _ in range(H)]
ans = [[0] * W for _ in range(H)]

cnt = 1
for h in range(H):
    for w in range(W):
        if grid[h][w] == ""#"":
            ans[h][w] = cnt
            cnt += 1

# left -> right
for h in range(H):
    for w in range(1, W):
        if ans[h][w] == 0 and ans[h][w - 1] != 0:
            ans[h][w] = ans[h][w - 1]

# right -> left
for h in range(H):
    for w in range(W - 2, -1, -1):
        if ans[h][w] == 0 and ans[h][w + 1] != 0:
            ans[h][w] = ans[h][w + 1]

# top -> bottom
for h in range(1, H):
    for w in range(W):
        if ans[h][w] == 0 and ans[h - 1][w] != 0:
            ans[h][w] = ans[h - 1][w]

# bottom -> top
for h in range(H - 2, -1, -1):
    for w in range(W):
        if ans[h][w] == 0 and ans[h + 1][w] != 0:
            ans[h][w] = ans[h + 1][w]

for a in ans:
    print(*a)
"
"n = int(input())
nn = []
odd = 0
for i in range(1, n+1):
    if i % 2 == 1:
        odd += 1
    nn.append(i)
s = len(nn)
print(odd/s)
"
"#2問目
import math
MAX = 10 ** 9 + 7
N, M = map(int, input().split())
if(abs(N - M) > 1):
    print(0)
elif(abs(N - M) == 0):
    #犬と猿が同数いる時
    print((((math.factorial(N) % MAX) * (math.factorial(M) % MAX) * 2)) % MAX)
else:
    #犬と猿の差が1の時
    print(((math.factorial(N) % MAX) * (math.factorial(M) % MAX)) % MAX)"
"a,b=map(int,input().split());c=[a,b,a-1,b-1];c.sort();print(sum(c[-2:]))"
"def WarshallFloyd(d):
    v = len(mat)
    for k in range(v):
        for i in range(v):
            for j in range(v):
                d[i][j] = min(d[i][j],d[i][k]+d[k][j])

n,m,r = map(int, input().split())
ls = list(map(int, input().split()))
INF = 1001001001001
mat = [[INF]*n for _ in range(n)]
for i in range(m):
    u,v,c = map(int, input().split())
    u-=1
    v-=1
    mat[u][v]=c
    mat[v][u]=c

WarshallFloyd(mat)

from itertools import permutations

ans=INF
for p in permutations(ls):
    now=0
    for i in range(len(p)-1):
        now+=mat[p[i]-1][p[i+1]-1]
    ans=min(ans,now)

print(ans)




"
"A, B = map(int, input().split())
lst = [A+B, A-B, A*B]
lst.sort()
print(lst[-1])"
"import os
import re
import sys
from collections import defaultdict

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(10 ** 9)
INF = float(""inf"")
IINF = 10 ** 18
MOD = 10 ** 9 + 7
# MOD = 998244353

N = int(sys.stdin.buffer.readline())


def is_ok(s):
    ok = True
    for ng in ['AGC', 'GAC', 'ACG']:
        ok &= ng not in s
    ok &= not re.match(r'A.GC', s)
    ok &= not re.match(r'AG.C', s)
    return ok


# 最後が s である文字の数
dp = [defaultdict(int) for _ in range(N)]
for c in 'AGCT':
    for d in 'AGCT':
        for e in 'AGCT':
            if is_ok(c + d + e):
                dp[2][c + d + e] = 1

for i in range(3, N):
    for k in dp[i - 1].keys():
        for c in 'AGCT':
            if is_ok(k + c):
                dp[i][k[-2:] + c] += dp[i - 1][k]
                dp[i][k[-2:] + c] %= MOD

print(sum(dp[-1].values()) % MOD)
"
"import sys

if __name__ == '__main__':
  r = int(input())
  print(r * r)

"
"N = int(input())
P = list(map(int, input().split()))
Q = []
m = 10**17
for p in P:
    m = min(m, p)
    Q.append(m)
c = 0
for x, y in zip(P, Q):
    if x <= y:
        c += 1
print(c)
"
"from math import gcd
n,start = map(int,input().split())
x_ls = list(map(int, input().split()))
diff_ls = [0] * n

for i in range(n):
    diff_ls[i] = abs(start-x_ls[i])

ans = diff_ls[0]
for i in range(1,n):
    ans = gcd(ans,diff_ls[i])

print(ans)"
"def main():
    n, m = map(int, input().split())
    costs = [None]*m
    keys = [None]*m
    pattern = 2**n
    inf = 10**12
    dp = [inf]*pattern
    for i in range(m):
        costs[i] = int(input().split()[0])
        keys[i] = sum([1<<(int(i)-1) for i in input().split()])
    dp[0] = 0
    for i in range(pattern):
        for cost, key in zip(costs, keys):
            pi = i|key
            if dp[pi] > cost + dp[i]:
                dp[pi] = cost + dp[i]
    if dp[pattern-1] == inf:
        print(-1)
    else:
        print(dp[pattern-1])
        

if __name__ == ""__main__"":
    main()"
"x = list(map(int, input().split()))[1]
l = list(map(int, input().split()))
m = [0]
for i in l:
    if i+m[-1] <= x:
        m.append(i+m[-1])
    else:
        break
print(len(m))"
"# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
# from decorator import stop_watch
#
#
# @stop_watch
def solve(H, W, K, Si):
    Si = [[int(i) for i in S] for S in Si]
    ans = H + W
    for i in range(2 ** (H - 1)):
        h_border = bin(i).count('1')
        w_border = 0
        white_counts = [0] * (h_border + 1)
        choco_w = 0
        for w in range(W):
            choco_w += 1
            wc_num = 0
            tmp_count = [0] * (h_border + 1)
            for h in range(H):
                white_counts[wc_num] += Si[h][w]
                tmp_count[wc_num] += Si[h][w]
                if i >> h & 1:
                    wc_num += 1
            if max(white_counts) > K:
                if choco_w == 1:
                    break  # 1列の時点で > K の場合は条件を達成できない
                w_border += 1
                white_counts = tmp_count
                choco_w = 1
        else:
            ans = min(ans, h_border + w_border)
    print(ans)


if __name__ == '__main__':
    H, W, K = map(int, input().split())
    Si = [input() for _ in range(H)]
    solve(H, W, K, Si)

    # # test
    # from random import randint
    # from func import random_str
    # 
    # H, W, K = 10, 1000, randint(1, 100)
    # Si = [random_str(W, '01') for _ in range(H)]
    # print(H, W, K)
    # for S in Si:
    #     print(S)
    # solve(H, W, K, Si)
"
"from itertools import accumulate
from collections import defaultdict
from operator import mul
from functools import reduce

def cmb(n,r):
    r = min(n-r, r)
    if r == 0:
        return 1
    over = reduce(mul, range(n, n - r, -1))
    under = reduce(mul, range(1, r + 1))
    return over // under

def main():
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(accumulate(A))
    d = defaultdict(int)
    for i in range(N):
        B[i] %= M
        d[B[i]] += 1

    cnt = 0
    for i, j in d.items():
        if i == 0:
            cnt += j
        if j >= 2:
            cnt += cmb(j , 2)

    print(cnt)
    
    
            
        
if __name__ == ""__main__"":
    main()"
"n = int(input())
a = [input() for i in range(n)]

c0, c1, c2, c3 = 0, 0, 0, 0

for output in a:
    if output == 'AC':
        c0 += 1
    elif output == 'WA':
        c1 += 1
    elif output == 'TLE':
        c2 += 1
    elif output == 'RE':
        c3 += 1
        
        
print('AC x {}'.format(c0))
print('WA x {}'.format(c1))
print('TLE x {}'.format(c2))
print('RE x {}'.format(c3))"
"l,r=map(int,input().split())
m=2019
c=m-1
r=min(r,l+m-1)
for i in range(l,r):
    for j in range(i+1,r+1):
        s=i*j
        c=min(c,s%m)
print(c)
"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque
from itertools import combinations, permutations, accumulate, groupby, product
from bisect import bisect_left,bisect_right
from heapq import heapify, heappop, heappush
from math import floor, ceil,pi,factorial
from operator import itemgetter
def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))
def LI2(): return [int(input()) for i in range(n)]
def MXI(): return [[LI()]for i in range(n)]
def SI(): return input().rstrip()
def printns(x): print('\n'.join(x))
def printni(x): print('\n'.join(list(map(str,x))))
inf = 10**17
mod = 10**9 + 7

n=I()
lis=[]
for i in range(n):
    a,b=MI()
    lis.append([a,b,a+b])
lis.sort(key=lambda x:x[2],reverse=True)
ans=0
for i in range(n):
    if i%2==0:
        ans+=lis[i][0]
    else:
        ans-=lis[i][1]
print(ans)

"
"money = int(input())
cake = int(input())
donut = int(input())

x = 1
y = (money - cake)//donut

print(money - cake * 1 - donut * y)"
"
url = ""https://atcoder.jp//contests/abc072/tasks/arc082_b""

def main():
    n = input()
    p = list(map(int, input().split()))
    count = 0
    for i, v in enumerate(p):
        if i == len(p)-1 and i+1 == v:
            count += 1
            break
        if i+1 == v:
            p[i] = p[i+1]
            p[i+1] = v
            count += 1
    print(count)


if __name__ == '__main__':
    main()

"
"input = raw_input().split("" "")
height = int(input[0])
width = int(input[1])
print height * width, (height + width) * 2"
"s=input()
count=1
ans='Yes'
for i in s:
    if count%2==1:
        if i=='R' or i=='U' or i=='D':
            count+=1
            continue
        else:
            ans='No'
            break
    else:
        if i=='L' or i=='U' or i=='D':
            count+=1
            continue
        else:
            ans='No'
            break
print(ans)
"
"n = int(input())
a = [int(i) for i in input().split()]

num = 0

is_swapped = True
i = 0
while is_swapped:
    is_swapped = False
    for j in range(n-1, i, -1):
        if a[j] < a[j-1]:
            tmp = a[j]
            a[j] = a[j-1]
            a[j-1] = tmp
            is_swapped = True
            num += 1
    i += 1

print(' '.join([str(i) for i in a]))
print(num)
"
"(N,M),*ab = [tuple(map(int, s.split())) for s in open(0)]

ab.sort()

max_a = 0
min_b = float('inf')

ans = 1
for i, (a, b) in enumerate(ab):
    if min_b <= a:
        ans += 1
        max_a, min_b = a, b
    else:
        max_a = max(max_a, a)
        min_b = min(min_b, b)

print(ans)"
"import sys
sys.setrecursionlimit(500000)
MOD = 10**9+7

def input():
    return sys.stdin.readline()[:-1]

def mi():
    return map(int, input().split())

def ii():
    return int(input())

def i2(n):
    tmp = [list(mi()) for i in range(n)]
    return [list(i) for i in zip(*tmp)]

def g(x):
    if x <= 0:
        return 0
    tmp = x
    n = 0
    while tmp > 0:
        tmp //= 2
        n += 1
    l = [0]*n
    for i in range(n):
        if i==0:
            l[i] = 1 if x%4==1 or x%4==2 else 0
        else:
            l[i] = max(x%(1<<(i+1))-(1<<i)+1, 0)%2
    return sum(l[i]*(2**i) for i in range(n))


def main():
    A, B = mi()
    print(g(B)^g(A-1))

if __name__ == '__main__':
    main()
"
"n = int(input())
d = {}
ans = []

for i in range(n):
    order = list(map(str, input().split()))
    if order[0] == 'insert':
        d[order[1]] = i
    else:
        if d.__contains__(order[1]):
            ans.append('yes')
        else:
            ans.append('no')

print(*ans, sep='\n')

"
"def main():
    r = int(input())
    if r >= 2800:
        print(""AGC"")
    elif r >= 1200:
        print(""ARC"")
    else:
        print(""ABC"")


if __name__ == ""__main__"":
    main()
"
"# -*- coding: utf-8 -*-
import sys

N = int(input())
A = [int(input()) for _ in range(N)]


flag = False
for a in A:
    if a%2 == 1:
        flag = True
        break

if flag:
    print('first')
else:
    print('second')"
"import math

def modpow(a,b,mod=10**9+7):
    res=1
    a%=mod
    leng=int(math.log2(b))
    for i in range(leng,-1,-1):
        res=(res*res)%mod
        if (b>>i)&1:
            res=(res*a)%mod
    return res

def fact(x):
    ans=1
    for i in range(2,x+1):
        ans = (ans*i)%(10**9+7)
    return ans

def comb(n,r):
    return fact(n)*modpow(fact(r),10**9+5)*modpow(fact(n-r),10**9+5)%(10**9+7)

x,y=map(int,input().split(' '))
if (x+y)%3!=0 or 2*x-y<0 or 2*y-x<0:
    print(0)
else:
    x,y=max(x,y),min(x,y)
    d=x-y
    n=((x-2*d)//3)
    m=n+d
    print(comb(n+m,n))"
"def main():
    r, c = map(int, input().split())
    table = []
    for _ in range(r):
        table.append(list(map(int, input().split())))
    table.append([0] * (c+1))
    for index, line in enumerate(table[:-1]):
        table[index].append(sum(line))
        for index1, value in enumerate(table[index]):
            table[-1][index1] += value
    for line in [map(str, line) for line in table]:
        print(' '.join(line))
    return


if __name__ == '__main__':
    main()

"
"n=int(input())
k=int(input())
given_integer=1
#Option A:-To Increase The Value By double
#Option B:-To Increase Value By K

for i in range(0,n):
	given_integer=min(given_integer*2,given_integer+k)

print(int(given_integer))
"
"r = int(input())
print(""ABC"" if r < 1200 else ""ARC"" if r < 2800 else ""AGC"")"
"N = int(input())
 
for i in range(1, N + 1):
  if i + (i * 8) // 100 == N:
    print(i)
    break
else:
  print("":("")"
"n = int(input())
l = [int(input()) for _ in range(n)]
print(""second"" if all(a % 2 == 0 for a in l) else ""first"")"
"#!/usr/bin/env python3

def main():
    n, y = map(int, input().split())

    for i in range(n + 1):
        for j in range(n + 1):
            if n - i - j >= 0 and 10000 * i + 5000 * j + 1000 * (n - i - j) == y:
                print(i, j, n - i - j)
                exit()
    else:
        print(""-1 -1 -1"")


if __name__ == ""__main__"":
    main()
"
"n,a,b = map(int, input().split())
g = n//(a+b)
k = n-(a+b)*g
if k >= a:
    print(a+a*g)
else:
    print(a*g + k)"
"n = int(input())
s = []
for i in range(n):
  s_ = int(input())
  s.append(s_)

s.sort() 
total = sum(s)
t = [i for i in s if i % 10 != 0]
if total % 10 != 0:
  print(total)
elif len(t) > 0:
  print(total - t[0])
else:
  print(0)"
"INF = 10000000000
def merge(A,left,mid,right):
  count = 0
  L = A[left:mid] + [INF]
  R = A[mid:right] + [INF]
  i,j = 0,0
  for k in range(left, right):
    count += 1
    if L[i] <= R[j]:
      A[k]=L[i]
      i += 1
    else:
      A[k]=R[j]
      j += 1
  return count
def merge_sort(A,left,right):
  if left+1 < right:
    mid = (left+right)//2
    count_l = merge_sort(A,left,mid)
    count_r = merge_sort(A,mid,right)
    return merge(A,left,mid,right) + count_l + count_r
  return 0


n = int(input())
A = [int(i) for i in input().split()]
count = merge_sort(A, 0, n)
for i in range(n):
  if i:
    print("" "", end = """")
  print(A[i], end = """")
print()
print(count)  

"
"N, M, *xy = map(int, open(0).read().split())
boxes = [1] * N
is_red = [0] * N
is_red[0] = 1

for x, y in zip(*[iter(xy)] * 2):
    x -= 1
    y -= 1
    boxes[x] -= 1
    boxes[y] += 1
    if is_red[x]:
        if boxes[x] == 0:
            is_red[x] = 0
        is_red[y] = 1
print(sum(is_red))
"
"n,m = map(int,input().split())

if 2*n <= m:
  print(n+(m-2*n)//4)
elif 2*n > m:
  print(m//2)
"
"N = int(input())
p=0
if N < 105:
    print(0)
else:
    for n in range(1,  N+1, 2):
        ans = []
        for i in range(2, int(n**0.5)+1):
            while n % i == 0:
                ans.append(i)
                n //= i
        if n!=1:ans.append(n)

        A = 1
        sp = list(set(ans))
        for s in sp:
            A *= ans.count(s)+1
        if A == 8:
            p+=1

    print(p)"
"def get_neg(neg_list, k, mod):
    ans = 1
    neg_list.sort(reverse=True)
    for num in neg_list[:k]:
        ans = ans * num % mod
    return ans


def get_pos(pos_list, neg_list, k, mod):
    ans = 1
    nums = []
    neg_iter = iter(sorted(neg_list))
    pos_iter = iter(sorted(pos_list, reverse=True))
    if k % 2 == 1:
        ans *= pos_iter.__next__()
        k -= 1
        
    for a, b in zip(pos_iter, pos_iter):
        nums.append(a * b)

    for a, b in zip(neg_iter, neg_iter):
        nums.append(a * b)

    nums.sort(reverse=True)
    for num in nums[:k//2]:
        ans *= num
        ans %= mod
    return ans


def get_all(num_list, mod):
    ans = 1
    for num in num_list:
        ans = ans * num % mod
    return ans


def main():
    n, k = map(int, input().split())
    A = list(map(int, input().split()))
    mod = 10 ** 9 + 7
    
    if n == k:
        ans = get_all(A, mod)
        print(ans)
        return
    
    pos_list = []
    neg_list = []

    for a in A:
        if a >= 0:
            pos_list.append(a)
        else:
            neg_list.append(a)

    if k % 2 and not pos_list:
        ans = get_neg(neg_list, k, mod)
    else:
        ans = get_pos(pos_list, neg_list, k, mod)

    print(ans)


if __name__ == ""__main__"":
    main()
"
"n,a,b = map(int, input().split())

both = min(a,b)
any = max(0, (a+b) - n)

print(both, any)"
"N = int(input())
A = list(map(int, input().split()))

useable = []
memo = {}

for a in A:
    try:
        memo[a] += 1
    except:
        memo[a] = 1
    if memo[a] == 2:
        useable.append(a)
        memo[a] = 0

# print(useable)

if len(useable) < 2:
    print(0)
else:
    useable.sort()
    print(useable[-1] * useable[-2])
"
"A500 = int(input())
B100 = int(input())
C50 = int(input())
X = int(input())

c = 0
for i in range(A500+1):
  for j in range(B100+1):
    for k in range(C50+1):
      if X == i*500 + j* 100 + k*50:
        c+=1
print(c)
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N, A, B = mapint()
print(min(A, B), max((A+B-N), 0))"
"S=input()

if S[0]==""A"" and S[2:-1].count(""C"")==1:
	SC = S.index(""C"")
	if (S[1:SC]+S[SC+1:]).islower():
		print(""AC"")
	else:
		print(""WA"")
else:
	print(""WA"")
"
"s = input()
acm = 0

for i in s:
    acm = (acm + ord(i)-ord('0'))%9

if(acm):
    print(""No"")
else:
    print(""Yes"")"
"def main():
    s = input()
    t = input()
    ans = 'No'
    s2 = s * 2
    for i in range(len(s2)):
        if t == s2[i:i + len(s)]:
            ans = 'Yes'
            break
    print(ans)



if __name__ == '__main__':
    main()"
"#!/usr/bin python3
# -*- coding: utf-8 -*-

def main():
    N = int(input())
    ret = 10**9
    for a in range(1,N):
        b = N-a
        ret = min(ret,sum(map(int,list(str(a))))+sum(map(int,list(str(b)))))

    print(ret)

if __name__ == '__main__':
    main()"
"import math
import collections
import fractions
import itertools
import functools
import operator

def solve():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    for i in range(k, n):
        print(""Yes"") if a[i] > a[i-k] else print(""No"")
    return 0

if __name__ == ""__main__"":
    solve()"
"n=int(input())
s=input()
num=n
for i in range(1,n):
    if s[i-1]==s[i]:
        num-=1
print(num)
"
"import sys
import math

if __name__ == ""__main__"":
    num = int(sys.stdin.readline().strip())
    ans = 0
    for i in range(0, num):
        n = int(sys.stdin.readline().strip())
        flag = False
        for j in range(2, int(math.sqrt(n)) + 1):
            if n % j == 0:
                flag = True
                break
        if not flag:
            ans += 1
    print ans"
"N, K = map(int, input().split())
R, S, P = map(int, input().split())
T = input()

dp = [[0]*3 for _ in range(N+1)]
for i in range(1, N+1):
    if i <= K:
        dp[i][0] = int(T[i-1]=='s') * R
        dp[i][1] = int(T[i-1]=='p') * S
        dp[i][2] = int(T[i-1]=='r') * P
    else:
        dp[i][0] = max(dp[i-K][1], dp[i-K][2]) + int(T[i-1]=='s') * R
        dp[i][1] = max(dp[i-K][0], dp[i-K][2]) + int(T[i-1]=='p') * S
        dp[i][2] = max(dp[i-K][0], dp[i-K][1]) + int(T[i-1]=='r') * P

ans = 0
for d in dp[-K:]:
    ans += max(d)
print(ans)"
"input()
print(""Four"" if ""Y"" in input() else ""Three"")"
"import sys
stdin = sys.stdin

n,m = map(int, stdin.readline().split())
an = [i*(-1) for i in map(int, stdin.readline().split())]
#print(an)
#print(sum(an))

import heapq
heapq.heapify(an)

for _ in range(m):
    b = heapq.heappop(an)
    heapq.heappush(an, (-1)*((-1)*b//2))

#print(an)
ans = (-1)*sum(an)
print(ans)"
"import sys
import itertools
tokens = itertools.chain.from_iterable(map(str.split, sys.stdin))

yesno = ['NO', 'YES']
n = int(next(tokens))
p = [int(next(tokens)) for _ in range(n)]


s = sum(1 if a != b else 0 for a, b in zip(p, sorted(p)))
print(yesno[s == 2 or s == 0])
"
"N = int(input())
A = list(map(int, input().split()))
cin = [0, 0, 0, 0, 0, 0, 0, 0]
kin = 0
pin = 0
flag = 0
for i in A:
    if i < 3200:
        cin[i//400] += 1
        pin = 1
    else:
        kin += 1
        flag = 1
if pin == 0:
    print(1, kin)
else:
    print(8-cin.count(0), 8-cin.count(0)+kin)"
"a=int(input())
result=[]
for i in range(26):
    for j in range(26):
        result.append(i*4+j*7)

if a in result:
    print('Yes')
else:
    print('No')"
"a, b, x = map(int,input().split())



## ことごとくTLEする件
# forを回すからだめなのかも→回さないですませるには？
# bまでに約数いくつあるか出す → a-1 までに約数いくつあるか出す→引き算



## まず、aが割り切れるかどうか判定
## aが割り切れるなら、最小値はa
## 割り切れないなら、a+（除数 - あまり ) が最小値

#### divmodを使ってみよう！！


result = 0

a_x = divmod(a,x)  ## a/x の商と余り
## a = x * a_x[0] + a_x[1]
if a_x[1]==0:  ## 割り切れるとき
    first = a
else:  ## 割り切れないとき
    first = x * (a_x[0]+1)
    first2 = a + (x - a_x[1])  ## 検算用


b_x = divmod(b-first, x)

result = b_x[0]+1

print(result)






""""""
名答だと思ったがだめだった

count = 0
first = 0
for i in range(a, b+1):
#    print(i)
    if i%x == 0:
        first = i
        count = 1
        break
    
if count != 0:
    result  = (b-first) // x +1

else :
    result = 0


print(result)



""""""

"
"n = int(input())
S = []
T = []
for _ in range(n):
  s, t = input().split()
  S.append(s)
  T.append(int(t))
x = input()
index = S.index(x)
if index == n - 1:
  print(0)
else:
  print(sum(T[index+1:]))
"
"s = [list(map(int, input().split())) for _ in range(3)]
flag = 0
cnt = 0
for i in range(1, 5):
    for j in s:
        if (j[0] == i) or (j[1] == i):
            cnt += 1
    if cnt == 3:
        flag = 1
        break
    else:
        cnt = 0
        continue

if flag == 1:
    print('NO')
else:
    print('YES')
"
"import sys
readline = sys.stdin.readline

X = int(readline())

limit = 600
rank = 8
for i in range(8):
  if X < limit:
    print(rank)
    break
  limit += 200
  rank -= 1"
"from math import *
s=int(input())
x1=ceil(sqrt(s))
if x1>10**9:
    x1-=1
y2=ceil(s/x1)
if y2>10**9:
    y2-=1
x2=x1*y2-s
print(0,0,x1,1,x2,y2)"
"x = int(input())
a = int(input())
b = int(input())
x -= a
x -= b * (x // b)
print(x)"
"N, L = map(int, input().split())
A = [L + i for i in range(N)]
M = L + N - 1
for x in A:
    if abs(M) > abs(x):
        M = x
print(sum(A) - M)
"
"n = int(input())
a = list(map(int, input().split()))
a.sort()
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a%b)
def lcm(a, b):
    return (a*b)//gcd(a, b)
llcm = 1
for i in a:
    llcm = lcm(llcm, i)
ans = 0
for i in a:
    ans += (llcm-1)%i
print(ans)"
"import sys
import math
from collections import defaultdict

sys.setrecursionlimit(10**7)
def input():
    return sys.stdin.readline()[:-1]

mod = 10**9 + 7

def I(): return int(input())
def II(): return map(int, input().split())
def III(): return list(map(int, input().split()))
def Line(N,num):
    if N<=0:
        return [[]]*num
    elif num==1:
        return [I() for _ in range(N)]
    else:
        read_all = [tuple(II()) for _ in range(N)]
        return map(list, zip(*read_all))

#################

N = I()

d = defaultdict(int)
for i in range(2,10**5):
    if i*(i-1)//2 > 10**5:
        break
    d[i*(i-1)//2] = i

if d[N]==0:
    print('No')
    exit()

k = d[N]
group = [[] for _ in range(k)]
val = 1
now = 0
while val<=N:
    for i in range(val,N+1):
        if len(group[now])==k-1:
            break
        else:
            group[now].append(i)
    for i in range(now+1,k):
        group[i].append(val)
        val += 1
    now += 1

print('Yes')
print(k)
for i in range(k):
    print(k-1,*group[i])"
"w, count = input(), 0

while True:
    line = input()
    if line == 'END_OF_TEXT':
        break
    count += line.lower().split().count(w)

print(count)"
"a,b,c = list(map(int,input().split("" "")))
print(""YES"" if b-a==c-b else 'NO')"
"N = int(input())
A = sorted(map(int,input().split()),reverse=True)
C = []
for i in range(N):
  C.append(A[2*i + 1])
print(sum(C))"
"# 各行の所属するグループを配列として持たせる実装。列ごと見ていってダメなら垂直線追加していく
H, W, K = map(int, input().split())
S = [input() for _ in range(H)]
ans = 10**9
for bit in range((1 << (H-1))):
    vidx = []
    gok = True
    g = 0
    gid = [0] * H
    for i in range(H-1):
        if (bit >> i) & 1:
            g += 1
        gid[i+1] = g
    g += 1
    gnum = [0]*g
    vertical = 0
    for w in range(W):
        ok = True
        one = [0]*g
        for h in range(H):
            one[gid[h]] += int(S[h][w])
            gnum[gid[h]] += int(S[h][w])
            if one[gid[h]] > K:
                gok = False
            if gnum[gid[h]] > K:
                ok = False
        if not ok:
            vertical += 1
            vidx.append(w)
            gnum = one

    # if bit == 2:
    #    print('aaaaa')
    #    print(gid)
    #    print(vidx)
    #    print(bin(bit), g-1, vertical)
    #    print('aaaaa')
    if gok:
        if ans > g-1 + vertical:
            ans = g-1 + vertical
            # print(bin(bit), g-1, vertical)
            # print(vidx)
            # print(ans)
        # ans = min(ans, g-1 + vertical)
if ans == 10**9:
    print(-1)
else:
    print(ans)
"
"N = int(input())
V = list(map(int, input().split()))
C = list(map(int, input().split()))

B = 0
for i in range(N):
    b = V[i]-C[i]
    if b>=0:
        B = B + b
    else:
        pass

print(B)"
"n=int(input())
a=list(map(int,input().split()))
if sum(a)==0:
  print(""Yes"")
else:
  t=list(set(a))
  if len(t)==3 and n%3==0:
    if t[0]^t[1]==t[2] and a.count(t[0])==n//3 and a.count(t[1])==n//3:
      print(""Yes"")
    else:
      print(""No"")
  elif len(t)==2 and a.count(0)==n//3 and n%3==0:
    print(""Yes"")
  else:
    print(""No"")"
"# n以下の非負整数が素数かどうかを示すリストを返す
def primes(n):
    is_prime = [False] * 2 + [True] * (n - 1)
    for i in [2] + list(range(3, int(n ** 0.5) + 1, 2)):
        if not is_prime[i]: continue
        for j in range(2 * i, n + 1 ,i):
            is_prime[j] = False
    return is_prime

N = 10 ** 5
Q = int(input())
is_prime = primes(N)
cum2017 = [0] * (N + 1) # 累積和
for i in range(1, N + 1):
    cum2017[i] = cum2017[i - 1]
    if i % 2 == 1 and is_prime[i] and is_prime[(i + 1) // 2]:
        cum2017[i] += 1

for _ in range(Q):
    l, r = [int(x) for x in input().split()]
    print(cum2017[r] - cum2017[l - 1])"
"n,k=map(int,input().split())
a=[]
for i in range(n):
    A=list(map(int,input().split()))
    a.append(A)
a = sorted(a, key=lambda x: x[0])
b=0
for i in range(n):
    b+=a[i][1]
    if b>=k:
        print(a[i][0])
        exit()"
"a=input().split()
print(str(int(a[0])*int(a[1]))+"" ""+str((int(a[0])+int(a[1]))*2))"
"n, m = map(int, input().split())
nodes = [input().split() for _ in range(m)]

node_num = {str(i): 0 for i in range(1, n + 1)}
for node in nodes:
    node_num[node[0]] += 1
    node_num[node[1]] += 1

for i in range(1, n + 1):
    print(node_num[str(i)])
"
"# vim: fileencoding=utf-8


def main():
    s = input()
    c = [""dreamer"", ""dream"", ""erase"", ""eraser""]
    n = [7, 5, 5, 6]
    while True:
        f = True
        for i in range(4):
            if s[-n[i] :] == c[i]:
                f = False
                s = s[: -n[i]]
                break
        if f:
            if len(s) == 0:
                print(""YES"")
            else:
                print(""NO"")
            return


if __name__ == ""__main__"":
    main()
"
"import sys
input = sys.stdin.readline
from collections import defaultdict

(n, k), s = map(int, input().split()), list(map(int, input().split()))
x, c = [1, s[0]], 0
for i in range(n): x.append(s[x[-1] - 1])
if len(x) > k: print(x[k]); exit()
while x[c] != s[x[-1] - 1]: c += 1
print(x[((k - c) % (len(x) - c)) + c])"
"def resolve():
    n=int(input())
    if n>=1000:
        print('ABD')
    else:
        print('ABC')
resolve()"
"n,*a = map(int,open(0).read().split())
a = sorted([(j,i) for i,j in enumerate(a)],reverse=True)
dp = [0]
for i,(j,k) in enumerate(a):
  ldp =  [abs(k-i+a)*j+b for a,b in enumerate(dp)]
  rdp =  [abs(n-1-k-a)*j+b for a,b in enumerate(dp)]
  dp = [max(a,b) for a,b in zip(ldp+[0],[0]+rdp)]
print(max(dp))"
"n, m = map(int, input().split())

n = (n + 2) if n == 1 else n
m = (m + 2) if m == 1 else m

print((n - 2) * (m - 2))"
"N = int(input())
A = [int(x) for x in input().split()]
base = 0
diff = 0
for i in range(N):
    if A[i] > base:
        base = A[i]
    diff += base - A[i]
print(diff)
"
"import sys

n, a, b  = map(int, sys.stdin.readline().split())

print(min(a * n, b))"
"a,b,c = map(int, input().split())
if b >= a * c:
    print(c)
else:
    sound = 0 if b < a else int(b / a)
    print(sound)"
"N=list(map(int,input().split()))
N.sort()

if (N[0]==1)and(N[1]==4)and(N[2]==7)and(N[3]==9):
    print(""YES"")
else:
    print(""NO"")"
"H, W = map(int, input().split())
C = [input() for h in range(H)]

for c in C:
    print(c)
    print(c)"
"def resolve():
    import bisect
    n = int(input())
    a = [int(input()) for _ in range(n)]
    m = []
    for i in range(n-1, -1, -1):
        if i == n-1:
            m.append(a[i])
        else:
            if m[-1] <= a[i]:
                m.append(a[i])
            elif m[0] > a[i]:
                m[0] = a[i]
            else:
                j = bisect.bisect_right(m, a[i])
                m[j] = a[i]
    print(len(m))
resolve()"
"import statistics

N = int(input())
AB = [map(int, input().split()) for _ in range(N)]
A, B = [list(i) for i in zip(*AB)]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
    print(int((B_median-A_median)*2)+1)
else:
    print(B_median-A_median+1)"
"def resolve():
    n = int(input())
    p = map(int,input().split())
    cnt = 0
    for i,j in enumerate(p):
        if (i+1) != j:
            cnt += 1
    print('YES' if cnt < 3 else 'NO')
resolve()"
"from collections import deque
n = int(input())
M = [[0]*n for _ in range(n)]
d = [-1]*n
st = [0]*n
for _ in range(n):
    i = [int(i) for i in input().split()]
    u = i[0]
    k = i[1]
    V = i[2:]
    for v in V: M[u-1][v-1] = 1

def bfs(s):
    Q = deque()
    Q.append(s)
    st[s] = 1
    d[s] = 0
    while Q:
        u = Q.popleft()
        for v in range(n):
            if M[u][v] and st[v] == 0:
                st[v] = 1
                Q.append(v)
                d[v] = d[u]+1
        st[u] = 2
    return

bfs(0)
for i in range(n): print(i+1,d[i])
"
"import sys
N,K=map(int, input().split())
mod=10**9+7
G={}
for i in range(N):
  G[i+1]=[]
for i in range(N-1):
  a,b=map(int, input().split())
  G[a].append(b)
  G[b].append(a)

for i in range(N):
  if len(G[i+1])>=K:
    print(0)
    exit()

def nPr(n,r):
  res=1
  for i in range(r):
    res*=(n-i)
    res%=mod
  return res

from collections import deque
q=deque([(1,0)])
ans=K
while q:
  n,m=q.pop()
  if m==0:
    ans*=nPr(K-1,len(G[n]))
    ans%=mod
    for d in G[n]:
      q.appendleft((d,n))
  else:
    ans*=nPr(K-2,len(G[n])-1)
    ans%=mod
    for d in G[n]:
      if d!=m:
        q.appendleft((d,n))
print(ans)"
"h, w = map(int, input().split())
field = [list(input()) for _ in range(h)]
dx = [1, 0, -1, 0, 1, -1, -1, 1]
dy = [0, 1, 0, -1, 1, 1, -1, -1]
for i in range(h):
    for j in range(w):
        if field[i][j] == ""#"":
            continue
        num = 0
        for k in range(8):
            ni = i + dy[k]
            nj = j + dx[k]
            if ni < 0 or h <= ni:
                continue
            if nj < 0 or w <= nj:
                continue
            if field[ni][nj] == ""#"":
                num += 1
        field[i][j] = str(num)
for out in field:
    print("""".join(out))
"
"# input()
# int(input())
# map(int, input().split())
# list(map(int, input().split()))
import math
import sys
import bisect
import heapq  # 優先度付きキュー(最小値取り出し)
from collections import deque

inf = 10 ** 15
mod = 10 ** 9 + 7

n,h = map(int, input().split())
blist = []
amax = 0
for i in range(n):
    a,b = map(int, input().split())
    amax = max(amax, a)
    blist.append(b)
# aが最大のやつじゃないとフル価値なし
ans = (h+amax-1)//amax
blist.sort(reverse = True)
btotal=0
for i,num in enumerate(blist):
    tmp = h
    if num <= amax:
        break
    else:
        btotal+=num
        tmp-=btotal
        if tmp <= 0:
            ans = min(ans, i+1)
            break
        else:
            ans = min((tmp+amax-1)//amax + i+1, ans)
print(ans)



"
"N, K = map(int, input().split())
H = list(map(int, input().split()))
print(len(list(filter(lambda x: x >= K, H))))"
"def examD():
    N, A, B = LI()
    X = LI()
    cur = int(0)
    for i in range(N-1):
        cur += min(A*(X[i+1]-X[i]),B)
    print(cur)

import sys
import copy
from collections import Counter,defaultdict,deque
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def S(): return sys.stdin.readline().strip()
mod = 10**9 + 7
inf = float('inf')

examD()"
"n,a=map(int,input().split())
x=list(map(int,input().split()))
dp=[[[0]*(2501) for i in range(51)] for j in range(51)]
#dp[i][j][k]は、i番目まででj枚とって総数kとなる取り方
for i in range(n+1):
    dp[i][0][0]=1
for i in range(n):
    for j in range(1,i+2):
        for k in range(1,2501):
            if k-x[i]>=0:
                dp[i+1][j][k]=dp[i][j-1][k-x[i]]+dp[i][j][k]
            else:
                dp[i+1][j][k] = dp[i][j][k]
ans=0
for j in range(1,n+1):
    ans+=dp[n][j][a*j]
print(ans)"
"N,K = map(int,input().split())
if K%2==0:
    k = K//2
    o = (N+k)//K
    e = N//K
    ans = e**3+o**3
else:
    ans = (N//K)**3
print(ans)    "
"from collections import defaultdict

n, m = map(int, input().split())
ac_dict = defaultdict(int)
wa_dict = defaultdict(int)
ac_p, wa_p = set(), set()
for _ in range(m):
    p, s = input().split()
    p = int(p)
    if s == 'AC':
        ac_p.add(p)
        ac_dict[p] = 1
    elif ac_dict[p] != 1:
        wa_p.add(p)
        wa_dict[p] += 1

wa = 0
for pi in ac_p:
    wa += wa_dict[pi]

print(sum(ac_dict.values()), wa)
"
"#!usr/bin/env python3
from collections import defaultdict
from collections import deque
from heapq import heappush, heappop
import sys
import math
import bisect
import random
import itertools
sys.setrecursionlimit(10**5)
stdin = sys.stdin
bisect_left = bisect.bisect_left
bisect_right = bisect.bisect_right
def LI(): return list(map(int, stdin.readline().split()))
def LF(): return list(map(float, stdin.readline().split()))
def LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))
def II(): return int(stdin.readline())
def IF(): return float(stdin.readline())
def LS(): return list(map(list, stdin.readline().split()))
def S(): return list(stdin.readline().rstrip())
def IR(n): return [II() for _ in range(n)]
def LIR(n): return [LI() for _ in range(n)]
def FR(n): return [IF() for _ in range(n)]
def LFR(n): return [LI() for _ in range(n)]
def LIR_(n): return [LI_() for _ in range(n)]
def SR(n): return [S() for _ in range(n)]
def LSR(n): return [LS() for _ in range(n)]
mod = 1000000007
inf = float('INF')

#A
def A():
    a, p = LI()
    print((a*3+p)//2)
    return

#B
def B():
    n = II()
    sp = []
    for i in range(n):
        sp.append(input().split())
    another = [(s[0], -1 * int(s[1]),num) for num,s in enumerate(sp)]
    another.sort()
    for s,p,q in another:
        print(q+1)

    return

#C
def C():
    n, m = LI()
    ks = LIR_(m)
    p = LI()
    patern = itertools.product(range(2), repeat=n)
    ans = 0
    for on in patern:
        ki = [0 for i in range(m)]
        for num, oni in enumerate(on):
            if oni:
                for i,ksi in enumerate(ks):
                    ksi = ksi[1::]
                    if num in ksi:
                        ki[i] ^= 1
        for num, pi in enumerate(p):
            if pi != ki[num]:
                break
        else:
            ans += 1
    print(ans)

            
    return

#D
def D():
    N, K = LI()#random.randint(1,50),random.randint(1,100)
    v = LI()#[random.randint(-10 ** 2, 10 ** 2) for i in range(N)]
    ans = 0
    for a in range(min(N, K) + 1):
        for b in range(min(N, K) + 1):
            if a + b > min(K,N):
                break
            if a == b == 0:
                continue
            deletes = K - a - b
            left = v[:a]
            right = v[:-b-1:-1]
            x = left + right
            x.sort()
            tmp = sum(x)
            for delete in range(min(deletes, len(x))):
                if x[delete] >= 0:
                    break
                tmp -= x[delete]
            ans = max(ans,tmp)
    
    print(ans)
                

    return


#E
def E():  
    N,q = LI()
    STX = LIR(N)
    D = IR(q)
    LV = (q - 1).bit_length()
    N0 = 1 << LV

    data = [inf] * (N0 << 1)
    INF = inf

    def update(l, r, x):
    
        #  区間[l, r)のdataの値を更新
        L = N0 + l; R = N0 + r
        while L < R:
            if R & 1:
                R -= 1
                data[R-1] = min(data[R-1], x)
            if L & 1:
                data[L-1] = min(data[L-1], x)
                L += 1
            L >>= 1; R >>= 1

    def query(x):
        L = N0 + x - 1
        #  xの最小値を求める
        s = INF
        while L >= 0:
            s = min(s, data[L])
            L = (L - 1) >> 1
        return s

    for s, t, x in STX:
        XS = max(-1, s - x)
        XT = max(-1, t - x)
        XS_index = bisect_left(D, XS)
        XT_index = bisect_left(D, XT)
        update(XS_index, XT_index, x)

    for i in range(q):
        a = query(i)
        print(a if a != inf else -1)
#F
def F():
    return

#Solve
if __name__ == '__main__':
    E()
"
"import math
N,D=map(int,input().split())
D=2*D+1
ans=math.ceil(N/D)

print(ans)
"
"n = int(input())
a = list(map(int,input().split()))
import bisect
a.sort()

idx = bisect.bisect_left(a, 0)
sm = [abs(x) for x in a]
if idx % 2 == 0:
    print(sum(sm))
else:
    print(sum(sm) - 2*min(sm))"
"N = int(input())

print(""ABC{:03d}"".format(N))
"
"import sys
import numpy as np

def main():
  input = sys.stdin.readline
  d = int(input())
  c = np.array([int(x) for x in input().split()])
  
  last = np.zeros(26, dtype=""int64"")
  
  for i in range(d):
    s = np.array([int(x) for x in input().split()])
    key, value = -1, -1
    for i in range(26):
      if value < s[i] + last[i]:
        key = i
        value = s[i] + last[i]
    last[key] = 0
    print(key+1)
    last += c

if __name__ == ""__main__"":
  main()"
"def main():
    N = int(input())
    A = [input() for i in range(3)]
    ans = 0
    for i in range(N):
        cur = {A[0][i], A[1][i], A[2][i]}
        # print(cur)
        ans += (len(cur) - 1)
    print(ans)


if __name__ == '__main__':
    main()
"
"import sys
from collections import Counter
from itertools import accumulate

def main():
    input = sys.stdin.readline
    N, M = map(int, input().split())
    A = list(map(int, input().split()))

    AC = accumulate([0] + A, func=lambda x,y:(x+y)%M)
    ACC = Counter(AC)

    ans = 0
    for c in ACC.values():
        ans += c * (c-1) // 2
    print(ans)

if __name__ == '__main__':
    main()"
"H,W=map(int,input().split())
a=[[] for i in range(0,H)]
for i in range(0,H):
    a[i]=list(map(int,input().split()))

ans=[]
for i in range(0,H):
    for j in range(0,W-1):
        if a[i][j]%2==1:
            ans.append((i,j,i,j+1))
            a[i][j+1]+=1

for i in range(0,H-1):
    if a[i][W-1]%2==1:
        ans.append((i,W-1,i+1,W-1))
        a[i+1][W-1]+=1

N=len(ans)
print(N)
for i in range(0,N):
    x,y,z,w=ans[i]
    print(x+1,y+1,z+1,w+1)"
"n = int(input())
a = int(input())
ans = n - (n // 500) * 500
if ans > a:
    print('No')
else:
    print('Yes')
"
"c=int(input())
c=c+int(input())
print(int(c*int(input())//2))"
"a = input().split()
print(a[1] if a[0] == 'H' else ('D' if a[1] == 'H' else 'H'))"
"a, b, c, k = map(int, input().split())

if(k <= a):
    print(k)
elif(k <= a+b):
    print(a)
else:
    if(a <= k-a-b):
        print(-1*(k-a-b-a))
    elif(a > k-a-b):
        print(a-(k-a-b))"
"c = input()
boin =['a','i','u','e','o']
if c in boin:
	print('vowel')
else:print('consonant')"
"# -*- coding: utf-8 -*-
import sys
sys.setrecursionlimit(10**9)
INF=10**18
MOD=10**9+7
input=lambda: sys.stdin.readline().rstrip()
YesNo=lambda b: bool([print('Yes')] if b else print('No'))
YESNO=lambda b: bool([print('YES')] if b else print('NO'))
int1=lambda x:int(x)-1

def main():
    N=int(input())
    a=list(map(int,input().split()))
    t=0
    f=0
    for i in range(N):
        if a[i]%4==0:
            f+=1
        elif a[i]%2==0:
            t+=1
    YesNo(N//2<=f+t//2)

if __name__ == '__main__':
    main()
"
"import numpy as np
from numba import njit
@njit
def op(A, n):
    B = np.zeros_like(A)
    for i, a in enumerate(A[:n]):
        B[max(i - a, 0)] += 1
        B[min(n - 1, a + i) + 1] -= 1
    return np.cumsum(B)

def main():
    n, k = list(map(int, input().split()))
    A = np.array(list(map(int, input().split())) + [0, ], dtype = np.int)
    for _ in range(k):
        A_new = op(A, n)
        if all(A[:n] == A_new[:n]):
            break
        A = A_new
    print(' '.join(list(map(str, A[:n]))))

if __name__ == '__main__':
    main()
"
"from collections import Counter
a = input()
c = len(a)*(len(a)-1)//2
for i in Counter(a).values():
  c -= i*(i-1)//2
print(c+1)"
"n,k = map(int, input().split())
A = list(map(int, input().split()))
counter = 0

for i in range(0,n,k-1):
  min_n = min(A[i:i+k])
  max_n = max(A[i:i+k])
  if min_n != max_n:
    counter += 1
  if i+k-1 < n:
    A[i+k-1] = min_n
  
print(counter)"
"from functools import reduce
a,b = map(int,input().split())
a -= 1
print(reduce(lambda x,y:x^y,list(range(a-a%4,a+1))+list(range(b-b%4,b+1))))"
"#2回目以降のあまりを計算
def f(j):
    cnt = 0
    while j:
        j %= bin(j).count(""1"")
        cnt += 1
    return cnt

N = int(input())
S = input()

#入力を数値に変換
X = int(S, 2)

#元のbit数をカウント
pcx = S.count(""1"")
#bit数は-1, +1のみなので予め計算しておく
#カウントが0ならば0にしておく
pc1 = X % (pcx - 1) if pcx > 1 else 0
pc2 = X % (pcx + 1)

for i, y in enumerate(S):
    k = N - 1 - i
    if y == ""0"":
        print(f((pc2 + pow(2, k, pcx + 1)) % (pcx + 1)) + 1)
    elif pcx > 1:
        print(f((pc1 - pow(2, k, pcx - 1)) % (pcx - 1)) + 1)
    else:
        print(0)

"
"def main():
    import sys
    input=sys.stdin.readline
    n=int(input())
    lst=[]
    for i in range(n):
        a,b=map(int,input().split())
        lst.append([a-b,a+b])
    lst=sorted(lst,key=lambda x:x[1])
    ans=0
    end=-float(""inf"")
    for i in lst:
        if i[0]>=end:
            ans+=1
            end=i[1]
    print(ans)
if __name__==""__main__"":
    main()"
"a=list(map(int,input().split()))
a.sort()
print(""YES"" if a==[5,5,7] else ""NO"")"
"n, m = map(int, input().split())
graph = [[] for _ in range(n)]
for _ in range(m):
    a, b = map(int, input().split())
    graph[a-1].append(b-1)
r = n
ans = 0
for i in range(n):
    if i>=r:
        ans += 1
        r = n
    if not graph[i]:
        continue
    mi = min(graph[i])
    r = min(r, mi)
print(ans)"
"X = int(input())

happy = X // 500 * 1000
happy += X % 500 // 5 * 5

print(happy)"
"import sys
n = int(input())
count = 0
for i in range(1,n+1):
    if len( str(i) ) % 2 != 0:
        count += 1
print( count )"
"s = input()
l = {}
for i in s:
    l.setdefault(i, 0)
    l[i] += 1
ans = float(""inf"")
for i in l.keys():
    count = 0
    s0 = """"
    for j in s:
        if i == j:
            s0 += i
        else:
            s0 += "".""
    while ""."" in s0:
        count += 1
        s1 = """"
        for j in range(len(s0) - 1):
            if s0[j] == i or s0[j + 1] == i:
                s1 += i
            else:
                s1 += "".""
        s0 = s1
    else:
        ans = min(ans, count)
print(ans)"
"while True:
    height, width = [int(x) for x in input().split("" "")]
    if height == width == 0:
        break
    for i in range(height - 1):
        print(""#"" * width)
    print(""#"" * width + ""\n"")"
"n = int(raw_input())
elems = map(int, raw_input().split(' '))
cumul = 0
res = 0
for j in range(len(elems)):
	res += elems[j] * cumul
	cumul += elems[j]
print res
"
"n,a,b=map(int,input().split())
def f(x):
    m=0
    while x>0:
        m+=x%10
        x=x//10
    return m
ans=0
for i in range(n):
    
    if a<=f(i+1)<=b:
        ans+=i+1
print(ans)
    
"
"cnt={}
tot=0

ans=1

for i,c in enumerate(input(),0):
	if c in cnt:
		ans+=i-cnt[c]
	else:
		cnt[c]=0
		ans+=i
	cnt[c]+=1

print(ans)
"
"N,M,X,Y = map(int,input().split())
x = max(X,max(map(int,input().split())))
y = min(Y,min(map(int,input().split())))

if x<y:
  print(""No War"")
else:
  print(""War"")"
"def readinput():
    n,k=map(int,input().split())
    return n,k

def main(n,k):
    ans=0
    for i in range(1,n+1):
        p=1/n
        point=i
        while(point<k):
            point*=2
            p/=2
        #print(p)
        ans+=p
    return ans

if __name__=='__main__':
    n,k=readinput()
    ans=main(n,k)
    print(ans)
"
"def move(up,bottom,right,left,front,back,direction):
    if direction == ""N"":
        return (front,back,right,left,bottom,up)
    elif direction == ""S"":
        return (back,front,right,left,up,bottom)
    elif direction == ""E"":
        return (left,right,up,bottom,front,back)
    elif direction == ""W"":
        return (right,left,bottom,up,front,back)
    
up,front,right,left,back,bottom = input().split()
direction = list(input())

for i in range(len(direction)):
    up,bottom,right,left,front,back = move(up,bottom,right,left,front,back,direction[i])
    
print(up)"
"a, b, c = map(int, input().split())
k = int(input())
p = ""No""
for i in range(k):
  if not(a < b and b < c):
    if b <= a:
      b = b * 2
    else:
      c = c * 2
if a < b and b < c:
  p = ""Yes""
print(p)"
"n = int(input())
a = [int(input()) for _ in range(n)]
if a[0] != 0:
  print(-1)
  exit(0)
cnt = 0
cur = 0
for i in range(n-1,-1,-1):
  if cur > a[i]:
    print(-1)
    exit(0)
  if cur < a[i]:
    cur = a[i]
    cnt += a[i]
  if cur > 0:
    cur -= 1
print(cnt)"
"D, N = map(int, input().split())
skips = N // 100
print((100 ** D) * (N+skips))
"
"n=int(input())
x=1
for i in range(1,n+1):
    x=x*(i%(10**9+7))
    x=x%(10**9+7)
print(x)"
"s = input()
print("" "".join(s.split(',')))"
"def my_pow(base, n, mod):
    if n == 0:
        return 1
    x = base
    y = 1
    while n > 1:
        if n % 2 == 0:
            x *= x
            n //= 2
        else:
            y *= x
            n -= 1
        x %= mod
        y %= mod
    return x * y % mod

N = int(input())
D = list(map(int, input().split()))
dmax = max(D)
MOD = 998244353
cnt = [0] * (10 ** 5 + 1)
for d in D:
    cnt[d] += 1

if D[0] or cnt[0] != 1:
    print(0)
    exit()
ans = cnt[0]
for i in range(1, dmax + 1):
    now = my_pow(cnt[i - 1], cnt[i], MOD)
    ans *= now
    ans %= MOD
print(ans)"
"def main():

    N, A, B = map(int, input().split())
    if (B-A) % 2 == 0:
        return  (B-A) // 2
    else:
        a = A-1 + (B-A+1)//2
        b = N-B+1 + (B-A-1) // 2
        return min([a, b])

if __name__ == '__main__':
    print(main())
"
print('NYoe s'['111'in''.join(str(len({*t.split()}))for t in open(0))[1:]::2])
"from math import gcd


N, *A = map(int, open(0).read().split())

acc_l = [0] * (N + 1)
acc_r = [0] * (N + 1)
for i in range(1, N + 1):
    acc_l[i] = gcd(acc_l[i - 1], A[i - 1])
    acc_r[i] = gcd(acc_r[i - 1], A[-i])
ans = 0
for i in range(N + 1):
    ans = max(ans, gcd(acc_l[i], acc_r[N - i - 1]))
print(ans)
"
"# -*- coding: utf-8 -*-

def get_input() -> tuple:
    """"""
    標準入力を取得する.

    Returns:\n
        tuple: 標準入力
    """"""
    N, K = list(map(int, input().split()))
    A = list(map(int, input().split()))

    return N, K, A

def main(N: int, K: int, A: list) -> None:
    """"""
    メイン処理.

    Args:\n
        N (int): 学期数（2 <= N <= 200000）
        K (int): 直近何回分までの点数を考慮するか（1 <= K <= N - 1）
        A (list): i学期の期末テストの点数
    """"""
    # 求解処理
    for i in range(K, N):
        if A[i] > A[i - K]:
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":
    # 標準入力を取得
    N, K, A = get_input()

    # メイン処理
    main(N, K, A)
"
"s = input()
count = 0
tmp = s[0]
for i in range(1, len(s)):
    if s[i] == tmp:
        count += 1
        if s[i] == ""0"":
            tmp = ""1""
        else:
            tmp = ""0""
    else:
        tmp = s[i]

print(count)"
"sx, sy, gx, gy = map(int, input().split(' '))

route = []
dy = gy - sy
dx = gx - sx
route.append('U' * dy)
route.append('R' * dx)
route.append('D' * dy)
route.append('L' * (dx + 1))
route.append('U' * (dy + 1))
route.append('R' * (dx + 1))
route.append('DR')
route.append('D' * (dy + 1))
route.append('L' * (dx + 1))
route.append('U')
print(''.join(route))
"
"a, b = map(int, input().split())
s = input()
try:
    A = int(s[:a])
    B = int(s[b:])
    if s[a] == '-':
        print('Yes')
    else:
        print('No')
except:
    print('No')
"
"n = int(input())
p = list(map(int, input().split()))
q = sorted(p)
cnt = sum(p[i] != q[i] for i in range(n))
print([""NO"", ""YES""][cnt <= 2])"
"n = int(input())
pl = list(map(float,input().split()))

# dp[i][j] i回目でj回表がでる確率
dp = [[0 for j in range(n+1)] for i in range(n+1)]
dp[0][0] = 1

for i in range(n):
    for j in range(n):
        dp[i+1][j+1] += pl[i] * dp[i][j]
        dp[i+1][j] += (1-pl[i]) * dp[i][j]

def ceil(a, b):
   return a // b + (a % b > 0)
print(sum(dp[-1][ceil(n,2):]))"
"#!/usr/bin/env python3
#%% for atcoder uniittest use
import sys
input= lambda: sys.stdin.readline().rstrip()
sys.setrecursionlimit(10**9)
def pin(type=int):return map(type,input().split())
def tupin(t=int):return tuple(pin(t))
def lispin(t=int):return list(pin(t))
#%%code

def resolve():
    A,B=pin()
    if A>9 or B>9:print(-1);return
    print(A*B)
#%%submit!
resolve()"
"def main():
    n = int(input())
    Ss = [input() for _ in range(n)]
    U = [[0, 0] for _ in range(n)]
    for i in range(n):
        for c in Ss[i]:
            if c == ""("":
                U[i][1] += 1
            else:
                if U[i][1] == 0:
                    U[i][0] += 1
                else:
                    U[i][1] -= 1
    L, R = 0, 0
    P = []
    for i in range(n):
        if U[i][0] == 0 and U[i][1] > 0:
            L += U[i][1]
        elif U[i][0] > 0 and U[i][1] == 0:
            R += U[i][0]
        elif U[i][0] > 0 and U[i][1] > 0:
            P.append([U[i][0], U[i][1]])
    P.sort(key=lambda x: (x[0]-x[1], x[0], -x[1]))
    if L == 0 and R == 0 and len(P) == 0:
        print(""Yes"")
    elif (L == 0 or R == 0) and len(P) > 0:
        print(""No"")
    else:
        f = True
        for i in range(len(P)):
            L -= P[i][0]
            if L < 0:
                f = False
                break
            L += P[i][1]
        if L == R and f:
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":
    main()"
"#   ????????????????????????????°?????????¨??§???????????\????????????????????°??????
#   ?????????????¨??????\?????????????????????
input_str = input()
#   ??§??????????°??????????????°????????????§??????????????????????????????
print(input_str.swapcase())"
"import sys
N, K = map(int, input().split())

ans = 0

for i in range(1,N+1,2):
    ans = ans + 1

if ans >= K:
    print(""YES"")
    sys.exit()

print(""NO"")
"
"from bisect import *
from math import *
N,D,A=map(int,input().split())
monsters=[list(map(int,input().split())) for _ in range(N)]
monsters.sort(key=lambda x:x[0])
killingrange=[0]*N
monsterspoint=[]
monstershp=[]
imos=[0]*N
for i in range(N):
    monsterspoint.append(monsters[i][0])
    monstershp.append(monsters[i][1])
for i in range(N):
    ind=bisect(monsterspoint,monsterspoint[i]+2*D)
    killingrange[i]=ind
#print(killingrange)
cnt=0
for i in range(N):
    monstershp[i]=monstershp[i]+imos[i]
    if (monstershp[i]>0):
        cnt=cnt+ceil(monstershp[i]/A)
        imos[i]=imos[i]-A*ceil(monstershp[i]/A)
        if killingrange[i]<N:
            imos[killingrange[i]]=imos[killingrange[i]]+A*ceil(monstershp[i]/A)
        monstershp[i]=monstershp[i]-A*ceil(monstershp[i]/A)
    if i<N-1:
        imos[i+1]=imos[i]+imos[i+1]
    #print(monstershp,imos)
print(cnt)"
"b, c = map(str, input().split())
d = b+c
for n in range(int(d)):
    if n == 0:
        continue
    if ((int(d)/n) == n):
        print('Yes')
        break
    if (n+1) == int(d):
        print('No')"
"import warnings

#data = map(int, raw_input().split())

r = input()

sq = 1.0 * r *r * 3.14159265358979323846264338327950288419716939937510

l = 2.0 * 3.14159265358979323846264338327950288419716939937510 * r

print ""%.30f %.30f"" % (sq, l) "
"n = input()
dictInProb = set()
for i in range(int(n)):
    cmdAndStr = list(input().split())
    if cmdAndStr[0] == ""insert"":
        dictInProb.add(cmdAndStr[1])
    elif cmdAndStr[0] == ""find"":
        if cmdAndStr[1] in dictInProb:
            print(""yes"")
        else:
            print(""no"")
    else: pass"
"def resolve():
    x = int(input())
    dp = [0] * (x+1+105)
    dp[0] = 1

    for i in range(x):
        if dp[i] == 1:
            for j in range(100, 106):
                dp[i+j] = 1
    print(dp[x])
resolve()"
"s = input()
print('vowel' if s in 'aeiou' else 'consonant')"
"# -*- coding: utf-8 -*-
import sys
from itertools import accumulate
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

n,c = map(int,readline().split())
stc = []
for i in range(n):
    stc.append(list(map(int,readline().split())))
stc.sort(key=lambda x: (x[2], x[0]))
 
nstc = []
for i in range(n):
    if len(nstc) > 0 and nstc[-1][2] == stc[i][2] and nstc[-1][1] == stc[i][0]: #同じチャンネルかつ終了時刻と始まりの時刻が同じ
        nstc[-1][1] = stc[i][1]
    else:
        nstc.append(stc[i])
n = len(nstc)
 
h = [0]*200005
for i in range(n):
    h[2*nstc[i][0] - 1] += 1
    h[2*nstc[i][1]] += -1
ah = list(accumulate(h))
print(max(ah))"
"h,w=map(int,input().split())
grid=[]
for _ in range(h):
    grid.append(list(input()))

row=[]
col=[]
#行探索
for i in range(h):
    flg=0
    for j in range(w):
        if grid[i][j]=='#':
            flg=1

    if flg==0:
        row.append(i)

#列探索
for j in range(w):
    flg=0
    for i in range(h):
        if grid[i][j]=='#':
            flg=1

    if flg==0:
        col.append(j)

ans=[]
for i in range(h):
    arr=[]
    for j in range(w):
        if i in row or j in col:
            continue
        else:
            arr.append(grid[i][j])
    if len(arr)!=0:
        ans.append(arr)

for k in ans:
    t=''.join(k)
    print(t)
"
"#!/usr/bin/env python3
import sys

S = input()

if S[-1] == ""s"":
    print(S+""es"")
else:
    print(S+""s"")"
"mo=10**9+7
s=input()
n=len(s)
dp=[[0]*(1+n) for i in range(3)]
cc=0
for i in range(n):
    c=s[i]
    if c=='A':
        da,db,dc,dd=1,0,0,1
    elif c=='B':
        da,db,dc,dd=0,1,0,1
    elif c=='C':
        da,db,dc,dd=0,0,1,1
    elif c=='?':
        da,db,dc,dd=1,1,1,3
        
    dp[0][i+1]=dp[0][i]*dd+da*pow(3,cc,mo)
    dp[1][i+1]=dp[1][i]*dd+dp[0][i]*db
    dp[2][i+1]=dp[2][i]*dd+dp[1][i]*dc
    dp[0][i+1]%=mo
    dp[1][i+1]%=mo
    dp[2][i+1]%=mo
    if c=='?':
        cc+=1

print(dp[2][n]%mo)"
"s=input()
cnt=0
for i in s:
    if i==""g"":cnt +=1
    else:cnt -=1
print(cnt//2)"
"N = int(input())
A = input()
B = input()
C = input()
wordlst = [A, B, C]
cnt = 0
for i in range(N):
    tmp = 0
    for j in range(3):
        tmp += wordlst[j - 1][i].count(wordlst[j][i])
        tmp += wordlst[j - 2][i].count(wordlst[j][i])
    if tmp == 0:
        cnt += 2
    elif tmp == 2:
        cnt += 1

print(cnt)"
"N=int(input())
*A,=map(int,input().split())
A.sort()

count=A[0]
i=1
while i<N:
    count=count^A[i]
    i+=1

if count==0:
    print('Yes')
else:
    print('No')"
"a = input().split()
print((a[0][0]+a[1][0]+a[2][0]).upper())"
"#m = int(input())
n, m = map(int, input().split())
#al = list(map(int, input().split()))
#al=[list(input()) for i in range(n)]
switch = []
kl = []
for i in range(m):
    temp = list(map(int, input().split()))
    kl.append(temp[0])
    switch.append(temp[1:])
pl = list(map(int, input().split()))
# print(switch)

pattern = [[0 for _ in range(n)] for _1 in range(2**n)]
for i in range(2**n):
    for j in range(n):
        if ((i >> j) & 1):  # 二進数iの下から数えてj桁目が1か否か
            pattern[i][j] = 1

ans = 0
for ptnum, spt in enumerate(pattern):
    islit = True
    for lightnum in range(m):
        count = 0
        for s in switch[lightnum]:
            if spt[s-1] == 1:
                count += 1
        if count % 2 != pl[lightnum]:
            islit = False
            break
    if islit:
        ans += 1
print(ans)
"
"n = int(input())
count = 0
for i in range(1,n+1):
  if 1<=i<=9 or 100<=i<=999 or 10000<=i<=99999:
    count += 1
print(count)"
"from collections import defaultdict

def main():
    N, P = map(int, input().split())
    S = list(map(int,list(input())))
    S_mod = [0] * N
    if P == 2:
        for i in range(N-1,-1,-1):
            if S[i] % 2 == 0:
                S_mod[i] = 1
        S_mod.reverse()
        ans = 0
        cnt = 0
        for i in range(N):
            if S_mod[i] == 1:
                cnt += 1
                ans += cnt
            else:
                ans += cnt
        print(ans)
        exit()
    if P == 5:
        for i in range(N-1,-1,-1):
            if S[i] % 5 == 0:
                S_mod[i] = 1
        S_mod.reverse()
        ans = 0
        cnt = 0
        for i in range(N):
            if S_mod[i] == 1:
                cnt += 1
                ans += cnt
            else:
                ans += cnt
        print(ans)
        exit()



    ten = 1
    for i in range(N-1,-1,-1):
        S_mod[i] = (S[i] * ten) % P
        ten *= 10
        ten %= P
    S_mod.reverse()
    S_acc = [0] * (N+1)
    for i in range(N):
        S_acc[i+1] = (S_acc[i] + S_mod[i]) % P
    d = defaultdict(int)
    for i in range(N+1):
        d[S_acc[i]] += 1
    ans = 0
    for i, j in d.items():
        if j >= 2:
            ans += (j * (j-1)) // 2

    print(ans)
    





if __name__ == ""__main__"":
    main()"
"x, a, b = map(int, input().split())
if b - a > x: print('dangerous')
elif b <= a: print('delicious')
else: print('safe')
"
"n = input()
print('ABC{0}'.format(n))"
"n,l=map(int,input().split())
a=list(map(int,input().split()))
cnt=0
flag=False
for i in range(0,n-1):
    if not flag:
        if a[i]+a[i+1]>=l:
            cnt=i+1
            flag=True

if not flag:
    print(""Impossible"")
    exit()

ans=[cnt]

for i in range(cnt-1,0,-1):
    ans.append(i)
for i in range(cnt+1,n):
    ans.append(i)
ans=ans[::-1]
print(""Possible"")
for i in range(len(ans)):
    print(ans[i])
"
"def main():
	N = int(input())
	A = [int(a) for a in input().split("" "")]
	S = sum(A)
	cA = [0] * 1000001
	for i in range(len(A)):
		cA[A[i]] += 1
	Q = int(input())
	for i in range(Q):
		B, C = [int(x) for x in input().split("" "")]
		diff = (C-B)*cA[B]
		S += diff
		cA[C] += cA[B]
		cA[B] = 0
		print(S)

main()
"
"N = int(input())
S_1 = input()
S_2 = input()

is_vertical = []

i = 0
while i < N:
    if i < N - 1 and S_1[i] == S_1[i + 1]:
        is_vertical.append(False)
        i += 2
    else:
        is_vertical.append(True)
        i += 1

res = 3 if is_vertical[0] else 6

for i in range(1, len(is_vertical)):
    if is_vertical[i] and is_vertical[i - 1]:
        res *= 2
    elif is_vertical[i] and not is_vertical[i - 1]:
        res *= 1
    elif not is_vertical[i] and is_vertical[i - 1]:
        res *= 2
    else:
        res *= 3

print(res % (10 ** 9 + 7))
"
"import sys
input=lambda: sys.stdin.readline().rstrip()
mod=10**9+7
n,m=map(int,input().split())
n_max=2*(10**5+1)
F,FI=[0]*(n_max+1),[0]*(n_max+1)
F[0],FI[0]=1,1
for i in range(n_max):
  F[i+1]=(F[i]*(i+1))%mod
FI[n_max-1]=pow(F[n_max-1],mod-2,mod)
for i in reversed(range(n_max-1)):
  FI[i]=(FI[i+1]*(i+1))%mod
def comb(x,y):
  return (F[x]*FI[x-y]*FI[y])%mod

pf={}
for i in range(2,int(m**0.5)+1):
  while m%i==0:
    pf[i]=pf.get(i,0)+1
    m//=i
if m>1:
  pf[m]=1

ans=1
for k in pf.keys():
  ans=(ans*comb(n-1+pf[k],pf[k]))%mod
print(ans)"
"import sys
import math
import bisect

def main():
    n = int(input())
    A = list(map(int, input().split()))
    ans = 0
    for i in range(1, n - 1):
        if A[i] == sorted([A[i-1], A[i], A[i+1]])[1]:
            ans += 1
    print(ans)

if __name__ == ""__main__"":
    main()
"
"
N = int(input())

s = 1

a = list(map(int,input().split()))
a.append(None)

ans = 0

for i in range(N):

    i += 1
    if a[i-1] == a[i]:
        s += 1

    else:
        ans += s//2
        s = 1

print (ans)
"
"# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)
import sys
def main(N, A):
    A = [-1] + A
    B = [0] * (N + 1)
    for i in range(N, 0, -1):
        xor = 0
        for j in range(i * 2, N + 1, i):
            xor ^= B[j]
        B[i] = xor ^ A[i]
    print(sum(B))
    print(*[i for i, b in enumerate(B) if b == 1])

if __name__ == '__main__':
    input = sys.stdin.readline
    N = int(input())
    *A, = map(int, input().split())
    main(N, A)
"
"S = raw_input()
print 'Yes' if 'AC' in S else 'No'"
"def main():
    p=sorted(int(input()) for _ in range(int(input())))
    p[-1] //= 2
    print(sum(p))
    
if __name__ == ""__main__"":
    main()"
"import math
n = int(input())
a = list(map(int, input().split()))
mod = 10**9 + 7

def lcm(a, b):
    return (a * b) // math.gcd(a, b)

a_lcm = 1
for ai in a:
    a_lcm = lcm(a_lcm, ai)

b_sum = 0
for ai in a:
    b_sum += a_lcm // ai

print(b_sum%mod)
"
"import numpy as np
dishes = [int(input()) for _ in range(5)]
dishes = sorted(dishes, key=lambda x: x % 10)
minutes = 0
first = True
for i in dishes:
    if i % 10 == 0:
        minutes += i
    else:
        if first:
            minutes += i
            first = False
        else:
            minutes += int(np.ceil(i/10)*10)
print(minutes)"
"import sys
input = sys.stdin.readline

a, b = [int(x) for x in input().split()]
if 2*b >= a:
    print(0)
else:
    print(a - 2*b)"
"s=input()
l=[ ""SUN"",""MON"",""TUE"",""WED"",""THU"",""FRI"",""SAT""]

ind=l.index(s)
if ind==0:
  print(7)
else:
  print(7-ind)"
"def gcd(a,b):
    if b == 0:
        return a
    else:
        return gcd(b,a%b)

N,M=map(int,input().split())
S=input()
T=input()

C=N*M//gcd(max(N,M),min(N,M))
n=C//N
m=C//M

i=0
j=0
ans=C
while i<C and j<C:
    if  i==j:
        if S[i//n]!=T[j//m]:
            ans=-1
        i+=n
        j+=m
    elif i<j:
        i+=n
    else:
        j+=m
print(ans)"
"a=list(map(int,input().split()))
thing=set()
for i in range(3):
  thing.add(a[i])
print(len(thing))
"
"N = int(input())
a = 0

for n in range(N):
  x,u = input().split()
  
  if u==""JPY"":
    a+=int(x)
  else:
    a+=380000*float(x)

print(a)"
"#!/usr/bin/env python3

from collections import deque

n = int(input())

connect_list = [[] for _ in range(n)]

ab = [list(map(int, input().split())) for i in range(n-1)]

for i in range(n-1):
    a, b = ab[i]
    connect_list[a-1].append(b-1)
    connect_list[b-1].append(a-1)


color_list = {}
check_list = [0]*n

color_max = max(map(len, connect_list))

vertex = [0 for i in range(n)]
d = deque([0])

while(len(d) > 0):
    # print(d)
    index = d.pop()
    check_list[index] = 1

    index_list = connect_list[index]

    for i in index_list:
        if check_list[i] == 1:
            continue

        check_list[i] = 1
        d.append(i)
        num = vertex[index] % color_max+1
        color_list[(min(index, i), max(index, i))] = num
        vertex[index], vertex[i] = num, num


print(color_max)
for a, b in ab:
    print(color_list[(a-1, b-1)])
"
"s=str(input())
C= list(s)
list=[]
for I in range(len(C)):
    if C[I]!='B':
        list.append(C[I])
    elif C[I]=='B' and len(list)!=0:
        list.pop()
 
print("""".join(list))"
"n = input()
a = map(int,raw_input().split())

print min(a),max(a),sum(a)"
"import math
import sys
import queue
from collections import Counter
from itertools import accumulate
from fractions import gcd
from functools import reduce

def lcm(a, b):
    return a * b // gcd(a, b)

def combination_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))

def permutations_count(n, r):
    return math.factorial(n) // math.factorial(n - r)

mod = 1000000007

""""""
# 標準入力取得
## 文字列
    = sys.stdin.readline().rstrip()
    = list(sys.stdin.readline().rstrip())

## 数値
    = int(sys.stdin.readline())
    = map(int, sys.stdin.readline().split())
    = list(map(int, sys.stdin.readline().split()))
    = [list(map(int,list(sys.stdin.readline().split()))) for i in range(N)]
""""""

if __name__ == ""__main__"":
    N = int(sys.stdin.readline())
    print(lcm(2, N))"
"N, M, X = map(int, input().split())
A = list(map(int, input().split()))
costRight, costLeft = 0, 0
for i in range(X, N):
    if i in A:
        costRight +=1
for i in range(X, 0, -1):
    if i in A:
        costLeft += 1
print(min(costRight, costLeft))"
"N=input()

if (N[0:3].count(N[0])==3) or (N[1:4].count(N[3])==3):
	print(""Yes"")
else:
	print(""No"")
"
"n = int(input())
A = list(map(int, input().split()))

import fractions
#import math
from functools import reduce

def gcd(*numbers):
    return reduce(fractions.gcd, numbers)
    #return reduce(math.gcd, numbers)

def gcd_list(numbers):
    return reduce(fractions.gcd, numbers)
    #return reduce(math.gcd, numbers)

g = gcd_list(A)
print(g)
"
"vis = [0]*4

for i in range(3):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    vis[a] += 1
    vis[b] += 1

cnt1 = vis.count(1)
cnt2 = vis.count(2)

if cnt1 == 2 and cnt2 == 2:
    print(""YES"")
else:
    print(""NO"")"
"# coding: utf-8
# Your code here!
a,b=map(int,input().split())
if  (1<=a<=9) and (1<=b<=9):
    print(a*b)
else:
    print(-1)"
"n,m=map(int,input().split())

def make_divisors(n):
    lower_divisors , upper_divisors = [], []
    i = 1
    while i*i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n//i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
  
a=make_divisors(m)

ans=[]

for i in a:
  if m//i>=n:
    ans.append(i)
    
print(max(ans))"
"from heapq import heapify, heappush, heappop
class HeapQue(object):
    def __init__(self, iterable, max_heap=False):
        self.sign = -1 if max_heap else 1
        sequence = [self.sign * number for number in iterable]
        heapify(sequence)
        self.heapque = sequence

    def push(self, item):
        heappush(self.heapque, item * self.sign)

    def pop(self):
        try:
            return heappop(self.heapque) * self.sign
        except:
            return 0

N, M = map(int, input().split())
jobs = sorted((tuple(map(int, input().split())) for _ in range(N)), key=lambda t: t[0], reverse=True)
q = HeapQue([], max_heap=True)
total = 0
for i in range(1, M + 1):
    while jobs and jobs[-1][0] == i:
        q.push(jobs.pop()[1])
    total += q.pop()
print(total)"
"#!/usr/bin/env python3

A, B, C = map(int, input().split())
if A == B: print(C)
elif A == C: print(B)
else: print(A)
"
"S=input()
T=""abcdefghijklmnopqrstuvwxyz""

for c in T:
    if S.count(c)==0:
        print(c)
        break;
else:
    print(""None"")
"
"K, T = map(int, input().split())
cake = [int(i) for i in input().split()]

print(max((max(cake) - 1 - (K -  max(cake))), 0))"
"X = int(input())
exps = []
for b in range(1,34):
  for p in range(2,11):
    x = b**p
    if x < 1001:
      exps.append(x)
exps = list(set(exps))
exps.sort()
for a in exps[::-1]:
  if X >= a:
    print(a)
    break"
"slist = list(input())
tlist = list(input())

slist_new = [slist[0] + '0', slist[1] + '1', slist[2] + '2']
tlist_new = [tlist[0] + '0', tlist[1] + '1', tlist[2] + '2']

list02 = slist_new + tlist_new
andlist = [x for x in list02 if list02.count(x) > 1]

print(len(andlist) // 2)
"
"if __name__ == ""__main__"":
    a, b, x = [int(x) for x in input().split("" "")]
    print(((b // x) + 1 - (((a - 1) // x) + 1)))
"
"from math import ceil


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    def check(Min):
        kill = 0
        for a in A:
            kill += (ceil(a/Min)-1)
        return kill <= K

    l = 0
    r = 1000000000

    while r-l > 1:
        mid = (l+r)//2
        if check(mid):
            r = mid
        else:
            l = mid
    print(r)
        


if __name__ == '__main__':
    main()"
"m_1,d_1 = map(int,input().split())
m_2,d_2 = map(int,input().split())
if m_1 < m_2:
  print('1')
else:
  print('0')"
"n,k = map(int,input().split())
l = list(map(int, input().split()))
freq = [0]*(n+1)
for i in l:
    freq[i]+=1
freq.sort()
vf = len(freq) - k if len(freq)> k else 0
print(sum(freq[:vf]))"
"import math
from functools import reduce

def lcm_base(x, y):  
    return (x * y) // math.gcd(x, y)

def lcm(*numbers):
    return reduce(lcm_base, numbers, 1)

def lcm_list(numbers):
    return reduce(lcm_base, numbers, 1)

N = int(input())
c = []
for _ in range(N):
    c.append(int(input()))

print(lcm(*c))"
"s = int(input())

v = [False] * 1000001
v[s] = True

i = 1
while True:
    i += 1
    if s % 2 == 0:
        s = s // 2
    else:
        s = 3 * s + 1
    
    if v[s]:
        break
    else:
        v[s] = True

print(i)"
"#!usr/bin/env python3
from collections import defaultdict
from collections import deque
from heapq import heappush, heappop
import sys
import math
import bisect
import random
import itertools
sys.setrecursionlimit(10**5)
stdin = sys.stdin
def LI(): return list(map(int, stdin.readline().split()))
def LF(): return list(map(float, stdin.readline().split()))
def LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))
def II(): return int(stdin.readline())
def IF(): return float(stdin.readline())
def LS(): return list(map(list, stdin.readline().split()))
def S(): return list(stdin.readline().rstrip())
def IR(n): return [II() for _ in range(n)]
def LIR(n): return [LI() for _ in range(n)]
def FR(n): return [IF() for _ in range(n)]
def LFR(n): return [LI() for _ in range(n)]
def LIR_(n): return [LI_() for _ in range(n)]
def SR(n): return [S() for _ in range(n)]
def LSR(n): return [LS() for _ in range(n)]
mod = 1000000007
inf = float(""INF"")

#A
def A():
    x, y = LI()
    print(x+y//2)
    return

#B
def B():
    II()
    t, a = LI()
    h = LI()
    ans = [0,inf]
    for num, i in enumerate(h):
        if ans[1] > abs(t - a - i * 0.006):
            ans = [num, abs(t - a - i * 0.006)]
    print(ans[0] + 1)
    return

#C
def C():
    n, m = LI()
    py = LIR(m)
    pya = py[::1]
    py.sort(key=lambda x: x[1])
    city = [1 for i in range(n)]
    dicity = {}
    for p, y in py:
        dicity[(p,y)] = city[p-1]
        city[p-1] += 1    
    for p, y in pya:
        a = ""00000"" + str(p)
        a = a[-6:]
        b = ""00000"" + str(dicity[(p, y)])
        b = b[-6:]
        print(a+b)

    return

#D
def D():
    h, w, k = LI()
    stick = [[0, 0] for i in range(w)]
    stick[0] = [1, 0]
    for i in range(1, w):
        stick[i][0] += stick[i - 1][0] + stick[i - 1][1]
        stick[i][1] += stick[i - 1][0]
    dp1 = [0] * (w + 2)
    dp1[1] = 1
    for i in range(h):
        dp2 = [0] * (w + 2)
        for wi in range(1, w + 1):
            tmp = dp1[wi - 1] * stick[wi - 1][1] * stick[w - wi][0]
            tmp += dp1[wi + 1] * stick[w - wi][1] * stick[wi - 1][0]
            tmp += dp1[wi] * stick[wi - 1][0] * stick[w - wi][0]
            dp2[wi] = tmp
            dp2[wi] %= mod
        dp1 = dp2
    print(dp2[k])

    return

#Solve
if __name__ == '__main__':
    D()
"
"n = int(input())
x = [float(s) for s in input().split()]
y = [float(s) for s in input().split()]

xy = [abs(xi-yi) for xi,yi in zip(x,y)]

D = lambda p:sum([xyi**p for xyi in xy])**(1/p)

print(D(1.0))
print(D(2.0))
print(D(3.0))
print(max(xy))"
"N = input()
MM = input().split()
list1 =[]
for i in MM:
  x = int(i)
  list1.append(x)
list1.sort(reverse = True)
total = 0
for i in range(len(list1)):
  if i%2 ==0:
    total += list1[i]
  else:
    total -= list1[i]
print(total)"
"s = raw_input().split()

stack = []
for op in s:
	if op.isdigit():
		stack.append(op)
	else:
		b = int(stack.pop())
		a = int(stack.pop())
		ret = 0
		if op == ""+"":
			ret = a + b
		elif op == ""-"":
			ret = a - b
		elif op == ""*"":
			ret = a * b
		stack.append(str(ret))
print stack.pop()"
"N = int(input())
block = list(map(int,input().split()))
a = 1
for i in block:
  if i == a:
    a += 1
if a==1:
  print(-1)
else:
  print(len(block)-a+1)"
"#C
n = int(input())
a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())

t = [a,b,c,d,e]
t.sort()

if n % t[0] == 0:
    p = n // t[0]
else:
    p = n // t[0] + 1
    
print(4+p)"
"a=input()
s=[0]*26
for i in range(len(a)):
    s[ord(a[i])-97]=1
if sum(s)==26:
    print(""None"")
else:
    print(chr(s.index(min(s))+97))"
"import sys
import math
import string
import fractions
import random
from operator import itemgetter
import itertools
from collections import deque
import copy
import heapq
from bisect import bisect, bisect_left, bisect_right

MOD = 10 ** 9 + 7
INF = float('inf')
input = lambda: sys.stdin.readline().strip()

sys.setrecursionlimit(10 ** 8)

s = input()
N = len(s)
p = 0
g = 0
ans = 0
for i in range(N):
    if s[i] == ""g"":
        if p + 1 <= g:
            ans += 1
            p += 1
        else:
            g += 1
    else:
        if p + 1 <= g:
            p += 1
        else:
            ans -= 1
            g += 1
print(ans)
"
"X, Y = input().split()
x = ord(X); y = ord(Y)

if x < y:
  print('<')
elif x == y:
  print('=')
else:
  print('>')"
"A, B = map(int, input().split())

ans = 0
for i in range(B):
  ans += A
  if ans%B == 0:
    break
    
print(ans)"
"s= input()
ans= """"
for i in range(int((len(s)+ 1)/ 2)):
  ans+= s[i* 2]
  
print(ans)"
"""""""
rootを決めて、aから必ずrootを通ってbに到達するとする
aとbのlcaより上は、+2されることになるので、実質通っていないのと同値
どんな木であっても、自分自身が偶数回(0を含む)でてこないと
ノードの値は偶数にはなりえない
""""""
n, m = map(int, input().split())
cnts = [0] * (n+1) 
for i in range(m):
    a,b = map(int, input().split())
    cnts[a] += 1
    cnts[b] += 1
if all([c%2 == 0 for c in cnts]):
    print(""YES"")
else:
    print(""NO"")"
"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

l = [A - B for A,B in zip(a,b)]
if sum(l) < 0:
    print(-1)
    exit()

nega = [i for i in l if i < 0]
posi = [i for i in l if i > 0]
nega.sort()
posi.sort()

p = 0
ans = 0
for n in nega:
    ans += 1
    p += n
    if p <= 0 and posi:
        # 補給
        p += posi.pop()
        ans += 1

print(ans)"
"import math
n,k=map(int,input().split());m=10**9+7
for i in range(1,k+1): print(math.comb(n-k+1,i)*math.comb(k-1,i-1)%m)"
"N = int(input())

def factorization(num):
    res = []
    n = num
    div_max = int(num ** 0.5)
    for i in range(2, div_max+1):
        if n % i == 0:
            count = 0
            while n % i == 0:
                count += 1
                n //= i
            res.append([i, count])

    if n != 1:
        res.append([n, 1])

    if len(res) == 0:
        res.append([num, 1])

    return res

res = factorization(N)

ans = 0
for i in range(len(res)):

    p, n = res[i]
    if p != 1:
        j = 1
        while n - j >= 0:
            ans += 1
            n -= j
            j += 1

print(ans)"
"dxdy = [(0, 1), (0, -1), (1, 0), (-1, 0)]
h, w = map(int, input().split())
s = [list(input()) for _ in range(h)]
for i in range(h):
    for j in range(w):
        if (i + j) % 2:
            if s[i][j] == '.':
                s[i][j] = '#'
            else:
                s[i][j] = '.'
d = [[True] * w for _ in range(h)]
ans = 0
for i in range(h):
    for j in range(w):
        if not d[i][j]:
            continue
        d[i][j] = False
        st = [(i, j)]
        b, wh = 0, 0
        while st:
            y, x = st.pop()
            if (x + y) % 2:
                b += 1
            else:
                wh += 1
            for dx, dy in dxdy:
                if 0 <= x + dx < w and 0 <= y + dy < h and d[y + dy][x + dx] and s[y][x] == s[y + dy][x + dx]:
                    st.append((y + dy, x + dx))
                    d[y + dy][x + dx] = False
        ans += b * wh
print(ans)
"
"rawtemp = input()
temp = int(rawtemp)

if temp < 30:
    print(""No"")
else:
    print(""Yes"")"
"a = list(map(str,(input())))
b = list(map(str,(input())))
c = list(map(str,(input())))
 
card = a[0]
 
for i in range(len(a) + len(b) + len(c)):
    if card == 'a':
        if a == []:
            print(""A"")
            break
        else:
            card = a[0]
            a.pop(0)
 
    elif card == 'b':
        if b == []:
            print(""B"")
            break
        else:
            card = b[0]
            b.pop(0)
 
    else:
        if c == []:
            print(""C"")
            break
        else:
            card = c[0]
            c.pop(0)"
"n = int(input())
a = list(map(int, input().split()))
a_suseki = 1
a_nukewa = 0

for i in range(n):
  a_suseki = a_suseki * a[i]

for i in range(n):
  a_nukewa = a_nukewa + (a_suseki/a[i])

print(a_suseki / a_nukewa)"
"b,a = map(int,input().split())
lis = []
for i in range(50):
	g = []
	for m in range(100):
		g.append(""."")
	lis.append(g)
for i in range(50):
	g = []
	for m in range(100):
		g.append(""#"")
	lis.append(g)
cou = 0
co = 0
for k in range(a-1):
	lis[cou][co] = ""#""
	co += 2
	if co >= 100:
		co = 0
		cou += 2
cou = 51
co = 0
for h in range(b-1):
	lis[cou][co] = "".""
	co += 2
	if co >= 100:
		co = 0
		cou += 2
print(""100 100"")
for m in range(100):
	print("""".join(lis[m]))"
"class Dice(object):
    
    def __init__(self, line):
        self.top = 1
        self.bottom = 6
        self.south = 2
        self.east = 3
        self.west = 4
        self.north = 5
        self.convert = [int(s) for s in line.split()]
    
    def move(self, direction):
        if 'N' == direction:
            self.top, self.north, self.bottom, self.south = self.south, self.top, self.north, self.bottom
        elif 'S' == direction:
            self.top, self.north, self.bottom, self.south = self.north, self.bottom, self.south, self.top
        elif 'W' == direction:
            self.top, self.east, self.bottom, self.west = self.east, self.bottom, self.west, self.top
        elif 'E' == direction:
            self.top, self.east, self.bottom, self.west = self.west, self.top, self.east, self.bottom
    
    def search(self, line):
        top, south = [int(s) for s in line.split()]
        for direction in 'NNNNWNNNN':
            self.move(direction)
            if self.convert[self.south - 1] == south:
                break
        for direction in 'WWWW':
            self.move(direction)
            if self.convert[self.top - 1] == top:
                break
        return self.result()
        
    def result(self):
        return self.convert[self.east - 1]
    
dice = Dice(input())
for i in range(int(input())):
    print(dice.search(input()))"
"def main():
    a=sorted(map(int,input().split()))
    print(abs(a[1]-a[0]) + abs(a[2]-a[1]))
    
if __name__ == ""__main__"":
    main()"
"A = list(map(int, input().split()))
A = sorted(A)
B = str(A[2]) + str(A[1])
print(int(B)+ A[0])"
"import bisect
import copy
import heapq
import math
import sys
from collections import *
from itertools import accumulate, combinations, permutations, product
# from math import gcd
def input():
    return sys.stdin.readline()[:-1]
def ruiseki(lst):
    return [0]+list(accumulate(lst))
mod=pow(10,9)+7
al=[chr(ord('a') + i) for i in range(26)]
direction=[[1,0],[0,1],[-1,0],[0,-1]]

m,k=map(int,input().split())

if m==0 and k!=0:
    print(-1)
    quit()
elif m==1 and k!=0:
    print(-1)
    quit()
elif k>=2**m:
    print(-1)
    quit()
if m==1 and k==0:
    print(*[0,0,1,1])
    quit()

lst=[i for i in range(2**m) if i!=k]
# print(lst)
anslst=lst[:]+[k]+sorted(lst,key=lambda x: -x)+[k]
print(*anslst)"
"import itertools,math
N = int(input())
x = [0] * N
y = [0] * N
for i in range(N):
    x[i], y[i] = map(int, input().split())
seq=[]
for i in range(N):
    seq.append(i)
    
l=list(itertools.permutations(seq))

num=0
for i in l:
    for u in range(1,len(i)):
        num+=math.sqrt((x[i[u-1]]-x[i[u]])**2+(y[i[u-1]]-y[i[u]])**2)
print(num/len(l))    "
"from collections import *;M=lambda:map(int,input().split());r=range;n,k,l=M()
def f(m):
 *a,=r(n)
 def g(i):
  if a[i]==i:return i
  a[i]=g(a[i]);return a[i]
 for _ in r(m):p,q=M();a[g(q-1)]=g(p-1)
 return g
x,y=f(k),f(l);c=Counter((x(i),y(i))for i in r(n));print(*(c[x(i),y(i)]for i in r(n)))"
"def shuffle(index):
    global a
    a = a[index:]+a[:index]
    
while True:
    a = input()
    if a == '-':
        break
    for i in range(int(input())):
        shuffle(int(input()))
    print(a)"
"# -*- coding: utf-8 -*-

#----------
a,b = input().rstrip().split()
#----------

if (a == ""H"" and b == ""H"") or (a == ""D"" and b == ""D""):
    print(""H"")

if (a == ""H"" and b == ""D"") or (a == ""D"" and b == ""H""):
    print(""D"")
"
"K, X = [int(s) for s in input().split()]
print('Yes' if X <= K * 500 else 'No')"
"n = int(input())
ans  = 0
for i in range(1,n+1):
    ans += (i + i*(n//i))*(n//i)/2

print(int(ans))"
"n, a, b = map(int, input().split())
if (b-a)%2 == 0:
    ans = (b-a)//2
else:
    ans = 0
    if a-1 <= n-b:
        ans += a
        a, b = 1, b-a
        ans += (b-a)//2
    else:
        ans += n-b+1
        a, b = a+n-b+1, n
        ans += (b-a)//2
print(ans)
"
"R = int(input())
if (R<1200):
    print('ABC')
elif (1200<=R) and (R<2800):
    print('ARC')
else:
    print('AGC')
"
"import sys
sys.setrecursionlimit(10**9)
INF=10**18
def input():
    return sys.stdin.readline().rstrip()

def main():
    N,K=map(int,input().split())
    A=list(map(int,input().split()))
    A.sort()
    F=list(map(int,input().split()))
    F.sort(reverse=True)
    
    def nibutan(ok,ng):
        while abs(ok-ng) > 1:
            mid = (ok + ng) // 2
            if solve(mid):
                ok = mid
            else:
                ng = mid
        return ok
    
    def solve(mid):
        k=0
        for i in range(N):
            k+=max(0,-(-(A[i]*F[i]-mid)//F[i]))
        if k<=K:
            return True
        else:
            return False
    
    print(nibutan(10**18,-1))
        
    
    

if __name__ == '__main__':
    main()
"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 7)

d, n = map(int, input().split())

if n != 100:
    print((100 ** d) * n)
else:
    print((100 ** d) * (n + 1))
"
"import sys

readline = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)


def main():
    N, A, B = map(int, readline().split())

    print(min(N * A, B))


if __name__ == '__main__':
    main()
"
"N=int(input())
cnt=[0 for _ in range(N+1)]
for i in range(1,N+1):
    cnt[i]=cnt[i-1]+1
    a=6
    while i-a>=0:
        cnt[i]=min(cnt[i],cnt[i-a]+1)
        a*=6
    a=9
    while i-a>=0:
        cnt[i]=min(cnt[i],cnt[i-a]+1)
        a*=9
print(cnt[N])
"
"a,b,c=map(int,input().split())
ans=0
for s in range(a):
    d,e=map(int,input().split())
    if b<=d and c<=e:
        ans+=1
print(ans)"
"k,n = map(int, input().split( ))
arr = list(range(n-k+1, n+k))

print("" "".join([str(n) for n in arr]))"
"from math import gcd
from collections import defaultdict


def sign(x):
    if x < 0:
        return -1
    if x > 0:
        return +1
    return 0


def power(a, b, m):
    res = 1
    base = a
    while b:
        if b & 1:
            res = res * base % m
        base = base * base % m
        b = b >> 1
    return res


N = int(input())
M = 1000000007
cnt = defaultdict(int)
case00 = 0

for _ in range(N):
    a, b = map(int, input().split())
    if a == 0 and b == 0:  # (0, 0) cannot pair with anyone
        case00 += 1
        continue

    s = sign(a) * sign(b)
    a, b = abs(a), abs(b)
    g = gcd(a, b)
    a, b = a // g, b // g
    cnt[s, a, b] += 1


ans = 1  # empty set
vis = set()
for (s, a, b) in cnt.keys():
    if (s, a, b) in vis:
        continue

    if (-s, b, a) in cnt:
        mul = 1  # empty set from (s, a, b) and (-s, b, a)
        mul += power(2, cnt[s, a, b], M) - 1  # non-empty subsets from (s, a, b)
        mul += power(2, cnt[-s, b, a], M) - 1  # non-empty subsets from (-s, b, a)
        ans = ans * (mul % M) % M
        vis.add((-s, b, a))
    else:
        ans = ans * power(2, cnt[s, a, b], M) % M

ans = (ans - 1 + M) % M  # Remove empty set
ans = (ans + case00) % M  # Special case
print(ans)
"
"class Dice(object):
    """"""Dice Class

    """"""

    def __init__(self, numbers):
        """"""

        Args:
            numbers:
        """"""
        self.numbers = {1: numbers[0], 2: numbers[1], 3: numbers[2], 4: numbers[3], 5: numbers[4], 6: numbers[5]}

        self.vertical = [self.numbers[1], self.numbers[2], self.numbers[6], self.numbers[5]]
        self.horizontal = [self.numbers[4], self.numbers[1], self.numbers[3], self.numbers[6]]

    def move_dice(self, s):
        """"""

        Args:
            s: move direction

        Returns:

        """"""
        if s == 'N':
            self.move_north()
        elif s == 'S':
            self.move_south()
        elif s == 'W':
            self.move_west()
        elif s == 'E':
            self.move_east()

    def move_south(self):
        """"""move this dice towered north
        """"""
        self.vertical = (self.vertical * 2)[3:7]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]

    def move_north(self):
        """"""move this dice towered south
        """"""
        self.vertical = (self.vertical * 2)[1:5]
        self.horizontal[1] = self.vertical[0]
        self.horizontal[3] = self.vertical[2]

    def move_east(self):
        """"""move this dice towered east
        """"""
        self.horizontal = (self.horizontal * 2)[3:7]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]

    def move_west(self):
        """"""move this dice towered west
        """"""
        self.horizontal = (self.horizontal * 2)[1:5]
        self.vertical[0] = self.horizontal[1]
        self.vertical[2] = self.horizontal[3]

    def get_top(self):
        return self.vertical[0]


numbers = [int(x) for x in raw_input().split()]
dice1 = Dice(numbers=numbers)
for s in raw_input():
    dice1.move_dice(s)

print(dice1.get_top())"
"import itertools
n = int(input())
dic = {}
for x in range(1, 101):
  for y in range(1, 101):
    for z in range(1, 101):
      f_xyz = x**2 + y**2 + z**2 + x*y + y*z + z*x
      if f_xyz in dic:
        dic[f_xyz] += 1
      else:
        dic[f_xyz] = 1
for i in range(1, n+1):
  if i in dic:
    print(dic[i])
  else:
    print(0)"
"s = input()
if s[0] == s[1] and s[2] == s[3] and s[0] != s[2]:
    print('Yes')
elif s[0] == s[2] and s[1] == s[3] and s[0] != s[1]:
    print('Yes')
elif s[0] == s[3] and s[1] == s[2] and s[0] != s[1]:
    print('Yes')
else:
    print('No')"
"def DFS(s, t):
    t += 1
    flag[s] = 1
    d[s] = t
    for i in range(1, n+1):
        if G[s][i] == 1:
            if flag[i] == 0:
                DFS(i, t)
                t = f[i]
    f[s] = t + 1

n = int(raw_input())
G = [[0 for i in range(n+1)] for j in range(n+1)]
d = [0 for i in range(n+1)]
f = [0 for i in range(n+1)]

for i in range(n):
    v = map(int, raw_input().split())
    for j in range(v[1]):
        G[v[0]][v[2+j]] = 1

flag = [0 for i in range(n+1)]
for i in range(1, n+1):
    if flag[i] == 0:
        DFS(i, max(f))

for i in range(1, n+1):
    print(str(i) + "" "" + str(d[i]) + "" "" + str(f[i]))"
"N=int(input())
A=list(map(int,input().split()))

r,S,R=0,0,0

for l in range(N):
  while r<N:
    if S&A[r]==0:
      S|=A[r]
      r+=1
    else:
      break
  R+=r-l
  S&=~A[l]

print(R)
"
"N,A,B = map(int,input().split())
i = N // (A + B)
N -= (A + B) * i

cnt_A = i * A

if N < A:
  cnt_A += N
else:
  cnt_A += A
  
print(cnt_A)"
"import sys
INF = 10 ** 9
MOD = 10 ** 9 + 7
from collections import deque
sys.setrecursionlimit(100000000)

def main():
    s = list(input())
    
    cnt = 0
    ans = 0
    if len(s) < 3:
        print(0)
        exit()

    i = len(s) - 1
    while i > 0:
        while i > 0 and s[i-1] == 'B' and s[i] == 'C':
            cnt += 1
            i -= 2  
            while i >= 0 and s[i] == 'A':
                ans += cnt
                i -= 1
        else:
            cnt = 0
            i -= 1

    print(ans)
if __name__=='__main__':
    main()
"
"#Digit Number

while True:
    try:
        i, n = input(). split()
        m = str(int(i) + int(n))
        print(len(m))
    except:
        break"
"from sys import stdin
N = int(stdin.readline().rstrip())
A = [int(x) for x in stdin.readline().rstrip().split()]
ans = 0
for i in range(N):
    if A[A[i]-1] == i+1:
        ans += 1
print(ans//2)"
"from collections import Counter
N, K, Q = map(int, input().split())
A = Counter([int(input()) for _ in range(Q)])
[print(""Yes"" if K > Q - A.get(i+1, 0) else ""No"") for i in range(N)]
"
"import sys
from heapq import heappush, heappop


I = sys.stdin.readlines()
N, Q = map(int, I[0].split())
P = []
for i in range(1, N + 1):
    s, t, x = map(int, I[i].split())
    P.append((s - x, t - 1 - x, x))
P.sort()


q = []
cur = 0
ans = [-1] * Q
for i in range(N + 1, N + Q + 1):
    d = int(I[i])
    while cur < N and P[cur][0] <= d:
        s, t, x = P[cur]
        heappush(q, (x, t))
        cur += 1
    while q and q[0][1] < d:
        heappop(q)
    if q:
        ans[i - N - 1] = q[0][0]

print(*ans, sep='\n')
"
"N = int(input())
T = list(map(int, input().split()))
M = int(input())
P = [list(map(int, input().split())) for _ in range(M)]
for p in P:
    copy_p = T.copy()
    copy_p[p[0] - 1] = p[1]
    print(sum(copy_p))"
"import sys

printf = sys.stdout.write


abc = []
ans = [0 for i in range(26)]

for i in range(26):
    abc.append(str(chr(i + 97)))


word = []
for line in sys.stdin:
    word.append(line)

for i in range(len(word)):
    for j in range(len(word[i])):
        for k in range(29):
            if (k + 65) == ord(word[i][j]) or (k + 97) == ord(word[i][j]): 
                ans[k] += 1

for i in range(26):
    printf(abc[i] + "" : "" + str(ans[i]) + ""\n"")"
"from collections import deque
import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
def main():
    N=ii()
    G = [[] for _ in range(N)]
    E = []
    _E = set()
    for i in range(N-1):
        a,b=mi()
        G[a-1].append(b-1)
        G[b-1].append(a-1)
        E.append((a-1,b-1))
        _E.add((a-1,b-1))
    
    leaf = 0
    for i in range(N):
        g = G[i]
        if len(g) == 1:
            leaf = i

    stack = deque([(leaf,1,None)])
    seen = set()
    path = {x:0 for x in E}
    K = 0

    def save(edge,color):
        if edge == None: return

        a,b = edge
        if (a,b) in _E:
            path[(a,b)] = color
        else:
            path[(b,a)] = color


    while stack:
        current,color,edge = stack.popleft()
        seen.add(current)
        save(edge,color)
        K = max(K,color)
        # print(current,color,edge)

        i = 1
        for next in G[current]:
            if next in seen: continue
            if color == i:
                i += 1
            
            stack.append((next,i,(current,next)))
            i += 1
    
    if N == 2:
        print(1)
        print(1)
        exit()


    print(K)
    for i in range(N-1):
        a,b = E[i]
        print(path[(a,b)],sep="""")







if __name__ == ""__main__"":
    main()"
"import sys
n, k = map(int, input().split())
if k == 0:
  print(n * n)
  sys.exit()
ans = n * n
for b in range(1, n + 1):
  if b <= k:
    ans -= n
    continue
  ans -= (n + 1) // b * k - 1
  ans -= min((n + 1) % b, k)
print(ans)
"
"#import numpy as np
import math
import collections
import bisect


def main():
    a = int(input())

    print(a + a**2 + a**3)


if __name__ == '__main__':
    main()
"
"A = int(input())
B = int(input())
print(B*2-A)"
"import sys
from decimal import Decimal as D, ROUND_FLOOR


def resolve(in_):
    x = D(next(in_))
    year = 0
    deposit = D('100')
    rate = D('1.01')
    a = D('1.')

    while deposit < x:
        year += 1
        deposit *= rate
        deposit = deposit.quantize(a, rounding=ROUND_FLOOR)
    
    return year


def main():
    answer = resolve(sys.stdin)
    print(answer)


if __name__ == '__main__':
    main()"
"""""""
b > g > r

""""""

r, g, b = list(map(int, input().split()))
k = int(input())
flag = False
for i in range(k):
    if r >= b and b > 2 * g :
        g *= 2
    elif r >= g and b > 2 * g:
        g *= 2
    else:
        b *= 2

if r < g < b:
    flag = True
print(""Yes"") if flag else print(""No"")"
n=input();print('NYoe s'[n[0]=='9' or n[1] =='9'::2])
"MOD=10**9+7
n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
x_sum=sum((2*i-n+1)*x[i]for i in range(n))
y_sum=sum((2*i-m+1)*y[i]for i in range(m))
print(x_sum*y_sum%MOD)"
"import bisect,collections,copy,heapq,itertools,math,string
import sys
def S(): return sys.stdin.readline().rstrip()
def M(): return map(int,sys.stdin.readline().rstrip().split())
def I(): return int(sys.stdin.readline().rstrip())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LS(): return list(sys.stdin.readline().rstrip().split())
x, y, z = M()
ans= 0
for i in range(1, 50000):
    if y*i + z*(i+1) <= x:
        ans = i
    else:
        break
print(ans)"
"a,b,c,d=map(int,input().split())
for i in range(a):
  if i<d:
    print('1'*c+'0'*(b-c))
  else:
    print('0'*c+'1'*(b-c))"
"
def main():
    x, y = map(int, input().split())
    print(x + int(y * 0.5))


if __name__ == ""__main__"":
    main()
"
"# C - Vacation AC
N = int(input())
A = []
for _ in range(N):
    a,b,c = map(int,input().split())
    A.append((a,b,c))
    
# 無限大の値
INF = 10**10

# DP テーブル (値と前に選んだ活動を保持)
# a (j = 0), b (j = 1), c (j = 2)に記録
dp = [[0]*3 for _ in range(100010)]

# DP テーブル全体を初期化
for i in range(100010):
    for j in range(3):
        dp[i][j] = -INF# 最大化問題
        
# 初期条件
dp[0][0],dp[0][1],dp[0][2] = 0,0,0
        
# v 日目以前に (v 日目以前の幸福度最大値を求める)
for v in range(1,N+1):
    # v 日目の活動
    for w in range(3):
        # v-1 日目の活動
        for k in range(3):
            # 前日と活動が同じならスルー
            if w == k:
                continue
            # v 日目の情報は A[v-1] であることに注意
            dp[v][w] = max(dp[v][w], dp[v-1][k] + A[v-1][w])

# N 日目以前の幸福度最大値を出力
ans = max(dp[N])            
print(ans)"
"def main():
 
    N, K = map(int, input().split())
    p = []
    for _ in range(N):
        x, y = map(int, input().split())
        p.append([x, y])
    p.sort(key = lambda x: x[0])
 
    min_area = float('inf')
    for i in range(N-1):
        for j in range(i+1, N):
            if j-i+1 >= K:
                x1 = p[i][0]
                x2 = p[j][0]
                ys = []
                for k in range(i, j+1):
                    ys.append(p[k][1])
                ys.sort()
                for k in range(len(ys)):
                    for l in range(k+K-1, len(ys)):
                        y1 = ys[k]
                        y2 = ys[l]
                        area = (x2-x1)*(y2-y1)
                        if area > 0:
                            min_area = min(min_area, area)
    return min_area
 
if __name__ == '__main__':
    print(main())"
"X,Y,Z = (int(X) for X in input().split())
Y,X = X,Y
Z,X = X,Z
print('{} {} {}'.format(X,Y,Z))"
"S=str(input())
x=S.count(""+"")
y=S.count(""-"")
print(x-y)"
"n,m=map(int,input().split())
ac=[0]*n
wa=[0]*n
acc,wac=0,0

for i in range(m):
  p,s=input().split()
  p=int(p)
  
  if ac[p-1]==1:
    continue
    
  else:
    if s==""AC"":
      ac[p-1]=1
      
    else:
      wa[p-1]+=1
      
for i in range(n):
  if ac[i]==1:
    acc+=1
    wac+=wa[i]
    
print(acc,wac)"
"# https://atcoder.jp/contests/panasonic2020/tasks/panasonic2020_d

N = int(input())

alphabet = ""abcdefghijklmnopqrstuvwxyz""

curr_str = []

def print_str(curr_str):
    string = """"
    for i in curr_str:
        string += alphabet[i]
    print(string)


def dfs(index, curr_str, curr_char):
    if curr_char > index:
        return None
    if curr_char > max(curr_str) + 1:
        return None

    if index == N-1:
        print_str(curr_str + [curr_char])
        return None

    for i in range(N):
        dfs(index+1, curr_str+[curr_char], i)


if N == 1:
    print(""a"")
else:    
    for i in range(N):
        dfs(1, [0], i)"
"def main():
    N = int(input())
    A = int(input())
    if N <= A:
        print('Yes')
        return
    times = N // 500
    if times*500 + A >= N:
        print('Yes')
    else:
        print('No')
main()"
"def solve():
    n = int(input())
    if n % 2 == 0:
        print(0.5)
    else:
        print(((n+1)//2) / n)


if __name__ == '__main__':
    solve()
"
"N = int(input())

cities = {}
for i in range(1, N + 1):
    s, p = input().split()
    p = int(p)
    if s in cities:
        cities[s].append((p, i))
    else:
        cities[s] = [(p, i)]
for k in cities.keys():
    cities[k] = list(sorted(cities[k], key=lambda x: x[0], reverse=True))

names = sorted(cities)
for name in names:
    for p, i in cities[name]:
        print(i)
"
"n=int(input())
ab=[[int(i) for i in input().split()] for _ in range(n)]
cd=[[int(i) for i in input().split()] for _ in range(n)]
inab=[sum(map(lambda x:x[0]>a and x[1]>b,cd)) for a,b in ab]
incd=[sum(map(lambda x:x[0]<c and x[1]<d,ab)) for c,d in cd]
ans=0
while 1:
  f=1
  mab=1000
  for i in range(n):
    if inab[i] > 0 and mab > inab[i]:
      f=0
      mab=inab[i]
  if f:
    break
  mcd=1000
  tmp=(-1,-1)
  ans+=1
  for i in range(n):
    if mab==inab[i]:
      a,b=ab[i]
      for j in range(n):
        if incd[j]==0:continue
        c,d=cd[j]
        if a<c and b<d and mcd>incd[j]:
          mcd=incd[j]
          tmp=(i,j)
  ta,tb=ab[tmp[0]]
  tc,td=cd[tmp[1]]
  inab[tmp[0]]=0
  incd[tmp[1]]=0
  for i in range(n):
    a,b=ab[i]
    c,d=cd[i]    
    if inab[i]:
      if a<tc and b<td:
        inab[i]-=1
    if incd[i]:
      if c>ta and d>tb:
        incd[i]-=1  
print(ans)
"
"#!/usr/bin/env python3
from collections import Counter

n, *v = map(int, open(0).read().split())
odd = [v[i] for i in range(0, n, 2)]
even = [v[i] for i in range(1, n, 2)]
o = Counter(odd)
e = Counter(even)

if o.most_common()[0][0] != e.most_common()[0][0]:
    print(n - o.most_common()[0][1] - e.most_common()[0][1])
else:
    a = n - o.most_common()[0][1] - max(sorted(e.values())[:-1] + [0])
    b = n - e.most_common()[0][1] - max(sorted(o.values())[:-1] + [0])
    print(min(a, b))
"
"N, M, X = list(map(int, input().split()))
A = [0]*N

for i in range(N):
    A[i] = list(map(int, input().split()))

min_sump = -1
for i in range(2**(N+1)):
    sump = 0
    sume = [0]*M
    for j in range(N):
        ns = ""0"" + str(N) +""b""
        bi = format(i,ns)
        if bi[-1-j] == ""1"":
            sump += A[j][0]
            sume = list(map(sum, zip(sume, A[j][1:])))
    if all([i >= X for i in sume]):
        if min_sump == -1:
            min_sump = sump
        else:
            min_sump = min(min_sump,sump)

print(min_sump)"
"N = int(input())
A = list(map(int, input().split()))

ave = sum(A) / len(A)

for i in range(N):
  A[i] = abs(A[i]-ave)

minA = min(A)

print(A.index(minA))"
"n = int(input())
s = [input() for i in range(n)]
z = ['AC','WA','TLE','RE']

for j in z:
    print(j+' x '+str(s.count(j)))
"
"#
# abc057 b
#

import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""2 2
2 0
0 0
-1 0
1 0""""""
        output = """"""2
1""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""3 4
10 10
-10 -10
3 3
1 2
2 3
3 5
3 5""""""
        output = """"""3
1
2""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""5 5
-100000000 -100000000
-100000000 100000000
100000000 -100000000
100000000 100000000
0 0
0 0
100000000 100000000
100000000 -100000000
-100000000 100000000
-100000000 -100000000""""""
        output = """"""5
4
3
2
1""""""
        self.assertIO(input, output)


def resolve():
    N, M = map(int, input().split())
    S = [list(map(int, input().split())) for _ in range(N)]
    C = [list(map(int, input().split())) for _ in range(M)]

    ans = []
    for s in S:
        D = float(""inf"")
        t = 0
        for i in range(M):
            d = abs(s[0]-C[i][0]) + abs(s[1]-C[i][1])
            if d < D:
                D = d
                t = i
        ans.append(t+1)

    for a in ans:
        print(a)


if __name__ == ""__main__"":
    # unittest.main()
    resolve()
"
"t,h=0,0
for _ in range(int(input())):
 a,b=input().split()
 if a>b:t+=3
 if a<b:h+=3
 if a==b:t+=1;h+=1
print(t,h)"
"import sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**20
def I(): return int(input())
def F(): return float(input())
def S(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LS(): return input().split()

def resolve():
    X, A, B = LI()

    if B <= A:
        print('delicious')
    elif A < B <= A + X:
        print('safe')
    else:
        print('dangerous')

if __name__ == '__main__':
    resolve()"
"n, k = map(int, input().split())
# 最大ケース・うに: (n - 1) * (n - 2) // 2
# 最小ケース・完全グラフ: 0

if k <= (n - 1) * (n - 2) // 2:
    # つくれる
    hen = []
    for i in range(2, n + 1):
        hen.append((1, i))
    m = (n - 1) * (n - 2) // 2 - k
    while m:
        for i in range(2, n + 1):
            for j in range(i + 1, n + 1):
                hen.append((i, j))
                m -= 1
                if m == 0:
                    break
            if m == 0:
                break
    print(len(hen))
    for a, b in hen:
        print(a, b)

else:
    print(-1)
"
"#C - Same Integers
ABC = list(map(int,input().split()))
ABC = sorted(ABC,reverse = True)
A = ABC[0]#max
B = ABC[1]
C = ABC[2]#min
count = 0
while A != B:
    C += 1
    B += 1
    count += 1
while (B - C)%2 == 1:
    A += 1
    B += 1
    count += 1
while A!=C:
    C += 2
    count += 1
print(count)"
"
N, Y = map(int, input().split())
ans = min(N%Y, Y-(N%Y))
print(ans)"
"import sys

for line in sys.stdin:
    l = line.replace('\n', '')
    a, b = l.split()
    a = int(a)
    b = int(b)
    print(len(str(a+b)))"
"S = input()
nick = S[:3]
print(nick)


"
"n = int(input())
print(int(n/2)+n%2)"
"while True:
    x, y, z = map(int, input().split())
    if x == -1 and y == -1 and z == -1:
        break
    if x == -1 or y == -1:
        print ('F')
    elif x + y >= 80:
        print ('A')
    elif 65 <= x+y < 80:
        print ('B')
    elif 50 <= x+y < 65 or (30 <= x+y < 50 and z >= 50):
        print ('C')
    elif 30 <= x+y < 50:
        print ('D')
    elif x + y < 30:
        print ('F')
"
"import numpy as np
from itertools import groupby

N = int(input())
T = np.array(['0'] + input().split() + ['10000000000'], np.int64)
A = np.array(['10000000000'] + input().split() + ['0'], np.int64)
mod = 10 ** 9 + 7

t = (T[1:] != T[:-1]) * T[1:]
a = (A[1:] != A[:-1]) * A[:-1]
t = t[:-1]
a = a[1:]
seq = np.zeros(N, np.int64)

flag = True
tmp = np.where((t != 0) & (a != 0))[0]
if np.any(t[tmp] != a[tmp]):
    flag = False
seq = np.maximum(t, a)
if np.any(seq > T[1:-1]) or np.any(seq > A[1:-1]):
    flag = False

if flag:
    group = [(i, len(list(j))) for i, j in groupby(seq.tolist())]
    answer = 1
    for i in range(len(group)):
        if group[i][0] == 0:
            answer *= pow(min(group[i - 1][0], group[i + 1][0]), group[i][1], mod)
            answer %= mod
    print(answer)
else:
    print(0)
"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")


h,w = map(int, input().split())
a = [None]*h
for i in range(h):
    a[i] = input()
cx = 0
cy = 0
d = set()
while (cx,cy)!=(h-1, w-1):
    val = 0
#     print(cx,cy)
    for dx, dy in [(1,0), (0,1)]:
        ccx = cx+dx
        ccy = cy+dy
        if ccx>=h or ccy>=w or a[ccx][ccy]==""."":
            continue
        nx, ny = ccx, ccy
        val += 1
    if val>=2 or val==0:
        ans = ""Impossible""
        break
    cx, cy = nx, ny
else:
    vv = sum(sum(item==""#"" for item in items) for items in a)
    if vv==h+w-1:
        ans = ""Possible""
    else:
        ans = ""Impossible""
print(ans)"
"N = int(input())
A = list(map(int, input().split()))
MOD = 10**9+7

def gcd(x, y):
  while(x % y != 0 and y % x != 0):
    if(x > y):
      x = x % y
    else:
      y = y % x
  if(x > y):
    return y
  else:
    return x
      
def lcm(x, y, MOD):
  return x * y // gcd(x, y)

X = 1
ans = 0
for i in range(N):
  X = lcm(X, A[i], MOD)
for i in range(N):
  ans = (ans + X*pow(A[i], MOD-2, MOD))%MOD
print(ans)"
"def resolve():
    N = int(input())
    W = [input() for _ in range(N)]
    if len(set(W)) != N:
        print('No')
        return
    for i in range(N-1):
        if W[i][-1] != W[i+1][0]:
            print('No')
            return
    print('Yes')
    return

resolve()"
"tmp = list(map(int, input().split()))

for i in range(2):
    if tmp[i] == 1:
        tmp[i] = 14

A, B = tmp

if A > B:
    print(""Alice"")
elif A == B:
    print(""Draw"")
else:
    print(""Bob"")"
"N = int(input())
v = sorted(map(int, input().split()))

for i in range(N-1):
	v[i+1] = (v[i]+v[i+1])/2
print(v[N-1])"
"a = [[0 for i in range(100)] for j in range(100)]
b = [[0 for i in range(100)] for j in range(100)]
n, m, l = map(int, input().split())
for i in range(n):
    a[i][:m] = map(int, input().split())
for i in range(m):
    b[i][:l] = map(int, input().split())
for i in range(n):
    for j in range(l):
        c = 0
        for k in range(m):
            c += a[i][k] * b[k][j]
        if j == l-1:
            break
        print(c, end=' ')
    print(c)"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7 
#mod = 998244353
from decimal import *
#import numpy as np
#decimal.getcontext().prec = 10

A, B, Q = MAP()
s = [-INF] + [INT() for _ in range(A)] + [INF]
t = [-INF] + [INT() for _ in range(B)] + [INF]

for _ in range(Q):
	x = INT()
	idx_s = bisect(s, x)
	idx_t = bisect(t, x)

	ans = INF
	for S, T in product([idx_s, idx_s-1], [idx_t, idx_t-1]):
		if min(s[S], t[T]) <= x <= max(s[S], t[T]):
			tmp = abs(s[S]-t[T]) + min(abs(x-s[S]), abs(x-t[T]))
		else:
			tmp = max(abs(x-s[S]), abs(x-t[T]))
		ans = min(ans, tmp)

	print(ans)

"
"a, b, c, d = map(int, input().split())
diff = a + b - c - d
print(""Left"" if diff > 0 else ""Balanced"" if diff == 0 else ""Right"")"
"N, K = map(int, input().split())
if N % 2 == 0:
    ans = int(N / 2)
else:
    ans = int(N / 2) + 1
if K <= ans:
    print(""YES"")
else:
    print(""NO"")
"
"n, k = map(int, input().split())
XY = [list(map(int, input().split())) for _ in range(n)]
XY.sort(key=lambda x: x[0])
XY = [xy + [x] for x, xy in enumerate(XY)]
XY.sort(key=lambda x: x[1])
XY = [xy + [y] for y, xy in enumerate(XY)]

gr = [[0] * n for _ in range(n)]
for _, _, i, j in XY:
  gr[i][j] = 1
  
rui = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
  for j in range(n):
    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]
    
# XYの2点,3点,4点を総当たり
ans = 10 ** 21
for i in range(n - 1):
  for j in range(i + 1, n):
    x = [XY[m][0] for m in [i, j]]
    y = [XY[m][1] for m in [i, j]]
    ii = [XY[m][2] for m in [i, j]]
    jj = [XY[m][3] for m in [i, j]]
    innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                + rui[min(ii)][min(jj)] \
                - rui[min(ii)][max(jj) + 1] \
                - rui[max(ii) + 1][min(jj)]
    if innerPoints >= k:
      area = (max(x) - min(x)) * (max(y) - min(y)) 
      if area < ans:
        ans = area

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        x = [XY[m][0] for m in [i, j, l]]
        y = [XY[m][1] for m in [i, j, l]]
        ii = [XY[m][2] for m in [i, j, l]]
        jj = [XY[m][3] for m in [i, j, l]]
        innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                    + rui[min(ii)][min(jj)] \
                    - rui[min(ii)][max(jj) + 1] \
                    - rui[max(ii) + 1][min(jj)]
        if innerPoints >= k:
          area = (max(x) - min(x)) * (max(y) - min(y)) 
          if area < ans:
            ans = area

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          x = [XY[m][0] for m in [i, j, o, l]]
          y = [XY[m][1] for m in [i, j, o, l]]
          ii = [XY[m][2] for m in [i, j, o, l]]
          jj = [XY[m][3] for m in [i, j, o, l]]
          innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                      + rui[min(ii)][min(jj)] \
                      - rui[min(ii)][max(jj) + 1] \
                      - rui[max(ii) + 1][min(jj)]
          if innerPoints >= k:
            area = (max(x) - min(x)) * (max(y) - min(y)) 
            if area < ans:
              ans = area

print(ans)"
"a,b,c,x = int(input()),int(input()),int(input()),int(input())
ans = 0
for i in range(min(a+1,41)):
    for j in range(min(b+1,201)):
        k = x-500*i-100*j
        if k >= 0 and k%50 == 0 and k//50 <= c:
            ans += 1
print(ans)"
"s = ''
while True:
  try:
    s += input().lower()
  except EOFError:
    break
for i in range(97, 123):
  print(chr(i)+' : '+str(s.count(chr(i))))
"
"from math import ceil

N, K = map(int, input().split())
A = list(map(int, input().split()))

if N == K:
    print(1)
    exit()


print(ceil((N - K) / (K - 1)) + 1)
"
"import numpy as np
from itertools import combinations
from itertools import permutations
from math import factorial


N = int(input())
xy = np.array([list(map(int, input().split())) for _ in range(N)])
cnt = 0

for i in xy:
    for j in xy:
        cnt += np.linalg.norm(i - j)
print(cnt / N)"
"n = int(input())

def fib(n):
    dp = [0] * (n+1)
    dp[0] = 1
    dp[1] = 1

    def fib_sub(n):
        if dp[n] != 0:
            return dp[n]

        fibn1 = fib_sub(n-1)
        fibn2 = fib_sub(n-2)
        dp[n-1] = fibn1
        dp[n-2] = fibn2
        return fibn1 + fibn2

    return fib_sub(n)
print(fib(n))

"
"
from collections import defaultdict

S = input()
n = len(S)

mod = 2019
d = defaultdict(int)
d[0] = 1
num = 0
for i in reversed(range(n)):
    num += int(S[i]) * pow(10, n - i - 1, mod)
    num %= mod
    d[num] += 1

ans = 0
for v in d.values():
    ans += v * (v - 1) // 2
print(ans)
"
"def main():
    A, B, C = map(int, input().split())

    if B <= C:
        count = 0

        count += B * 2
        C -= B

        if C >= 1:
            count += 1
            C -= 1

        if A < C:
            count += A
        else:
            count += C

        print(count)
    else:
        print(B+C)


main()
"
"
from heapq import heappush, heappop
INF = float(""inf"")
def dijkstra(N, G, s):
    dist = [INF] * N
    que = [(0, s)]
    dist[s] = 0
    while que:
        c, v = heappop(que)
        if dist[v] < c:
            continue
        for t, cost in G[v]:
            if dist[v] + cost < dist[t]:
                dist[t] = dist[v] + cost
                heappush(que, (dist[t], t))
    return dist

N = int(input())
edge = [[] for _ in range(N)]

for _ in range(N-1):
    a,b,c = map(int,input().split())
    edge[a-1].append((b-1,c))
    edge[b-1].append((a-1,c))

Q,K = map(int,input().split())

dist = dijkstra(N,edge,K-1)

for _ in range(Q):
    x,y = map(int,input().split())
    print(dist[x-1]+dist[y-1])"
"S = input()
prev = S[0]
cnt = 0
for c in S[1:]:
    if c == prev:
        continue
    prev = c
    cnt += 1
print(cnt)
"
"s=input()
s_list=list(s)
 
x=len(s_list)

if s_list[x-1]==""s"":
  s_list.append(""es"")
else:
  s_list.append(""s"")

print("""".join(s_list))"
"n, m = map(int, input().split())
c = [int(i) for i in input().split()]
dp = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]
for i in range(1, n + 1):
    dp[i][1] = i
for j in range(1, m + 1):
    dp[0][j] = 0
    # dp[1][j] = 1
for i in range(n + 1):
    for j in range(1, m):
        if c[j] > i:
            dp[i][j + 1] = dp[i][j]
        else:
            dp[i][j + 1] = min(dp[i][j], dp[i - c[j]][j + 1] + 1)
print(dp[n][m])

"
"x=int(input())
A=[i**5 for i in range(-2000,2000)]
for i in range(4000):
    for j in range(i):
        if A[i]-A[j]==x:
            print(*[i-2000,j-2000]);exit()
"
"sa = input()
sb = input()
sc = input()

turn = sa[0]
sa = sa[1:]
while True:
    if turn == ""a"":
        if sa == """":
            print(""A"")
            break
        else:
            turn = sa[0]
            sa = sa[1:]
    elif turn == ""b"":
        if sb == """":
            print(""B"")
            break
        else:
            turn = sb[0]
            sb = sb[1:]
    elif turn == ""c"":
        if sc == """":
            print(""C"")
            break
        else:
            turn = sc[0]
            sc = sc[1:]
"
"n, m, X, Y = map(int, input().split())
x = list(map(int, input().split()))
y = list(map(int, input().split()))
z = min(y)
if z > max(x) and z > X and z <= Y:
    print('No War')
else:
    print('War') 
"
"t1, t2 = map(int, input().split())
a1, a2 = map(int, input().split())
b1, b2 = map(int, input().split())
first = a1 * t1 - b1 * t1
second = (a2 * t2 - b2 * t2)
last = second + first
if first * last > 0:
    ans = 0
elif (abs(last) == 0):
    ans = 'infinity'
else:
    s = abs(first) // abs(last)
    t = abs(first) % abs(last)
    ans = 2 * s
    if t != 0:
        ans += 1
print(ans)"
"def main():
    D = int(input())
    C = [0] * 26
    C = list(map(int,input().split()))
    S = [ list(map(int,input().split("" ""))) for i in range(D)]
    
    score = 0
    last = [0] * 26
    for i in range(D):
        t = int(input())
        for j in range(26):
            if j+1 == t:
                last[j] = 0
                score += S[i][j]
            else:
                last[j] += 1
                score -= last[j]*C[j]
        print(score)
if __name__ == '__main__':
    main()"
"import sys

N = int(input())

p = 0

for i in range(N):
    A,B = list(map(int, input().split()))

    if A == B:
        p += 1
    else:
        p = 0

    if p == 3:
        print(""Yes"")
        sys.exit()

print(""No"")"
"N = int(input())
T = list(map(int, input().split()))
M = int(input())
L = []
res = []
for i in range(M):
    P, X = map(int, input().split())
    buf = []
    for j in range(len(T)):
        if P == j+1:
            buf.append(X)
        else:
            buf.append(T[j])
    res.append(sum(buf))

for i in res:
    print(i)
"
"def resolve():
	s = input()
	if 'a' in s and 'b' in s and 'c' in s:
		print('Yes')
	else:
		print('No')
resolve()"
"import sys

sys.setrecursionlimit(10**5)
n, u, v = map(int, input().split())
u -= 1
v -= 1
m_mat = [[] for i in range(n)]
for _ in range(n-1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    m_mat[a].append(b)
    m_mat[b].append(a)
u_map = [-1]*n
v_map = [-1]*n
u_map[u] = 0
v_map[v] = 0


def dfs(current, depth, ma):
    for nex in m_mat[current]:
        if ma[nex] > -1:
            continue
        ma[nex] = depth
        dfs(nex, depth+1, ma)


dfs(u, 1, u_map)
dfs(v, 1, v_map)

ans = -1
for i in range(n):
    if u_map[i] < v_map[i] and v_map[i] > ans:
        ans = v_map[i]

print(ans-1)
"
"a, b, c = map(int, input().split())
d = a - b
e = b - c
f = c - a
if d != 0 and e != 0 and f != 0:
    print(3)
elif d == 0 and e != 0 and f != 0:
    print(2)
elif d != 0 and e == 0 and f != 0:
    print(2)
elif d != 0 and e != 0 and f == 0:
    print(2)
elif d == 0 and e == 0 and f == 0:
    print(1)"
"from collections import deque

n, q = map(int, input().split())
ps = [input().split() for _ in range(n)]

que = deque(ps)
time = 0

while que:

    p, rest = que.popleft()

    elapsed = min(q, int(rest))
    time += elapsed
    rest = str(int(rest) - elapsed)

    if int(rest) > 0:
        que.append([p, rest])
    else:
        print(p, time)
"
"N, K = list(map(int, input().split()))
C = 10**9+7

ans = 0
A = sum(list(range(N, N-K, -1)))
B = sum(list(range(K)))
for i in range(K, N+2):
    # print(A,B)
    ans += A-B+1
    A += N-i
    B += i
    ans %= C
print(ans)"
"def bubble_sort(array):
	N = len(array)
	count = 0
	
	for i in range(N - 1):
		flag = 0
		
		for j in range(N - 1, i, -1):
			if array[j - 1] > array[j]:
				array[j - 1], array[j] = array[j], array[j - 1]
				count += 1
				flag = 1
				
		if flag == 0:
			break
	
	return array, count
	
n = int(input())
array = [int(i) for i in input().split()]
result = bubble_sort(array)
print(*result[0])
print(result[1])"
"S = input()
T = input()

min_dist = 10**10
for i in range(len(S) - len(T) + 1):
    for k in range(len(T)):
        dist = 0
        for s, t in zip(S[i:i + len(T)], T):
            if s != t:
                dist += 1
            if dist >= min_dist:
                break

        min_dist = min(dist, min_dist)
        if min_dist == 0:
            print(0)
            exit()

print(min_dist)
"
"a, b = map(int, input().split())

res = 0
for v in range(a, b+1):
    s = str(v)
    if s[0] == s[4] and s[1] == s[3]:
        res += 1
print(res)"
"s = input()
if s[0] == ""S"":
  print(""Cloudy"")
elif s[0] == ""C"":
  print(""Rainy"")
else:
  print(""Sunny"")"
"array = list(map(int, input().split()))
K = int(input())

maxABC = max(array)
maxIndex = array.index(maxABC)
array.pop(maxIndex)

print(sum(array) + maxABC * 2**K)
"
"N = input()
print('Yes' if ''.join(list(reversed(N))) == N else 'No')
"
"from scipy.sparse import*
n,*t=map(int,open(0).read().split())
c=sorted(t[-n:])[::-1]
f=find(c)[0]
f[csgraph.depth_first_order(csr_matrix((f[1:],(t[:-n:2],t[1:-n:2])),[n+1]*2),1,0,0)-1]=c
print(sum(c[1:]),*f)"
"# # Make IO faster
# import sys
# input = sys.stdin.readline

# # get single (or) multiple str
# X = input()

# # get single int
# N = int(input())
# # get multiple int (e.g., 2)
# X, Y = map(int, input().split())
# # get multiple int (e.g., 2) for N lines
# XY = [list(map(int, input().split())) for _ in range(N)]

# from IPython import embed; embed(); exit();

# 全部入り
import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import accumulate, permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce
import numpy as np
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

N, X = MAP()
m = sorted([INT() for i in range(N)])
X = X - sum(m)

ans = N
ans += (X // m[0])

print(ans)
"
"import math
A,B,C = map(int,input().split())
num = math.gcd(math.gcd(A,B),C)
A = A//num
B = B//num
C = C//num
for i in range(1,100000):
    if (A*i)%B == 1:
        print('YES')
        exit()
print('NO')"
"N = int(input())

def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    # divisors.sort()
    return divisors

K = []
# N = K**n*(K*m+1)
# n >= 1

K1 = make_divisors(N)
K1.pop(0)
# print(K1)

for k in K1:
    # print(""k="",k)
    n=0
    while N-k**n >= 0:
        # print((N-k**n)%(k**(n+1)))
        # print(""n="",n)
        if (N-k**n)%(k**(n+1))==0:
            K.append(k)
        n += 1
# print(K)

# n == 0
K2 = make_divisors(N-1)
K2.pop(0)
K += K2

# print(K)

print(len(K))

"
"N = int(input())
S = [input() for _ in range(N)]
print('AC x ' + str(S.count('AC')))
print('WA x ' + str(S.count('WA')))
print('TLE x ' + str(S.count('TLE')))
print('RE x ' + str(S.count('RE')))"
"import sys
N, M = [int(x) for x in input().split()]

s = 1
e = 2 * -(-M // 2)
for _ in range(M):
    if s >= e:
        s = N - 2 * (M // 2)
        e = N
    print(s, e)
    s += 1
    e -= 1"
"temperature = int(input())
if temperature >= 30:
    print (""Yes"")
else:
    print(""No"")"
"n = int(input())

dict = {0:1,1:1}

def fib(n):
    if n in dict.keys():
        return dict[n]
    else:
        dict[n] = fib(n-1) + fib(n-2)
        return dict[n]

print(fib(n))
"
"def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])

    if temp!=1:
        arr.append([temp, 1])

    if arr==[]:
        arr.append([n, 1])

    return arr

N = int(input())

if N == 1:
    print(""0"")
    exit()

factors = factorization(N)

ans = 0
for factor in factors:
    num = factor[1]
    x = 1
    for i in range(num+1):
        if i**2 + i > 2*num:
            x = i-1
            break
#    print(num,x)                                                                                      
    ans += x

print(ans)
"
"from collections import deque
N,W=map(int,input().split())
w1,v1=map(int,input().split())
V=[[v1],[],[],[]]
for i in range(N-1):
    w,v=map(int,input().split())
    V[w-w1].append(v)
for i in range(4):
    V[i].sort(reverse=True)
W0=W
V0=0
ans=0
for a in range(-1,len(V[0])):
    if a!=-1:
        W0-=w1
        if W0<0:
            break
        V0+=V[0][a]
    W1=W0
    V1=V0
    ans=max(ans,V0)
    for b in range(-1,len(V[1])):
        if b!=-1:
            W1-=w1+1
            if W1<0:
                break
            V1+=V[1][b]
        W2=W1
        V2=V1
        ans=max(ans,V1)
        for c in range(-1,len(V[2])):
            if c!=-1:
                W2-=w1+2
                if W2<0:
                    break
                V2+=V[2][c]
            ans=max(ans,V2)
            if W2//(w1+3)>0:
                ans=max(ans,V2+sum(V[3][0:(W2//(w1+3))]))
print(ans)"
"MOD = 1e9 + 7
n = int(input())
ans = [[0, 1, 1, 8]]
for i in range(n-1):
    a, b, c, d = ans.pop()
    a = (a * 10 + b + c) % MOD
    b = (b * 9 + d) % MOD
    c = (c * 9 + d) % MOD
    d = (d * 8) % MOD
    ans.append([a, b, c, d])

a, b, c, d = ans.pop()
print(int(a))"
"# 20200612_yorukatsu_e.py
import collections
N = int(input())
A = list(map(int,input().split()))
C = collections.Counter(A)
ans = 0
for i,v in C.items():
    # print(i,v)
    if i!=v:
        if i<v:
            ans += v-i
        else:
            ans += v
print(ans)"
"N = int(input())
C = [0] * N
S = [0] * N
F = [0] * N

for i in range(N-1):
    C[i], S[i], F[i] = map(int, input().split())

def arrive(st):
    time = C[st] + S[st]
    for i in range(st + 1, N-1):
        if time <= S[i]:
            time = C[i] + S[i]
        else:
            if time % F[i] != 0:
                time = time + C[i] + (F[i] - time % F[i])
            else:
                time = time + C[i]
    return time

for i in range(N-1):
    print(arrive(i))
print(""0"")"
"x, t = list(map(int, input().split()))
print(max([0, x - t]))"
"N, M = map(int, input().split())

coins = map(int, input().split())

dp = [0] + [50001 for i in range(N)]

for coin in coins:
    for index in range(N-coin+1):
        dp[index+coin] = min(dp[index+coin], dp[index]+1)
print(dp[N])
"
"a,b,k = map(int,input().split())
t1 = min(a,k)
k -= t1
a -= t1
t2 = min(b,k)
k -= t2
b -= t2
print(a,b)"
"N = int(input())

sum = 0
for i in range(1,N+1):
    sum += i

print(sum)"
"X,K,D=input().split(' ')
x,k,d=abs(int(X)),int(K),int(D)

x_par=x%d
x_num=int((x-x_par)/d)

s=0
if x_num<=k:
  x_div=x-x_num*d
  k-=x_num
  if k%2==0:
    s=abs(x_div)
  else:
    s=x_div-d
else:
  s=x-d*k
print(abs(s))"
"N = int(input())
ans = 0
for i in range(1, N+1):
    if i % 3 == 0:
        continue
    if i % 5 == 0:
        continue
    ans += i
print(ans)
"
"def f(x):
    cou = 0
    re = 0
    while True:
        if x < 2**cou:
            break
        if cou == 0:
            if 1 <= x % 4 <= 2:
                re += 1
        else:
            p = x % (2**(cou+1))
            if 2**cou <= p and p % 2 == 0:
                re += 2**cou
        cou += 1
    return re
a , b = map(int,input().split())

print(f(a-1) ^ f(b))"
"import sys
def input(): return sys.stdin.readline().strip()

def resolve():
    x,y=map(int, input().split())
    ans=0
    if x==3:
        ans+=100000
    elif x==2:
        ans+=200000
    elif x==1:
        ans+=300000
    if y==3:
        ans+=100000
    elif y==2:
        ans+=200000
    elif y==1:
        ans+=300000
    if x==1 and y==1:
        ans+=400000
    print(ans)

resolve()"
"H, W = map(int, input().split())
N = int(input())
a = list(map(int, input().split()))
i = 0

for x in range(H):
    c = []
    for y in range(W):
        c.append(i + 1)
        a[i] -= 1
        if a[i] == 0:
            i += 1
            
    if x % 2 == 0:
        print(*c)
    else:
        print(*c[::-1])"
"# dp[i][j] := sのi文字目まで見たときに、ABCのj文字目までを部分列として取り出す方法の数。

s = input()

dp = [[0 for _ in range(4)]for _ in range(len(s))]
mod = 10 ** 9 + 7

power_3 = 1
for idx, letter in enumerate(s):
    dp[idx] = dp[idx-1].copy()

    if letter == 'A':
        dp[idx][1] += power_3
    elif letter == 'B':
        dp[idx][2] += dp[idx-1][1]
    elif letter == 'C':
        dp[idx][3] += dp[idx-1][2]
    elif letter == '?':
        dp[idx][1] *= 3
        dp[idx][2] *= 3
        dp[idx][3] *= 3
        dp[idx][1] += power_3 # 3**(この?を含まない、今までの?の個数)だけ、Aの手前の場合が考えられる。
        power_3 *= 3
        power_3 %= mod
        dp[idx][2] += dp[idx-1][1]
        dp[idx][3] += dp[idx-1][2]
        dp[idx][1] %= mod
        dp[idx][2] %= mod
        dp[idx][3] %= mod


print(dp[len(s)-1][3] % mod) 
# print(dp)
"
"import sys
input = sys.stdin.readline

s = list(input().rstrip())
k = int(input())
n = len(s)

group = []

cnt = 0

from collections import Counter
c = Counter(s)
if len(c) == 1:
    print(n*k//2)
    sys.exit()

for i in range(n):
    if i == 0:
        cnt += 1
        continue
    elif i == n - 1:
        if s[i] == s[i - 1]:
            cnt += 1
            group.append(cnt)
        else:
            group.append(cnt)
            group.append(1)
        continue
    
    if s[i] == s[i - 1]:
        cnt += 1
    else:
        group.append(cnt)
        cnt = 1
ans = 0
if k == 1:
    for i in group:
        ans += i//2
    print(ans)
    sys.exit()
from copy import deepcopy
first = deepcopy(group)
last = deepcopy(group)
if s[0] == s[-1]:
    first[-1] += last[0]
    last[0] = 0

for i in first:
    ans += i//2
for i in last:
    ans += i//2
if k == 2:
    print(ans)
    sys.exit()
mid = deepcopy(first)
if s[0] == s[-1]:
    mid[0] = 0
temp = 0
for i in mid:
    temp += i//2
ans += temp*(k - 2)
print(ans)


"
"a = list(map(int, input().split()))
a = sorted(a)
if a[-1] == a[0]+a[1]:
  print(""Yes"")
else:
  print(""No"")"
"import queue

K = int(input())

Q = queue.Queue()

for i in range(1, 10):
    Q.put(i)

ans = 1
for k in range(K):
    ans = Q.get()
    ansm = ans % 10
    if ans%10 != 0:
        Q.put(10 * ans + ansm - 1)
    Q.put(10 * ans + ansm)
    if ans%10 != 9:
        Q.put(10 * ans + ansm + 1)

print(ans)"
"# Problem: https://atcoder.jp/contests/abc047/tasks/abc047_b
# Python 3rd Try

import sys
# import pprint
# from collections import defaultdict
# import heapq,copy
# from collections import deque
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]


def solver(WIDTH, HEIGHT, OPERATION):
    result = 0
    all_ope = len(OPERATION)
    up_max = HEIGHT
    left_min = 0
    right_max = WIDTH
    down_min = 0
    for j in range(0, all_ope, +1):
        each_ope = OPERATION[j]
        ope = each_ope[2]
        if ope == 1:
            if left_min < each_ope[0]:
                left_min = each_ope[0]
        if ope == 2:
            if each_ope[0] < right_max:
                right_max = each_ope[0]
        if ope == 3:
            if down_min < each_ope[1]:
                down_min = each_ope[1]
        if ope == 4:
            if each_ope[1] < up_max:
                up_max = each_ope[1]
    if ((left_min < right_max) and (down_min < up_max)):
        result = (right_max-left_min) * (up_max - down_min)
    return result


if __name__ == ""__main__"":

    W, H, N = MI()
    OPE = list()
    for _ in range(0, N, +1):
        OPE.append(LI())
    print(""{}"".format(solver(W, H, OPE)))
"
"# https://drken1215.hatenablog.com/entry/2020/04/20/003900
# k  個足してできる最小の整数を求める (a とする)
# k 個足してできる最大の整数を求める (b とする)
# 出来上がる整数は b−a+1 個である

N, K = map(int, input().split())
mod = 10 ** 9 + 7

ans = 0
for k in range(K, N+2):
    mx = k * (2 * N - k + 1) / 2
    mi = k * (k - 1) / 2
    add = mx - mi + 1
    ans += add
    ans %= mod
print(int(ans))"
"S = input()
x, y, z = sorted([S.count('a'), S.count('b'), S.count('c')])
if z-x >= 2:
    print('NO')
else:
    print('YES')"
"def resolve():
    a,b = map(int, input().split())
    if a*500 >= b:
        print(""Yes"")
    else:
        print(""No"")
resolve()"
"h, a = map(int, input().split())
b = 0
while h-a > 0:
  h = h - a
  b += 1
print(b + 1)
"
"r,g,b = [int(i) for i in input().split()]

s = 100*r + 10*g + b

if s%4 == 0:
    print('YES')
else:
    print('NO')
"
"import math

N = int(input())
m = int(math.sqrt(N)) + 1

a = N
for i in range(1, m):
  if N % i == 0:
    a = N / i
print(int(math.log10(a) + 1))"
"x=int(input())
kosu=0
for i in range(1000):
    kosu+=1
    if 100*kosu<=x<=105*kosu:
        print(1)
        quit()
print(0)"
"n = int(input())
li = list(map(int, input().split()))
print(min(li), max(li), sum(li))"
"from collections import deque

def reachable(es, source):
	ret = {source}
	Q = [source]
	while Q:
		cur = Q.pop()
		for nxt in es[cur]:
			if nxt not in ret:
				Q.append(nxt)
				ret.add(nxt)
	return ret

def SPFA(G:list, source=0):
	V = len(G)
	d = [float(""inf"")]*V
	inQ = [False]*V
	cnt = [0]*V
	d[source] = 0
	cnt[source] = 1
	Q = deque([source])
	while Q:
		f = Q.popleft()
		inQ[f] = False
		for t,c in G[f]:
			dist = d[f] + c
			if dist < d[t]:
				d[t] = dist
				if not inQ[t]:
					Q.append(t)
					inQ[t] = True
					cnt[t] += 1
					front = Q.popleft()
					if d[front] > dist:
						Q.append(front)
					else:
						Q.appendleft(front)
				if cnt[t] > V:
					#negative cycle
					return None
	return d[-1]
	
def main():
	N,M,P,*L=map(int,open(0).read().split())
	fwd = [[] for _ in range(N)]
	bwd = [[] for _ in range(N)]
	G = [[] for _ in range(N)]
	for a,b in zip(L[::3],L[1::3]):
		fwd[a-1].append(b-1)
		bwd[b-1].append(a-1)
	judge = reachable(fwd,0) & reachable(bwd,N-1)
	for a,b,c in zip(*[iter(L)]*3):
		if a-1 in judge and b-1 in judge:
			G[a-1].append((b-1,P-c))
	ans = SPFA(G)
	if ans==None:
		print(-1)
	else:
		print(max(0,-ans))

if __name__==""__main__"":
	main()"
"L,R,d = map(int,input().split())
print(int(R/d)-int((L-1)/d))"
"S_ID = input().rstrip()
T_ID = input().rstrip()

if (T_ID[0:-1] in S_ID) and(len(S_ID)!=len(T_ID)):
    print(""Yes"")
else:
    print(""No"")"
"n=int(input())
s=list(input())

rn=s.count('R')
gn=s.count('G')
bn=n-rn-gn

ans=bn*gn*rn
if n>2:
  
  for x in range(n-2):
    
    y=(n-1-x)//2
    for i in range(1,y+1):
      if  (not s[x]==s[x+i]) & (not s[x]==s[x+i+i]) & (not s[x+i]==s[x+i+i]):
        ans-=1
        
  print(ans)
    
else:
  print(0)
"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque
from collections import defaultdict
from itertools import combinations, permutations, accumulate, groupby, product
from bisect import bisect_left,bisect_right
from heapq import heapify, heappop, heappush
from math import floor, ceil
from operator import itemgetter
def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))
def LI2(): return [int(input()) for i in range(n)]
def MXI(): return [[LI()]for i in range(n)]
def printns(x): print('\n'.join(x))
def printni(x): print('\n'.join(list(map(str,x))))
inf = 10**17
mod = 10**9 + 7
#s=input().rstrip()

n=I()
lis=[[]for i in range(n)]
lis[0].append([1])
for i in range(n-1):
    for j in lis[i]:
        for m in range(max(j)+1):
            lis[i+1].append(j+[m+1])
        #print(max(j))
#print(lis[n-1])
alpha=[""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""i"",""j""]
for u in lis[n-1]:
    ans=""""
    for j in u:
        ans+=alpha[j-1]
    print(ans)"
"n, k, c = map(int, input().split())
plan = list(input())

a = [0] * k
b = [0] * k

idx = 0
pause = c
for i in range(n):
  pause += 1
  if plan[i]=='x':
    continue
  if pause>c and idx<k:
    a[idx] = i+1 
    idx += 1
    pause = 0
  
idx = k-1
pause = c
for i in range(n-1, -1, -1):
  pause += 1
  if plan[i]=='x':
    continue
  if pause>c:
    if idx>=0:
      b[idx] = i+1
      idx -= 1
      pause = 0
#print(a)
#print(b)

for i in range(k):
  if a[i]==b[i]:
    print(a[i])"
"import math
def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])

    if temp!=1:
        arr.append([temp, 1])

    if arr==[]:
        arr.append([n, 1])

    return arr

a,b = map(int,input().split())
g = math.gcd(a,b)
l = factorization(g)
l = list(map(lambda x:x[0],l))
lenl = len(l) if l != [1] else 0
print(lenl+1)"
"import sys

def solve():
    input = sys.stdin.readline
    N, T = map(int, input().split())
    A = [int(t) for t in input().split()]

    Ans = 0
    currentTime = A[0]
    for i in range(1, N):
        if A[i] - currentTime < T: Ans += A[i] - currentTime
        else: Ans += T
        currentTime = A[i]
    Ans += T
    print(Ans)
    return 0

if __name__ == ""__main__"":
    solve()"
"n, m = map(int, input().split())
a = [input() for i in range(n)]
b = [input() for i in range(m)]

for x in range(n-m+1):
    for y in range(n-m+1):
        for i in range(m):
            if b[i] != a[y+i][x:x+m]:
                break
        else:
            print('Yes')
            exit()
print('No')"
"import sys
input = sys.stdin.buffer.readline
from operator import itemgetter
import numpy as np

def main():
    N,T = map(int,input().split())
    food = []
    for _ in range(N):
        a,b = map(int,input().split())
        food.append((a,b))
        
    dp = np.zeros(T,dtype=int)
    food.sort(key = itemgetter(0))
    
    ans = 0
    for a,b in food:
        ans = max(ans,dp[-1]+b)
        dp[a:] = np.maximum(dp[a:],dp[:-a]+b)

    print(ans)
    
if __name__ == ""__main__"":
    main()"
"import sys

sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    n = int(input())
    k = int(input())

    res = 1
    for _ in range(n):
        if res < k:
            res *= 2
        else:
            res += k

    print(res)


if __name__ == '__main__':
    resolve()
"
"s=input()
ct=0
for i in s:
  if i=='o':
    ct+=1
if 15-len(s)+ct>=8:
  print('YES')
else:
  print('NO')
"
"N=int(input())
A=list(map(int,input().split()))
ans=0
for i in range(N):
 ans+=A[i]*((-1)**(i%2))
B=[0]*N
for i in range(N):
 B[i]=ans
 ans*=-1
 ans+=A[i]*2
print(*B)"
"def main():
    n,m = map(int,input().split())
    lines = [[] for _ in range(n)]
    for i in range(m):
        l,r,d = map(int,input().split())
        lines[l-1].append([r-1,d])
        lines[r-1].append([l-1,-d])

    from collections import deque
    # from heapq imort heappush, heappop
    inf = 10**18
    dist = [inf]*n

    for i in range(n):
        if dist[i] != inf:
            continue
        dist[i] = 0
        q = deque()
        q.append([i,0])
        while q:
            now,cnt = q.popleft()
            for nxt,nd in lines[now]:
                if dist[nxt] == inf:
                    dist[nxt] = cnt+nd
                    q.append([nxt,cnt+nd])
                    continue
                if dist[nxt] != cnt+nd:
                    print('No')
                    return 0
    print('Yes')

if __name__ == '__main__':
    main()

"
"import copy
N=int(input())
n=(N//2)*2
g=[set() for i in range(N)]
tmp={i for i in range(n)}
for i in range(n):
  g[i]=copy.copy(tmp)
  g[i].remove(i)
  g[i].remove(n-1-i)
count=0
if N%2!=0:
  g[N-1]=copy.copy(tmp)
  for i in range(N-1):
    g[i].add(N-1)
for i in range(N):
  count+=len(g[i])
print(count//2)

for i in range(N):
  for x in g[i]:
    print(i+1,x+1)
    g[x].remove(i)"
"n, t = map(int, input().split())
A = list(map(int, input().split()))
d = {}
min_ = 10**18
for a in A:
    p = a-min_
    if p not in d:
        d[p] = 1
    else:
        d[p] += 1
    if a <= min_:
        min_ = a
M = max(d.keys())
print(d[M])
"
"import string

n = int(input())
s = ''
lowCase = string.ascii_lowercase

while n > 0:
    n -= 1
    s += lowCase[int(n % 26)]
    n //= 26

print(s[::-1])
"
"from sys import setrecursionlimit
setrecursionlimit(10 ** 5 + 10)

N, M, *XY = map(int, open(0).read().split())

E = [[] for _ in range(N + 1)]
for x, y in zip(*[iter(XY)] * 2):
    E[x].append(y)

memo = {}
def dp(p):
    if p not in memo:
        memo[p] = max((1 + dp(c) for c in E[p]), default=0)
    return memo[p]

print(max(dp(p) for p in range(1, N + 1)))"
"import itertools

def solve():
    s, t = input().split()
    return t+s

print(solve())"
"n, t = map(int, input().split())
dish = [list(map(int, input().split())) for _ in range(n)]
dish.sort(key=lambda x: x[0])
dp = [[0 for _ in range(3005)] for _ in range(3005)]

ans = 0
for i in range(n):
    for j in range(t):
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])
        nj = j + dish[i][0]
        if nj < t:
            dp[i + 1][nj] = max(dp[i + 1][nj], dp[i][j] + dish[i][1])
    now = dp[i][t- 1] + dish[i][1]
    ans = max(ans, now)

print(ans)"
"import math
a,b,C = map(int,input().split())
C = math.radians(C)
c = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(C))
S = 1/2*a*b*math.sin(C)
L = a+b+c
h = b * math.sin(C)
print('{0:.5f}\n{1:.5f}\n{2:.5f}'.format(S,L,h))

"
"import sys
input=sys.stdin.readline #文字列入力はするな！！
import heapq
n,m=map(int,input().split())
a=list(map(int,input().split()))
for i in range(n):
    a[i]*=-1
a=sorted(a)
for i in range(m):
    h=-heapq.heappop(a)
    h=h//2
    heapq.heappush(a,-h)
print(-sum(a))

"
"W, H, N  = map(int,input().split()) 
l = 0; r = W; u = H; d = 0 

for i in range(N):
    x, y, a = map(int,input().split()) 
    if a == 1:
        l = max(l,x) 
    elif a == 2:
        r = min(r,x) 
    elif a == 3:
        d = max(d,y) 
    else:
        u = min(u,y) 

print(max(0,(r-l))*max(u-d, 0)) "
"from collections import Counter
class UnionFind:
    def __init__(self,N):
        self.par=[i for i in range(N)]
        self.siz=[1 for _ in range(N)]
        self.rank=[0 for _ in range(N)]
    def find(self,x):
        if self.par[x]==x:
            return x
        else:
            self.par[x]=self.find(self.par[x])
            return self.par[x]
    def union(self,a,b):
        a=self.find(a)
        b=self.find(b)
        if a==b:
            return 0
        else:
            if self.rank[a]>self.rank[b]:
                self.par[b]=a
                self.siz[a]+=self.siz[b]
            else:
                self.par[a]=b
                self.siz[b]+=self.siz[a]
                if self.rank[a]==self.rank[b]:
                    self.rank[b]+=1
    def size(self,a):
        return self.siz[self.find(a)]
    def same(self,a,b):
        return self.find(a)==self.find(b)

N,K,L=map(int,input().split())
road=UnionFind(N)
train=UnionFind(N)

for i in range(K):
    p,q=map(lambda x:int(x)-1,input().split())
    road.union(p,q)
for i in range(L):
    r,s=map(lambda x:int(x)-1,input().split())
    train.union(r,s)
li=[(road.find(i),train.find(i)) for i in range(N)]
c=Counter(li)
ans=[c[li[i]] for i in range(N)]
print(*ans)"
"n = int(input())
seats = []
for i in range(n):
    l, r = map(int, input().split())
    seat = r - l +1
    seats.append(seat)
print(sum(seats))"
"num = int(input())
edges = list(map(int, input().split(' ')))
can_draw = 0
edges.sort(reverse=True)
if edges[0] < sum(edges[1:]):
  print(""Yes"")
else:
  print(""No"")"
"n = int(input())
low = 0
hi = 10**9

li = []
lin = []

for _ in range(n):
    x,y,h = map(int,input().split())
    if h != 0:
        li.append((x,y,h))
    lin.append((x,y,h))

for i in range(101):
    for j in range(101):
        flag = True
        h = li[0][2]+abs(i-li[0][0])+abs(j-li[0][1])
        for a,b,c in lin:
            if max(h-abs(i-a)-abs(j-b),0) != c:
                flag = False
                break
        if flag:
            print(i,j,h)
            exit()"
"data =[1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51]
line =int(input())

print(data[line -1])"
"A, B, H, M = map(int, input().split())

import math

theta = (30 * H) - (5.5 * M)

d2 = A * A + B * B - 2 * A * B * math.cos(math.radians(theta))

d = math.sqrt(d2)

print(d)
"
"from math import ceil
debt = 100000
n = int(input())
for _ in range(n):
    tmp = ceil(debt*1.05)
    debt = ceil((tmp/1000))*1000
print(debt)"
"n,m,x,y = map(int,input().split())
l = list(map(int,input().split()))
r = list(map(int,input().split()))

for i in range(-100,101):
  if x<i and i<=y and max(l)<i and min(r) >= i:
    print(""No War"")
    exit()
print(""War"")"
"# encoding:utf-8
import copy
import random
import bisect #bisect_left　これで二部探索の大小検索が行える
import fractions #最小公倍数などはこっち
import math
import sys
import collections

mod = 10**9+7
sys.setrecursionlimit(mod) # 再帰回数上限はでdefault1000

d = collections.deque()
def LI(): return list(map(int, sys.stdin.readline().split()))

S = str(input())

if S[2] == S[3] and S[4] == S[5]:
    ans = ""Yes""
else:
    ans = ""No""

print(ans)"
"h,w=map(int,input().split())
num=[list(map(int,input().split())) for i in range(h)]
ctrl=[]
cnt=0
for i in range(h):
  for j in range(w):
    if i==h-1:
      if j==w-1:pass
      else:
        if num[i][j]%2==1:
          num[i][j]-=1
          num[i][j+1]+=1
          ctrl.append([i+1,j+1,i+1,j+2])
          cnt+=1
    else:
      if num[i][j]%2==1:
        num[i][j]-=1
        num[i+1][j]+=1
        ctrl.append([i+1,j+1,i+2,j+1])
        cnt+=1
print(cnt)
for i in range(cnt):
  print(ctrl[i][0],ctrl[i][1],ctrl[i][2],ctrl[i][3])
"
"h, w = map(int, input().split())
S = [[1 if i==""#"" else 0 for i in input()] for _ in range(h)]
dy = (1, 0, -1, 0)
dx = (0, 1, 0, -1)
seen = [[False]*w for _ in range(h)]

def dfs(y, x):
  white = 0
  black = 0
  stack = [(y, x)]
  seen[y][x] = True
  while stack:
    s, t = stack.pop()
    if S[s][t]:
      black += 1
    else:
      white += 1
    for di, dj in zip(dy, dx):
      ny, nx = s+di, t+dj
      if 0 <= ny < h and 0 <= nx < w:
        if seen[ny][nx]:
          continue
        if S[s][t] ^ S[ny][nx]:
          seen[ny][nx] = True
          stack.append((ny, nx))
  return black, white

ans = 0
for i in range(h):
  for j in range(w):
    if not seen[i][j]:
      black, white = dfs(i, j)
      ans += black * white
print(ans)"
"n,q = map(int,raw_input().split())
task = []
lst = []
a = 0
for i in range(n):
    name,time = raw_input().split()
    task.append(int(time))
    lst.append(name)
while True:
	if task[0] > q:
		task[0] = task[0] - q
		task.append(task.pop(0))
		lst.append(lst.pop(0))
		a += q
	else:
		a += task[0]
		print lst[0],a
		task.pop(0)
		lst.pop(0)
		if len(lst) == 0:
			break"
"from collections import deque

n, x, y = map(int, input().split())

inf = 100100100
x -= 1
y -= 1

ans = [0] * n

for i in range(n):
    dist = [inf] * n
    queue = deque()
    queue.append(i)
    dist[i] = 0
    while queue:
        current = queue.popleft()
        d = dist[current]

        if current - 1 >= 0 and dist[current - 1] == inf:
            queue.append(current - 1)
            dist[current - 1] = d + 1
        if current + 1 < n and dist[current + 1] == inf:
            queue.append(current + 1)
            dist[current + 1] = d + 1
        if current == x and dist[y] == inf:
            queue.append(y)
            dist[y] = d + 1
        if current == y and dist[x] == inf:
            queue.append(x)
            dist[x] = d + 1

    for j in range(n):
        ans[dist[j]] += 1

for k in range(1, n):
    print(ans[k] // 2)
"
"a = input()
b = input()
if a == b[:-1]:
  print(""Yes"")
else:
  print(""No"")"
"process_num, qms = map(int, input().split())
raw_procs = [input() for i in range(process_num)]


if __name__ == '__main__':
    procs = []
    for row in raw_procs:
        name, time = row.split()
        procs.append({
            ""name"": name,
            ""time"": int(time),
        })

    total_time = 0
    current_proc = 0
    while len(procs) > 0:
        if procs[current_proc][""time""] > qms:
            procs[current_proc][""time""] = procs[current_proc][""time""] - qms
            total_time += qms
            if current_proc == len(procs)-1:
                current_proc = 0
            else:
                current_proc += 1
        else:
            total_time += procs[current_proc][""time""]
            print(""{} {}"".format(procs[current_proc][""name""], total_time))
            del procs[current_proc]
            if current_proc == len(procs):
                current_proc = 0
"
"n = int(input())

s = list(map(int, input().split()))

s.sort()

v = 0

if n == 1:
  print(s[0])
  exit()
elif n == 2:
  print((s[0]+s[1])/2)
  exit()

c = (s[0]+s[1])/2

del s[0]
del s[0]

for i in range(n-2):
  c = (c + s[0])/2
  del s[0]
  
  
print(c)"
"import os, sys, re, math

S = input()
count = 0
for i in range(len(S) // 2):
    if S[i] != S[-i - 1]:
        count += 1

print(count)
"
"import sys
line = input()

if(line[2]==line[3] and line[4]==line[5]):
  print(""Yes"")
  sys.exit()

print(""No"")"
"N, K = map(int, input().split())

k = (N-1)*(N-2) // 2
if k < K:
    print(-1)
else:
    d = k - K
    M = N-1 + d
    print(M)

    for i in range(N-1):
        print(i+1, N)

    count = 0

    flag = True
    if d > 0:
        for i in range(N-2):
            for j in range(i+1, N-1):
                print(i+1, j+1)
                count += 1
                if count == d:
                    flag = False
                    break
            if flag:
                continue
            else:
                break
"
"import sys

sys.setrecursionlimit(10 ** 7)
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    s = input()
    flg = False
    for i in s:
        if i == ""C"":
            flg = True

        if flg and i == ""F"":
            print(""Yes"")
            break
    else:
        print(""No"")


if __name__ == '__main__':
    resolve()
"
"N, K = map(int, input().split())
total = 0
if not K:
    print(N ** 2)
    quit()

for b in range(K + 1, N + 1):
    total += (b - K) * (N // b) + max(0, N % b - K + 1)

print(total)
"
"from collections import Counter
ABC = list(map(int, input().split()))
ABC = Counter(ABC)
if len(ABC) == 2:
    ans = 'Yes'
else:
    ans = 'No'
print(ans)
"
print(len(set(open(0).read().split())) - 1)
"r, g, b = list(map(int, input().split(' ')))
num = r*100 + g*10 + b
if num%4==0:
  print('YES')
else:
  print('NO')"
"a,b,c=map(str,input())
A,B,C=map(str,input())

count=0
if a==A:
  count+=1
if b==B:
  count+=1
if c==C:
  count+=1
print(count)"
"from math import gcd
N, M = map(int, input().split())
A = [a//2 for a in map(int, input().split())]

lcm = 1
for a in A:
    lcm = lcm*a//gcd(lcm, a)
    if lcm > M:
        print(0)
        exit()

for a in A:
    div = lcm//a
    if div % 2 == 0:
        print(0)
        exit()

ans = (M//lcm+1)//2
print(ans)
"
"cards = [
          ""{0} {1}"".format(s, r)
          for s in ('S', 'H', 'C', 'D')
          for r in range(1, 13 + 1)
        ]
count = int(input())
for n in range(count):
  card = input()
  cards.remove(card)

for n in cards:
  print(n)"
"a = 0
N = int(input())
for i in range(1, 10):
  for j in range(1, 10):
    if N == i*j:
      print('Yes')
      a = 1
  if a == 1:
    break
if a == 0:
  print('No')"
"def main():
    N = int(input())
    S = input()
    h_left, h_min, h_cur = 0, 0, 0
    for c in S:
        if c == '(':
            h_cur += 1
        else:
            h_cur -= 1
        h_min = min(h_min, h_cur)
    h_right = h_cur
    if h_min < 0:
        h_left -= h_min
        h_right -= h_min
    print('(' * h_left + S + ')' * h_right)


if __name__ == '__main__':
    main()"
"n, m, k = map(int, input().split())

def bin(a, b, p):
    res = 1
    while b > 0:
        if b & 1 > 0:
            res = res * a % p
        a = a * a % p
        b >>= 1

    return res

MOD = 998244353
N = 200000 + 50
f = [0 for i in range(N)]
invf = [0 for i in range(N)]

f[0] = invf[0] = 1
for i in range(1, N):
    f[i] = f[i-1] * i % MOD

invf[n] = bin(f[n], MOD-2, MOD)
for ri in range(1, N-1):
    i = n - ri
    invf[i] = invf[i+1] * (i+1) % MOD

def binom(n, m):
    if n < m or n < 0 or m < 0:
        return 0
    return f[n] * invf[m] % MOD * invf[n-m] % MOD

def g(n, m):
    return m * bin(m-1, n-1, MOD)

ans = 0
for i in range(0, k+1):
    # print(n-i, i, binom(n-1, i), bin(n-i, m, MOD), n-i, m)
    ans = (ans + binom(n-1, i) * g(n-i, m)) % MOD

print(ans)"
"import sys

k,n=map(int,input().split())
a=list(map(int,input().split()))
a=[[a[i],i] for i in range(n)]

if n==1: print(a[0][0]-1);sys.exit()

pre=-1
ans=0
for _ in range(k):
    a.sort(reverse=True)
    if a[0][1]!=pre:
        a[0][0]-=1
        pre=a[0][1]
    elif a[1][0]>0:
        a[1][0]-=1
        pre=a[1][1]
    else:
        ans=a[0][0]
        break
print(ans)"
"from collections import defaultdict, Counter
from itertools import product, groupby, count, permutations, combinations
from math import pi, sqrt
from collections import deque
from bisect import bisect, bisect_left, bisect_right
from string import ascii_lowercase
from functools import lru_cache
import sys
sys.setrecursionlimit(10000)
INF = float(""inf"")
YES, Yes, yes, NO, No, no = ""YES"", ""Yes"", ""yes"", ""NO"", ""No"", ""no""
dy4, dx4 = [0, 1, 0, -1], [1, 0, -1, 0]
dy8, dx8 = [0, -1, 0, 1, 1, -1, -1, 1], [1, 0, -1, 0, 1, 1, -1, -1]


def inside(y, x, H, W):
    return 0 <= y < H and 0 <= x < W


def ceil(a, b):
    return (a + b - 1) // b


def main():
    n, m = map(int, input().split())
    x_list = list(sorted(list(map(int, input().split()))))
    y_list = list(sorted(list(map(int, input().split()))))
    MOD = 10 ** 9 + 7

    x = 0
    for i, d in enumerate(range(-(n - 1), n, 2)):
        x += d * x_list[i]
        x %= MOD

    y = 0
    for i, d in enumerate(range(-(m - 1), m, 2)):
        y += d * y_list[i]
        y %= MOD
        
    print((x * y) % MOD)




if __name__ == '__main__':
    main()
"
"class nCrMod():
    def __init__(self, mod):
        self.mod = mod
        self.fac = [1, 1]
        self.finv = [1, 1]
        self.inv = [0, 1]

    def prep(self, n):
        mod = self.mod
        f, fi = self.fac[-1], self.finv[-1]
        for i in range(len(self.fac), n + 1):
            fn = f * i % mod
            v = -self.inv[mod % i] * (mod // i) % mod
            fin = fi * v % mod
            f, fi = fn, fin
            self.fac.append(f)
            self.finv.append(fi)
            self.inv.append(v)

    def __call__(self, n, r):
        if len(self.fac) <= n:
            self.prep(n)
        return self.fac[n] * self.finv[r] * self.finv[n - r] % self.mod

def main():
    mod = 10 ** 9 + 7
    nCr = nCrMod(mod)
    N, K = map(int, input().split())
    r = 0
    for i in range(1, K + 1):
        if i - 1 > N - K:
            print(0)
            continue
        print(nCr(K - 1, i - 1) * nCr(N - K + 1, i) % mod)
main()
"
"#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from fractions import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
#mod = 998244353
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
    return int(readline())
n = I()
D,X = readInts()
ans = 0
for i in range(n):
    a = I()
    ans += (D//a)+1 if D%a else D//a
print(X+ans)
"
"a,b = map(int,input().split())
print('No' if a%2==0 or b%2==0 else ""Yes"")"
"import sys
A, B, C, D = map(int, input().split())
s, g = 0, 0
if A <= C:
    s = C
    if B < s:
        print(0)
        sys.exit()
else:
    s = A
    if D < s:
        print(0)
        sys.exit()

if B <= D:
    g = B
else:
    g = D

print(g - s)"
"a,b,c=[int(x) for x in input().split()]
if a+b+c>=22:
    print('bust')
else:
    print('win')


"
"N = int(input())

for i in range(1, 10):
    m = N/i
    if(m.is_integer() and m <= 9):
        print(""Yes"")
        break
else:
    print(""No"")
"
"#!/usr/bin/env python
# encoding: utf-8

from __future__ import print_function


class Solution:
    """"""
    @param prices: Given an integer array
    @return: Maximum profit
    """"""

    @staticmethod
    def insertion_sort():
        # write your code here
        array_length = int(input())
        unsorted_array = [int(x) for x in input().split()]

        for i in range(array_length):
            v = unsorted_array[i]
            j = i - 1
            while j >= 0 and unsorted_array[j] > v:
                unsorted_array[j + 1] = unsorted_array[j]
                j -= 1
            unsorted_array[j + 1] = v
            print("" "".join(map(str, unsorted_array)))


if __name__ == '__main__':
    solution = Solution()
    solution.insertion_sort()"
"import sys
stdin = sys.stdin

sys.setrecursionlimit(10 ** 7)

def li(): return map(int, stdin.readline().split())
def li_(): return map(lambda x: int(x) - 1, stdin.readline().split())
def lf(): return map(float, stdin.readline().split())
def ls(): return stdin.readline().split()
def ns(): return stdin.readline().rstrip()
def lc(): return list(ns())
def ni(): return int(stdin.readline())
def nf(): return float(stdin.readline())

from math import ceil

t1, t2 = li()
a1, a2 = li()
b1, b2 = li()

# 交互になる
if (b1 - a1) * t1 + (b2 - a2) * t2 == 0:
    print('infinity')

# 高橋君が先を行く
elif (b1 - a1) * t1 + (b2 - a2) * t2 < 0:
    # ずっと高橋君の方が速い
    if (b1 - a1) * t1 < 0 and (b2 - a2) * t2 < 0:
        print(0)
    # T2分間は追いつかれる
    elif (b1 - a1) * t1 < 0 and (b2 - a2) * t2 > 0:
        print(0)
    # T1分間は追いつかれる
    else:
        cross = ceil((b1-a1)*t1 / ((a1-b1)*t1 + (a2-b2)*t2)) - 1
        #print(((b1-a1)*t1 + (b2-a2)*t2) * (cross+1) + (a1-b1)*t1)
        if ((a1-b1)*t1 + (a2-b2)*t2) * (cross+1) + (a1-b1)*t1 == 0:
            print(2* (cross+ 1))
        else:
            print(2 * cross + 1)

# 高橋君が遅れる
else:
    # ずっと高橋君のほうが遅い
    if (b1 - a1) * t1 > 0 and (b2 - a2) * t2 > 0:
        print(0)
    # T2分間は追い上げる
    elif (b1 - a1) * t1 > 0 and (b2 - a2) * t2 < 0:
        print(0)
    # T1分間は追い上げる
    else:
        cross = ceil((b1-a1)*t1 / ((a1-b1)*t1 + (a2-b2)*t2)) - 1
        #print(((a1-b1)*t1 + (a2-b2)*t2) * (cross+1) + (a1-b1)*t1)
        if ((a1-b1)*t1 + (a2-b2)*t2) * (cross+1) + (a1-b1)*t1 == 0:
            print(2 * (cross + 1))
        else:
            print(2 * cross + 1)
"
"def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(2000000)


    N = int(input())
    edges = [[]for _ in range(N+1)]
    for _ in range(N-1):
        u,v,w = map(int,input().split())
        edges[u].append((v,w%2))
        edges[v].append((u,w%2))
    colors = [0]*(N+1)
    def dfs(n,p,c):
        colors[n] = c
        for nx,w in edges[n]:
            if nx != p:
                if w%2 == 0:
                    dfs(nx,n,c)
                else:
                    dfs(nx,n,(c+1)%2)

    dfs(1,0,0)
    for i in range(1,N+1):
        print(colors[i])

main()"
"s = int(input())
a = b = 0; c = int(s > 2)
for _ in range(s - 3):
  a, b, c = b, c, a + c
print(c % (10**9 + 7))
"
"h,w = map(int,input().split())
c = []
for _ in range(h):
  c.append(input())
  
for i in range(2*h):
  print(c[i//2])"
"N, *P = map(int, open(0).read().split())
pairs = sorted((P[i], i) for i in range(N))

sub = 1
right = 0
for left in range(N):
    while right < N - 1 and pairs[right + 1][1] > pairs[right][1]:
        right += 1

    sub = max(sub, right - left + 1)

    if left == right:
        right += 1
print(N - sub)
"
"A, B, C=list(map(int, input().split("" "")))
if ([A, B, C].count(5)==2) and ([A, B, C].count(7)==1):
  print('YES')
else:
  print('NO')
"
"# 171 A
X = input()
print('a') if X.islower() else print('A')"
"# ABC129 C

MOD = 10**9 + 7
n, m = map(int, input().split())
a_l = [int(input()) for _ in range(m)]

dp = [0] * (n+1)
dp[0] = 1
k = 0
if m > 0 and a_l[0] == 1:
    k = min(k+1, m-1)
else:
    dp[1] = 1

for i in range(2, n+1):
    if m > 0 and i == a_l[k]:
        k = min(k+1, m-1)
        continue
    dp[i] = (dp[i-1] + dp[i-2]) % MOD
    
print(dp[n])"
"H,W = map(int,input().split())
A = [input() for i in range(H)]

B = []
for row in A:
    if all(a=='.' for a in row): continue
    B.append(row)

C = ['' for _ in range(len(B))]
for col in zip(*B):
    if all(a=='.' for a in col): continue
    for i,a in enumerate(col):
        C[i] += a
for row in C:
    print(row)"
"a,b,c,d=map(int,input().split("" ""))
print(""Balanced"") if a+b==c+d else print(""Right"") if a+b<c+d else print(""Left"")"
"import sys

sys.setrecursionlimit(10 ** 5 + 10)


def input(): return sys.stdin.readline().strip()


def resolve():
    N = int(input())
    F = [list(map(int, input().split())) for i in range(N)]
    P = [list(map(int, input().split())) for i in range(N)]
    profit = -10**10
    # bit全探索
    # https://qiita.com/gogotealove/items/11f9e83218926211083a#%E4%BE%8B%E9%A1%8C-1
    n = 10
    # 昇順での探索だよ
    for i in range(1, 2 ** n):
        bag = [0] * N
        cnt = 0

        """"""        
        10進数表記　2進数表記
        0           000
        1           001
        2           010
        3           011
        4           100
        5           101
        6           110
        7           111
        """"""

        for j in range(n):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                for k in range(N):
                    if F[k][j] == 1:
                        bag[k] += 1
        for l in range(N):
            cnt += P[l][bag[l]]
        profit = max(profit, cnt)
    print(profit)


resolve()"
"n,l = map(int, input().split())
taste = [l+i for i in range(n)]
tasteabs = [abs(l+i) for i in range(n)]
d = tasteabs.index(min(tasteabs))
print(sum(taste) - taste[d])"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N, C = mapint()

Xs = []
Vs = []
for _ in range(N):
    x, v = mapint()
    Xs.append(x)
    Vs.append(v)
r_Xs = [C-x for x in Xs[::-1]]
r_Vs = Vs[::-1]

max_neg = []
tmp = 0
maxi = -10**18
for i in range(N):
    x, v = r_Xs[i], r_Vs[i]
    tmp += v
    max_neg.append(max(tmp-x, maxi))
    maxi = max(tmp-x, maxi)

max_pos = []
tmp = 0
maxi = -10**18
for i in range(N):
    x, v = Xs[i], Vs[i]
    tmp += v
    max_pos.append(max(tmp-x, maxi))
    maxi = max(tmp-x, maxi)
ans = 0
for i in range(N):
    x, v = Xs[i], Vs[i]
    if i!=N-1:
        ans = max(ans, max_pos[i], max_pos[i]-x+max_neg[N-i-2])
    else:
        ans = max(ans, max_pos[i])
for i in range(N):
    x, v = r_Xs[i], r_Vs[i]
    if i!=N-1:
        ans = max(ans, max_neg[i], max_neg[i]-x+max_pos[N-i-2])
    else:
        ans = max(ans, max_neg[i])
print(ans)"
"N = int(input())
A = list(map(int, input().split()))

money = 1000
stock = 0

for i in range(N-1) :
  if A[i] > A[i+1] :
    money += stock * A[i]
    stock = 0
  elif A[i] < A[i+1] :
    temp = int(money / A[i])
    stock += temp
    money -= temp * A[i]
    
money += stock * A[N-1]
stock = 0
print(money)"
"def k_city(n: int, m: int)->int:
    return (n-1)*(m-1)


if __name__ == ""__main__"":
    n, m = map(int, input().split())
    ans = k_city(n, m)
    print(ans)
"
"s = input()

answer = 0
a = 0
z = 0

words = list(s)

for num in range(len(words)):
    if words[num] == 'A':
        a = num
        break

for num in range(len(words)):
    if words[num] == 'Z':
        z = num

answer = z - a + 1

print(answer)


"
"
import math


def prime_factorization(x):
    if x == 1:
        return {1: 1}

    notprime = {}
    pf = {}
    for y in range(2, math.ceil(math.sqrt(x)) + 1):
        if y not in notprime.keys():
            if x % y == 0:
                pf[y] = 0
                while x % y == 0:
                    x //= y
                    pf[y] += 1
            
            coef = 2
            while coef * y < x:
                notprime[coef * y] = True
                coef += 1
    if x > 1:
        pf[x] = 1    
    return pf


def submit():
    n = int(input())

    #　階乗の素因数分解を求める
    pf_all = {}
    for x in range(2, n + 1):
        pf = prime_factorization(x)
        for k, v in pf.items():
            if k not in pf_all.keys():
                pf_all[k] = v
            else:
                pf_all[k] += v

    pf_cand = [v for k, v in pf_all.items() if v > 1]
    pf_cand.sort()
    possible_divisors = [1, 3, 5, 15, 25, 75]
    
    def dfs(curr, rest, cnt):
        if curr > 75:
            return cnt
        if not rest:
            if curr == 75:
                return cnt + 1
            else:
                return cnt
        
        l = rest[-1]
        new_rest = rest[:-1]
        for p in possible_divisors:
            if p - 1 <= l:
                cnt = dfs(curr * p, new_rest, cnt)
            else:
                break
        return cnt
            
    print(dfs(1, pf_cand, 0))


if __name__ == ""__main__"":
    submit()
"
"D,G = map(int,input().split())
P = [list(map(int,input().split())) for d in range(D)]
ans = 1000

for i in range(1<<D):
  s=0
  n=0
  for j in range(D):
    if i>>j&1==1:
      s+=100*(j+1)*P[j][0]+P[j][1]
      n+=P[j][0]
  for j in range(D-1,-1,-1):
    if i>>j&1==0:
      r = ((G-s)//100+j)//(j+1)
      if r>P[j][0]:
        n = 1000
      else:
        n+=max(r,0)
      break
  ans=min(ans,n)

print(ans)"
"a=input().split()
a.sort(reverse=True)
if len(set(a))==1:
  print(12*int(a[0]))
else:
  ans=int(a[0]+a[1])+int(a[2])
  print(ans)"
"XS = open(0).read().split()
i = 0
while True:
    t = XS[i]
    i += 1
    if t == ""-"":
        break
    n = int(XS[i])
    i += 1
    m = sum(map(int, XS[i:i+n])) % len(t)
    i += n
    print(t[m:] + t[:m])
"
"N = int(input())
AB = list()
for _ in range(N):
    ab = list(map(int, input().split()))
    ab.reverse()
    AB.append(ab)
AB.sort()
#print(AB)

at = 0
flag = False

for i in range(N):
    bt = AB[i][0]
    at += AB[i][1]
    #print(at, bt)
    if at > bt:
        flag = True
        break

if flag:
    print(""No"")
else:
    print(""Yes"")
"
"N = int(input())
s = 800*N - 200*(N//15)
print(s)"
"import sys 
from collections import Counter
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
N = int(readline())
A = list(map(int,readline().split()))
X = [0]*N
Y = [0]*N
for i in range(N):
    X[i] = (i+1) + A[i]
    Y[i] = (i+1) - A[i]  
cnt = Counter(Y)
ans = 0
for i in range(N):
    ans += cnt[X[i]] 
    cnt[Y[i]] -= 1
print(ans)"
"import math
#import numpy as np
import queue
from collections import deque,defaultdict
import heapq as hpq
from sys import stdin,setrecursionlimit
#from scipy.sparse.csgraph import dijkstra
#from scipy.sparse import csr_matrix
ipt = stdin.readline
setrecursionlimit(10**7)

def main():
    n,c,k = map(int,ipt().split())
    t = [int(ipt()) for i in range(n)]

    t.sort()
    t0 = t[0]
    n = 1
    ans = 0
    for i in t[1::]:
        if n == c or i > k+t0:
            ans += 1
            n = 1
            t0 = i
        else:
            n += 1
    ans += 1
    print(ans)

    return

if __name__ == '__main__':
    main()
"
"# C - String Transformation

S = list(str(input()))
T = list(str(input()))
l = len(S)
d = set()

ans = 'Yes'
for i in range(l):
    if S[i] != T[i]:
        tmp = S[i]
        if S[i] in d or T[i] in d:
            ans = 'No'
            break
        d.add(T[i])
        for j in range(i, l):
            if S[j] == tmp:
                S[j] = T[i]
            elif S[j] == T[i]:
                S[j] = tmp
    else:
        d.add(T[i])

print(ans)"
"'''
https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_e
'''
def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10000000)
    from collections import Counter, deque
    #from collections import defaultdict
    from itertools import combinations, permutations, accumulate
    #from itertools import product
    from bisect import bisect_left,bisect_right
    import heapq
    from math import floor, ceil
    #from operator import itemgetter

    #inf = 10**17
    mod = 10**9 + 7

    n = int(input())
    a = list(map(int, input().split()))
    cnt = [3] + [0]*n
    res = 1

    for i in a:
        res *= cnt[i] % mod
        cnt[i] -= 1
        cnt[i+1] += 1
        res %= mod

    print(res)
        
if __name__ == '__main__':
    main()"
"input()
A = list([int(i) for i in input().split()])
print(min(A),max(A),sum(A))"
"a=list(map(int,input().split()))
print(-(-sum(a)//2))"
"S = input()
ans = S[0] + str(len(S) - 2) + S[-1]
print(ans)"
"import sys
lines = sys.stdin.readlines()
l = map(int, lines[1].split())
print min(l),max(l),sum(l)"
"N = int(input())
A = list(int(x) for x in input().split())

ans = 0
for i in range(N):
    if i == N - 1:
        break
    if A[i] > A[i+1]:
        sa = A[i] - A[i+1]
        A[i+1] += sa
        ans = ans + sa

print(ans)
"
"n = int(input())
a = list(map(int, input().split(' ')))
q = int(input())
M = list(map(int, input().split(' ')))
minA = min(a)
sumA = 0
for i in a:
    sumA += i


def solve(i, m):
    if m==0 :
        return True
    if i>=n:
        return False
    res = solve(i+1, m) or solve(i+1, m-a[i])
    return res

for j in M:
    if j < minA or j > sumA:
        print('no')
    else:
        if solve(0, j):
            print('yes')
        else:
            print('no')

"
"N, A, B =map(int,input().split())

al = []
for i in range(1, N + 1):
    checkno = 0

    for j in range(len(str(i))):
        str_i = str(i)
        checkno += int(str_i[j])
    if A <= checkno and checkno <= B:
        al.append(i)

print(sum(al))
"
"N=int(input())
S=list(input())
x=0
X=[0]
for i in range(N):
    if S[i]=='I':
        x+=1
        X.append(x)
    elif S[i]=='D':
        x-=1
        X.append(x)
print(max(X))"
"from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
from itertools import permutations, accumulate, combinations, combinations_with_replacement
from math import sqrt, ceil, floor, factorial
from bisect import bisect_left, bisect_right, insort_left, insort_right
from copy import deepcopy
from operator import itemgetter
from functools import reduce, lru_cache  # @lru_cache(None)
from fractions import gcd
import sys
def input(): return sys.stdin.readline().rstrip()
sys.setrecursionlimit(10**6)
# ----------------------------------------------------------- #

a, v = (int(x) for x in input().split())
b, w = (int(x) for x in input().split())
t = int(input())

if a == b:
    print(""YES"")
elif a < b:
    if a + t*v >= b + t*w:
        print(""YES"")
    else:
        print(""NO"")
else:
    if a - t*v <= b - t*w:
        print(""YES"")
    else:
        print(""NO"")"
"mod = 10**9+7
mod2 = 998244353
rng = 200001
fctr = [1]
finv = [1]
for i in range(1,rng):
    fctr.append(fctr[-1]*i%mod)
for i in range(1,rng):
    finv.append(pow(fctr[i],mod-2,mod))
def cmb(n,k):
    if n<0 or k<0:
        return 0
    else:
        return fctr[n]*finv[n-k]*finv[k]%mod
h,w,a,b = map(int, input().split(' '))
ans = cmb(h+w-2,h-1)
x = h-a+b-1
for i in range(1,min(a,b)+1):
    ans = (ans-(cmb(x,b-i)*cmb(h+w-2-x,w-b+i-1))%mod)%mod
print(ans)"
"import math
N=int(input())
ans=N
for i in range(N):
  if math.sqrt(ans).is_integer():
    print(ans)
    break
  ans-=1"
"import sys

sys.setrecursionlimit(10 ** 7)
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    n, k = map(int, input().split())
    print(k * pow(k - 1, n - 1))


if __name__ == '__main__':
    resolve()
"
"import sys
sys.setrecursionlimit(2147483647)
INF=float(""inf"")
MOD=10**9+7
input=lambda :sys.stdin.readline().rstrip()
def resolve():
    h,w=map(int,input().split())
    n=int(input())
    A=[0]*(h*w)
    idx=0
    for i,a in enumerate(map(int,input().split())):
        cnt=0
        while(cnt<a):
            A[idx]=i+1
            cnt+=1
            idx+=1

    idx=0
    for i in range(h):
        G=[0]*w
        for j in range(w):
            G[j]=A[idx]
            idx+=1
        if(i&1): G=G[::-1]
        print(*G)
resolve()"
"N,M = map(int,input().split())
d = [[10**10]*N for i in range(N)]
a = [0]*M
b = [0]*M
c = [0]*M
for i in range(M):
  a[i],b[i],c[i]=map(int,input().split())
  a[i] -= 1
  b[i] -= 1
  d[a[i]][b[i]] = c[i]
  d[b[i]][a[i]] = c[i]
for i in range(N):
  d[i][i] = 0

for i in range(N):
  for j in range(N):
    for k in range(N):
      d[j][k] = min(d[j][k], d[j][i] + d[i][k])

ans = M
for i in range(M):
  tmp = 0
  for j in range(N):
    if d[j][a[i]] + c[i] == d[j][b[i]]:
      tmp = 1
  ans -= tmp
print(ans)"
"s = input() * 2
t = input()
if t in s:
    print('Yes')
else:
    print('No')"
"import sys
input = sys.stdin.readline

class Dinic:
    def __init__(self, len_X, len_Y):
        self.len_X, self.len_Y = len_X, len_Y
        self.edges = [[] for _ in range(len_X)]
        self.matched = [-1] * len_Y
        self.visited = set()

    def add_edge(self, x, y):
        self.edges[x].append(y)

    def dfs(self, x):
        """"""
        :param x: X側の未マッチングの頂点の1つ
        :param visited: 空のsetを渡す（外部からの呼び出し時）
        :return: 増大路が見つかればTrue
        """"""
        for next_x in self.edges[x]:
            if next_x in self.visited:
                continue
            self.visited.add(next_x)
            if self.matched[next_x] == -1 or self.dfs(self.matched[next_x]):
                self.matched[next_x] = x
                return True
        return False

    def solve(self):
        """""" 増大路発見に成功したらTrue(=1)。合計することでマッチング数となる """"""
        res = 0
        for x in range(self.len_X):
            self.visited = set()
            res += self.dfs(x)
        return res

#################################################################################################

N = int(input())

X = []
Y = []
for i in range(N):
    X.append([int(i) for i in input().split()])

for i in range(N):
    Y.append([int(i) for i in input().split()])

dinic = Dinic(len(X), len(Y))

for i in range(len(X)):
    for j in range(N):
        if X[i][0] < Y[j][0] and X[i][1] < Y[j][1]:
            dinic.add_edge(i, j)

print(dinic.solve())
"
"N,K = map(int,input().split())
H = [int(x) for x in input().split()]
H_sort = sorted(H,reverse=True)
print(sum(H_sort[K:]))"
"dish = [int(input()) for i in range(5)]
a = [i%10 for i in dish]

x=10
for i in a:
  if i>0:
    x=min(x,i)
if x ==10:
  x = 0
y = a.index(x)
l = dish.pop(y)

time = [(i//10+1)*10  if i%10 != 0 else i for i in dish]

ans = sum(time) + l
print(ans)"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
num=min(a)
if a[0]==num:
    n-=1
if a[-1]==num:
    n-=1
n-=1
k-=1
print(-1*(n//-k))
"
"n=input()
s=int(n)
for i in range(s,1000):
    if(len(set(str(i)))==1):
        print(i)
        exit()
"
"#template
def inputlist(): return [int(j) for j in input().split()]
#template

mod = 10**9 + 7
N = int(input())
A = inputlist()

s = sum(A)
ans = 0
for i in range(N):
    s -= A[i]
    ans += A[i]*s
    ans %= mod
print(ans)"
"S = input()
result = 0
now = S[0]
temp = """"
for s in S[1:]:
    temp += s
    if now == temp:
        continue
    else:
        result += 1
        now = temp
        temp = """"
print(result + 1)
"
"import math

N=input()
N=int(N)

print(math.factorial(N)%((10**9)+7))"
"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

n, m = map(int, input().split())
p = list(map(int, input().split()))
uf = UnionFind(n)
xy = [list(map(int, input().split())) for _ in range(m)]
for i in range(m):
    a, b = xy[i][0], xy[i][1]
    a-= 1
    b-= 1
    uf.union(a, b)
cnt = 0
for i in range(n):
    if uf.same(p[i]-1, i):
        cnt += 1
print(cnt)


"
"R =int(input())
print(R*3.14159*2)"
"N = input().split()
K = int(N[0])
X = int(N[1])
for i in range(X-K+1,X+K):
  print(i,end=' ')"
"x, t = map(int, input().split())
print(0 if (x-t<0) else x-t)"
"n,d=map(int,input().split())
print(n//(2*d+1) if n%(2*d+1)==0 else n//(2*d+1)+1)"
"#!/usr/bin/env python

a, b, x = map(int, input().split())

if a == b:
    if a%x == 0:
        print(1)
    else:
        print(0)
    exit()
if a%x == 0 and b%x == 0:
    ans = b//x - a//x + 1 
    print(ans)
    exit()
if a%x != 0 and b%x != 0:
    ans = b//x - a//x
    print(ans)
    exit()
if a%x == 0 and b%x != 0:
    ans = b//x - a//x + 1 
    print(ans)
    exit()
ans = b//x - a//x 
print(ans)
"
"import math
def main():
    a, b, C = map(int, input().split())
    C /= 180
    C *= math.pi
    
    S = 1 / 2 * a * b * math.sin(C)
    L = math.sqrt(a ** 2 + b ** 2 - 2 * a * b * math.cos(C)) + a + b
    h = 2 * S / a
    print(S)
    print(L)
    print(h)


if __name__ == ""__main__"":
    main()"
"def gcd(x, y):
    if x % y == 0:
        return y
    else:
        return gcd(y, x % y)

x, y = map(int, input().split())

print(gcd(x, y))
"
"from math import gcd

n = int(input())
g = int(input())

for i in range(n-1):
    t = int(input())
    g = g * t // gcd(g, t)

print(g)
"
"import unittest

def print_str(S,T):
	return T+S
    
S, T = input().split(' ')
print(print_str(S,T))

class TestPrint_str(unittest.TestCase):

  def test_print_str(selt):
    
    self.assertEqual(T+S, print_str(T,S))"
"n,x = map(int, input().split())
m = [int(input()) for i in range(n)]
num = n
x -= sum(m)
num += x//min(m)
print(num)"
"n = int(input())
a = list(map(int,input().split()))

b = [[] for _ in range(n)]
for i in range(n):
    b[i] = [i for i in range(max(0,a[i]-1),a[i]+2)]


def dfs(i,v,n,b):
    if i==n:
        if v==0:
            return 1
        else:
            return 0
    else:
        res = 0
        for j in b[i]:
            res += dfs(i+1,v*(j%2),n,b)

        return res
    

ans = dfs(0,1,n,b)
print(ans)"
"N,K=map(int,input().split())
h=[int(input()) for i in range(N)]
h.sort()
a=10**9
for i in range(N-K+1):
  a=min(a,h[K+i-1]-h[i])
print(a)
"
"N,K,S = map(int,input().split())
A = [10**9]*N
if S != 10**9:
    for i in range(K):
        A[i] = S
else:
    for i in range(N-K):
        A[i] = 10**9-1
print(*A)"
"n, u, v = map(int, input().split())
u -= 1
v -= 1
ab = [list(map(int, input().split())) for _ in range(n - 1)]

adj = [[] for _ in range(n)]
for a, b in ab:
    a -= 1
    b -= 1
    adj[a].append(b)
    adj[b].append(a)


def dfs(s):
    d = [-1] * n
    d[s] = 0
    stack = [s]
    while stack:
        frm = stack.pop()
        for to in adj[frm]:
            if d[to] == -1:
                d[to] = d[frm] + 1
                stack.append(to)

    return d


du = dfs(u)
dv = dfs(v)

ans = 0
for eu, ev in zip(du, dv):
    if eu < ev:
        ans = max(ans, ev - 1)

print(ans)
"
"n = int(input())
L = list(map(int,input().split()))

cnt = 0
ud = 0
ch = 1
for i in range(n-1):
    if L[i] < L[i+1] and ud == -1 and ch == 0:
        ch = 1
        ud = 1
        cnt +=1
    elif L[i] < L[i+1] and ch ==1:
        ch = 0
        ud = 1
    elif L[i] > L[i+1] and ud == 1 and ch == 0:
        ch = 1
        ud= -1
        cnt +=1
    elif L[i] > L[i+1] and ch == 1:
        ch = 0
        ud = -1
print(cnt+1)"
"import sys
sys.setrecursionlimit(10 ** 5 + 10)
def input(): return sys.stdin.readline().strip()

def resolve():
    from scipy.sparse.csgraph import connected_components  # https://note.nkmk.me/python-scipy-connected-components/
    from scipy.sparse import csr_matrix
    
    N, M = map(int, input().split())  # 頂点数、辺数
    A, B, C = [0] * M, [0] * M, [1] * M  # A[i]からB[i]へコストC[i]の有向辺。
    # ただし、connected_components()では有向グラフも無向グラフとして扱われる
    for i in range(M):
        A[i], B[i] ,_= map(int, input().split())
        A[i] -= 1  # indexを調整
        B[i] -= 1
    
    csr = csr_matrix((C, (A, B)), shape=(N, N))
    # nは連結成分の個数。labelは各頂点が属する連結成分のラベル
    n, labels = connected_components(csr)
    print(n)

    
resolve()"
"num = input().split()
a = int(num[0])
b = int(num[1])
c = int(num[2])
ans = 0
for i in range(a,b+1):
    if c % i == 0:
        ans += 1
print(ans)"
"#!/usr/bin/env python
# coding: utf-8

# In[1]:


S = input()
T = input()


# In[4]:


for i in range(len(S)):
    tmp = S[i:] + S[:i]
    if tmp == T:
        print(""Yes"")
        break
else:
    print(""No"")


# In[ ]:




"
"h,w,d = map(int,input().split())
p = [(0,0)] * (h*w)
c = [0] * (h*w)
for i in range(h):
  a = list(map(int,input().split()))
  for j in range(w):
    p[a[j]-1] = (i,j)

for i in range(d, h*w):
  c[i] = c[i-d] + abs(p[i][0] - p[i-d][0]) + abs(p[i][1] - p[i-d][1])

q = int(input())
ans = 0
for i in range(q):
  l,r = map(int,input().split())
  print(c[r-1] - c[l-1])"
"N, M = map(int,input().split())

switch = []
for _ in range(M):
    S = list(map(int,input().split()))
    switch.append(S[1:])

P = list(map(int,input().split()))

ans = 0
for bits in range(1<<N):
    flag = True

    for i in range(M):
        cnt = 0
        for s in switch[i]:
            if(bits>>(s-1) & 1):
                cnt += 1

        if cnt % 2 != P[i]:
            flag = False
    
    if flag: ans += 1

print(ans)"
"import bisect
import heapq
import sys
N,Q = [int(x) for x in sys.stdin.readline().split()]

hitos = []
ans = [-1 for _ in range(Q)]
queries =[]
jump = ans[::]



queries = [[int(x) for x in sys.stdin.readline().split()] for i in range(N)]
hitos = [int(sys.stdin.readline()) for i in range(Q)]


# for i in range(N):
    # S,T,X =list(map(int,input().split("" "")))
    # lt = S -X -0.5
    # rt = T -X -0.5
    # queries.append([lt,rt,X]) #-1 → 挿入クエリ lが時間、-1がクエリの種類、Xが場所


queries.sort(key=lambda x:x[2])





for l,r,x in queries:
     lind  = bisect.bisect_left(hitos,l-x - 0.5)
     rind  = bisect.bisect_left(hitos,r -x - 0.5)
     while lind < rind:
         if ans[lind] == -1:
            ans[lind] = x
            jump[lind] = rind
            lind += 1
         else:

             lind = jump[lind]

for i  in ans:
    print(i)
"
"r,g,b=input().split()
factor=g+b
gb=int(factor)

if(gb%4==0):
  print(""YES"")
else:
  print(""NO"")"
"def main():
    n = int(input())
    l = list(map(int,input().split()))
    if max(l) < sum(l) - max(l):
        print(""Yes"")
    else:
        print(""No"")
if __name__ == ""__main__"":
    main()
"
"print(input().count('2'))
"
"import math

n = int(input())
hL = list(map(int, input().split("" "")))

ans = 0
cont = False
while True:
    if len(set(hL)) == 1 and hL[0] == 0:
        break
    cont = False
    cnt = 0
    for j in range(n):
        if hL[j] != 0:
            hL[j] -= 1
            if not cont:
                cnt += 1
            cont = True
            continue
        else:
            cont = False

    ans += cnt

print(ans)
"
"N = int(input())

for a in range(N//4+1):
    for b in range(N//7+1):
        if 4*a + 7*b == N:
            print('Yes')
            exit()
print('No')
"
"import math
import cmath
def check(inp):
    if inp==2:
        return True
    for num in xrange(2,int(math.sqrt(inp)+1)):
        if inp%num==0:
            return False
    return True
st=set()


while True:
    try:
       str=raw_input().strip()

    except EOFError:
        break
    #print str
    num=int(str)
    st.add(num)
sum=0
for nm in st:
    if check(nm):
        sum+=1
print sum
"
"W, H, x, y, r = [int(a) for a in input().split()]

if r <= x and x <= W - r and r <= y and y <= H - r:
    print('Yes')
else:
    print('No')"
"def main():
  a,b,c = map(int,input().split())
  s = [a,b,c]

  cnt = 0
  while (a % 2 == 0) and (b % 2 == 0) and (c % 2 == 0):
    
    a1,b1,c1 = a,b,c
    a = (b1+c1)//2
    b = (a1+c1)//2
    c = (a1+b1)//2
    
    if [a,b,c] == s:
      return -1
    
    cnt += 1
    #print(a,b,c)
    
  return cnt    
    

ans = main()
print(ans)"
"def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)

    divisors.sort()
    return divisors


N = int(input())
li = make_divisors(N)
ans = []
if len(li) % 2 == 1:
    ans.append(len(str(li[len(li)//2])))
else:
    ans.append(len(str(li[len(li) // 2])))
    ans.append(len(str(li[len(li) // 2 - 1])))
print(max(ans))
"
"#import sys
#import numpy as np
import math
#from fractions import Fraction
import itertools
from collections import deque
from collections import Counter
import heapq
#from fractions  import gcd
#input=sys.stdin.readline
import bisect
s=input()
t=input()
n=len(s)
ans=0
for i in range(n):
    if s[i]!=t[i]:
        ans+=1
print(ans)"
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time

sys.setrecursionlimit(10**7)
inf=10**20
mod=10**9+7

def LI(): return list(map(int,input().split()))
def I(): return int(input())
def LS(): return input().split()
def S(): return input()

# nCr
def nCr(n,r):
  return math.factorial(n)//(math.factorial(n-r)*math.factorial(r))

# 方針
# 大きい順から選ぶと平均は最大値を取れる
# 選んだ数字の最初と最後が違う場合、A個選んだ場合のみ平均が最大値になる
# よって最後の数の選び方が何通りあるかを求めればよい
# 最初と最後が同じ場合、選んだ数の種類は全て同じ
# よってその数を選ぶ方法は何通りあるかを求める

def main():
  n,a,b=LI()
  l=LI()

  l=sorted(l,key=lambda x:x,reverse=True)

  l2=l[:a]
  print(sum(l2)/len(l2))
  
  if l2[0]!=l2[-1]:
    c=l.count(l2[-1])
    c2=l2.count(l2[-1])
    print(nCr(c,c2))

  else:
    c=l.count(l2[-1])
    sm=0
    for i in range(a,min(b+1,c+1)):
      sm+=nCr(c,i)

    print(sm)

main()
"
"import heapq

X, Y, Z, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
C = list(map(int, input().split()))
A.sort(reverse=True)
B.sort(reverse=True)
C.sort(reverse=True)


def calc(p):
    cnt = 0
    for a in A:
        for b in B:
            for c in C:
                if a + b + c < p:
                    break
                cnt += 1
                if cnt >= K:
                    return True
    return False


end = A[0] + B[0] + C[0] + 1
start = 0
while end - start > 1:
    mid = (end + start)//2
    if calc(mid):
        start = mid
    else:
        end = mid

D = []

for a in A:
    for b in B:
        for c in C:
            if a + b + c < start:
                break
            D.append(a + b + c)
D.sort(reverse=True)
for d in D[:K]:
    print(d)
"
"n = int(input())
s = list(input())
count = 0
ans = [0]
for i in s:
    if i == 'I':
        count += 1
    elif i == 'D':
        count -= 1
    ans.append(count)
print(max(ans))"
"#!/usr/bin/env python3
import sys


def solve(M: int, K: int):
    if K >= (1 << M):
        print(-1)
        return
    if M == 1:
        if K == 0:
            print(0, 0, 1, 1)
        else:
            print(-1)
        return
    for i in range(1 << M):
        if i != K:
            print(i, end="" "")
    print(K, end="" "")
    for i in reversed(range(1 << M)):
        if i != K:
            print(i, end="" "")
    print(K)


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    M = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    solve(M, K)


if __name__ == '__main__':
    main()
"
"n = int(input())
h = list(map(int, input().split()))
max_ = h[0]

for i in range(1, n - 1):
    max_ = max(max_, h[i])
    if max_ - h[i + 1] >= 2:
        print(""No"")
        exit()
print(""Yes"")"
"def solve() -> 'max(averages), count(max(averages))':
    from collections import Counter
    from functools import lru_cache
    n, a, b = map(int, input().split())
    v = tuple(sorted(map(int, input().split()), reverse=True))

    def max_ave_x() -> 'max(average),{counts_to_make_max_average}':
        ret = -1
        t = 0
        max_i = set()
        for i, e in enumerate(v, 1):
            t += e
            if a <= i:
                ave = t / i
                if ret < ave:
                    max_i = {i}
                    ret = ave
                elif ret == ave:
                    max_i.add(i)
            if i == b:
                break
        return ret, max_i

    @lru_cache(maxsize=None)
    def combination(n, r):
        if n < r or r < 0:
            return 0
        if r > n - r:
            return combination(n, n - r)
        if r == 0:
            return 1
        if r == 1:
            return n
        return combination(n - 1, r - 1) * n // r

    max_, indices = max_ave_x()

    ret = 0

    c1 = Counter(v)
    for i in indices:
        c2 = Counter(v[:i])
        t = 1
        for chr_ in c2:
            t *= combination(c1[chr_], c2[chr_])
        ret += t

    return max_, ret


print(*solve(), sep='\n')"
"def gcd(p,q):
    if p%q==0: return q
    else: return gcd(q,p%q)
n,x = map(int,input().split())
a = list(map(int,input().split()))
b = [abs(x-i) for i in a]
ans = b[0]
for i in range(1,n):
    ans = min(ans,gcd(ans,b[i]))
print(ans)"
"n = int(input())

def dfs(s, mx_idx):
    if len(s) == n:
        print(s)
    else:
        for i in range(mx_idx+1):
            nc = chr(ord('a') + i)
            if i == mx_idx:
                dfs(s + nc, mx_idx + 1)
            else:
                dfs(s+nc, mx_idx)

dfs('a', 1)
"
"s = input()
t = input()
 
ans = 0
 
for i in range(len(s) - len(t) + 1):
  count = 0
  for j in range(len(t)):
    if s[i + j] == t[j]:
      count += 1
 
  if ans <= count:
    ans = count
print(len(t) - ans)"
"def restore():
    for i in range(N - M, -1, -1):
        if all(s == '?' or s == t for s, t in zip(S[i:i + M], T)):
            ans = S[:i] + T + S[i + M:]
            return ''.join('a' if c == '?' else c for c in ans)
    return 'UNRESTORABLE'


S = input()
T = input()
N = len(S)
M = len(T)
print(restore())"
"H, W, A, B = input().strip().split()
H, W, A, B = [int(H), int(W), int(A), int(B)]

for i in range(B): # i = 0, 1, ..., B-1
    print('1' * A + '0' * (W - A))

for i in range(H-B):
    print('0' * A + '1' * (W - A))"
"import itertools

A, B, C, D, E, F = map(int, input().split())

water, sugar = set(), set()
for a, b in itertools.product(range(F // (100 * A) + 1),
                              range(F // (100 * B) + 1)):
    tmp = 100 * A * a + 100 * B * b
    if 0 < tmp <= F:
        water.add(tmp)

for c, d in itertools.product(range(F // C + 1),
                              range(F // D + 1)):
    tmp = C * c + D * d
    if tmp <= F:
        sugar.add(tmp)

conc_max = 0
ans_w, ans_s = 100 * A, 0
for w, s in itertools.product(water, sugar):
    if w + s > F or w // 100 * E < s:
        continue
    conc = 100 * s / (w + s)
    if conc > conc_max:
        conc_max = conc
        ans_w, ans_s = w + s, s
print(ans_w, ans_s)
"
"num_a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

for i in num_a:
    for j in num_a:
        print(i, 'x', j, '=', i*j, sep='')

"
"from math import ceil
print(ceil(int(input())/2))"
"a=[]
for x in input().split("" ""):
    a.append(int(x))

if a[1]==1:
    print(0)
else:
    print(a[0]-a[1])"
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Created: Jul, 14, 2020 09:24:45 by Nobody
# $Author$
# $Date$
# $URL$
__giturl__ = ""$URL$""


from collections import defaultdict
from collections import deque
from collections import OrderedDict
import itertools
from sys import stdin
input = stdin.readline


def main():
  N = int(input())
  A = sorted(list(map(int, input().split())))

  div = 1
  ans = 0
  for i in range(N-1, 0, -1):
    div *= 2
    ans += (A[i] / div)
  ans += (A[0] / div)
  print(ans)


if(__name__ == '__main__'):
  main()
"
"str = input()
if(len(str)==3):
    str = str[2]+str[1]+str[0]
print(str)"
"def main():
    N, S = map(int, input().split())
    A = list(map(int, input().split()))
    return solve(N, S, A)

def solve(N, S, A):
    mod = 998244353
    dp = [0] * (S + 1)
    dp[0] = pow(2, N, mod)
    div2 = pow(2, mod - 2, mod)
    m = 0
    for a in A:
        m += a
        for i in reversed(range(a, min(S, m) + 1)):
            dp[i] = (dp[i] + dp[i - a] * div2) % mod
    return dp[S]

print(main())
"
"from numpy import cumsum
n,m=map(int,input().split())
a=list(map(int,input().split()))
result=cumsum(a)[-1]
mi=result/(4*m)
ans=0
for i in range(n):
    if a[i]>=mi:
        ans+=1
if ans>=m:
    print('Yes')
else:
    print('No')"
"n=int(input())
hs=list(map(int,input().split()))
a=1
x=hs[0]
for h in hs[1:]:
    if h>=x:
        a+=1
        x=h
print(a)
"
"n = int(input())
S = list(input())
ans = 0
for i in range(len(S)-2):
  if S[i] == ""A"":
    if S[i+1] == ""B"":
      if S[i+2] == ""C"":
        ans += 1

print(ans)"
"from collections import deque
k=int(input())
que=deque()
for i in range(1,10):
    que.append(i)

for i in range(k):
    x=que.popleft()
    if list(str(x))[-1]==""0"":
        que.append(x*10+int(list(str(x))[-1]))
        que.append(x*10+int(list(str(x))[-1])+1)
    elif list(str(x))[-1]==""9"":
        que.append(x*10+(int(list(str(x))[-1])-1))
        que.append(x*10+int(list(str(x))[-1]))
    else:
        que.append(x*10+int(list(str(x))[-1])-1)
        que.append(x*10+int(list(str(x))[-1]))
        que.append(x*10+int(list(str(x))[-1])+1)

print(x)"
"n, x, m = map(int, input().split())

mn = min(n, m)
S = set()
A = []
a = x
ans = 0

for i in range(mn):
    if a in S: break
    S.add(a)
    A.append(a)
    ans += a
    a = a*a%m
    if a == 0:
        print(ans)
        exit()

if len(A) >= mn:
    print(ans)
    exit()

st_len = 0
while st_len < len(A) and a != A[st_len]: st_len += 1
st = sum(A[:st_len])
cyc_sum = sum(A[st_len:])
cyc_len = len(A) - st_len
cyc_num = (n - st_len) // cyc_len
cyc = cyc_sum * cyc_num
ed_len = (n - st_len) % cyc_len
ed = sum(A[st_len:][:ed_len])
print(st + cyc + ed)
"
"import sys
def input(): return sys.stdin.readline().rstrip()
# 単位元とseg_funcを設定する
from fractions import gcd
class seg():
    def __init__(self,init_val):
        self.n=len(init_val)
        self.ide_ele=0 #単位元
        self.num=2**(self.n-1).bit_length() #n以上の最小の2のべき乗
        self.seg=[self.ide_ele]*2*self.num
        for i in range(self.n):
            self.seg[i+self.num-1]=init_val[i]
        for i in range(self.num-2,-1,-1):
            self.seg[i]=self.seg_func(self.seg[2*i+1],self.seg[2*i+2])
    def seg_func(self,a,b):
        #return a+b #0
        #return a*b #1
        return gcd(a,b) #0
        #return max(a,b) #-1か-10**10 (十分小さいもの)
        #return min(a,b) #10**10 (十分大きいもの)
    def update(self,k,x):
        k+=self.num-1
        self.seg[k]=x
        while k:
            k=(k-1)//2
            self.seg[k]=self.seg_func(self.seg[k*2+1],self.seg[k*2+2])
    def query(self,p,q): #O(logN)
        if q<=p:return self.ide_ele
        p+=self.num-1
        q+=self.num-2
        self.res=self.ide_ele
        while q-p>1:
            if p&1==0:
                self.res=self.seg_func(self.res,self.seg[p])
            if q&1==1:
                self.res=self.seg_func(self.res,self.seg[q])
                q-=1
            p=p//2
            q=(q-1)//2
        if p==q:self.res=self.seg_func(self.res,self.seg[p])
        else:self.res=self.seg_func(self.seg_func(self.res,self.seg[p]),self.seg[q])
        return self.res

def main():
    n=int(input())
    A=[int(_) for _ in input().split()]
    ans=0
    seg_a=seg(A)
    for i in range(n):
        ans=max(ans,gcd(seg_a.query(0,i),seg_a.query(i+1,n)))
    print(ans)
if __name__=='__main__':
    main()"
"n,m=map(int,input().split())
a=list(map(int,input().split()))
cnt=0
a.sort(reverse=True)
ALL=0

for i in a:
    ALL+=i


for i in range(m):
    if a[i]>=ALL/(4*m):
        cnt+=1
        if cnt==m:
            print(""Yes"")
    else:
        print(""No"")
        break
"
"n=int(input())
i=1
ans=1
while i*i<=n:
  if n%i==0:
    ans=i
  i+=1
print(len(str(n//ans)))"
"x,y = (int(i) for i in input().split())

if x%y==0:
    print(-1)
    exit()

for i in range(2,(10**18)//x):
    if x*i%y!=0:
        print(x*i)
        exit()

print(-1)"
"def divisors(N):
    U = int(N ** 0.5) + 1
    L = [i for i in range(1, U) if N % i == 0]
    return L + [N // i for i in reversed(L) if N != i * i]

def solve(k):
    n = N
    while n % k == 0:
        n //= k
    return (n % k == 1)

N = int(input())

K = set(divisors(N) + divisors(N - 1)) - {1}
print(sum(solve(k) for k in K))"
"N,K = map(int,input().split())

import numpy as np 

arr = np.array(input().split(),np.int64)

print(np.count_nonzero(arr>=K))"
"s=input()
n=len(s)+1
mountain=[0,0]
count=[0,0]
sum=0
for i in range(n-1):
    if s[i]==""<"":
        mountain[1]+=1
    else:
        if mountain[1]>0:
            sum+=(mountain[0]*(mountain[0]-1)+mountain[1]*(mountain[1]+1))//2+max([0,mountain[0]-count[1]])
            count=mountain
            mountain=[1,0]
        else:
            mountain[0]+=1

sum+=(mountain[0]*(mountain[0]-1)+mountain[1]*(mountain[1]+1))//2+max([0,mountain[0]-count[1]])

print(sum)
"
"a = int(input())
b = list(input())
c = int(input())
z = b[c-1]
for i in range(a):
    if not b[i] == z:
        b[i] = ""*""
print(*b, sep="""")"
"#!/usr/bin/env python3
import sys


def solve(N: int, L: int, S: ""List[str]""):
    return """".join(sorted(S))


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    L = int(next(tokens))  # type: int
    S = [next(tokens) for _ in range(N)]  # type: ""List[str]""
    print(solve(N, L, S))

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
"
"N, M = map(int, input().split())
r = [0]*(N+1)
for _ in range(M):
    a, b = map(int, input().split())
    r[a-1] += 1
    r[b-1] += 1

for i in range(N-1):
    if r[i]%2==1:
        print(""NO"")
        break
else:
    print(""YES"")"
"import math
a,b,c = map(float, input().split())

r = c * (math.pi/180)
h = b * math.sin(r)
S = 0.5*a*h
L = a+b+math.sqrt(a**2+b**2-2*a*b*math.cos(r))
print(S)
print(L)
print(h)

"
"n, m = map(int, input().split())
cnt = 0
if n == 1 and m == 1:
  corner = 0
  wall = 0
if n > 1 and m > 1:
  corner = 4
  wall = max(0, n-2) * 2 + max(0, m-2) * 2
if n == 1 and m > 1:
  corner = 2
  wall = 0
if n > 1 and m == 1:
  corner = 2
  wall = 0
print(n * m - corner - wall)"
"import sys
from io import StringIO
import unittest
import os

# 再帰処理上限(dfs作成時に設定するのが面倒なので限度近い値を組み込む)
sys.setrecursionlimit(999999999)


# 実装を行う関数
def resolve(test_def_name=""""):
    n, m = map(int, input().split())

    for i in reversed(range(1, m // n + 1)):
        if (m - i * n) % i == 0:
            print(i)
            return




# テストクラス
class TestClass(unittest.TestCase):
    def assertIO(self, assert_input, output):
        stdout, sat_in = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(assert_input)
        resolve(sys._getframe().f_back.f_code.co_name)
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, sat_in
        self.assertEqual(out, output)

    def test_input_1(self):
        test_input = """"""3 14""""""
        output = """"""2""""""
        self.assertIO(test_input, output)

    def test_input_2(self):
        test_input = """"""10 123""""""
        output = """"""3""""""
        self.assertIO(test_input, output)

    def test_input_3(self):
        test_input = """"""100000 1000000000""""""
        output = """"""10000""""""
        self.assertIO(test_input, output)

    # 自作テストパターンのひな形(利用時は「tes_t」のアンダーバーを削除すること
    def tes_t_1original_1(self):
        test_input = """"""データ""""""
        output = """"""データ""""""
        self.assertIO(test_input, output)


# 実装orテストの呼び出し
if __name__ == ""__main__"":
    if os.environ.get(""USERNAME"") is None:
        # AtCoder提出時の場合
        resolve()

    else:
        # 自PCの場合
        unittest.main()
"
"n = int(input())
l = list(map(int, input().split()))
w = list(set(l))
r = {w[i]:0 for i in range(len(w))}
for i in range(n):
    r[l[i]] += 1
t = list(r.items())
ans = 0
for i in range(len(t)-2):
    for j in range(i+1, len(t)-1):
        for k in range(j+1, len(t)):
            y = sum([t[i][0], t[j][0], t[k][0]])
            x = max([t[i][0], t[j][0], t[k][0]])
            if 2*x < y:
                ans += t[i][1] * t[j][1] * t[k][1]
print(ans)"
"def slove():
    import sys
    input = sys.stdin.readline
    x, a = list(map(int, input().rstrip('\n').split()))
    print(0 if x < a else 10)


if __name__ == '__main__':
    slove()
"
"h, w = map(int, input().split())
p = [input() for _ in range(h)]
for i in range(h):
    print(p[i])
    print(p[i])"
"a, b = map(int, input().split())
 
c = (a+b) / 2
 
print(int(c+0.9))"
"import sys

sys.setrecursionlimit(10000000)
import os
import math
import bisect
import collections
import itertools
import heapq
import re
import queue

# import fractions

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)
# lcm = lambda x, y: (x * y) // fractions.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N, M = il()
    A = il()
    matches = [2, 5, 5, 4, 5, 6, 3, 7, 6]
    dict = {i + 1: matches[i] for i in range(9)}
    dp = [-1] * (N + 1)
    dp[0] = 0

    for n in range(N + 1):
        for a in A:
            if n + dict[a] <= N:
                dp[n + dict[a]] = max(dp[n + dict[a]], dp[n] * 10 + a)
    print(dp[N])


if __name__ == '__main__':
    main()
"
"#ABC081A
s = input()
print(700+100*s.count(""o""))"
"n = int(input())
p = list(map(int, input().split()))
l = list(range(1,(n+1)))

if p == l:
    ans = ""YES""
cnt = 0
for i in range(n):
    if p[i] != l[i]:
        if p[p[i]-1] == l[i]: cnt += 1
        else:
            ans = ""NO""
            break
if cnt > 0:
    print(""YES"" if cnt//2 == 1 else ""NO"")
else:
    print(ans)"
"import numpy as np
N = int(input())
A = np.array(list(map(int, input().split())))
A.sort()
cumsum = A.cumsum()
# sortした後にcumsumを２倍しても一つ隣のAより大きくなっていないものは最後に残れない
# 後ろから調べていって途切れたらそこから左みんなダメ
# print('A', A)
# print('cumsum', cumsum)

for i in range(N - 2, -1, -1):
    if A[i + 1] > cumsum[i] * 2:
        ans = N - 1 - i
        break
else:
    ans = N
print(ans)
"
"import numpy as np

n= int(input())
a= [int(i) for i in input().split(' ')]

if abs(max(a)) >= abs(min(a)):
  ma  = max(a)
  ma_i= np.argmax(a)
  mi  = 0
  mi_i= 0
else:
  mi  = min(a)
  mi_i= np.argmin(a)
  ma  = 0
  ma_i= 0

xa=[]
if ma == 0:
  for i in range(n):
    if a[i] > 0:
      a[i] = a[i] + mi
      xa.append([mi_i+1, i+1])
  for i in reversed(range(1,n)):
    if a[i-1] > a[i]:
      a[i-1] = a[i-1] + a[i]
      xa.append([i+1, i-1+1])
else:
  for i in range(n):
    if a[i] < 0:
      a[i] = a[i] + ma
      xa.append([ma_i+1, i+1])
  for i in range(1,n):
    if a[i-1] > a[i]:
      a[i] = a[i] + a[i-1]
      xa.append([i-1+1,i+1])

print(len(xa))
for i in range(len(xa)):
  print(xa[i][0],xa[i][1])"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**5)

N = int(input())
a = [int(i) for i in input().split()]

avg = sum(a) / N
mk, mv = 0, float('inf')
for i in range(N) :
    if abs(a[i]-avg) < mv :
        mk, mv = i, abs(a[i]-avg)
print(mk)"
"s = input()
xlist = []
xcount = 0
t = """"
for i in range((len(s))):
    if s[i] == ""x"":
        xcount += 1
    else:
        xlist.append(xcount)
        xcount = 0
        t += s[i]
xlist.append(xcount)
if t != t[::-1]:
    print(-1)
else:
    ans = 0
    for i in range(len(xlist)//2):
        ans += abs(xlist[i]-xlist[-(i+1)])
    print(ans)"
"from collections import deque

def main():
    n = int(input())
    _next = [[] for _ in range(n)]
    for _ in range(n):
        u, k, *v = map(lambda s: int(s) - 1, input().split())
        _next[u] = v
    queue = deque()
    queue.append(0)
    d = [-1] * n
    d[0] = 0
    while queue:
        u = queue.popleft()
        for v in _next[u]:
            if d[v] == -1:
                d[v] = d[u] + 1
                queue.append(v)
    for i, v in enumerate(d, start=1):
        print(i, v)


if __name__ == '__main__':
    main()

"
"class Node(object):
    def __init__(self, key=None):
        self.key = key
        self.prev = None
        self.next = None

class DoublyLinkedList(object):
    def __init__(self):
        self.first = Node()
        self.first.prev = self.first
        self.first.next = self.first

    def insert(self, key):
        x = Node(key)
        x.next = self.first.next
        self.first.next.prev = x
        self.first.next = x
        x.prev = self.first

    def search(self, key):
        cur = self.first.next
        while cur != self.first and cur.key != key:
            cur = cur.next

        return cur

    def delete(self, key):
        self.delete_node(self.search(key))

    def delete_node(self, node):
        if node == self.first:
            return
        else:
            node.prev.next = node.next
            node.next.prev = node.prev

    def delete_first(self):
        self.delete_node(self.first.next)

    def delete_last(self):
        self.delete_node(self.first.prev)


if __name__ == ""__main__"":
    import sys
    input = sys.stdin.readline # faster input

    linklist = DoublyLinkedList()

    n = int(input())

    for _ in range(n):
        inputs = input().rstrip()
        if inputs[0] == 'i':
            linklist.insert(inputs[7:])
        elif inputs[6] == 'F':
            linklist.delete_first()
        elif inputs[6] == 'L':
            linklist.delete_last()
        else:
            linklist.delete(inputs[7:])

    result = []
    cur = linklist.first.next
    while cur != linklist.first:
        result.append(cur.key)
        cur = cur.next

    print(' '.join(result))

"
"n = int(input())
a = list(map(int, input().split()))
evens = len(list(filter(lambda x: x % 2 == 0, a)))
print(3 ** n - 2 ** evens)
"
"print(eval(""3*""+input().replace("" "",""+""))//2)"
"# abc131_b.py
# https://atcoder.jp/contests/abc131/tasks/abc131_b

# B - Bite Eating /
# 実行時間制限: 2 sec / メモリ制限: 1024 MB
# 配点 : 200点

# 問題文
# N個のリンゴがあります。
# これらはそれぞれリンゴ 1、リンゴ 2、リンゴ 3、...、リンゴ N と呼ばれており、リンゴ i の「味」は L+i−1です。
# 「味」は負になることもありえます。
# また、1個以上のリンゴを材料として、アップルパイをつくることができます。
# その「味」は、材料となったリンゴの「味」の総和となります。
# あなたはこれらのリンゴを全て材料として、アップルパイをつくる予定でしたが、おなかがすいたので 1個だけ食べることにしました。
# 勿論、食べてしまったリンゴはアップルパイの材料にはできません。
# つくる予定だったアップルパイとできるだけ同じものをつくりたいので、N個のリンゴ全てを材料としてできるアップルパイの「味」と、
# 食べていない N−1個のリンゴを材料としてできるアップルパイの「味」の差の絶対値ができるだけ小さくなるように、
# 食べるリンゴを選ぶことにしました。
# このようにして選ばれたリンゴを食べた時、食べていない N−1個のリンゴを材料としてできるアップルパイの「味」を求めてください。
# なお、この値は一意に定まることが証明できます。

# 制約
#     2≦N≦200
#     −100≦L≦100
#     入力は全て整数である。

# 入力
# 入力は以下の形式で標準入力から与えられます。
# N L

# 出力
# 最適に食べるリンゴを選んだ時の、食べていない N−1個のリンゴを材料としてできるアップルパイの「味」を出力してください。

# 入力例 1
# 5 2

# 出力例 1
# 18

# リンゴ 1,2,3,4,5の「味」は、それぞれ 2,3,4,5,6 です。リンゴ 1 を食べるのが最適で、答えは 3+4+5+6=18となります。

# 入力例 2
# 3 -1

# 出力例 2
# 0

# リンゴ 1,2,3の「味」は、それぞれ −1,0,1 です。リンゴ 2 を食べるのが最適で、答えは (−1)+1=0となります。

# 入力例 3
# 30 -50

# 出力例 3
# -1044


global FLAG_LOG
FLAG_LOG = False


def log(value):
    # FLAG_LOG = True
    # FLAG_LOG = False
    if FLAG_LOG:
        print(str(value))


def calculation(lines):
    # S = lines[0]
    # N = int(lines[0])
    N, L = list(map(int, lines[0].split()))
    # values = list(map(int, lines[1].split()))
    # values = list(map(int, lines[2].split()))
    # values = list()
    # for i in range(6):
    #     values.append(int(lines[i]))
    # valueses = list()
    # for i in range(M):
    #     valueses.append(list(map(int, lines[i+1].split())))

    mi = None
    su = 0

    for i in range(N):
        value = i + L
        if mi is None:
            mi = value
        if abs(mi) > abs(value):
            mi = value
        su += value

    return [su-mi]


# 引数を取得
def get_input_lines(lines_count):
    lines = list()
    for _ in range(lines_count):
        lines.append(input())
    return lines


# テストデータ
def get_testdata(pattern):
    if pattern == 1:
        lines_input = ['5 2']
        lines_export = [18]
    if pattern == 2:
        lines_input = ['3 -1']
        lines_export = [0]
    if pattern == 3:
        lines_input = ['30 -50']
        lines_export = [-1044]
    return lines_input, lines_export


# 動作モード判別
def get_mode():
    import sys
    args = sys.argv
    global FLAG_LOG
    if len(args) == 1:
        mode = 0
        FLAG_LOG = False
    else:
        mode = int(args[1])
        FLAG_LOG = True
    return mode


# 主処理
def main():
    import time
    started = time.time()
    mode = get_mode()
    if mode == 0:
        lines_input = get_input_lines(1)
    else:
        lines_input, lines_export = get_testdata(mode)

    lines_result = calculation(lines_input)

    for line_result in lines_result:
        print(line_result)

    # if mode > 0:
    #     print(f'lines_input=[{lines_input}]')
    #     print(f'lines_export=[{lines_export}]')
    #     print(f'lines_result=[{lines_result}]')
    #     if lines_result == lines_export:
    #         print('OK')
    #     else:
    #         print('NG')
    # finished = time.time()
    # duration = finished - started
    # print(f'duration=[{duration}]')


# 起動処理
if __name__ == '__main__':
    main()
"
"X, Y = map(int, input().split())
X1, Y1 = map(int, input().split())
if Y1 == 1:
    print(""1"")
else:
    print(""0"")
"
"n = int(input())
a = list(map(int, input().split()))

acc = [0 for i in range(n+1)]
for i in range(n):
    acc[i+1] = a[i] + acc[i]

ans = {}
for x in acc:
    ans.setdefault(x, 0)
    ans[x] += 1
cnt = 0
for i in ans:
    cnt += ans[i]*(ans[i]-1)//2

print(cnt)"
"# -*- coding:utf-8 -*-
import sys


def allcation(truck, baggage, limit):
    t = 1
    cap = 0
    for weight in baggage:
        if weight <= limit:
            if cap + weight <= limit:
                cap += weight
            else:
                cap = weight
                t += 1

            if t > truck:
                return False
        else:
            return False
    return True


def bin_search(truck, baggage):
    small = 0
    big = 10000 * 100000
    minimum = 0
    while small < big:
        mid = (small + big) >> 1
        if allcation(truck, baggage, mid):
            big = mid
            minimum = mid
        else:
            small = mid + 1

    return minimum


if __name__ == ""__main__"":
    n = [int(val) for val in input().split()]
    lst = [int(val) for val in sys.stdin.read().splitlines()]
    print(bin_search(n[1], lst))"
"# 入力
N = int(input())
A = list(map(int, input().split()))

R = max(A)
prime_factor_counter = [0]*(R+1)

# D[x]にxを割り切れる最初の素数を格納
# 次に行う素因数分解で試し割りのムダを削減するための前準備
D = [0]*(R+1)
for i in range(2, R+1):
    if D[i]:
        continue
    n = i
    while n < R+1:
        if D[n] == 0:
            D[n] = i
        n += i

# 素因数分解し、素因子をカウント
# ex: 12 => 2と3のカウントを+1する
for a in A:
    tmp = a
    while tmp > 1:
        prime_factor = D[tmp]
        prime_factor_counter[prime_factor] += 1
        while tmp%prime_factor == 0:
            tmp //= prime_factor

# 回答出力
if max(prime_factor_counter) < 2:
    print('pairwise coprime')
elif max(prime_factor_counter) - A.count(1) < N:
    print('setwise coprime')
else:
    print('not coprime')"
"import sys
import math
import itertools
import collections
import heapq
import re
import numpy as np

rr = lambda: sys.stdin.readline().rstrip()
rs = lambda: map(str, sys.stdin.buffer.readline().split())
ri = lambda: int(sys.stdin.buffer.readline())
rm = lambda: map(int, sys.stdin.buffer.readline().split())
rl = lambda: list(map(int, sys.stdin.buffer.readline().split()))

n = ri()
a = rl()
b = rl()
cnt = 0
for i in range(n):
  ai = a[i]
  bi = b[i]
  if bi > ai:
    cnt += ai
    bi -= ai
    ai1 = a[i+1]
    if bi > ai1:
      cnt += ai1
      a[i+1] = 0
    else:
      a[i+1] -= bi
      cnt += bi
  else:
    cnt += bi
print(cnt)



"
"import sys
input = sys.stdin.readline

N = int(input())
schedule = []
for i in range(N):
    A, B = map(int, input().split())
    schedule.append((A, B))

schedule = sorted(schedule, key=lambda x: x[1])
ans = 0
end = 0

flg = True
for i in range(N):
    end += schedule[i][0]
    if end <= schedule[i][1]:                   # 重複がダメならば等号を消す
         continue
    flg = False

print(""Yes"" if flg else ""No"")"
"n=int(input())
ans=0
for i in range(n):
    a,b=input().split()
    if b==""JPY"":
        ans+=int(a)
    else:
        ans+=float(a)*380000.0

print(ans)"
"N=int(input())

factors = {num: 0 for num in range(2, N+1)}

def factorization(n, factors):
    arr = []
    temp = n
    for i in range(2, int(n**0.5)+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
            factors[i] += cnt

    if temp!=1:
        arr.append([temp, 1])
        factors[temp] += 1

    if arr==[]:
        arr.append([n, 1])
        factors[n] += 1

    return factors

for num in range(2, N+1):
    factors = factorization(num, factors)
    
ans = 1
MOD = 10**9+7
for num in range(2, N+1):
    ans *= (factors[num] + 1) % MOD
    ans %= MOD
print(ans % MOD)"
"import sys
s=input()
t=set()
for i in range(len(s)):
  if s[i] in t:
    print('no')
    sys.exit()
  t.add(s[i])
print('yes')"
"s = str(input())
for i in range(len(s)):
    if s[i] == ""A"" and s[i+1] == ""C"":
        print(""Yes"")
        break
else:
    print(""No"")"
"N=int(input())
s=input()
A=[]
for i in range(N):
    A.append(s[i])

cntW=0
for i in range(N):
    if A[i]==""W"":
        cntW+=1
cntR=N-cntW

changeW=0
changeR=0
for i in range(cntR):
    if A[i]==""W"":
        changeW+=1
for i in range(cntR,N):
    if A[i]==""R"":
        changeR+=1

if changeR==changeW:
    ans=changeW
else:
    #minN=min(changeW,changeR)
    maxN=max(changeR,changeW)
    ans=maxN
print(ans)"
"class Edge:
  def __init__(self, starting_point, arrival_point, cost):
    self.starting_point = starting_point
    self.arrival_point = arrival_point
    self.cost = cost

def solve():
  N, M, P = map(int, input().split())
  edges = []
  INF = float('inf')
  dist = [INF for _ in range(N + 10)]
  dist[1] = 0
  for i in range(M):
    a, b, c = map(int, input().split())
    e = Edge(a, b, -c + P)
    edges.append(e)
  for i in range(2 * N):
    for e in edges:
      if dist[e.arrival_point] > e.cost + dist[e.starting_point]:
        dist[e.arrival_point] = e.cost + dist[e.starting_point]
        if i == N - 1:
          dist[e.arrival_point] = -INF
  if dist[N] != -INF:
    return max(-dist[N], 0)
  else:
    return -1
print(solve())"
"from collections import Counter
import sys


class UnionFind:
    def __init__(self, n):
        self.table = [-1] * n

    def _root(self, x):
        stack = []
        tbl = self.table
        while tbl[x] >= 0:
            stack.append(x)
            x = tbl[x]
        for y in stack:
            tbl[y] = x
        return x

    def find(self, x, y):
        return self._root(x) == self._root(y)

    def union(self, x, y):
        r1 = self._root(x)
        r2 = self._root(y)
        if r1 == r2:
            return
        d1 = self.table[r1]
        d2 = self.table[r2]
        if d1 <= d2:
            self.table[r2] = r1
            self.table[r1] += d2
        else:
            self.table[r1] = r2
            self.table[r2] += d1


def main():
    n, k, l = map(int, sys.stdin.buffer.readline().split())
    a = UnionFind(n)
    b = UnionFind(n)
    cnt = 0
    for x in sys.stdin.buffer.readlines():
        p, q = map(int, x.split())
        cnt += 1
        if cnt <= k:
            a.union(p-1, q-1)
        else:
            b.union(p-1, q-1)

    pairs = [(a._root(i), b._root(i)) for i in range(n)]
    d = Counter(pairs)
    ans = [d[x] for x in pairs]
    print(*ans)


if __name__ == '__main__':
    main()
"
"a = int(input())
b = int(input())
print(""GREATER""*(a>b) or ""LESS""*(a<b) or ""EQUAL"")"
"while True:
    try:
        a = map(int,raw_input().split())

	n = [a[0],a[1]]

        while True:
            if a[0] < a[1]:
	        tmp = a[0]
                a[0] = a[1]
	        a[1] = tmp

            a[0] = a[0] - a[1]
	    if a[0] == 0:
		break

	b = n[0]*n[1]/a[1]

	print ""%d %d"" % (a[1],b)

    except EOFError:
	break"
"a,b,c = map(int, raw_input().split(' '))
print (a*b) >> 1"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# FileName: 	C
# CreatedDate:  2020-06-14 14:59:04 +0900
# LastModified: 2020-06-14 15:07:55 +0900
#


import os
import sys
#import numpy as np
#import pandas as pd
from itertools import accumulate as ac

def main():
    n,q = map(int,input().split())
    s = input()
    poly = [0]*len(s)
    for i in range(0,len(s)-1):
        if s[i]=='A' and s[i+1]=='C':
            poly[i]=1
    ans = list(ac(poly))
    ans.insert(0,0)
    for _ in range(q):
        l,r = map(int,input().split())
        print(ans[r-1]-ans[l-1])


if __name__ == ""__main__"":
    main()
"
"a,b,k = map(int,input().split())

if a == k :
    print(0,b)
elif a > k :
    print(a-k,b)
elif a < k :
    c = b - (k-a)
    if c >= 0 :
        print(0,c)
    else :
        print(0,0)
"
"S = list(input())
L = len(S)
K = int(input())
idx = 0
while K > 0:
    # aまでの必要な回数
    if S[idx] == ""a"" and idx < L-1:
        idx += 1
        continue
        
    k = 123 - ord(S[idx])
    if k > K:
        if idx < L-1:
            # aまで操作できないのに、操作すると辞書順でより後ろの文字列になってしまうので、次の文字へ
            idx += 1
        else:
            # 一番後ろの場合
            t = chr(ord(S[idx])+(K%26))
            S[idx] = t
            K = 0
    else:
        K -= k
        S[idx] = ""a""
        if idx < L-1:
            idx += 1

print("""".join(S))
"
"a,b = map(int,input().split())
cnt = 0
for i in range(1,4):
    if a*b*i%2==1:
        cnt += 1
print(""Yes"" if cnt>0 else ""No"")"
"import sys
import numpy as np


def input():
    return sys.stdin.readline().strip()


sys.setrecursionlimit(10 ** 9)


def main():
    N = int(input())
    A = np.array(list(map(int, input().split())))
    B = np.array(list(map(int, input().split())))
    diff = A - B
    lack = -diff[diff < 0]
    enough = diff[diff > 0]
    x = lack.sum()
    enough.sort()
    enough = reversed(enough)
    s = 0
    ans = 0
    for e in enough:
        if s < x:
            s += e
            ans += 1
        else:
            break
    if s < x:
        print(-1)
    else:
        print(len(lack) + ans)


if __name__ == ""__main__"":
    main()
"
"a, b, c, d = map(int, input().split())
import math
c_div = 0
d_div = 0
if a % c == 0:
    c_div = max(0, 1 + ((b - (b % c)) - a) // c )
else:
    c_div = max(0, 1 + ((b - (b % c)) - (a + (c - a % c))) // c )
if a % d == 0:
    d_div = max(0, 1 + ((b - (b % d)) - a) // d )
else:
    d_div = max(0, 1 + ((b - (b % d)) - (a + (d - a % d))) // d )
gcd_input = c * d // math.gcd(c, d)
if a % gcd_input == 0:
    c_d_div = max(0, 1 + ((b - (b % gcd_input)) - a) // gcd_input )
else: 
    c_d_div = max(0, 1 + ((b - (b % gcd_input)) - (a + (gcd_input - a % gcd_input))) // gcd_input )
print(b - a + 1 - d_div - c_div + c_d_div)"
"n, m = list(map(int, input().split()))
c = list(map(int, input().split()))
DP = [i for i in range(n + 1)]
for cost in c:
	for i in range(cost, n + 1):
		DP[i] = min(DP[i], DP[i - cost] + 1)
print(DP[n])

"
"N=int((input()))

if N%1000==0:
    print(0)
    
else:
  N=str(N)
  a = len(N)
  if a>=3:
        x = int(N[a-3]+N[a-2]+N[a-1])
        print(1000-x)
  elif a==2:
        x = int(N[a-2]+N[a-1])
        print(1000-x)
  else :
        x = int(N[a-1])
        print(1000-x)"
"for i in range(1,10001):
    n = int(input())
    if n:
        print(f'Case {i}: {n}')
"
"import sys
n=int(input())
a = list(map(int,input().split()))
b=0
while(True):
  for i in range(n):
    if(a[i]%2!=0):
      print(b)
      sys.exit()
    a[i]=a[i]//2
  b+=1
print(b)"
"A, B, C = input().split()

A_e = A[-1]
B_f = B[0]
B_e = B[-1]
C_f = C[0]

if (A_e == B_f) and (B_e == C_f):
    print(""YES"")

else:
    print(""NO"")"
"A = int(input())
B = int(input())
C = int(input())
D = int(input())

_ = min(A,B)
print(_+min(C,D))"
"t=input()
print(t.replace(""?"",""D""))"
"import sys
sys.setrecursionlimit(10**6)
input=sys.stdin.readline
from collections import deque
N=int(input())

graph=[[] for _ in range(N+1)]
for _ in range(N-1):
  a,b=map(int,input().split())
  graph[a].append(b)
  graph[b].append(a)
#print(graph)

dist_f=[-1]*(N+1)
d=0
queue=[1]
while queue:  
  new_queue=set()
  for u in queue:
    dist_f[u]=d
    for v in graph[u]:
      if dist_f[v]==-1:
        new_queue.add(v)
        
  queue=list(new_queue)
  d+=1
#print(dist_f)

dist_s=[-1]*(N+1)
d=0
queue=[N]
while queue:  
  new_queue=set()
  for u in queue:
    dist_s[u]=d
    for v in graph[u]:
      if dist_s[v]==-1:
        new_queue.add(v)
        
  queue=list(new_queue)
  d+=1
#print(dist_s)

cnt_f,cnt_s=0,0
for i in range(1,N+1):
  if dist_f[i]<=dist_s[i]:
    cnt_f+=1
  else:
    cnt_s+=1

#print(cnt_f,cnt_s)
if cnt_f>cnt_s:
  print(""Fennec"")
else:
  print(""Snuke"")"
"import sys
s = input()
s = sorted(s)

for i in range(1,len(s)):
    if s[i] == s[i-1]:
        print('no')
        sys.exit()
print('yes')"
"import sys
input = sys.stdin.readline
n, m = map(int, input().split())
a = [0] * (n + 1)
for _ in range(m):
    x, y = map(int, input().split())
    a[x] = (a[x] + 1) & 1
    a[y] = (a[y] + 1) & 1
print(""YES"" if sum(a) == 0 else ""NO"")
"
"import collections
S=input()
s=collections.Counter(S)
S=list(set(S))
if len(S)!=2:
    print(""No"")
else:
    for i in S:
        if s[i]==2:
            pass
        else:
            print(""No"")
            break
    else:
        print(""Yes"")"
"s = input()
ans = 999
for i in range(0, len(s) - 2):
    if ans > abs(int(s[i:i + 3]) - 753):
        ans = abs(int(s[i:i + 3]) - 753)
print(ans)"
"n,w = map(int,input().split())
items = sorted([list(map(int,input().split())) for i in range(n)])
dp = [[0]*(w+1) for _ in range(n+2)]
for i in range(n):
    wi, vi = items[i]
    for j in range(w+1):
        if j+wi<=w:
            dp[i+1][j+wi] = max(dp[i+1][j+wi], dp[i][j]+vi)
        dp[i+1][j] = max(dp[i][j], dp[i+1][j])
ans = 0
for i, (wi, vi) in enumerate(items):
    ans = max(ans, dp[i][w-1]+vi)
print(ans)
"
"length = raw_input()
a, b = length.split()
 
a = int(a)
b = int(b)

if a < b:
   print ""a < b""
elif a == b:
   print ""a == b""
elif a > b:
   print ""a > b"""
"a=int(input())
b=0
c=list(map(int,input().split()))
for i in range(a):
  for k in range(a):
    b=b+c[i]*c[k]
for u in range(a):
  b=b-c[u]*c[u]
print(int(b/2))"
"s=input()
con=0
con=s.count('o')
print(700+con*100)"
"N = int(input())
A = list(map(int, input().split()))

m = set(A)
M = len(m)

if N == M:
  print(""YES"")
  
else:
  print('NO')"
"r, c = map(int, input().split())
sheet = [list(map(int, input().split())) for _ in range(r)]

for i in range(r):
    sheet[i].append(sum(sheet[i]))
new_row = []
for j in range(c+1):
    sum_col = 0
    for i in range(r):
        sum_col += sheet[i][j]
    new_row.append(sum_col)
sheet.append(new_row)

for i in range(r+1):
    print(' '.join(str(x) for x in sheet[i]))"
"a,b,c=map(int,input().split());print('YNeos'[a!=b or b!=c or c!=a::2])"
"# B - Five Dishes
import numpy as np
n=[]
for i in range(5):
    t = int(input())
    n.append(t)
n = np.array(n)
dl = [0]
s = np.ceil(n/10)*10

if max(n%10)==0:
    print(int(np.sum(s)))
    exit()
m = [e for e in n%10 if e not in dl]
print(int(np.sum(s)-(10-min(m))))"
"S = input()
cnt = 0
cntmax = 0
for i in range(len(S)):
    if S[i] == ""A"" or S[i] == ""T"" or S[i] == ""G"" or S[i] == ""C"":
        cnt+=1
        if cnt>cntmax:
            cntmax = cnt
    else:
        cnt = 0

print(cntmax)"
"n,x,y = map(int,input().split())
ans = [0] * (n-1)
l = list(range(1,n+1))

import itertools

for a,b in itertools.combinations(l, 2):
    dis = min(b-a, abs(b-y)+abs(x-a)+1)
    ans[dis-1] += 1

for i in ans:
    print(i)"
"import heapq

s = []
h, w = map(int, input().split())
for _ in range(h):
    s.append(list(input().strip()))

ans = 0
for i in range(h):
    for j in range(w):
        if s[i][j] == '#':
            continue

        q = [(0, (i, j))]
        mins = [[h * w for _ in range(w)] for _ in range(h)]
        visited = [[0 for _ in range(w)] for _ in range(h)]
        while len(q) > 0:
            c, (x, y) = heapq.heappop(q)
            ans = max(ans, c)
            if visited[x][y]:
                continue
            visited[x][y] = True
            for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
                if nx < 0 or nx >= h or ny < 0 or ny >= w or s[nx][ny] == '#':
                    continue
                if visited[nx][ny]:
                    continue
                if mins[nx][ny] > c + 1:
                    mins[nx][ny] = c + 1
                    heapq.heappush(q, (c + 1, (nx, ny)))

print(ans)
"
"N, M = map(int,input().split())
ans = []

if N %2 == 0:
    L1 = list(range(1,N//2+1))
    L2 = list(range(N//2+1,N+1))
    L = len(L1)
    i = 0
    j = 0
    # print(L)
    for m in range(M):
        if m %2 == 0:
            ans.append([L1[L//2-1-i],L1[L//2+i]])
            i += 1
        else:
            ans.append([L2[L//2-1-j], L2[L//2+1+j]])
            j += 1

else:
    for i in range(1,M+1):
        ans.append([i,N+1-i])

for a in ans:
    print(*a)"
"from collections import Counter
N = int(input())
blue = [input() for _ in range(N)]
M = int(input())
red = [input() for _ in range(M)]
Cb = Counter(blue)
Cr = Counter(red)
ans = 0
for b in Cb.most_common():
    x = b[0]
    y = b[1]
    if Cr.get(x):
        ans = max(ans, y - Cr[x])
    else:
        ans = max(ans, y)
print(ans)"
"n = int(input())
power = 1

for x in range(1, n+1):
  power = (power * x) % (10 ** 9 + 7) 
  
print(power)"
"x,y = list(map(int,input().split()))
cnt=0
while x<=y:
    x=x*2
    cnt+=1
print(cnt)
"
"import sys

sys.setrecursionlimit(10 ** 8)
ini = lambda: int(sys.stdin.readline())
inl = lambda: [int(x) for x in sys.stdin.readline().split()]
ins = lambda: sys.stdin.readline().rstrip()
debug = lambda *a, **kw: print(""\033[33m"", *a, ""\033[0m"", **dict(file=sys.stderr, **kw))


def solve():
    n = ini()
    p = [x - 1 for x in inl()]
    cnt = 0
    i = 0
    while i < n:
        if i != p[i]:
            i += 1
        elif i + 1 < n and (i + 1) == p[i + 1]:
            cnt += 1
            i += 2
        else:
            cnt += 1
            i += 1

    return cnt


print(solve())
"
"lst = input().split()
X = lst[0]
Y = lst[1]
lst.sort()

if X == Y:
   print('=')
elif X == lst[0]:
   print('<')
else:
   print('>')"
"import sys
a = []
for l in sys.stdin:
    a.append(l)
a[0] = int(a[0])
if a[0] >= 3200:
  print(a[1])
else:
  print('red')"
"s=input()

s_odd = s[0::2]
print(s_odd)"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10 ** 7)

from itertools import product
from collections import Counter

n, a, b, c, *l = map(int, read().split())
ans = float('inf')
for bit in product([0, 1, 2, 3], repeat=n):
    if 0 not in bit or 1 not in bit or 2 not in bit:
        continue
    counter = Counter()
    memo = 0
    for ll, num in zip(l, bit):
        if num == 3:
            continue
        if counter[num] != 0:
            memo += 10
        counter[num] += ll
    ans = min(ans, abs(counter[0] - a) + abs(counter[1] - b) + abs(counter[2] - c) + memo)
print(ans)
"
"N = int(input())
print('ABD' if N >= 1000 else 'ABC' )
"
"#import numpy as np

#def area--------------------------#
#ryouno syokiti
class ryou:
	def flinit(self):
		room=list()
		for i in range(10):
			room+=[0]
		return room

#def kaijo([a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9,a_10]):


#def kaijo(x):
#	y=[]
#	for i in x:
#		y=y+ "" ""+x[i]
#	return y		
def kaijo(x):
	print """",
	for i in range(len(x)-1):
		print str(x[i]),
	print str(x[len(x)-1])


#----------------------------------#

floor_11=ryou().flinit()
floor_12=ryou().flinit()
floor_13=ryou().flinit()
floor_21=ryou().flinit()
floor_22=ryou().flinit()
floor_23=ryou().flinit()
floor_31=ryou().flinit()
floor_32=ryou().flinit()
floor_33=ryou().flinit()
floor_41=ryou().flinit()
floor_42=ryou().flinit()
floor_43=ryou().flinit()


fldic={""11"":floor_11,
       ""12"":floor_12,
       ""13"":floor_13,
       ""21"":floor_21,
       ""22"":floor_22,
       ""23"":floor_23,
       ""31"":floor_31,
       ""32"":floor_32,
       ""33"":floor_33,
       ""41"":floor_41,
       ""42"":floor_42,
       ""43"":floor_43
       }

#----------------------------------#


#1kaime yomikomi
n=int(raw_input())

#nkaime syusyori

for l in range(n):
	list_mojiretsu=raw_input().split("" "")
	henka=map(int,list_mojiretsu)
	fldic[str(henka[0])+str(henka[1])][henka[2]-1]+=henka[3]
	


kaijo(floor_11)
kaijo(floor_12)
kaijo(floor_13)
print ""####################""
kaijo(floor_21)
kaijo(floor_22)
kaijo(floor_23)
print ""####################""
kaijo(floor_31)
kaijo(floor_32)
kaijo(floor_33)
print ""####################""
kaijo(floor_41)
kaijo(floor_42)
kaijo(floor_43)"
"MOD = 10 ** 9 + 7
INF = 10 ** 10
import sys
sys.setrecursionlimit(100000000)
dy = (-1,0,1,0)
dx = (0,1,0,-1)
from collections import deque

def main():
    n,m = map(int,input().split())
    G = [[] for _ in range(3*n)]
    for _ in range(m):
        u,v = map(int,input().split())
        u -= 1
        v -= 1
        for i in range(3):
            G[u*3 + i].append(v*3 + (i + 1)%3)
    
    s,g = map(int,input().split())
    s -= 1
    g -= 1

    q = deque([3*s])
    dist = [-1] * (3*n)
    dist[3*s] = 0
    while q:
        p = q.popleft()
        for e in G[p]:
            if dist[e] < 0:
                dist[e] = dist[p] + 1
                q.append(e)
                
    print(dist[3*g]//3 if dist[3*g] >= 0 else -1)
if __name__ == '__main__':
    main()"
"a, b = map(int, input().split())
ans = a+b
if(ans >= 10): print(""error"")
else: print(ans)"
"s = input()
ans = 0
s_len = len(s)
dum = ""CODEFESTIVAL2016""
for i in range(s_len):
    if s[i] != dum[i]:
        ans += 1
print(ans)"
"t, h = 0, 0

for i in range(int(input())):
    tc, hc= input().split()
    if tc > hc:
        t += 3
    elif tc < hc:
        h += 3
    else:
        t += 1
        h += 1

print('%d %d' % (t, h))"
"import sys
import math
n, m = map(int, input().split())
mod = 10 ** 9 + 7
if n == m:
    ans = math.factorial(n) % mod
    ans = (ans * math.factorial(m)) % mod
    ans = (ans * 2) % mod
elif abs(n - m) >= 2:
    ans = 0
else:
    ans = math.factorial(n) % mod
    ans = (ans * math.factorial(m)) % mod
print(ans)"
"K = int(input())
 
x = 7
for i in range(K):
  if x % K == 0:
    print(i+1)
    exit()
  else:
    x = (10*x + 7) % K
print(-1)"
"# AOJ ITP1_9_C

def numinput():
    a = input().split()
    for i in range(len(a)):
        a[i] = int(a[i])
    return a

def main():
    SCORE_taro = 0
    SCORE_hanako = 0
    n = int(input())
    for i in range(n):
        words = input().split()
        if words[0] > words[1]: SCORE_taro += 3
        elif words[0] < words[1]: SCORE_hanako += 3
        else:
            SCORE_taro += 1; SCORE_hanako += 1
    print(str(SCORE_taro) + "" "" + str(SCORE_hanako))

if __name__ == ""__main__"":
    main()
"
"def main():
    n, q = map(int, input().split())
    s = input()
    indic = {}
    for i in range(q):
        l, r = map(int, input().split())
        indic[i] = [l, r]
    
    ruisekidic = {}
    tmp = 0
    
    for i in range(n):
        if i == 0:
            mae = s[0]
            ruisekidic[i] = 0
        else:
            if mae == ""A"" and s[i] == ""C"":
                tmp += 1
                ruisekidic[i] = tmp
                mae = s[i]
            else:
                ruisekidic[i] = tmp
                mae = s[i]
    for i in range(q):
        [l, r] = indic[i]
        if l > 0:
            print(ruisekidic[r-1] - ruisekidic[l-1])
        else:
            print(ruisekidic[r-1])


    
if __name__ == ""__main__"":
    main()
"
"def main():
    n = int(input())
    d_lst = list(map(int, input().split()))
    ans = 0

    for i in range(n - 1):
        for j in range(i + 1, n):
            ans += d_lst[i] * d_lst[j]

    print(ans)


if __name__ == ""__main__"":
    main()
"
"MOD=10**9+7
n, k = map(int, input().strip().split())
d=[0]*(k+1)
d[0]=None

for i in range(1,k+1):
    d[i]=pow(k//i,n,MOD)

# update d
for i in range(k,0,-1):
    for j in range(i*2,k+1,i):
        d[i]-=d[j]
        d[i]%=MOD
ans=0
for i in range(1,k+1):
    ans+=d[i]*i%MOD
    ans%=MOD
print(ans)"
"w, h, n = map(int, input().split())
field = [[1] * w for _ in range(h)]
for i in range(n):
    x, y, a = map(int,input().split())
    if a == 1:
        for i in range(h):
            for j in range(x):
                field[i][j] = 0
    elif a == 2:
        for i in range(h):
            for j in range(x, w):
                field[i][j] = 0
    elif a == 3:
        for i in range(y):
            for j in range(w):
                field[i][j] = 0
    elif a == 4:
        for i in range(y,h):
            for j in range(w):
                field[i][j] = 0

count = 0
for i in field:
    count += i.count(1)
print(count)
"
"def l(): return list(map(int, input().split()))
def m(): return map(int, input().split())

def main():
  c = [0]*3
  for i in range(3):
    c[i] = l()
  # for i in range(2):
  #   x = c[2][i+1] - c[2][i]
  #   for j in range(2):
  #     if c[j][i+1] - c[j][i] != x:
  #       print('No')
  #       exit()
  # print('Yes')

  a = [0]*3
  b = [0]*3
  b[0] = min(c[0])
  for i in range(3):
    a[i] = c[0][i] - b[0]
  for i in range(1,3):
    b[i] = c[i][0] - a[0]
  # print(a,b)
  for i in range(3):
    for j in range(3):
      if c[i][j] != a[j] + b[i]:
        print('No')
        exit()
  print('Yes')

  
if __name__ == '__main__':
  main()"
"from math import sqrt, ceil
def solve():
    n = int(input())
    keta = [0] * (n+1)
    for i in range(2, n+1):
        for j in range(2, int(pow(i, 0.5))+1):
            while i % j == 0:
                i //= j
                keta[j] += 1
        keta[i] += 1

    mod = 1000000007
    ans = 1
    keta[0] = 0
    keta[1] = 0
    for ex in keta:
        ans *= (ex + 1)
        ans %= mod
    print(ans)

if __name__ == '__main__':
    solve()"
"import sys 
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
mod = 10 ** 9 +7
    
K = int(readline())
S = readline().decode().rstrip()
s = len(S)-1

n = s+K
fact = [1] * (n+1)
fact_inv = [1] * (n+1)
for i in range(1,n+1):
    fact[i] = fact[i-1] * i % mod 
fact_inv[n] = pow(fact[n],mod-2,mod)
for i in range(n,0,-1):
    fact_inv[i-1] = (i * fact_inv[i]) % mod 

def comb(n,r):
  return fact[n] * fact_inv[r] * fact_inv[n-r] % mod

ans = 0
for i in range(K+1):
    ans += (comb(i+s,s) * pow(25,i,mod) % mod * pow(26,K-i,mod)) % mod
print(ans%mod)"
"a,b=map(int,input().split())
ans=0
if (a-b)%2!=0:
    ans=""IMPOSSIBLE""
else:
    ans=int((a+b)/2)
print(ans)"
"n = int(input())
s = input()
wcount = 0
min_val = 0
for i in range(n):
    if s[i] == '.':
        wcount += 1
    min_val = min(min_val, i + 1 - wcount * 2)
print(wcount + min_val)
"
"n,m = map(int,input().split())
k = (n-1)*(m-1)
print(k)"
"import math
N=int(input())
a=0
for i in range(1,N+1):
    if ((math.log10(i))//1)%2==0:
        a+=1
print(a)"
"n = int(input())
a = list(map(int,input().split()))
t = [0] * 8
p = 0

for i in range(n):
    if a[i] < 3200:
        t[a[i] // 400] = 1
    else:
        p += 1

x = t.count(1)
amax = p+x
if x == 0:
    amin = 1
else:
    amin = x
print(amin,amax)"
"
S =  input()

ans = 0

prev,now = """",""""

for i in range(len(S)):
    now += S[i]
    if now != prev:
        ans += 1
        prev,now = now,""""

print(ans)
"
"a = sorted(list(map(int, input().split())))
ok = False
for i in a:
    if i%2==0: ok = True
print(0 if ok else a[0]*a[1])"
"
n = int(input())
li = list(map(int,input().split()))

# dp = [[-1 for i in range(1100)] for j in range(1100)]
ans = [0]*n
ans[0] = 0
# def solve(a,b,dp,li):
#     if dp[a][b] !=-1 :
#         return dp[a][b]
#     else:
#         dp[a][b] = abs(li[a]-li[b])
#         return dp[a][b]

for i in range(2,n+1):
    if i == 2:
        ans[i-1]= abs(li[1]-li[0])
    else:
        ans[i-1] = min(abs(li[i-1]-li[i-2])+ans[i-2],abs(li[i-1]-li[i-3])+ans[i-3])

print(ans[-1])"
"N = int(input())
a = list(map(int, input().split()))
A = [0] + a + [0]

total_fee = 0
for i in range(N+1):
    total_fee += abs(A[i+1]-A[i])

ans_lst = [total_fee] * N
for j in range(N):
    ans_lst[j] -= abs(A[j+1]-A[j])
    ans_lst[j] -= abs(A[j+2]-A[j+1])
    ans_lst[j] += abs(A[j+2]-A[j])
    print(ans_lst[j])"
"def az8():
    xs = map(int,raw_input().split())
    a,b = xs[0],xs[1]
    print (a/b),(a%b), ""%5f""%(float(a)/b)
az8()"
"S = input()

while 1:
    bef = S
    bef = bef.replace(""?"", ""D"")
    if S==bef:
        break
    S = bef
    
print(S)"
"n, m = map(int, input().split())
mod = 10**9 + 7
# [[素因数,数]]を出力
def fctr1(n):
    f = []
    c = 0
    r = int(n**0.5)
    for i in range(2, r+2):
        while n % i == 0:
            c += 1
            n = n//i
        if c != 0:
            f.append([i, c])
            c = 0
    if n != 1:
        f.append([n, 1])
    return f

def comb(n, r):
    res = 1
    for i in range(1, r+1):
        res = res*(n-i+1) % mod
        res = res*pow(i, mod-2, mod) % mod
    return res

prime_count = fctr1(m)
#print(prime_count)
ans = 1
for p, e in prime_count:
    ans *= comb(e+n-1, e)
    ans %= mod
print(ans)"
"#!/usr/bin/env python3
import itertools
import numpy as np

n = int(input())
v = list(map(int, input().split()))
c = list(map(int, input().split()))

v = np.array(v)
c = np.array(c)

ans = np.sum((v-c)*((v-c) >= 0))

print(ans)
"
"#!/usr/bin/env python3
from collections import deque
import sys
try:
    from typing import Deque, List
except ImportError:
    pass


def bfs(G: ""List[List[int]]"", a: int):
    q = deque()  # type: Deque[int]
    q.append(a)
    dist = [-1] * len(G)
    dist[a] = 0
    while q:
        s = q.popleft()
        for t in G[s]:
            if dist[t] >= 0:
                continue
            q.append(t)
            dist[t] = dist[s] + 1
    return dist


def solve(N: int, a: ""List[int]"", b: ""List[int]""):
    G = [[] for i in range(N)]
    for ai, bi in zip(a, b):
        ai -= 1
        bi -= 1
        G[ai].append(bi)
        G[bi].append(ai)
    db = bfs(G, 0)
    dw = bfs(G, N - 1)
    bn = sum((dbi <= dwi) for dbi, dwi in zip(db, dw))
    wn = N - bn
    if bn > wn:
        print(""Fennec"")
    else:
        print(""Snuke"")


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    a = [int()] * (N - 1)  # type: ""List[int]""
    b = [int()] * (N - 1)  # type: ""List[int]""
    for i in range(N - 1):
        a[i] = int(next(tokens))
        b[i] = int(next(tokens))
    solve(N, a, b)


if __name__ == '__main__':
    main()
"
"N,M=map(int,input().split())
a = list(map(int,input().split()))
if N-sum(a)>=0:
    print(N-sum(a))
else:
    print(""-1"")"
"n = int(input())
s, t = map(str, input().split())
ans = ''
for a, b in zip(s, t):
    ans += a+b
print(ans)"
"h, a = map(int, input().split())
if h % a > 0:
  number_of_times = h // a + 1
  print(number_of_times)
else:
  print(h // a)"
"n ,k = map(int, input().split())
s = input()
ret = """"
for i in range(n):
    if i==k-1:
        if s[k-1]==""A"":
            ret += ""a""
        elif s[k-1]==""B"":
            ret += ""b""
        elif s[k-1]==""C"":
            ret += ""c""
    else:
        ret += s[i]
print(ret)"
"#ABC139B
a,b = map(int,input().split())
ans = 0 
outlet = 1
while b>outlet:
    outlet = outlet - 1
    outlet = outlet + a
    ans = ans + 1
print(ans)"
"import math
from math import gcd
INF = float(""inf"")

import sys
input=sys.stdin.readline
import itertools

def main():
    n, m = map(int , input().split())
    print(n*(n-1)//2+m*(m-1)//2)


if __name__==""__main__"":
    main()
"
"""abc091c - 2D Plane 2N Points""
N = int(input())
reds = [list(map(int, input().split())) for _ in range(N)]
blues = [list(map(int, input().split())) for _ in range(N)]

# 赤い点をy座標による降順ソートする
reds.sort(key=lambda x: -x[1])
# 青い点をx座標による昇順ソートする
blues.sort(key=lambda x: x[0])
# 一番左側の青い点からマッチング相手を探していく
for c, d in blues:
    for a, b in reds:
        if a <= c and b <= d:
            reds.remove([a, b])
            break
print(N-len(reds))
"
"info = list(map(int, input().split()))
matrix = [[""""] * info[1] for i in range(info[0])]

for i in range(info[0]):
    matrix[i] = list(input())


Black = 0

for i in range(info[0]):
    for j in range(info[1]):
        if matrix[i][j] == ""#"":
            Black += 1


combination = 0

for i in range(2 ** info[0]):
    non_selected = set()
    count = 0

    for j in range(info[0]):
        if (i >> j) & 1:
            
            for k in range(info[1]):
                if matrix[j][k] == ""#"":
                    count += 1
        else:
            non_selected.add(j)
    

    for l in range(2 ** info[1]):

        count2 = count
        for t in range(info[1]):
            if (l >> t) & 1:

                for s in non_selected:
                    if matrix[s][t] == ""#"":
                        count2 += 1

        if (Black - count2) == info[2]:
            combination += 1


print(combination)"
"x=input()
s=t=0
for i in x:
  if i==""S"":s+=1
  else:
    if s:
      s-=1
    else:
      t+=1
print(s+t)"
"n = int(input())
a = list(map(int, input().split()))
four = 0
two = 0
for i in range(n):
    if a[i] % 4 == 0:
        four += 1
    elif a[i] % 2 == 0:
        two += 1

if four >= n // 2 or n - 2 * four <= two:
    print(""Yes"")
else:
    print(""No"")
"
"a=int(input())
b=int(input())
s=a*a
t=s-b
print(t)
    

    
"
"n = int(input())

x, y = divmod(n, 2)

print(x + y)"
"def bingo():
    for i in a:
        if i[0] in b and i[1] in b and i[2] in b:
            return True
    for i in range(3):
        if a[0][i] in b and a[1][i] in b and a[2][i] in b:
            return True
    tmp=[(a[i][i] in b) for i in range(3)]
    if tmp.count(True)==3:
        return True
    tmp=[a[0][2] in b,a[1][1] in b,a[2][0] in b]
    if tmp.count(True)==3:
        return True
 
a=[[int(i)for i in input().split()]for j in range(3)]
n=int(input())
b=[int(input())for i in range(n)]
bingo=bingo()
print(""Yes"" if bingo else ""No"")"
"a = ord(input())
if ord(""a"") <= a <= ord(""z""):
    print(""a"")
else:
    print(""A"")
"
"A, B = map(int, input().split())
for i in range(0, 20):
    if B <= A*i - (i - 1):
        print(i)
        break"
"X,Y = map(int,input().split())
print(len(bin(Y//X))-2)"
"import sys


# input = sys.stdin.readline

def main():
    r = int(input())
    print(r*r)
    


if __name__ == ""__main__"":
    main()"
"#!/usr/bin/env python3
import sys
INF = 1<<32
MOD = 1000000007  # type: int

# def iterate_tokens():
#     for line in sys.stdin:
#         for word in line.split():
#             yield word
# tokens = iterate_tokens()
# n = int(next(tokens))  # type: int
# k = int(next(tokens))  # type: int


def solve(n: int, k: int):
    fact = [1] * (n+1)
    ifact = [1] * (n+1)
    for i in range(1, n+1):
        fact[i] = i*fact[i-1] % MOD

    ifact[-1] = pow(fact[-1], MOD-2, MOD)
    for i in range(n-1, 0, -1):
        ifact[i] = ifact[i+1] * (i+1) % MOD

    def comb(n, r, MOD=10**9+7):
        return fact[n] * ifact[n-r] * ifact[r] % MOD
    
    
    ans = 0
    for i in range(min(k, n-1)+1):
        ans += comb(n, i) * comb(n-1, i) % MOD
        ans %= MOD
    
    print(ans)

    return

def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    n = int(next(tokens))  # type: int
    k = int(next(tokens))  # type: int
    solve(n, k)

if __name__ == '__main__':
    main()"
"import math
from fractions import Fraction

N = int(input())
a, b = map(int, input().split())
ret_a = a
ret_b = b
for _ in range(1, N):
    a, b = map(int, input().split())
    x = math.ceil(max(Fraction(ret_a, a), Fraction(ret_b, b)))
    ret_a = a * x
    ret_b = b * x
print(ret_a + ret_b)"
"import sys

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10 ** 8)
INF = float('inf')
MOD = 10 ** 9 + 7


def main():
    N = list(map(int, readline().split()))
    N.sort()
    if N==[1,4,7,9]:
        print('YES')
    else:
        print('NO')



if __name__ == '__main__':
    main()
"
"N,X,Y=map(int,input().split())
distance=[0]*N
for i in range(1,N):
    for j in range(i+1,N+1):
        k=min(j-i,abs(j-X)+abs(i-Y)+1,abs(j-Y)+abs(i-X)+1)
        distance[k]+=1
print(*distance[1:],sep=""\n"")"
"a, b = input().split()
a = int(a)
b1, b2 = b.split('.')
b = int(b1 + b2)
print(a * b // 100)"
"N = int(input())
cnt = 0
st_cnt = 0
end_cnt =0
same_cnt =0

for k in range(N):
    s = input()
    cnt +=s.count(""AB"")

    if (s[0] =='B') & (s[-1]=='A'):
        same_cnt += 1
    elif (s[0] =='B'):
        st_cnt +=1
    elif (s[-1] == 'A'):
        end_cnt += 1
if same_cnt==0:
    print(cnt + same_cnt + min(st_cnt, end_cnt))
elif (st_cnt==0) and (end_cnt==0):
    print(cnt+same_cnt-1)
else:print(cnt+same_cnt+min(st_cnt,end_cnt))"
"N = int(input())
ans = [] if N != 0 else [0]
while N:
    ans.append(-(N % -2))
    N = -(N // 2)
print("""".join(map(str, ans[::-1])))
"
"N = int(input())
dmin = N+N
for i in range(1,int(N**0.5)+1):
    if N%i==0:
        dmin = min(dmin,i+N//i-2)
print(dmin)"
"#coding:utf-8
n=[int(i) for i in input().split()]
if(n[1]-n[0]==n[2]-n[1]):
  print(""YES"")
else:
  print(""NO"")"
"n,k=map(int,input().split())
a=sorted(list(map(int,input().split())))
mod=10**9+7
ans=0
MOD=10**9+7

factorial = [1]
inverse = [1]
for i in range(1, n+2):
    factorial.append(factorial[-1] * i % MOD)
    inverse.append(pow(factorial[-1], MOD - 2, MOD))
 
 
# 組み合わせ計算
def nCr(n, r):
    if n < r or r < 0:
        return 0
    elif r == 0:
        return 1
    return factorial[n] * inverse[r] * inverse[n - r] % MOD
for i in range(n-k+1):
    ans-=a[i]*nCr(n-i-1,k-1)%mod
    ans%=mod
a=a[::-1]
for i in range(n-k+1):
    ans+=a[i]*nCr(n-i-1,k-1)%mod
    ans%=mod

print(ans%mod)"
"n,p = map(int, input().split())
A = list(map(int, input().split()))
cnt = 0
for a in A:
    if a%2==0: cnt += 1
if n == cnt:
    if p == 0: ans = 2**n
    else: ans = 0
else: ans = 2**(n-1)
print(ans)"
"N = int(input())
A,B=map(int,input().split())
P_s = list(map(int,input().split()))
CNT_s = [0]*3
for P in P_s:
    if P <= A:
        CNT_s[0] += 1
    elif A <  P <= B:
        CNT_s[1] += 1
    if B <  P:
        CNT_s[2] += 1
print(min(CNT_s))"
"import bisect
import copy
import heapq
import math
import sys
from collections import *
from functools import lru_cache
from itertools import accumulate, combinations, permutations, product
def input():
    return sys.stdin.readline()[:-1]
def ruiseki(lst):
    return [0]+list(accumulate(lst))
sys.setrecursionlimit(500000)
mod=10007
al=[chr(ord('a') + i) for i in range(26)]
direction=[[1,0],[0,1],[-1,0],[0,-1]]

n,k=map(int,input().split())
h=list(map(int,input().split()))

dp=[float('inf')]*n
dp[0]=0
for i in range(n):
    for j in range(k):
        # nex=i+j+1
        if i+j+1<n:
            dp[i+j+1]=min(dp[i+j+1],dp[i]+abs(h[i]-h[i+j+1]))
    # print(dp)
print(dp[-1])"
"import numpy as np

S=input()

s = [st for st in S]
if len(np.unique(s)) == 3:
  print(""Yes"")
else:
  print(""No"")"
"def d_maximum_average_sets():
    from functools import reduce
    N, A, B = [int(i) for i in input().split()]
    V = sorted([int(i) for i in input().split()], reverse=True)

    def combination(n, r):
        numerator = reduce(lambda x, y: x * y, range(n, n - r, -1))
        denominator = reduce(lambda x, y: x * y, range(1, r + 1))
        return numerator // denominator

    if V[0] == V[A - 1]:  # V の上位 A 個がすべて同じ値 (v_max とおく)
        # V で値が v_max である x 個から A 個以上 B 個以下選ぶ
        x = V.count(V[0])
        count = sum([combination(x, i) for i in range(A, B + 1)])
    else:
        # 上位 A 個のうち最も値が小さな要素の値を v_min とおき、
        # v_min が上位 A 個のうち a 個あったとする。
        # V で値が v_min である x 個から a 個選ぶ。
        v_min = V[A-1]
        x, a = V.count(v_min), V[:A].count(v_min)
        count = combination(x, a)
    return '{}\n{}'.format(sum(V[:A]) / A, count)

print(d_maximum_average_sets())"
"s,t,u=map(str,input().split())
print(s[0]+t[0]+u[0])"
"x = input()
n = len(x)
s = 0
t = 0
cou = 0

for i in range(n):
    if x[i] == ""S"":
        s += 1
    elif x[i]== ""T"":
        if s >= 1:
            s -= 1
            cou += 1
print(n - cou * 2)"
"#!/usr/bin/env python3
import sys
INF = float(""inf"")


def solve(N: int, T: int, A: ""List[int]""):

    amin, amin_i = (INF, -1)
    gmax = 0
    cand = []

    for i, a in enumerate(A):
        if a < amin:
            amin = a
            amin_i = i
        else:
            if a-amin > gmax:
                gmax = a-amin
                cand = [(gmax, amin_i, i)]
            elif a-amin == gmax:
                cand.append((gmax, amin_i, i))
    print(len(cand))
    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    T = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: ""List[int]""
    solve(N, T, A)


if __name__ == '__main__':
    main()
"
"import sys
input = sys.stdin.buffer.readline
from operator import itemgetter

def main():
    N = int(input())
    a = list(map(int,input().split()))
    posi,nega = [],[]
    for num in a:
        if num >= 0:
            posi.append(num)
        else:
            nega.append(num)
    
    posi.sort()
    nega.sort(reverse=True)
    ans = []
    if len(posi) == 0:
        a = nega[0]
        for i in range(N-1):
            ans.append((a,nega[i+1]))
            a -= nega[i+1]
    elif len(nega) == 0:
        if len(posi) == 2:
            ans.append((max(posi),min(posi)))
        else:
            a = posi[0]
            for i in range(N-2):
                ans.append((a,posi[i+1]))
                a -= posi[i+1]
            ans.append((posi[-1],a))
    else:
        pl,nl = len(posi),len(nega)
        a = posi[0]
        for i in range(pl-1):
            ans.append((nega[0],posi[i+1]))
            nega[0] -= posi[i+1]
        for i in range(nl):
            ans.append((a,nega[i]))
            a -= nega[i]
            
    print(ans[-1][0]-ans[-1][1])
    for x,y in ans:
        print(x,y)

if __name__ == ""__main__"":
    main()
"
"#AGC033-A-Darker and Darker
from collections import deque

h,w = map(int,input().split())
grid = [input() for i in range(h)]

#初期の黒('#')の位置からの距離
dist = [[-1]*w for _ in range(h)]

p = deque()
d = 0
for i in range(h):
    for j in range(w):
        if grid[i][j] == '#':
            p.append((i,j))
            dist[i][j] = 0

while p:
    y,x = p.popleft()
    d = dist[y][x]
    for dy,dx in ((1,0),(0,1),(-1,0),(0,-1)):
        if 0<= x+dx < w and 0<= y+dy < h and dist[y+dy][x+dx] == -1:
            dist[y+dy][x+dx] = d+1
            p.append((y+dy,x+dx))

    
print(d)"
"N, K = map(int, input().split())
A = list(map(int, input().split()))

ans = []
for i in range(K, N):
    ans.append(['No', 'Yes'][A[i] > A[i - K]])

print('\n'.join(ans))"
"def main():
    info_num = int(input())
    min_score_index = 0
    min_score = float(""inf"")
    for _ in range(info_num):
        a, b = map(int, input().split())
        if min_score_index < a:
            min_score_index = a
            min_score = b
    print(min_score + min_score_index)


if __name__ == '__main__':
    main()

"
"import math
while True:
    n=int(input())
    if n==0:
        break
    else:
        score=list(map(int,input().split()))
        dev=math.sqrt(sum((x-sum(score)/len(score))**2 for x in score)/len(score))
        print(""{:.8f}"".format(dev))

"
"from itertools import combinations

n = int(input())

def dfs(s):
    if len(s) == n:
        print(s)
        return 0
    for i in range(ord('a'), ord(max(s))+2):
        t = s
        t += chr(i)
        dfs(t)


dfs('a')"
"txt = list(input())
a = txt[0]
count = 1
i = 1
while(i < len(txt)):
  #print(temp)
  if a != txt[i]:
    a = txt[i]
    i += 1
    count += 1
  else:
    if (len(txt)-i) >= 2:
      a = txt[i:i+1]
      i += 2
      count += 1
    else:
      break
print(count)"
"def gcd(x, y):
    while y > 0:
        r = x % y
        x = y
        y = r
    return x

def lcm(x, y):
    return x // gcd(x, y) * y

n, m = map(int, input().split())
a = list(map(int, input().split()))

l = 1
for i in range(n):
    a[i] //= 2
    l = lcm(a[i], l)

flg = True
for x in a:
    if (l // x) % 2 == 0:
        flg = False
        break

if flg:
    print(m // l - m // (l * 2))
else:
    print(0)"
"a, op, b = input().split(' ')

if op == '-':
	print(int(a)-int(b))
else:
	print(int(a)+int(b))"
"n=int(input())
l=[]
for _ in range(n):
  l.append(int(input()))
l.sort()
non_0s=[x%10!=0 for x in l]

if not any(non_0s):
  print(0)
  exit()

ans=sum(l)
if ans%10==0:
  for i in range(n):
    if non_0s[i]:
      ans-=l[i]
      break
print(ans)"
"s = input()
print(s[::(-1)**(len(s))])"
"kn=input("""").split("" "")
k=int(kn[0])
n=int(kn[1])
aa=input("""").split("" "")
lista=[]
for i in aa:
    lista+=[int(i)]
for i in range(n):
    lista[i]%=k
lista.sort()

s=k-lista[n-1]+lista[0]
t=lista[n-1]-k
for i in range(n):
    ss=lista[i]-t
    
    if(ss>s):
        s=ss
        
    t=lista[i]
print(k-s)
    
    
"
"A, V = map(int, input().split())
B, W = map(int, input().split())
T = int(input())
if A < B and B+W*T <= A+V*T:
    print(""YES"")
elif A > B and B-W*T >= A-V*T:
    print(""YES"")
else:
    print(""NO"")
"
"s=input()
w=int(input())
ans=''
for i in s[::w]:
	ans+=i
print(ans)
"
"from collections import defaultdict
n,m=map(int,input().split())
a=[int(i) for i in input().split()]
a.sort()
bc=defaultdict(int)
for i in range(m):
  b,c=map(int,input().split())
  bc[c]+=b
i=0
newc=[0]*n
for c,b in sorted(bc.items(),key=lambda x:x[0],reverse=True):
  for _ in range(b):
    if i==n:
      break
    newc[i]=c
    i+=1
ans=sum(a)
for i in range(n):
  if newc[i]>a[i]:
    ans+=newc[i]-a[i]
print(ans)"
"n = int(input())

ans = 0
for i in range(int(n ** 0.5) + 1):
    if i ** 2 <= n:
        ans = max(ans, i ** 2)

print(ans)
"
"from decimal import Decimal, ROUND_HALF_UP

l = int(input())

ans = Decimal(str((l/3)**3)).quantize(Decimal('0.0000001'), rounding=ROUND_HALF_UP)

print(ans)"
"from collections import defaultdict

N, W = map(int, input().split())

data_list = []
for i in range(N):
    w, v = map(int, input().split())
    data_list.append((w, v))
    
data = defaultdict(int)
data[0] = 0
for w, v in data_list:
    for cw, cv in list(data.items()):
        if cw + w <= W:
            data[cw+w] = max(data[cw+w], cv+v)
            
print(max(data.values()))"
"#!/usr/bin/env python3

def main():
    H, W = map(int, input().split())
    h, w = map(int, input().split())
    all_cells = H * W
    black_cells = h * W + w * H - (h * w)
    print(all_cells - black_cells)

if __name__ == ""__main__"":
    main()
"
"a = int(input())

if a == 0:
    print(1)
elif a == 1:
    print(0)
"
"# coding: utf-8
# Your code here!
import sys

k = int(input())
a = list(map(int,input().split()))[::-1] 
x=2
y=2
if a[0]!=2:
    print(-1)
    sys.exit(0)

for t in a:
    x=((x-1)//t+1)*t
    y=y//t*t+t-1
    #print(x,y) 

if x > y:
    print(-1)
    sys.exit(0)
print(str(x)+"" "" + str(y)) "
"while True:
	try:
		a=input().split()
	except:
		break
	b=int(a[0])+int(a[1])
	print(len(str(b)))"
"n=int(input())
p = list(map(float,input().split()))
dp = [[0 for _ in range(n+1)] for __ in range(n+1)]
dp[0][0] = 1
for i in range(n+1):
    for j in range(n+1):
        cnt = i + j
        if cnt == 0 or cnt > n:
            continue
        if j == 0:
            dp[i][j] = dp[i-1][0] * p[cnt-1]
        elif i == 0:
            dp[i][j] = dp[i][j-1] * (1 - p[cnt-1])
        else:
            dp[i][j] = dp[i-1][j]*p[cnt-1] + dp[i][j-1]*(1-p[cnt-1])
        
ans = 0
for i in range((n+1)//2, n+1):
    ans += dp[i][n-i]
print(ans)"
"N = int(input())
ans = [0] * 100001
for i in range(6):
    ans[i] = i
s = 6
n = 9
for i in range(6,N+1):
    p = i%3
    if p != 0:
        ans[i] =  ans[i-p] + p
    else:
        if i == s*6:
            s *= 6
        if i == n*9:
            n *= 9
        ans[i] = min(ans[i-s]+1,ans[i-n]+1)
print(ans[N])"
"def main():
    n = int(input())
    pt = []
    for _ in range(n):
        x,y = map(int,input().split())
        pt.append([x,y])
    a,b,c = [],[],[]
    for p in pt:
        a.append(p[0]+p[1])
        b.append(p[0]-p[1])
        c.append(p[1]-p[0])
    ans = 0
    if max(a)-min(a)>ans:
        ans = max(a)-min(a)
    if max(b)-min(b)>ans:
        ans = max(b)-min(b)
    if max(c)-min(c)>ans:
        ans = max(c)-min(c)
    print(ans)

if __name__ == ""__main__"":
    main()"
"n = int(input())

if n < 1200:
    print('ABC')
if n >= 1200 and n < 2800:
    print('ARC')
if n >= 2800:
    print('AGC')"
"N, M = map(int, input().split())
K = []
for i in range(M):
  i = list(map(int, input().split()))
  K.append(i[1:])
p = list(map(int, input().split()))

ans = 0
for i in range(2**N):
  tmp = i
  flag = True
  cnt = 0
  for j in range(len(K)):
    for k in range(N):
      if ((i>>k) & 1):
        if k+1 in K[j]:
          cnt += 1
    if cnt % 2 != p[j]:
      flag = False
      break
    else:
      cnt = 0
      i = tmp
  if flag:
    ans += 1
print(ans)"
"import sys
input = sys.stdin.readline
def main():
    N = int(input())
    V = list(map(int, input().split()))
    C = list(map(int, input().split()))
    val = 0
    for i in range(N):
        if V[i]-C[i] >= 0:
            val += V[i]-C[i]
    print(val)

if __name__ == '__main__':
    main()"
"def height(a, b, x, y, h):
	return h + abs(a - x) + abs(b - y)

n = int(input())
P = []
for i in range(n):
	x, y, h = map(int, input().split())
	P.append([x, y, h])

# sort by h
P.sort(key=lambda x: x[2], reverse=True)

for i in range(101):
	for j in range(101):
		H = height(i, j, P[0][0], P[0][1], P[0][2])
		for k in range(1, n):
			if max(H - abs(P[k][0] - i) - abs(P[k][1] - j), 0) != P[k][2]:
				break
		else:
			print(i, j, H)
			exit()"
"a,b,c=map(int,input().split())
s = [a,b,c]
s = sorted(s)
print('Yes' if s[0]+s[1]==s[2] else 'No')"
"def is_stable(output_str, same_num_str):
    if len(same_num_str)>0:
        for i in range(len(same_num_str)):
            if output_str.find(same_num_str[i]) == -1:
                return ""Not stable""
    return ""Stable""
    
data_num = int(input())
cards = input().split("" "")
cards2 = cards[:]
cnt = 0
num_1 = 0
num_2 = 0
same_num_str = []
output_str = """"
judge_stbl = """"
for i in range(data_num):
    
    for j in range(data_num-1, i,-1):
        if int(cards[j][1:]) < int(cards[j-1][1:]):
            cards[j], cards[j-1] = cards[j-1], cards[j]
        elif int(cards[j][1:]) == int(cards[j-1][1:]):
            same_num_str.append(cards[j-1]+"" ""+cards[j])    
            
output_str = "" "".join(cards) 
judge_stbl = is_stable(output_str, same_num_str)

print(output_str + ""\n"" + judge_stbl)

same_num_str = []
output_str = """"
judge_stbl = """"

for i in range(data_num):
    min_idx = i
    for j in range(i, data_num):
        if int(cards2[j][1:]) < int(cards2[min_idx][1:]):
            min_idx = j
        elif int(cards2[j][1:]) == int(cards2[min_idx][1:]) and j != min_idx:
            same_num_str.append(cards2[min_idx]+"" ""+cards2[j])    

    if i != min_idx:
        cards2[i], cards2[min_idx] = cards2[min_idx], cards2[i]

output_str = "" "".join(cards2) 
judge_stbl = is_stable(output_str, same_num_str)

print(output_str + ""\n"" + judge_stbl)"
"a,b,c,k=map(int,input().split())
if k < a:
    print(k)
elif k <= a+b:
    print(a)
else:
    print(2*a+b-k)"
"#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from fractions import gcd
from itertools import combinations,permutations,accumulate # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
#import bisect
#
#    d = m - k[i] - k[j]
#    if kk[bisect.bisect_right(kk,d) - 1] == d:
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
def readInts():
  return list(map(int,input().split()))
def I():
  return int(input())
import math
a,b,h,m = readInts()
h = h-12 if h>=12 else h
h_ = 30 * h + 30 * m/60
m_ = 360 * m / 60
kakudo = min(abs(m_ - h_), 360 - abs(m_ - h_))
c = pow(a**2 + b**2 - 2*a*b*math.cos(math.radians(kakudo)),.5)
print(c)
"
"S = input()
bb = 'x'*len(S)
print(bb)
"
"import sys
sys.setrecursionlimit(10 ** 9)

n = int(input())
x = input()

p = [-1 for _ in range(2*(10**5)+1)]
cnt = x.count('1')

def calc(a):
  #print('a=',a)
  if p[a] != -1:
    return p[a]
  else:
    if a == 0:
      ret = 0
    else:
      b = bin(a).count('1')
      ret = 1+calc(a%b)
    p[a] = ret
    return ret

if cnt > 1:
  x0 = int(x,2)%(cnt-1)
  xx0 = [1]
  for i in range(n):
    xx0.append((xx0[-1]*2)%(cnt-1))
x1 = int(x,2)%(cnt+1)
xx1 = [1]
for i in range(n):
  xx1.append((xx1[-1]*2)%(cnt+1))

y = list(x)  
for i in range(n):
  if y[i] == '0':
    xx = xx1[n-i-1]
    print(calc((x1+xx)%(cnt+1))+1)
  else:
    if cnt == 1:
      print(0)
    else:
      xx = xx0[n-i-1]
      print(calc((x0-xx)%(cnt-1))+1)"
"N = int(input())
A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())
m = min(A, B, C, D, E)
import math
n = math.ceil(N/m)
ans = n + 4
print(ans)"
"N = [int(input()) for i in range(4)]
if N[0] <= N[1]:
    print(N[2] * N[0])
else:
    print(N[2] * N[1] + N[3] * (N[0] - N[1]))"
"import math
n = int(input())
if n%1000 == 0:
  print(0)
else:
  print(1000 - n%1000)
"
"# This code is generated by [Atcoder_base64](https://github.com/kyomukyomupurin/AtCoder_base64)
import base64
import subprocess
import zlib


exe_bin = ""c%1E9e{@q-p1&_iX@NEgTA-*55euhXAQC9p3e|+B@ZzS>fiQyzKGGy@Gqy=hUZ6PaSWl?(wi9Gr*X4}Pk>l>!(b;occh2tmW1O|6NR>HzmNI8XX4DnkQBzUD6|w%H+3)whd(-z`6ZAOyr<X&%_xpL@@ArQ1_ulut@7;HMce8)JNe~DxW^xljZtx0~cQZWe%!>e4Po~4~cgTD)4S0)2&Pc}vJuS<(qw3Y0RNhFhA$lrkXbCA^gepBH#F5uSUu)*8Xw7_wj-F@jZY$C2nV6oN>A9Iar*@{tDes?!{SPqQNWDZ)EsVClEr+o_I9uh7G(hx}>wOpWrjf5-?2K+^?G=m5Y347dd>pRtingt;yS^*DtScHz^)BnJU%hN~oiiDCuAn~Ine2v*Td6#bw@Kr3CByLg)46RY9-01knOxt`CC{sW*nTF~89~|EWOCdv!UAZrFp$c_<xR<lO1a4?<#+J^iURoaMet9G;7@`B3k%@8ipXy*g8x`3jQ_j{{?j7(hehl!Eh7KJBKV3T_}n7+0>bYIeQ7Hq|LY>Sy@;JPMeu(hh3(t|_GgiK#O+YE>}+B_OjLZ=wJKi4CoIg@q#O<{S%PzPHIbx_?s!Z}%E5#zNksAmTBL9!5$T8~<wzpX($p1?MFPRLu84ZA@RjWww?q@k=FL&4ZjtLEv2d3!v_*EgLY={cBqxGVIq3^EH*W@PWm_;A4N38&oQMRweE})3Tx#C3TB52eL(v#DC)Y>gNeM(Fb-q|s_PUyPQ#{@vwMfxeGLn#ey=X8VP&HjQNRr%{i0=WVuoUd-iic1m+||0<V9>QHxi=P)_C)1Q=yy08Z*Idd^!7?Ukwh{c3wA~2z0&UGpcdQHUC5gz)f?z(D4vorq#dD<l*EX-h_p4fCmIV&n<L3ocLXnnc&H)Dp*y5d=N(deFxmw`Fo_-ET&OoF1?5O@R3_b#?oiKOhP6l0r@J7|5?W(})g6RTZD?weRyvoH4SwIcCTWGUE?;v^R#!Mzk*00iJnMXt%ehj8w`~KxI%k8H!|7pyY-ED`Vxqq#tTqk)mlDkCYMwRGe^><g7Z4`rbL-;0Gg0op*nAVf-kt2a8~#^DqZOFRUSZgSKY3^xu4HdAK6O=eI%dZAHTnXX%+tU9=R06!Dy8cvV#?jMCd{B_lgi7r50s&Qvsgyt`J1mtgIB6_xdA`KZmxO*-pAz29D1DdCl{!cum8N9*5Eb`enx}O(%@MQuD#FCYw#;I__zkI)ZljJ7skx0!FhhbWqq~==lKEgIU2l^*)JuNYaNyz4X#~udNsINgZF80?eoe34X$0U4{7jH4SraImuc`L8hpA2e_Vsl(BMyL@R=I?84X^p!3Q;Xg$92~gWEN@n0~)Z94PtQ*$yK156Y(8Nilt_Y?$O${coj%<Q83kU)usV)R6B)m9aB9D2v`h9z#8LlJajMk0Bl#r2HR|$Iy;FMfp?6<CGgaLirQOV~EENQT{0M7}~Ku%0GuZx;xfG`ClTBp&Z*q`ClN9AslO^{A0*t=*HZX|0(hqva#iqe*k$5)tH0we+_*5p?n-N70PrZs}@tz=$ftu=eZbM&9;C>yVJH{KNYquAfE4gzURt$wt50vw}|(=e;ClPIAB>+gSM3Y)dzsO2D5KZ<Z@z0uC51*PhgBkO75Mbjzo5hU0W+EBiYxG3GD!;|5e-m|ADxO&*apyKx`Pc-FN3SbZhDB)LG?R_6t-{yw&!0+X8qP9icWy+!l3E2g}6tSs^th4uFI|vuGK%Exafy!(u~LUf6y}RQ}tqyqk?sACeYy;a04ths(r<*HdR+a6C~(vJbIF9B9WOW)2}r+Y?7fzNLnfsq<8TDv2ZRGMpBwJ!la0Ys5?+UYiV|IAT`yvAto?SKbhp>;u6OZ?&ijc&l4^WgD;TQoDai9J*u{`#-Sl|Gh;YsTXbc)k5&HuU&%12f&~|bA);YUbN!RHop?C-X%7CA=^b|;yLx&NOm8{r!NV3aT_+&$y@B<m0qkUS*W?Od!Fa<_g6UKZ3kb0&Zy(iEd0saaOUpuri`W93&!02gJS5kt^YBQ$TWjXf$C25t5wX@y@<2f7dj?p%8$ARRef=wvQ$(m1vRk8Q|COHKy|MF)Q{wh<qC1Y589zqzGq$OJ@ZY^E;fmW#i281F|&5mpYaOk!KmQLc&jG>wfJfWHSr#>isp?lD?YS~>2qbG@{;e<G58gS#%~sfKA$Vr9u=cU1=6=htQ``SO=Z4@^QjY_^p}F|;9>CH0~1y7WBa~m@{Na%`$jB77>7fn6B)~DF*K2B6~x27f$|}A(_B7E8_E`IsQ;o*DgP{W6edr7dR&0vsj?k>LqK<TR677&`)dra?>XM2Ka;fMH9Lr2lg<ia#tRb&m@?afKI|vxT+=^jJE#cgvt=n2_GY?sAY%~^w`A51(Kss~E=gK!2R;EYZ^MU5_60howoRWbG53~x8?sP+Q5i{(2;PQwY?(bK6nocpf6Row`Kv{*@Qzn_w_(Dky!2PQAs@Ie9v5U6L?nG&fPN2Qzm?zkK7CKyb!8NT8+{pj@2mZdU-^Uk;)ozS)8_;+G}2<W4EdG87G)UJprVPGUyWEx?Qn~7dURqm*D$d!;}>Wv`X(^Cr_|_<`pnkL3wRse_9<3d=4t5sfLv|yDK<V|E<2t@4f64%xAmGGFe?3j16d&bqTov(FI&@v!@HekIv8m>#*i29v_Wnfs2k2c{uw5Wk?bJS%)V-O_8l5-xQnx2(ra&IFCfLFhO1Q>O1}k&Yfv0`gy!6^xbhmBgl+wcaUR`s3{&%MJ3Tu*J3Y61q+vEsTo;w>5;Gljn^F!gjV(gI^f?z_V*HtEnsYH*-bWjU(f0|*MCB;1i=r|^OdnOV?Z@b9C#H}doRYNGEB5E)l58Vr_J80VfP`Q>So<Y3ckYW^PEE2dv<hj(uI4t#qhp!Ru}@=bzQ90K^qA?wlrhnT>6bvBy9*QSGvm2jwh6Sew~wo-7TR}YN0CYI1AFoeMC{oY#?|0`Iw@9@{RJ>*|1*0X8u^cL7IC<m#mC>XuR`tYP_|@TO{1NtMthQENGr1cmJOqoCt*FwG`@x72rFi`kBT&Yw*vUg?Cq4SI!3P^D;rw~SKAM{KJY1{w~NYKV){?#TLb<~3BEZ)XRo8A@ez>9&AwRfAQ#lUm}$Hg3~d!NCG*f=!?>utEzg5TmlNgcqf5ok+?mOIw{sXrN0a|Djc=AyNB&rjW@;xuUmTh+i^_R%D0{Og92Z9?WSEpCKVb&T(O@xqeT^SkVI5ChFQyxB1_dw){**(ve*j$eXP-h;Md-rul9xeF*vaSJ$HQu#NAaCw?f6(h`7NUIg*b3`jT&U@rx?K>+L4=f+gR>mE_d7Tl;;nh@(MnH!16w4It|UT?*QH6Q7-wEi~icT>9ZXyl-aqU538l@aJ|Y+_?6H7%0;ho&XcQr4Q^KfSN->JfHe2Yp~)sc9%j#q^yv_vu}#D)`6I!eXskmD1n+Q$dV0um$J$0mPdw>ZyqJ=;j+mrAU(qXFh<8yGYZOahEumsd94`JmwmTjTJGMkRx+5_;kcdRqwk&n5zv;#sQ$1mL<*bRu<fV?5TE}hpR_thTfbDp!L;ZnkYaHtV!Z*&E+8b|N+ZF6?3kOkYb=^`2CABy0B$q2Kg&OaO$ZE^*^Jlg#Ty0*1dx7`>d*nhccLe9uC%N29xR?UPmzY7IbwE!-zBquH3Z7B$al{Up>I_gf&?A691vJZEdicAQaMxxc^xB21%S+1+38i+#aZmOD*jl3LXJL6ls+s)w$7)-|YF}@yy2UngPgx(i`KmR4v9fw0*T=okr=Sno_Z-yS0sm{j=j#ygSnX-kZ8NN8%`-jLGWrg(5B<5ouHS04=l6{7YV}iZN*}I;34Jy92_Fa1ul=B7g*OAsuYg%+wcl@AXRSJD_F5eo%Q|b#k4rq(<@ZkWSnJcJ8>}Y<^TQ=Gto49-tTpSb4v+<%b=ER*CiC9{w%w3w=~nq)TJ5)kf7qvM06z@ziV$5p&G~jjY)8a)TCDCwp*Cng!#I{;NBjPn%L$E(;odkdRKHn49y66ZP(dCwmpofRemkS$R0X*(v*c_AIZ+PJvY863{%ZwPU#dWfcPcKolm2b_wtQQ@E#DR_eE*d1m-78l?RQBn4G4PvPFCT2Y$Ds7<9ll|TR`VAp6}mY&3L}ob`_(1zm~6ce9io1A{R$`m@N`K!)MthE#Gq-WY_r~;e5vPy+Qu@RJ&)2h3|2;vVB0l7S$V`8~7gPT<-sLJ$|}W?>E=ydzrlb?-0ElEU&bG0)r+PU(f927|;DY&-iKV`e%&S?pgnT7XDq>Sa!2O-^=JjjQ%5||IX-fMt{%fJB(grbQ&9=IgBo5bhUO<_Zt+xug}YdrluPmHCx+KF*)V9!MV!0eA&tr<y=2<)jOBh)vD;%v5j9c>I;0S#V;;_g1DK;1#wG$UhDCa{Cw8q)AI9PkC*1>gB~x-&m%oPJwIRd_>BC#*5fnt_qQG|C%X#b6~tX&{LI8kS_|T~e7?}*cG6c6pOrs9pvSKuRdWjASCYZGh49LJUee>U^Z7`R&nb96m?10h{GrF;u6Go|C%^OR@vEj_m_{t*qnr`PbZvroo@9CZI)>L5!FMv8$DiZ((>Cnn42yG^;iC-S#p1k+;rLw|?eKMjAET)jP<|fSyU>yM8_P<eu>UtPJLe4_!`%#Dex)AY!tg!=9%b$J8rtop_|$QHl-U_H*!d?aKXpD7^Zx{uzk)npU|toHKTRE*I&aTXJ5%S?1u9=T#s3nMiW~i`GNGNR^Uz7Zr&f_F!+e`#!SB3N=jSRDdO3OD@pR)g6+XA{gCh6?Mere0;qxa8==lm5Up7CjEI++o#LgmE5NDaHrsVk*<|5}Sir^8zuLV2&dn;d;hb$;RH80&$#Lk07@F$DlS6S5l@^fi?@8M_>`QH`6cThW1^Yce6KE`psWG;Npq|&0!lPUR%&YyXtZ=oK))}rD@`^zka{oKs@%O9vB3~wtUpSBb}Kl5l2`KOuvp31!2w2W8^pPzZXh@CHsv^%q;Futgyu$=;%fYSDjE|+Ha%-6fU4!6Uaw|4dRHcQRk73$fT%L}=_hR|wtH?TR{>+A_8Walc-_}VJXt_DeJ-P{}q+$yc#y0IzX+q4l+6n&M2l^qeeIT|gdzQMm~oyRXp$yA%<QxCo1$s2#YBt_%VSX3sVgq)O9?d{GGnLN29$=y;2PbejcB!%NrM_0Tp*d>MKcp@nUQ@tb<@9yb}$dRz~hSd%Ag@y3sO;idd62ZL^c%Rry+7rR<h!jqBcjMt44JV;1I#EelzuD6Q9o*=}en=ZOZk3uv28!OzMDpIc(bM8<f@?bEupXeNee!YGw0`}T=71FNtn)X6)d&PXNF?7TdXgz7rIL|w(c@5VxAw44vC~vKDQCl1AD%Lp)g4)4*VrMXZ+<w;*hV-RmpX%BNqhLrD5N=ErT4@8eP<%l?ksrdOFeltDetP&oy;<J2+x-p;~Lx3ZFEI{@@vuvUJJA|@kzpuluhX_j541HQd=^~>xGY|8MW!5u~0HaXH~(YZf>{ceAs2r0O}66K|}2PnWhoEXYyzH3c50Re$5cg0%sA6o;NITKv3TpaVGb6%fU9Fazdq@ycUgt$sXd2#pQ?-`n^mJb}+6ZmU6bGqFv!-(J-N0XE51GoZ-DOu%}Wvp<dYyL5#*@I!1zPiAYxv1zD}9OU5Q4_E>dx#GwL{34Up;oQXKSi=B~9mQgyxiAfHuheA@MHx%iSC7Jf$Ihh_*8@vu}2D_sns8EA2Q-~819j4wwYt1((xDSI%VSc}($a!^M1Ot!n58AV1#`E9~gS_#z)n(A<@5h{0e}z7Nhq#!_#koFzkLI+7;e5YH`wa%mMxyQwaee;2&1nszxW6Q5^!Yx{_lW)sIDaqabiU#J-59^yiMqGL#rXR>r~JK&`)@MPJBYehlpnuRJw3whGCz&|#}DNejXk~}z$xFqGRBYhe?QY-$9TSPz^PV$ZUOy+M0*x~a{rK1<7<_1{1t;f--qDzj6vRRpbr}K`F;hb#(0$(=+6xL{Jomfg@%0;yPhR~Z_wxO8JrroVT}EMg6QvG{=UYk+c4oA2K|3A=okCDjAHG-V9@9LE}TAYXx|vmmyPYu)l-i_-gy7KO4M_)d|!0(?>toA7;oeFy-U>dyj-8ZXV=d!?5|P(V={SfVVV3p8rHrhe`xi%Ux!(rjQh{63snB8uW0{EgMR+KjgkDH3mNoyF|iHjy#GwUis`!z`O9t4FBR1GjT@$1zt(^k`mRvuk6lFGK64n?p_OE6{+O=uU0V*Y#D9z7Q?POV%qpUPYMDyy1_h)3{{iJ9@00""

open(""./kyomu"", 'wb').write(zlib.decompress(base64.b85decode(exe_bin)))
subprocess.run([""chmod +x ./kyomu""], shell=True)
subprocess.run([""./kyomu""], shell=True)"
"S = input()
T = input()
ans = 1001
for i in range(len(S)-len(T)+1):
  ans = min(ans, sum(S[i+j] != T[j] for j in range(len(T))))
print(ans)"
"n = input()
op_cnt = len(n) - 1
for i in range(2 ** op_cnt):
  op = ['-'] * op_cnt#['-', '-', '-']
  for j in range(op_cnt):
    if ((i >> j) & 1):
      op[-1-j] = '+'
  formula = ''
  for p_n, p_o in zip(n, op + ['']):#(1,+),(2,+),(3,+),(4,'')
    formula += (p_n + p_o)
  if eval(formula) == 7:#'1+2+3+4'
    print(formula + '=7')
    break"
"if __name__ == '__main__':
    n, k = map(int, input().split())
    if k % 2 == 1:
        base = n // k
        if base == 0:
            print(0)
        else:
            print(base ** 3)
    else:
        ans = 0
        base = n // k
        if base != 0:
            ans += base ** 3

        base = n // (k // 2)
        if base % 2 == 0:
            base = base // 2
        else:
            base = (base + 1) // 2

        ans += base ** 3

        print(ans)"
"from collections import deque
import copy
H,W = map(int, input().split())
s=[list(input()) for i in range(H)]
#H,W=3,3
#s=[['.', '.', '#'], ['#', '.', '.'], ['.', '.', '.']]

ss=copy.deepcopy(s)
q=deque([[0,0]])#(H,W)
ss[0][0]=0
move=[[1,0],[0,1],[0,-1],[-1,0]]
num=0
t=False
while q:
    num+=1
    for i in range(len(q)):
        b=q.popleft()
        #print(b)
        if b==[H-1,W-1]:
            t=True
            num-=1
            break
        for m in move:
         #  print(m)
            if 0<=b[0]+m[0]<=H-1 and 0<=b[1]+m[1]<=W-1 and ss[b[0]+m[0]][b[1]+m[1]]=='.':
                ss[b[0]+m[0]][b[1]+m[1]]=num
                q.append([b[0]+m[0],b[1]+m[1]])
    else:
        continue
    break
if not t :
    print('-1')
else:
    x=num
    b=H-1,W-1
    ss[b[0]][b[1]]='#'
    while x!=0:
        for m in move:
            if 0<=b[0]+m[0]<=H-1 and 0<=b[1]+m[1]<=W-1 and ss[b[0]+m[0]][b[1]+m[1]]==x-1:
                x=x-1
                ss[b[0]+m[0]][b[1]+m[1]]='#'
                b=b[0]+m[0],b[1]+m[1]
                break
    ans=0
    for h in range(H):
        for w in range(W):
            if ss[h][w]!='#':
                ans+=1
    print(ans)"
"N, K = map(int, input().split())
As = list(map(int, input().split()))
d = [True]+[True]*K
for i in range(1, K+1):
    for a in As:
        if i-a<0:
            continue
        if d[i-a]:
            d[i] = False
            break

if d[-1]:
    print(""Second"")
else:
    print(""First"")

"
"N = int(input())

s = [None] * N
l, c, r = 0, N//2, N-1

while True:
    for i in (l, c, r):
        if s[i] == None:
            print(i, flush=True)
            s[i] = input()
            if s[i] == 'Vacant':
                exit()
    if ((c-l)%2==0 and s[l]!=s[c]) or ((c-l)%2 and s[l]==s[c]):
        r = c
        c = (l + r) // 2
    else:
        l = c
        c = (l + r) // 2
"
"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

n, k = map(int, input().split())
a = list(map(int, input().split()))
m = max(a)
for i in range(1, n):
    a[i] = gcd(a[i], a[i - 1])
print(""POSSIBLE"" if k % a[n - 1] == 0 and k <= m else ""IMPOSSIBLE"")"
"n = int(input())

a = sorted(list(map(int, input().split())))

x = 1

for i in range(n):
    x = x * a[i]
    if x == 0:
        break
    elif x > 10 ** 18:
        x = -1
        break

print(x)
"
"N, M = map(int, input().split())
S = [0] + list(map(int, input().split()))
T = [0] + list(map(int, input().split()))
mod = 10**9 + 7

dp = [[0] * (M+1) for i in range(N+1)]
dp_sum = [[0] * (M+1) for i in range(N+1)]

for i in range(1, N+1):
    for j in range(1, M+1):
        if S[i] == T[j]:
            dp_sum[i][j] = dp_sum[i][j-1] + dp_sum[i-1][j] + 1
        else:
            dp_sum[i][j] = dp_sum[i][j-1] + dp_sum[i-1][j] - dp_sum[i-1][j-1]
        dp_sum[i][j] %= mod

print((dp_sum[N][M]+1) % mod)
"
"a,b = map(int,input().split())

if a > 0 and b > 0:
    print(""Positive"")
elif a <= 0 and b >= 0:
    print(""Zero"")
elif a < 0 and b < 0:
    if ((b-a)-1) % 2  != 0:
        print(""Negative"")
    else:
        print(""Positive"")"
"def ind(S):
  L4=list()
  for i in range(len(S)):
    if S[len(S)-i-1]==""1"":
      L4.append(i)
  return set(L4)
N=int(input())
L=list(map(int,input().split()))
L=[ind(bin(i)[2:]) for i in L]
ans=0
n=0
i=0
T=set()
while True:
  if i==N and n==N:
    break
  elif i==N:
    ans+=i-n
    n+=1
    continue
  if T&L[i]==set():
    T=T|L[i]
    ans+=1
    i+=1
  else:
    T=T-L[n]
    n+=1
    ans+=i-n
  if i==N and n!=N:
    n+=1
print(ans)"
"nums = list(map(int, input().split()))
print(nums.index(0)+1)"
"#!/usr/bin/env python3
_, _, *s = open(0).read().split()
s.sort()
print(*s, sep="""")
"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

abc = list(map(int, readline().split()))
abc.sort()

ans = abc[2]-abc[1]
res = abc[1]-abc[0]
if res % 2 == 0:
    ans += res // 2
else:
    ans += res // 2 + 2

print(ans)"
"#coding: UTF-8

l = raw_input()

a = int(l)
x = 1

while a != 0:
	print ""Case %d: %d"" %(x,a)
	x += 1

	l = raw_input()
	a = int(l)
	if l == 0:
		print ""end"""
"import sys
## io ##
def IS(): return sys.stdin.readline().rstrip()
def II(): return int(IS())
def MII(): return list(map(int, IS().split()))
from itertools import accumulate
from collections import Counter
#======================================================#
def main():
    n = II()
    cum = list(accumulate([0]+MII()))
    cnt = [n for n in Counter(cum).values() if n > 1]
    ans = sum([(n*(n-1))//2 for n in cnt])
    print(ans)

if __name__ == '__main__':
    main()"
"def main():
    n, k = map(int, input().split())
    if k == 1:
        print(0)
    else:
        print(n-k)


if __name__ == '__main__':
    main()"
"n = int(input())

cnt_ac = 0
cnt_wa = 0
cnt_tle = 0
cnt_re = 0

for i in range(n):
    s = input()
    if s == 'AC':
        cnt_ac += 1
    elif s == 'WA':
        cnt_wa += 1
    elif s == 'TLE':
        cnt_tle += 1
    elif s == ""RE"":
        cnt_re += 1

print('AC x ', cnt_ac)
print('WA x ', cnt_wa)
print('TLE x ', cnt_tle)
print('RE x ', cnt_re)


"
"import numpy as np

def solve(H, W, M, h, w):
    f = [0] * (H+1)
    g = [0] * (W+1)
    for r, c in zip(h, w):
        f[r] += 1
        g[c] += 1
    p = np.max(f)
    q = np.max(g)
    num = len(list(filter(p.__eq__, f))) * len(list(filter(q.__eq__, g)))
    for r, c in zip(h, w):
        if (f[r] == p) and (g[c] == q):
            num -= 1
    return p + q - (num <= 0)

H, W, M = map(int, input().split())
h, w = zip(*[map(int, input().split()) for i in range(M)])
print(solve(H, W, M, h, w))"
"K, A, B = map(int, input().split())
if A >= B - 1 or K <= A - 1:
    print(1 + K)
else:
    r = K - (A - 1)
    print(r // 2 * (B - A) + A + r % 2)"
"import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy

A, B = map(int, input().split())

print(""Possible"" if len(list(filter(lambda x: x % 3 == 0, [A, B, A + B]))) > 0 else ""Impossible"")"
"N, X, M = map(int, input().split())

existence = [False] * M
a = []
A = X
for i in range(N):
    if existence[A]:
        break
    existence[A] = True
    a.append(A)
    A = A * A % M

for i in range(len(a)):
    if a[i] == A:
        loop_start = i
        break
else:
    loop_start = len(a)

result = sum(a[:loop_start])
N -= loop_start
if N != 0:
    a = a[loop_start:]
    loops = N // len(a)
    remainder = N % len(a)
    result += sum(a) * loops + sum(a[:remainder])
print(result)
"
"s = input()
first = s[0]
end = s[len(s)-1]
print(first+str(len(s)-2)+end)
"
"# 3つリストを作って、各頭文字をくっつけた略語をアッパー

s1, s2, s3 = map(list, input().split())
# print(s1)
# print(s2)
# print(s3)

abbreviation = s1[0] + s2[0] + s3[0]
# print(abbreviation)

print(abbreviation.upper())
"
"h, w = map(int, input().split())
if h == 1 or w == 1:
    print(1)
else:
    print((-(-w//2)) * (-(-h//2)) + (w//2) * (h//2))
"
"l,r=map(int,input().split())
s=10000
for i in range(l,r+1):
    if i%2019==0:
        s=0
        break
    elif (i%673==0 and r-l!=1) or (i%673==0 and (r%3==0 or l%3==0)):
        s=0
        break
if s==0:
    print(0)
else:
    t=10000
    for i in range(l,r):
        for j in range(i+1,r+1):
            if ((i%2019)*(j%2019))%2019<t:
                t=((i%2019)*(j%2019))%2019
    print(t)"
"n=int(input())
h=list(map(int,input().split()))
ans=""Yes""
for i in range(n-1):
  if h[i]<h[i+1]:
    h[i+1]-=1
  if h[i]>h[i+1]:
    ans=""No""
    break
  
print(ans)"
"import sys
from collections import Counter
N = int(input())
D = Counter(map(int, input().split()))

M = int(input())

for t in map(int, input().split()):
    if t in D:
        if D[t] > 0:
            D[t] -= 1
        else:
            print(""NO"")
            exit()
    else:
        print(""NO"")
        exit()

print(""YES"")

"
"N,K=map(int,input().split())
if N==K:
  print(0)
elif K==1:
  print(0)
else:
  print(N-K)"
"N = int(input())
A = input()
B = input()
C = input()
ans = 0
for x, y, z in zip(A, B, C):
    x, y, z = sorted([x, y, z])
    if x != y and y != z:
        ans += 2
    elif x == y and y != z:
        ans += 1
    elif x != y and y == z:
        ans += 1
print(ans)"
"#print("" "",sep='',end='')
s=input().split()
a=int(s[0])
b=int(s[1])
c=int(s[2])

if b-a==c-b:
    print(""YES"")
else :
    print(""NO"")"
"_, k = map(int, input().split())
l = [int(x) for x in input().split()]
l.sort()
print(sum(l[-k:]))"
"N, K = map(int, input().split())
ls = list(map(int, input().split()))
ans = 0

for i in range(K):
  M = max(ls)
  index = ls.index(M)
  ls[index] = 0
  ans+= M
  
print(ans)"
"a,b,c=(int(x) for x in input().split())
ireru=a-b#cが入れる量
if (c-ireru<0):
    print(0)
else:
    print(c-ireru)"
"k,a,b=map(int,input().split())


bisket=1

cnt=a-bisket

if cnt>k:
    print(1+k)
    exit(0)

k-=cnt
bisket+=cnt

if a+2<=b:
    trade=k//2
    k-=trade*2
    
    bisket+=trade*(b-a)

    if k==1:
        bisket+=1
    
    print(bisket)


else:
    print(bisket+k)"
"h,w = map(int,input().split())
l=[]
[l.append(input()) for _ in range(h)]

print(""#""*(w + 2))
for s in l:
    print(""#"",s,""#"",sep='')

print(""#""*(w + 2))"
"def is_win(n,k):
	dp=[False]*(k+1)
	for i in range(k+1):
		for j in range(n):
			if i-arr[j]>=0 and dp[i-arr[j]]==False:
				dp[i]=True
				break

	return dp[k]
	

# with open ('input.txt') as f :
n,k=map(int,input().split())
arr=list(map(int,input().split()))
res=is_win(n,k)
print('First' if res else 'Second')

# 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99"
"a,b,x = map(int,input().split())
print(""YES"" if a+b >= x and a <= x else ""NO"")"
"class UnionFind():
    """"""
        unionfindtree のクラス
            グループを管理するデータ構造.
            全てのメソッドの計算量が O(log(n)) よりも小さい
        init: 管理対象の個数 n を用いて初期化
        find: ある要素 x の親がどの要素か返す
        union: ある要素 x と y が属しているグループを結合して1つのグループとする
        msize: ある要素 x が属するグループの大きさを返す
    """"""
    def __init__(self, n):
        self.n = n
        self.parents = [-1]*n
        self.rank = [0]*n
        self.size = [1]*n

    def find(self, x):
        """"""
            ある要素 x の親の要素を見つけるメソッド
        """"""
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
    
    def union(self, x, y):
        """"""
            ある要素 x, y の属するグループを結合するメソッド
            x と y のランク(子の数)の小さい方が結合先の親となる
        """"""
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.rank[x] < self.rank[y]:
            self.size[y] += self.size[x]
            self.parents[x] = y
        else:
            self.size[x] += self.size[y]
            self.parents[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def msize(self, x):
        """"""
            ある要素 x の属するグループの大きさを返すメソッド
        """"""
        return self.size[self.find(x)]
    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]
    def group_count(self):
        return len(self.roots())


def main():
    N, Q = map(int, input().split())
    uf = UnionFind(N)
    for _ in range(Q):
        u, v = map(int, input().split())
        uf.union(u-1, v-1)
    print(uf.group_count()-1)   
if __name__ == ""__main__"":
    main()
"
"n=int(input())
t=list(str(n))
cnt=0
for i in range(1,len(t)):
  if t[i]==""9"":
    cnt=cnt+1
if cnt==len(t)-1:
  print(int(t[0])+9*cnt)
else:
  print(int(t[0])-1+9*(len(t)-1))"
"a, b, c = input().split()
x = [a, b, c]
x = [int(i) for i in x]
x.sort()
print(int((int(x[0])*int(x[1]))/2))"
"N = int(input())
d_list = list(map(int,input().split()))

ans = 0
for i in range(N-1):
    for j in range(i+1,N):
        ans += d_list[i] * d_list[j]

print(ans)
"
"
def s0():return input()
def s1():return input().split()
def s2(n):return [input() for x in range(n)]
def s3(n):return [input().split() for _ in range(n)]
def n0():return int(input())
def n1():return [int(x) for x in input().split()]
def n2(n):return [int(input()) for _ in range(n)]
def n3(n):return [[int(x) for x in input().split()] for _ in range(n)]
def t3(n):return [tuple(int(x) for x in input().split()) for _ in range(n)]
def p0(b,yes=""Yes"",no=""No""): print(yes) if b else print(no)
# from collections import Counter,deque,defaultdict
# import itertools
# import math
# import networkx
# from bisect import bisect_left,bisect_right
n=n0()
a=[0]
a.extend(n1())

b=[0]
b.extend(n1())
c=[0]
c.extend(n1())

ans=0
for i in range(1,n+1):
    ans+=b[a[i]]
    if i<n:
        if a[i]+1==a[i+1]:
            ans+=c[a[i]]
print(ans)"
"# coding: utf-8
import sys

sr = lambda: sys.stdin.readline().rstrip()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

X, Y, Z = lr()
print(Z, X, Y)
"
"N = int(input())

ans = 0

for i in range(N):
    ans += i + 1
print(ans)"
"INF=float('inf')

n=int(input())
P=list(map(float,input().split()))#0

dp=[[0 for i in range(n+1)] for j in range(n+1)]

for i in range(n+1):
  if i==0:
    dp[0][0]=1
  else:
    dp[i][0]=(1-P[i-1])*dp[i-1][0]

    
for j in range(1,n+1):
  for i in range(1,n+1):
    if i<j:
      continue
    dp[i][j]=P[i-1]*(dp[i-1][j-1])+(1-P[i-1])*(dp[i-1][j])

ans=0
for i in range(1,n+1):
  if i>=(n+1)//2:
    ans+=dp[n][i]
    
print(ans)"
"def solve():
  N = int(input())
  A = [int(input()) for _ in range(N)]
  ans = sum(A)
  if ans%10!=0:
    return ans
  A.sort()
  for i in range(N):
    if A[i]%10!=0:
      return ans-A[i]
  return 0
print(solve())"
"# C - Attack Survival
N,K,Q = map(int,input().split())
P = [0]*N
for _ in range(Q):
    A = int(input())
    P[A-1] += 1
for p in P:
    print('Yes' if K-Q+p>0 else 'No')"
"for i in xrange(1,10):
    for j in xrange(1,10):
        print '%sx%s=%s'%(i,j,i*j)"
"N = int(input())
A = [int(input()) for _ in range(N)]


ans = 0
cnt = 0
for i in range(N):
    if A[i] != 0:
        ans += (A[i]+cnt)//2
        cnt = (A[i]+cnt)%2
    else:
        cnt = 0
print(ans)"
"import numpy as np
N, A, B = map(int, input().split())
h = np.sort([int(input()) for i in range(N)])

def enough(A, B, h, T):
    h = np.ceil((h - B * T) / (A - B))
    count = sum(h[h > 0])
    
    return True if count <= T else False
right = 10 ** 9
left = 1
while right != left:
    mid = (left + right) // 2
    if enough(A, B, h, mid):
        right = mid
    else:
        left = mid + 1

print(left)"
"def main():
    N, M, *A = map(int, open(0).read().split())

    C = [0, 1, 4, 4, 3, 4, 5, 2, 6, 5]

    dp = [0] * N + [-1] * 6
    for i in range(N):
        dp[i + 1] = max(dp[i - C[a]] * 10 + a for a in A)

    print(dp[N])

if __name__ == '__main__':
    main()"
"def gcd(m, n):
    r = m % n
    return gcd(n, r) if r else n

def lcm(m, n):
    return m//gcd(m, n)*n
MOD = 10**9+7
n = int(input())
a = list(map(int, input().split()))
l = a[0]
for x in a:
    l = lcm(x, l)
ans = 0
for x in a:
    ans += l*pow(x, MOD-2, MOD)%MOD
print(ans%MOD)
"
"n = int(input())
h = list(map(int,input().split()))
t = [0 for _ in range(n)]
memo = h[0]
for i in range(n-1):
	if memo >= h[i+1]:
		t[i+1] += t[i]+1
		memo = h[i+1]
	else:
		memo = h[i+1]
print(max(t))"
"i = 1
n = 1
while n != 0:
	n = int(raw_input())
	if n == 0:
		continue
	print ""Case %d: %d"" %(i, n)
	i += 1"
"import sys

def input():
  return sys.stdin.readline()


N,K = map(int,input().split())
A=list(map(int,input().split()))
P=[True]*N
P[0]=False
i,a=1,0
while 1:
  a+=1
  if P[A[i-1]-1]:
    P[A[i-1]-1]=False
    i=A[i-1]
  else:
    i=A[i-1]
    break
if a>=K:
  i=1
  for _ in range(K):
    i=A[i-1]
  print(i)
else:
  K-=a
  a,j=0,i
  while 1:
    a+=1
    if A[j-1]==i:
      break
    j=A[j-1]
  K%=a
  for _ in range(K):
    i=A[i-1]
  print(i)"
"n,m=map(int,input().split())
mod=10**9+7
dp=[1]*(n+1)
for _ in range(m):
  dp[int(input())]=0
dp[1]*=dp[0]
for i in range(2,n+1):
  dp[i]*=dp[i-1]+dp[i-2]
print(dp[-1]%mod)"
"n = int(input())

data = [list(map(int, input().split())) for _ in range(n)]
data.sort(key=lambda x: x[1])

time = 0
for a, b in data:
    time += a
    if (time > b):
        print('No')
        exit()
    else:
        pass

print('Yes')
"
"n=int(input())
a=list(map(int,input().split()))
b=sum(a)
ans=[0]*n
for i in range(n//2):
    ans[(i+1)*2]=ans[i*2]-(2*(a[i*2]-a[i*2+1]))
ans[1]=ans[-1]-(2*(a[-1]-a[0]))
for i in range(1,n//2):
    ans[i*2+1]=ans[(i-1)*2+1]-(2*(a[(i-1)*2+1]-a[i*2]))
c=(b-sum(ans))//n
ans2=[0]*n
for i in range(n):
    ans2[i]=c+ans[i]
print(*ans2)
"
"def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]
def input():
    return sys.stdin.readline().rstrip()
def rand_N(ran1, ran2):
    return random.randint(ran1, ran2)
def rand_List(ran1, ran2, rantime):
    return [random.randint(ran1, ran2) for i in range(rantime)]
def rand_ints_nodup(ran1, ran2, rantime):
  ns = []
  while len(ns) < rantime:
    n = random.randint(ran1, ran2)
    if not n in ns:
      ns.append(n)
  return sorted(ns)

def rand_query(ran1, ran2, rantime):
  r_query = []
  while len(r_query) < rantime:
    n_q = rand_ints_nodup(ran1, ran2, 2)
    if not n_q in r_query:
      r_query.append(n_q)
  return sorted(r_query)

from collections import defaultdict, deque, Counter
from sys import exit
from decimal import *
import heapq
import math
from fractions import gcd
import random
import string
import copy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce
from bisect import bisect_left, bisect_right

import sys
sys.setrecursionlimit(1000000000)
mod = 10 ** 9 + 7

#############
# Main Code #
#############

N = getN()
A = getArray(N)

cnt = 0
for i in range(N - 1):
    # 一つから
    p = A[i] // 2
    cnt += p
    A[i] -= p * 2

    # 二つから
    u = min(A[i], A[i + 1])
    cnt += u
    A[i] -= u
    A[i + 1] -= u

p = A[-1] // 2
cnt += p
A[-1] -= p * 2
print(cnt)"
"MOD = 10 ** 9 + 7
n = int(input())
c = [int(input()) for _ in range(n)]
l = [c[0]]
for i in range(1, n):
    if c[i] != c[i - 1]:
        l.append(c[i])
n = len(l)
p = [-1] * (max(c) + 1)
q = [-1] * n
for i, x in enumerate(l[::-1]):
    q[n - i - 1] = p[x]
    p[x] = n - i - 1
dp = [0] * (n + 1)
dp[0] = 1
for i in range(n):
    dp[i + 1] += dp[i]
    if q[i] != -1:
        dp[q[i] + 1] += dp[i + 1]
print(dp[n] % MOD)
"
"def get_sieve_of_eratosthenes_new(n):
    import math
    if not isinstance(n, int):
        raise TypeError('n is int type.')
    if n < 2:
        raise ValueError('n is more than 2')
    prime = []
    limit = math.sqrt(n)
    data = [i + 1 for i in range(1, n)]
    while True:
        p = data[0]
        if limit <= p:
            return prime + data
        prime.append(p)
        data = [e for e in data if e % p != 0]

primelist=get_sieve_of_eratosthenes_new(55555)

N=int(input())
ans=[]
count=0
i=0
while count<N:
    if primelist[i]%5==1:
        ans.append(primelist[i])
        count+=1
    i+=1
print(*ans)
"
"def read_a(n, m):
    A = []
    for _ in range(0, n):
        A.append([int(x) for x in input().split()])

    return A

def read_b(m):
    B = []
    for _ in range(0, m):
        B.append(int(input()))

    return B

def multiply(A, B):
    C = []
    for a in A:
        C.append(sum(map(lambda x, y:x*y, a, B)))

    return C

def main():
    n, m = [int(x) for x in input().split()]

    A = read_a(n, m)
    B = read_b(m)
    C = multiply(A, B)

    print(""\n"".join([str(x) for x in C]))

if __name__ == '__main__':
    main()

"
"from fractions import gcd
from datetime import date, timedelta
from heapq import*
import math
from collections import defaultdict, Counter, deque
import sys
from bisect import *
import itertools
import copy
sys.setrecursionlimit(10 ** 7)
MOD = 10 ** 9 + 7


def main():
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    
    ans = 0
    ruiseki = [0]
    d = defaultdict(int)
    d[0]=1
    for i in range(n):
        if i - k + 1>= 0:
            d[ruiseki[i - k+1]]-=1
        ruiseki.append((ruiseki[i] + a[i] - 1)%k)
        ans += d[ruiseki[i+1]]
        d[ruiseki[i + 1]] += 1
    print(ans)


if __name__ == '__main__':
    main()
"
"n = int(input())
a = list(map(int,input().split())) 
b = list(map(int,input().split())) 
c = list(map(int,input().split())) 


 
b_sum = sum(b) 


for i in range(0,n-1) :
	if a[i]+1 == a[i+1] :
		b_sum = c[a[i]-1]+b_sum 

print(b_sum) 

"
"import sys

sys.setrecursionlimit(10 ** 8)
ini = lambda: int(sys.stdin.readline())
inl = lambda: [int(x) for x in sys.stdin.readline().split()]
ins = lambda: sys.stdin.readline().rstrip()


def solve():
    x = ini()
    lb, ub = 0, 0
    while lb <= x:
        if lb <= x <= ub:
            return True
        lb += 100
        ub += 105
    return False


print(1 if solve() else 0)
"
"N = int(input())
S = []
T = []
for _ in range(N):
    s, t = input().split()
    S.append(s)
    T.append(int(t))
X = input()

time = None
for s, t in zip(S, T):
    if s == X:
        time = 0
    elif time is not None:
        time += t
    else:
        continue

print(time)
"
"a,b=map(int,input().split())
if a<b:
  print(str(a)*b)
else:
  print(str(b)*a)"
"N = int(input())
A, B = map(int, input().split())
P = list(map(int, input().split()))
cnt = [0, 0, 0]
for p in P:
    if p <= A:
        cnt[0] += 1
    elif p <= B:
        cnt[1] += 1
    else:
        cnt[2] += 1
print(min(cnt))"
"def resolve():
    N, M = list(map(int, input().split()))
    SC = [list(map(int, input().split())) for _ in range(M)]
    value = [None for _ in range(N)]
    for s, c in SC:
        if not (value[s-1] is None or value[s-1] == c):
            print(-1)
            return
        value[s-1] = c
    for i in range(N):
        if value[i] is None:
            if i == 0:
                if N > 1:
                    value[i] = 1
                else:
                    value[i] = 0
            else:
                value[i] = 0
    if N > 1 and value[0] == 0:
        print(-1)
    else:
        print("""".join(map(str, value)))


if '__main__' == __name__:
    resolve()"
"#from collections import deque,defaultdict
printn = lambda x: print(x,end='')
inn = lambda : int(input())
inl   = lambda: list(map(int, input().split()))
inm   = lambda:      map(int, input().split())
ins = lambda : input().strip()
DBG = True # and False
BIG = 10**18
R = 10**9 + 7

def ddprint(x):
  if DBG:
    print(x)

n = inn()
a = inl()
b = inl()
ia = ib = 0
for i in range(n):
    if a[i]>b[i]:
        ib += a[i]-b[i]
    elif a[i]<b[i]:
        d = b[i]-a[i]
        if d%2==0:
            ia += d//2
        else:
            ia += (d+1)//2
            ib += 1
print('Yes' if ia>=ib else 'No')
"
"S = input()
b = 1
B = 0
for i in S:
  if i != str(b):
    B += 1
  b = 1 - b
l = len(S)
print(min(B, l - B))"
"line = input()
A,B,C = [int(n) for n in line.split()]
print(min(B//A,C))"
"n,m = map(int, input().split())
# x,y,z=[],[],[]
xyz = []
for _ in range(n):
    a,b,c = map(int, input().split())
    xyz.append((a,b,c))

ans = 0
for i in range(8):
    a,b,c = (-1)**(i&4 > 0), (-1)**(i&2 > 0), (-1)**(i&1 > 0)
    xyz.sort(key=lambda x:a*x[0] + b*x[1] + c*x[2], reverse=True)
    x,y,z=0,0,0
    for i in range(m):
        a,b,c = xyz[i]
        x += a
        y += b
        z += c
    tmp = abs(x) + abs(y) + abs(z)
    #print(tmp, ans)
    if ans < tmp:
        ans = tmp
print(ans)
"
"
def s0():return input()
def s1():return input().split()
def s2(n):return [input() for x in range(n)]
def s3(n):return [input().split() for _ in range(n)]
def s4(n):return [[x for x in s] for s in s2(n)]
def n0():return int(input())
def n1():return [int(x) for x in input().split()]
def n2(n):return [int(input()) for _ in range(n)]
def n3(n):return [[int(x) for x in input().split()] for _ in range(n)]
def t3(n):return [tuple(int(x) for x in input().split()) for _ in range(n)]
def p0(b,yes=""Yes"",no=""No""): print(yes if b else no)
# from sys import setrecursionlimit
# setrecursionlimit(1000000)
# from collections import Counter,deque,defaultdict
# import itertools
# import math
# import networkx as nx
# from bisect import bisect_left,bisect_right
# from heapq import heapify,heappush,heappop

x,y,a,b,c=n1()
P=n1()
Q=n1()
R=n1()

P.sort()
Q.sort()

A=P[-x:]+Q[-y:]+R

A.sort()
print(sum(A[-x-y:]))"
"s = input()

if 1 <= int(s[2:4]) <= 12 and 1 <= int(s[0:2]) <= 12:
    print('AMBIGUOUS')
elif 1 <= int(s[2:4]) <= 12:
    print('YYMM')
elif 1 <= int(s[0:2]) <= 12:
    print('MMYY')
else:
    print('NA')"
"import sys
input=sys.stdin.readline

class list2D:
    def __init__(self, H, W, num):
        self.__H = H
        self.__W = W
        self.__dat = [num] * (H * W)

    def __getitem__(self, a):
        return self.__dat[a[0]*self.__W+a[1]]

    def __setitem__(self, a, b):
        self.__dat[a[0]*self.__W+a[1]] = b

    def debug(self):
        print(self.__dat)

class list3D:
    def __init__(self, H, W, D, num):
        self.__H = H
        self.__W = W
        self.__D = D
        self.__X = W * D
        self.__dat = [num] * (H * W * D)

    def __getitem__(self, a):
        return self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]]

    def __setitem__(self, a, b):
        self.__dat[a[0]*self.__X+a[1]*self.__D + a[2]] = b

    def debug(self):
        print(self.__dat)

def main():
    r,c,k=map(int,input().split())
    v = list2D(r, c, 0)

    for _ in range(k):
        ri,ci,a=map(int,input().split())
        v[ri-1, ci-1] = a

    dp = list3D(r, c, 4, 0)
    #print(dp)
    if v[0, 0]>0: dp[0, 0, 1]=v[0, 0]

    for i in range(r):
        for j in range(c):
            val = v[i, j]
            if i>0:
                x = max(dp[i-1, j, 0], dp[i-1, j, 1], dp[i-1, j, 2], dp[i-1, j, 3])
                dp[i, j, 1]=max(dp[i, j, 1],x+val)
                dp[i, j, 0]=max(dp[i, j, 0],x)

            if j>0:
                X = dp[i, j-1, 0]
                Y = dp[i, j-1, 1]
                V = dp[i, j-1, 2]
                Z = dp[i, j-1, 3]
                dp[i, j, 0]=max(dp[i, j, 0],X)
                dp[i, j, 1]=max(dp[i, j, 1],X+val,Y)
                dp[i, j, 2]=max(dp[i, j, 2],Y+val,V)
                dp[i, j, 3]=max(dp[i, j, 3],V+val,Z)

    #print(dp)
    ans=0
    for i in range(4): ans=max(dp[r-1, c-1, i],ans)
    return print(ans)
if __name__==""__main__"":
    main()
"
"from itertools import combinations
N = int(input())
L = sorted(map(int, input().split()))
ans = 0
for a, b, c in combinations(L, 3):
    if a < b < c and a + b > c:
        ans += 1
print(ans)
"
"'''
Created on 2020/08/31

@author: harurun
'''
def main():
  import sys
  pin=sys.stdin.readline
  pout=sys.stdout.write
  perr=sys.stderr.write

  N=int(pin())
  ans=""""
  while N:
    N-=1
    ans+=chr(97+N%26)
    N=N//26
  print(ans[::-1])
  return
main()
#解説AC"
"N,M,K = map(int, input().split())

mod = 10**9+7
a = 1
b = 1
for i in range(min(K-2, N*M-K)):
    a *= (N*M-2-i)
    a %= mod
    b *= i+1
    b %= mod
comb = a * pow(b, mod - 2, mod) % mod

ans = (((N*N*(N+1)//2-N*(N+1)*(2*N+1)//6)*M**2 + (M*M*(M+1)//2-M*(M+1)*(2*M+1)//6)*N**2)*comb)%mod
print(ans)"
"R=int(input())
print(""A""+""RGB""[(R>=2800)+2*(R<1200)]+""C"")"
"n = input()
s = list(map(int, input().split()))
nn = input()
t = list(map(int, input().split()))
t_and_s = len(set(s) & set(t))
print(t_and_s)"
"S = list(input())
N = len(S)

if N % 2 == 0:
    m = int(N/2)
    LS = S[:m]
    RS = S[N:m-1:-1]
    ans = 0
    for i in range(m):
        if LS[i] == RS[i]:
            pass
        else:
            ans += 1
else:
    m = int((N+1)/2)
    LS = S[:m-1]
    RS = S[N:m-1:-1]
    ans = 0
    for i in range(m-1):
        if LS[i] == RS[i]:
            pass
        else:
            ans += 1

print(ans)"
"N = int(input())
D = set(int(input()) for T in range(N))
print(len(D))"
"N = int(input())
MOD = 10**9 + 7

ans = pow(10, N, MOD) - 2*pow(9, N, MOD) + pow(8, N, MOD)
ans %= MOD

print(ans)"
"import sys, re, os
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, acos, atan, asin, log, log10
from itertools import permutations, combinations, product, accumulate, combinations_with_replacement
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from fractions import gcd
def debug(*args):
    if debugmode:
        print(*args)
def input(): return sys.stdin.readline().strip()
def STR(): return input()
def INT(): return int(input())
def FLOAT(): return float(input())
def MAP(): return map(int, input().split())
def S_MAP(): return map(str, input().split())
def LIST(): return list(map(int, input().split()))
def S_LIST(): return list(map(str, input().split()))
def lcm(a, b): return a * b // gcd(a, b)
sys.setrecursionlimit(10 ** 9)
inf = sys.maxsize
mod = 10 ** 9 + 7
dx = [0, 1, 0, -1, 1, -1, -1, 1]
dy = [1, 0, -1, 0, 1, -1, 1, -1]
debugmode = True

n = INT()
f = [LIST() for _ in range(n)]
p = [LIST() for _ in range(n)]

def func(i, arr):
    if i == 10:
        if sum(arr) == 0:
            return -inf
        pp = 0
        for i in range(n):
            cnt = 0
            for j in range(10):
                if arr[j] == 1 and f[i][j] == 1:
                    cnt += 1
            pp += p[i][cnt]
        return pp
    tmp = deepcopy(arr)
    tmp[i] = 1
    return max(func(i + 1, arr), func(i + 1, tmp))

print(func(0, [0 for _ in range(10)]))

"
"import sys
from itertools import groupby
def input(): return sys.stdin.readline().rstrip()


def main():
    S=list(input())
    ans=[0]*(len(S))
    index=0
    for key, value in groupby(S):
        le=len(list(value))
        if key=='L':
            ans[index]+=(le+1)//2
            ans[index-1]+=le//2
        else:
            ans[index+le]+=le//2
            ans[index+le-1]+=(le+1)//2
        index+=le
    print(*ans, sep="" "")
    


if __name__ == '__main__':
    main()"
"n = int(input())
a= list(map(int,input().split()))

b= list(map(lambda x:1/x, a))

print(1/sum(b))"
"import sys
from collections import defaultdict

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10 ** 8)
INF = float('inf')
MOD = 10 ** 9 + 7


def main():
    N = int(readline())
    title = defaultdict(int)
    cumsum = [0]
    for i in range(1, N + 1):
        s, t = readline().strip().decode('utf-8').split()
        title[s] = i
        cumsum.append(cumsum[-1] + int(t))
    X = readline().decode('utf-8').strip()
    ans = cumsum[-1] - cumsum[title[X]]
    print(ans)


if __name__ == '__main__':
    main()
"
"n = int(input())
c = input()
cnt = [0 for _ in range(n)]
red = 0
for i in range(n):
    if c[i] == 'R':
        red += 1
    cnt[i] = red
print(red - cnt[red-1])
"
"D=int(input())
print('Christmas' if D==25 else 'Christmas Eve' if D==24 else 'Christmas Eve Eve' if D==23 else 'Christmas Eve Eve Eve')"
"n = int(input())
h = [int(i) for i in input().split()]
max_cnt, cnt = 0, 0
for i in range(n - 1):
    if h[i] >= h[i + 1]:
        cnt += 1
    else:
        cnt = 0
    max_cnt = max(max_cnt, cnt)
print(max_cnt)"
"s = input().split('T')
dx = list(map(len, s[0::2]))
dy = list(map(len, s[1::2]))
x, y = map(int, input().split())

def check(start, ds, goal):
    cands = {start}
    for d in ds:
        new_cands = set()
        for c in cands:
            new_cands.add(c - d)
            new_cands.add(c + d)
        cands = new_cands
    return goal in cands

x_ok = check(dx[0], dx[1:], x)
y_ok = check(0, dy, y)

print('Yes' if x_ok and y_ok else 'No')
"
"import sys
import numpy as np
input = sys.stdin.buffer.readline
N = int(input())
A = np.array(list(map(int, input().split())))

B = np.array([0] * N)
for i in range(len(A), 0, -1):
    v = B[2 * i - 1::i].sum() % 2
    if A[i - 1] != v:
        B[i - 1] = 1
# print(f'{B=}')

M = B.sum()
print(M)
idx = np.where(B == 1)[0] + 1
print(*idx, sep=' ')
"
"import math
inf = float('inf')

n, t = map(int, input().split())
c_t = [list(map(int, input().split())) for i in range(n)]

min_c = inf
for i in c_t:
    if i[1] <= t:
        min_c = min(min_c, i[0])

if min_c == inf:
    print(""TLE"")
else:
    print(min_c)"
"s=input()
t=input()

S=[]
T=[]
for a in s:
    S.append(a)
for a in t:
    T.append(a)
S.sort()
T.sort(reverse=True)


s2=0
t2=0
ans=""No""
for i in range(min(len(S),len(T))):
    s2=s2*256+ord(S[i])
    t2=t2*256+ord(T[i])
if s2<t2 :
    ans=""Yes""
elif s2==t2 :
    if len(s)<len(t) :
        ans=""Yes""
print(ans)"
"M,D = map(int,input().split())
count = 0
for i in range(1,M+1):
  for j in range(1,D+1):
    if j >21:
      a = j//10
      b = j%10
      if i == int(a*b) and a>=2 and b>=2:
        
        count += 1
print(count)"
"def examD():
    N, T =LI()
    A = LI()
    maXI = [0]*N
    maXI[N-1] = A[N-1]
    for i in range(1,N):
        maXI[N-i-1] = max(maXI[N-i],A[N-i-1])
    maXAD = int(0)
    for i in range(N-1):
        maXAD = max(maXAD,maXI[i+1]-A[i])
    cur = int(0)
    for i in range(N-1):
        if maXI[i+1]-A[i]==maXAD:
            cur +=1
    print(cur)



import sys
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def S(): return sys.stdin.readline().strip()
mod = 10**9 + 7
inf = float('inf')

examD()
"
"import sys
input = sys.stdin.readline
# warshall_floyd法
def warshall_floyd(d,n):
 for k in range(n):
  for i in range(n):
   for j in range(n):
    d[i][j]= min(d[i][j],d[i][k]+d[k][j])
 return d

H,W = map(int,input().split())
# 隣接行列の定義、初期化
# ①コスト(存在しないときはinf)
d = [0 for i in range(10)]
# ②自分自身へのコストは０
for i in range(10):
 d[i] = list(map(int,input().split()))
ct=[0]*11
for i in range(H):
  lst=list(map(int,input().split()))
  for j in range(W):
   ct[lst[j]+1]+=1

A=warshall_floyd(d,10)
ans=0
for i in range(10):
 ans+=ct[(i+1)]*A[i][1]
print(ans)
"
"#B問題
import math
K = int(input())
A = list(map(int,input().split()))
B = A[::-1]

MIN = 0
MAX = 0
flag = 0
for i in range(K):
    if i == 0:
        if B[i] != 2:
            flag = 1
            break
        else:
            MIN = 2
            MAX = 3
    else:
        if MAX < B[i]:
            flag = 1
            break
        else:
            MAX = (MAX//B[i] + 1)*B[i]-1
            MIN = math.ceil(MIN/B[i])*B[i]
            if MAX < MIN:
                flag = 1
                break
if flag == 1:
    print(-1)
else:
    print(MIN,MAX)"
"N = int(input())
AB = [list(map(int, input().split())) for _ in range(N-1)]

child = [[] for _ in range(N+1)]
par = [0]*(N+1)

for ab in AB:
    a,b = ab[0], ab[1]
    child[a].append(b)
    par[b] = a

k = 0
for i in range(1,N+1):
    l = len(child[i])
    if par[i] > 0:
        l += 1
    k = max(k, l)

print(k)#Maxの数

col = [0] * (N+1)
col[1] = 1
for i in range(1, N):
    cnt = 0
    for c in child[i]:
        cnt += 1
        col[c] = (col[i] + cnt) % k #k以下のものを順番に割り当てていく

for ab in AB:
    b = ab[1]
    print(col[b] + 1)"
"H, W, K = map(int, input().split())
s = ['' for i in range(H)]
for i in range(H):
    s[i] = input()
now = 1
ans = [[] for i in range(H)]
count = 0
flag = False
for i in range(H):
    gokei = s[i].count('#')
    shap = 0
    if gokei >= 1:
        flag = True
        for j in range(W):
            ans[i].append(now)
            if j == W-1:
                now += 1
            elif s[i][j] == '#' and shap < gokei-1:
                now += 1
                shap += 1
            elif s[i][j] == '#' and shap == gokei-1:
                shap += 1
    elif gokei == 0 and flag:
        ans[i] = ans[i-1]
    elif gokei == 0 and flag == False:
        count += 1
for i in range(count):
    ans[i] = ans[count]
for i in range(H):
    print(*ans[i])
"
"N, M = map(int, input().split())
L = [0] * M
R = [0] * M
for c in range(M):
    L[c], R[c] = map(int, input().split())

L_max = max(L)
R_min = min(R)

ans = R_min - L_max
ans += 1

if ans < 0:
    print(0)
else:
    print(ans)"
"(X1,X2,Y1,Y2)=list(map(int,input().split()))
ans=X2*Y2
ans=max(ans,X1*Y1)
ans=max(ans,X1*Y2)
ans=max(ans,X2*Y1)
print (ans)"
"N, Y = input().split()
N = int(N)
Y = int(Y)
i = 0
j = 0
k = N - i - j


for i in range(N+1):
    for j in range(N - i + 1):
        k = N - i - j
        SUM = 10000*i + 5000 * j + 1000 * k
        if SUM == Y:
            print(i, j, k)
            exit()
        else:
            continue
        
print('-1', '-1', '-1')"
"n=int(input())
a=input()

for i in a:
  if ord(i)+n<=90:
    print(chr(ord(i)+n),end='')
  else:
    print(chr(ord(i)+n-26),end='')
"
"input()
a=[a for a in map(int,input().split())if a%2==0]
r=""DENIED""
for i in a:
	if i%3 and i%5:break
else: r=""APPROVED""
print(r)"
"def main():
    from sys import setrecursionlimit, stdin, stderr
    from os import environ
    from collections import defaultdict, deque, Counter
    from math import ceil, floor
    from itertools import accumulate, combinations, combinations_with_replacement
    setrecursionlimit(10**6)
    dbg = (lambda *something: stderr.write(""\033[92m{}\033[0m"".format(str(something)+'\n'))) if 'TERM_PROGRAM' in environ else lambda *x: 0
    input = lambda: stdin.readline().rstrip()
    LMIIS = lambda: list(map(int,input().split()))
    II = lambda: int(input())
    P = 10**9+7
    INF = 10**18+10

    N = II()
    A = []
    for i in range(N):
        A.append(deque(map(lambda x: int(x)-1, input().split())))
    
    dbg('hoge')
    ans = 0
    players = deque(range(N))
    calc = 0
    
    match = defaultdict(lambda : -1)
    first = True
    while True:
        mathced = False
        next_players = deque()
        next_match = defaultdict(lambda : -1)
        # dbg('day',ans)
        for i in players:
            # dbg(i,ans,players,A,match)
            calc += 1
            a = A[i]
            if len(a) == 0:
                continue
            j = a[0]
            b = A[j]

            
            
            if match[j] == i and match[i] == j:
                # dbg(i,j)
                b.popleft()
                # if b[0] != i:
                #     dbg('fuga')
                a.popleft()
                mathced = True
                match[i] = -1
                match[j] = -1
                if len(a) > 0:
                    next_match[i] = a[0]
                    next_players.append(i)

                if len(b) > 0:
                    next_match[j] = b[0]
                    next_players.append(j)


            else:
                next_match[i] = a[0]

        players = next_players
        match.update(next_match)
        if first:
            dbg('hogehoge')
            first = False
            players = range(N)
            continue
        ans += 1
        if not mathced or len(players) == 0:
            break

        
    print(ans if mathced and len(next_players)==0 else -1)
    dbg(calc,mathced,len(next_players),len(a),len(b))







    

    ans = 0

    

    
   
main()"
"n,k = map(int, input().split())
v = list(map(int, input().split()))

ans = 0
for x in range(k+1):# LeftHand
  for y in range(k-x+1):# RightHand
    temp = v[:x]+v[len(v)-y:]
    if x+y >= n:
      temp = v
    temp1 = []
    temp2 = []
    for i in temp:
      if i >= 0:
        temp1.append(i)
      else:
        temp2.append(i)

    temp2.sort()
    ans = max(ans, sum(temp1) + sum(temp2[k-x-y:]))
print(ans)"
"a = input()
s = input()

x = 0
m = 0
for i in s:
    if i == 'I':
        x += 1
        m = max(m, x)
    else:
        x -= 1

print(m)
"
"N = int(input())
X = input()
ans = [1 for _ in range(N)]
#original 1 count
l = X.count('1')
if l == 0:
  for _ in range(N):
    print(1)
  exit()
if l == 1:
  if X[-1] == '1':
    for _ in range(N-1):
      ans[_] = 2
  else:
    ans[-1] = 2 
  for k in range(N):
    if X[k] =='1':
      ans[k] = 0 
  for _ in range(N):
    print(ans[_])
  exit()
 
 
intN = int(X, 2)
N1 = intN %(l-1)
N0 = intN % (l+1)
 
 
start = []
if N == 1:
  if X[0] == '1':
    print(0)
    exit()
  else:
    print(1)
    exit()
else:
  s1 = 1
  s0 = 1
  for k in range(N-1, -1, -1):
    if X[k] == '1':      
      ia = (N1 - s1)%(l-1)
    else:
      ia = (N0 + s0)%(l+1)
    start.append(ia)
    s1 = s1*2%(l-1)
    s0 = s0*2%(l+1)
start = start[::-1]
 
ml = len(bin(l+1))-2
poplist = [0 for _ in range(N)]
t = 1
while t < N + 1:
  t *= 2
  for k in range(t//2, N, t):
    for j in range(t//2):
      if k+j>N-1:
        break
      poplist[k+j] += 1
""""""
 
def popcount(n):
  c = 0
  n = bin(n)[2:]
  for k in range(len(n)):
    if n[k] == '1':
      c+=1
  return c
""""""
for k in range(len(start)):
  for count in range(10*5):
    if start[k] == 0:
      ans[k] += count
      break
    else:
      start[k] = start[k] % poplist[start[k]]
 
for k in range(N):
  print(ans[k])"
"def main():
    S,W=map(int,input().split())
    if S<=W: print('unsafe')
    else: print('safe')
    return

if __name__=='__main__':
    main()
"
"def main():
    import sys
    import numpy as np
    ikimasu = sys.stdin.buffer.readline
    ini = lambda: int(ins())
    ina = lambda: list(map(int, ikimasu().split()))
    ins = lambda: ikimasu().strip()
    
    n,m,q = ina()
    tmp = [[0]*(n+1) for _ in range(n+1)]
    for _ in range(m):
        l,r = ina()
        tmp[l][r]+=1


    tmp = np.cumsum(tmp,axis=1).cumsum(axis = 0)

    for _ in range(q):
        p,q = ina()
        rick = tmp[q][q]+tmp[p-1][p-1]-tmp[p-1][q]-tmp[q][p-1]
        print(rick)
        


    
        


        


    




















if __name__ == ""__main__"":
    main()
"
"import math

N,K = map(int,input().split())
A = list(map(int,input().split()))
F = list(map(int,input().split()))
if sum(A) <= K:
  print(0)
  exit()
A.sort()
F.sort(reverse=True)

l,r = -1,10**12+1

while r-l > 1:
  m = (l+r)//2

  k = 0
  for i in range(N):
    a,f = A[i], F[i]
    k += max(0,a-(m//f))

  if k <= K:
    r = m
  else:
    l = m

print(r)"
"S = input()
T = input()
if S==T[::-1]:
  print(""YES"")
else:
  print(""NO"")"
"N, M = [int(i) for i in input().split()]
R = [0 for _ in range(N)]
for _ in range(M):
    a, b = [int(i) for i in input().split()]
    R[a - 1] += 1
    R[b - 1] += 1
for i in range(N):
    print(R[i])
"
"s1 = []
s2 = []
a = 0
s = input()
for i in range(len(s)):
    if s[i] == ""\\"":
        s1.append(i)
    elif s[i] == ""/"" and len(s1)>0:
        j = s1.pop()#position of nearest \
        a += i-j
        a_splt = i-j
        while(len(s2) > 0 and s2[-1][0] > j):
            a_splt += s2.pop()[1]
        s2.append([j, a_splt])

print(a)
ans = """"
ans += str(len(s2))
for area in s2:
    ans += "" "" + str(area[1])
print(ans)
"
"from collections import Counter
N = int(input())
S = input()
ans = 0
for x in range(10):
    for y in range(10):
        hantei = []
        for i in range(N):
            if x != int(S[i]):
                continue
            for j in range(i+1, N):
                if y != int(S[j]):
                    continue
                for k in range(j+1, N):
                    hantei.append(S[k])
                ans += len(Counter(hantei))
                break
            break

print(ans)
"
"N = int(input())

if N%2 == 1:
    print(0)
    exit()

ans = 0
for i in range(30):
    ans += N//(2*5**(i+1))
print(ans)"
"import sys
import math
import itertools
import collections
import heapq
import re
import numpy as np

rr = lambda: sys.stdin.readline().rstrip()
rs = lambda: sys.stdin.readline().split()
ri = lambda: int(sys.stdin.readline())
rm = lambda: map(int, sys.stdin.readline().split())
rl = lambda: list(map(int, sys.stdin.readline().split()))
inf = float('inf')
mod = 10**9 + 7

a, b = rm()
if a <= b:
  print(a)
else:
  print(a-1)














"
"a,b = map(int, raw_input().split())
c = a*b
d = 2*(a+b)
print'%d %d'%(c,d)"
"x,y=map(int,input().split())
ans=0
x=max(4-x,0)
y=max(4-y,0)
ans+=x*100000+y*100000
if x==3 and y==3:
  ans+=400000
print(ans)"
"print(''.join(map(lambda x: x[0], input().split())).upper())
"
"A, B = map(int, input().split())
if A >= 6 and 12 >= A:
  print(int(B/2))
elif 5 >= A:
  print(0)
else:
  print(B)"
"# -*- coding: utf-8 -*-
import sys
from collections import deque

N,D,A=map(int, sys.stdin.readline().split())
XH=[ map(int, sys.stdin.readline().split()) for _ in range(N) ]
XH.sort()

q=deque()   #（攻撃が無効となる座標、攻撃によるポイント）
ans=0
cnt=0

attack_point=0
for x,h in XH:
    while q:
        if x<q[0][0]:break  #無効となる攻撃がない場合はwhileを終了
        end_x,end_point=q.popleft()
        attack_point-=end_point #攻撃が無効となる座標<=現在の座標があれば、その攻撃のポイントを引く

    if h<=attack_point: #モンスターの体力よりも攻撃で減らせるポイントの方が大きければ新規攻撃は不要
        pass
    else:   #新規攻撃が必要な場合
        if h%A==0:
            cnt=(h-attack_point)/A  #モンスターの大量をゼロ以下にするために何回攻撃が必要か
        else:
            cnt=(h-attack_point)/A+1
        attack_point+=cnt*A
        q.append((x+2*D+1,cnt*A))   #（攻撃が無効となる座標、攻撃によるポイント）をキューに入れる
        ans+=cnt

print ans"
"R, C, K = map(int, input().split())
score = [[0]*C for i in range(R)]

for i in range(K):
  r, c, v = map(int, input().split())
  score[r-1][c-1]+=v
  
ans0 = [[0]*C for i in range(R)]
ans1 = [[0]*C for i in range(R)]
ans2 = [[0]*C for i in range(R)]
ans3 = [[0]*C for i in range(R)]

ans1[0][0]=score[0][0]
ans2[0][0]=score[0][0]
ans3[0][0]=score[0][0]

for i in range(R):
  for j in range(C):
    if i>0:
      ans0[i][j]=max(ans0[i][j],ans3[i-1][j])
      ans1[i][j]=max(ans1[i][j],ans3[i-1][j]+score[i][j])
      ans2[i][j]=max(ans2[i][j],ans3[i-1][j]+score[i][j])
      ans3[i][j]=max(ans3[i][j],ans3[i-1][j]+score[i][j])
    if j>0:
      ans0[i][j]=max(ans0[i][j],ans0[i][j-1])
      ans1[i][j]=max(ans1[i][j],ans0[i][j-1]+score[i][j],ans1[i][j-1])
      ans2[i][j]=max(ans2[i][j],ans1[i][j-1]+score[i][j],ans2[i][j-1])
      ans3[i][j]=max(ans3[i][j],ans2[i][j-1]+score[i][j],ans3[i][j-1])

print(ans3[R-1][C-1])"
"def sort(a):
    n = len(a)
    for i in range(1,n):
        for j in range(i):
            p = i-j
            if a[p] < a[p-1]:
                a[p], a[p-1] = a[p-1], a[p]
        print ' '.join(map(str, a))

n = int(raw_input())
a = map(int, raw_input().split(' '))
print ' '.join(map(str, a))
sort(a)"
"from itertools import *
N = int(input())
ans = 0

for i in product(""0357"",repeat=10):
  j = """".join(i)
  if ""0"" not in str(int(j)) and ""3"" in j and ""5"" in j and ""7"" in j and int(j)<=N:
    ans+=1

print(ans)"
"import sys
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

H, W, M = map(int, input().split())

rows = [0] * (H + 1)
cols = [0] * (W + 1)

from collections import defaultdict
ng_cols = defaultdict(set)

for _ in range(M):
    h, w = map(int, input().split())
    rows[h] += 1
    cols[w] += 1
    ng_cols[h].add(w)

max_of_rows = max(rows)
max_of_cols = max(cols)
max_rows_index = set()
max_cols_index = set()
for i in range(H + 1):
    if rows[i] == max_of_rows:
        max_rows_index.add(i)
for i in range(W + 1):
    if cols[i] == max_of_cols:
        max_cols_index.add(i)
flag = 0
for i in max_rows_index:
    for j in max_cols_index:
        if j not in ng_cols[i]:
            flag = 1
            break
print(max_of_rows + max_of_cols - 1 + flag)






"
"a,b=map(int,input().split())
s=input()
t=True
if s[a]==""-"":
    x,y=s[:a],s[a+1:]
    if ""-"" in x or ""-"" in y:
        t=False
else:
    t=False
print(""Yes"" if t else ""No"")"
"while input()!='0':
    l=list(map(float,input().split()))
    m=sum(l)/len(l)
    s=0
    for i in range(len(l)):
        s+=(l[i]-m)**2
    print('%.8f'%((s/len(l))**.5))"
"def main():
    N  = int(input())
    A,B  = map(int, input().split()) 
    P = list(map(int, input().split()))  
    c1 = 0
    c2 = 0
    c3 = 0

    for i in range(len(P)):
        if P[i]<=A:
            c1 +=1
        elif P[i]<=B:
            c2 +=1
        else:
            c3 +=1
    print(min([c1,c2,c3]))




if __name__ == '__main__':
    main()
"
"S = input()
T = input()
X,Y = len(S),len(T)
L = [[0 for _ in range (Y+1)] for _ in range (X+1)]
for i in range (X):
  for j in range (Y):
    if S[i] == T[j]:
      L[i+1][j+1] = L[i][j]+1
    else:
      L[i+1][j+1] = max(L[i][j+1] , L[i+1][j] , L[i+1][j+1])
K = ''
while X*Y:
  if S[X-1] == T[Y-1]:
    K += S[X-1]
    X -= 1
    Y -= 1
  else:
    if L[X-1][Y] > L[X][Y-1]:
      X -= 1
    else:
      Y -= 1
print(K[::-1])"
"S=input()
cnt=0;l='@';i=0
while(i<len(S)):
    if(S[i]==l):
        if(i<len(S)-1):
            l=S[i:i+2]
            cnt+=1
        i+=2
    else:
        l=S[i];cnt+=1;i+=1
print(cnt)"
"import sys
input = sys.stdin.readline
A,B =list(map(int,input().split()))
print(max(0,A-2*B)) 
"
"n, a, b = map(int, input().split())
count = 0
for i in range(int(n) + 1):
  c = len(str(i))
  d = 0
  for j in range(c):
    d += int(str(i)[j])
  if int(a) <= d and d <= int(b):
    count += i
print(count)"
"sx, sy, tx, ty = map(int, input().split())

dx = abs(tx - sx)
dy = abs(ty - sy)

s = ['U'] * dy + ['R'] * dx + ['U'] + ['L'] * (dx+1) + ['D'] * (dy+1) + ['R'] + ['R'] * dx + ['U'] * dy + ['R'] + ['D'] * (dy+1) + ['L'] * (dx + 1) + ['U']

print("""".join(s))
"
"N = int(input())
T = [int(t) for t in input().split()]
A = [int(a) for a in input().split()]

mod = 10**9+7
TM = [0]*N
TM[0] = T[0]
AM = [0]*N
AM[-1] = A[-1]
for i in range(N-1):
    if T[i] < T[i+1]:
        TM[i+1] = T[i+1]
    if A[i+1] < A[i]:
        AM[i] = A[i]

M = [0]*N
ans = 1
for i in range(N):
    if TM[i] > 0 and AM[i] > 0 and TM[i] != AM[i]:
        ans = 0
    elif TM[i] > 0 and AM[i] == 0 and TM[i] <= A[i]:
        M[i] = TM[i]
    elif TM[i] == 0 and AM[i] > 0 and AM[i] <= T[i]:
        M[i] = AM[i]
    elif TM[i] == AM[i]:
        M[i] = TM[i]
    elif TM[i] == 0 and AM[i] == 0:
        continue
    else:
        ans = 0
        break

for i in range(N):
    if M[i] > 0:
        continue
    ans *= min(T[i], A[i])
    ans %= mod

print(ans)"
"def is_prime(x):
  k = 2
  while k * k <= x:
    if x % k == 0:
      return False
    k += 1
  return True

x = int(input())
while True:
  if is_prime(x):
    print(x)
    break
  else:
    x+=1"
"def solve():
  ans = 0
  N = int(input())
  A = list(map(int, input().split()))
  lis = [0]*(10**5+2)
  for i in range(N):
    lis[A[i]-1] += 1
    lis[A[i]] += 1
    lis[A[i]+1] += 1
  ans = max(lis)
  return ans
print(solve())"
"a, b = map(int, input().split())
print('Yes' if a%2 and b%2 else 'No')"
"# -*- coding: utf-8 -*-

import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

class SegTree:
    """"""
    セグメント木
    1.update:  i番目の値をxに更新する
    2.query: 区間[l, r)の値を得る
    """"""

    def __init__(self, n, func, intv, A=[]):
        """"""
        :param n: 要素数(0-indexed)
        :param func: 値の操作に使う関数(min, max, add, gcdなど)
        :param intv: 要素の初期値(単位元)
        :param A: 初期化に使うリスト(オプション)
        """"""
        self.n = n
        self.func = func
        self.intv = intv
        # nより大きい2の冪数
        n2 = 1
        while n2 < n:
            n2 <<= 1
        self.n2 = n2
        self.tree = [self.intv] * (n2 << 1)
        # 初期化の値が決まっている場合
        if A:
            # 1段目(最下段)の初期化
            for i in range(n):
                self.tree[n2+i] = A[i]
            # 2段目以降の初期化
            for i in range(n2-1, -1, -1):
                self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])

    def update(self, i, x):
        """"""
        i番目の値をxに更新
        :param i: index(0-indexed)
        :param x: update value
        """"""
        i += self.n2
        self.tree[i] = x
        while i > 0:
            i >>= 1
            self.tree[i] = self.func(self.tree[i*2], self.tree[i*2+1])

    def query(self, a, b):
        """"""
        [a, b)の値を得る
        :param a: index(0-indexed)
        :param b: index(0-indexed)
        """"""
        l = a + self.n2
        r = b + self.n2
        s = self.intv
        while l < r:
            if r & 1:
                r -= 1
                s = self.func(s, self.tree[r])
            if l & 1:
                s = self.func(s, self.tree[l])
                l += 1
            l >>= 1
            r >>= 1
        return s

    def get(self, i):
        """""" 一点取得 """"""
        return self.tree[i+self.n2]

    def all(self):
        """""" 全区間[0, n)の取得 """"""
        return self.tree[1]

N, M = MAP()
S = input()

dp = SegTree(N+1, min, INF)
dp.update(N, 0)
for i in range(N-1, -1, -1):
    # ゲームオーバーマスには遷移できない
    if S[i] == '1':
        continue
    mn = dp.query(i+1, min(N+1, i+M+1))
    if mn != INF:
        dp.update(i, mn+1)

# 辿り着けない
if dp.get(0) == INF:
    print(-1)
    exit()

cnt = dp.get(0)
cur = 0
prev = -1
ans = []
for i in range(1, N+1):
    if dp.get(i) == INF:
        continue
    # 手数が変わる場所でなるべく手前に飛ぶ
    if dp.get(i) != cnt:
        prev = cur
        cur = i
        ans.append(cur-prev)
        cnt = dp.get(i)
print(*ans)
"
"A, B = map(int, input().split())

if divmod(B, A)[1] == 0:
    print(A + B)
else:
    print(B - A)
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N = int(input())
K = int(input())
now = 1
for _ in range(N):
    now = min(now*2, now+K)
print(now)"
"n = int(input())
As = list(map(int, input().split()))

internal_max = [1]*(n+1)
internal_max[0] = 1-As[0]

for i in range(1,n+1):
    internal_max[i] = 2*internal_max[i-1]-As[i]

depth_sum = [0]*(n+1)
depth_sum[n] = As[n]
judge = False

for i in range(n-1, -1, -1):
    if depth_sum[i+1] > internal_max[i]*2:
        judge = True
        break
    else:
        depth_sum[i] = As[i] + min(internal_max[i], depth_sum[i+1])

if n == 0:
    if As[0] > 1:
        judge = True

if judge:
    print(-1)
else:
    print(sum(depth_sum))
"
"n, i = map(int, input().split())
if 1 <= n <= 100 and 1 <= i <= n:
    print(n - i + 1)
else:
    print('hoge!')"
"import sys
input = sys.stdin.readline
from bisect import *

A, B, Q = map(int, input().split())
s = [-10**18]+[int(input()) for _ in range(A)]+[10**18]
t = [-10**18]+[int(input()) for _ in range(B)]+[10**18]

for _ in range(Q):
    x = int(input())
    idx1 = bisect_right(s, x)
    idx2 = bisect_right(t, x)
    ls, rs = s[idx1-1], s[idx1]
    lt, rt = t[idx2-1], t[idx2]
    ans = 10**18
    
    for p1, p2 in [(ls, lt), (ls, rt), (rs, lt), (rs, rt), (lt, ls), (lt, rs), (rt, ls), (rt, rs)]:
        ans = min(ans, abs(p1-x)+abs(p2-p1))
    
    print(ans)"
"K, X = list(map(int, input().split()))
for i in range(X - K + 1, X + K):
	print(i)
"
"A,B,C,D=map(int,input().split())
start=max(A,C)
goal=min(B,D)
dt=goal-start
if dt<0:
    print(0)
else:
    print(dt)"
"tmp = input().split("" "")

print(""Yes"") if int(tmp[0]) <= int(tmp[2]) <= int(tmp[1]) else print(""No"")"
"n = int(input())
a = list(map(int, input().split()))

sm = a[0]


def f(sm):
    ret = 0
    for e in a[1:]:
        if sm * (sm + e) < 0:
            sm += e
            continue

        else:
            if sm > 0:
                a_mx = -sm - 1
                ret += e - a_mx
                sm += a_mx
            else:
                a_mn = -sm + 1
                ret += a_mn - e
                sm += a_mn

    return ret


if sm > 0:
    ans = min(f(sm), f(-1) + sm + 1)
elif sm < 0:
    ans = min(f(sm), f(1) - sm + 1)
else:
    ans = min(f(1), f(-1)) + 1

print(ans)
"
"sx,sy,tx,ty = map(int, input().split())
x = tx-sx
y = ty-sy

ans = []
ans = ans + ['R']*x
ans = ans + ['U']*y

ans = ans + ['L']*x
ans = ans + ['D']*y

ans = ans + ['D']
ans = ans + ['R']*(x+1)
ans = ans + ['U']*(y+1)
ans = ans + ['L']

ans = ans + ['U']
ans = ans + ['L']*(x+1)
ans = ans + ['D']*(y+1)
ans = ans + ['R']

print(''.join(ans))
"
"import sys


def input(): return sys.stdin.readline().strip()
def I(): return int(input())
def LI(): return list(map(int, input().split()))
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def S(): return input()
def LS(): return input().split()


def satisfaction(d, last, c):
    res = 0
    for i in range(26):
        res += c[i] * (d - last[i])
    return res


def main():
    d = I()
    c = LI()
    s = LIR(d)
    t = IR(d)
    last = [0] * 26
    satis = 0
    for day in range(d):
        j = t[day] - 1
        last[j] = day + 1
        satis += s[day][j]
        satis -= satisfaction(day + 1, last, c)
        print(satis)


main()
"
"def main():
    n = int(input())

    if n == 1 or n == 2:
        ans = 0
    else:
        if n % 2 == 0:
            ans = n // 2 - 1
        else:
            ans = n // 2

    print(ans)


if __name__ == ""__main__"":
    main()
"
"N, M, L = map(int, input().split())
D = [[1000000000000]*N for i in range(N)]
for i in range(N):
  D[i][i] = 0
for i in range(M):
  A, B, C = map(int, input().split())
  A, B = A-1, B-1
  D[A][B] = C
  D[B][A] = C
for k in range(N):
  for i in range(N):
    for j in range(N):
      D[i][j] = min(D[i][j], D[i][k]+D[k][j])
E = [[1000000000000]*N for i in range(N)]
for i in range(N):
  E[i][i] = 0
for i in range(N):
  for j in range(N):
    if D[i][j] <= L:
      E[i][j] = 1
for k in range(N):
  for i in range(N):
    for j in range(N):
      E[i][j] = min(E[i][j], E[i][k]+E[k][j])
Q = int(input())
for i in range(Q):
  s, t = map(int, input().split())
  s, t = s-1, t-1
  if E[s][t] == 1000000000000:
    r = -1
  else:
    r = E[s][t]-1
  print(r)
"
"def resolve():
    N = int(input())
    A = [int(i) for i in input().split()]
    sumA = 0
    for i in range(N):
        sumA += 1 / A[i]
    print(1 / sumA)

resolve()
"
"#import itertools
#import fractions
#import numpy as np
#mod = 10**4 + 7
""""""def kiri(n,m):
  r_ = n / m
  if (r_ - (n // m)) > 0:
    return (n//m) + 1
  else:
    return (n//m)""""""

# Written by NoKnowledgeGG @YlePhan

import math
#mod = 10**9+7

def main():
  n,k = map(int,input().split())
  print(k * (k-1) ** (n-1))
    
if __name__ == '__main__':
  main()"
"X, Y = map(int, input().split())
if X%Y == 0:
  print(-1)
  exit()
r = X*(Y-1)
print(r)
"
"w,a,b=map(int,input().split())
A=[i for i in range(a,a+w+1)]
B=[i for i in range(b,b+w+1)]
if a in B or b in A:
    print(0)
else:
    print(min(abs(a+w-b),abs(b+w-a)))"
"import sys
input = sys.stdin.readline

s = input()
count0 = s.count(""0"")
count1 = s.count(""1"")

print(2 * min(count0, count1))"
"while(True):
    H, W = map(int, input().split())
    if(H == W == 0):
        break
    first = False
    for i in range(H):
        print(""#"" * W)
    print()"
"input()
K = int(input())
l = list(map(int,input().split()))
ans = 0
for i in range(len(l)):
  if (K - l[i]) <= (l[i] - 0):
    ans += (K - l[i]) * 2
  elif (l[i] - 0) < (K - l[i]):
    ans += (l[i] - 0) * 2
print(ans)"
"import sys
sys.setrecursionlimit(10**6)
n=int(input())
def res(v:int, all:list):
    if v>n:
        return
    if ""3"" in list(str(v)) and ""5"" in list(str(v)) and ""7"" in list(str(v)):
        all.append(v)
    res(10*v+3,all)
    res(10*v+5,all)
    res(10*v+7,all)
all=[]

res(3,all)
res(5,all)
res(7,all)


print(len(all))"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(10 ** 7)

n = list(map(int, list(readline().rstrip().decode())[::-1]))
a = 0
b = 10000
for x in n:
    memo = min(a + x, b + x)
    b = min(a + 11 - x, b + 9 - x)
    a = memo
print(min(a, b))
"
"import math
from collections import Counter

n, m = map(int, input().split())
mod = 10**9 + 7

K = 50
fact = [0] * (n+1+K)
ifact = [0] * (n+1+K)
fact[0] = 1
for i in range(1,n+1+K):
    fact[i] = fact[i-1] * i % mod
ifact[n+K] = pow(fact[n+K], mod-2, mod)
for i in reversed(range(1,n+1+K)):
    ifact[i-1] = ifact[i] * i % mod

def comb(n, k):
    return fact[n] * ifact[n-k] % mod * ifact[k] % mod

def getprime(n):
    primes = []
    i = 2
    while n >= i * i:
        while n % i == 0:
            n //= i
            primes.append(i)
        i += 1
    if n != 1:
        primes.append(n)
    return primes

ans = 1
counter = Counter(getprime(m))
for k in counter.values():
    ans *= comb(n+k-1, k)
    ans %= mod
print(ans)"
"K = int(input())
count =1

x = 7%K

for i in range(0,K+1):
    if x== 0:
        print(count)
        break

    count+=1
    x = (x*10+7)%K

if i== K:  
    print(-1)"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, K, *X = map(int, read().split())

    ans = 0
    for x in X:
        ans += min(abs(x), abs(x - K)) * 2

    print(ans)
    return


if __name__ == '__main__':
    main()
"
"import sys
import math
import itertools
import bisect
from copy import copy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def k(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def X(): return list(input())
def L(): return list(input().split())
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
def gcd(*numbers): reduce(math.gcd, numbers)
sys.setrecursionlimit(10 ** 9)
mod = 10**9+7
count = 0
ans = 0

N, C, K =I()
T = []
for i in range(N):
    t = k()
    T.append(t)

T.sort()
a = T[0]+K
pas = 0
ans = 1

for i in range(N):
    if pas == C or a < T[i]:
        pas = 1
        ans += 1
        a = T[i]+K
    else:
        pas += 1

print(ans)
"
"H, W = map(int, input().split())
L = ['#' + input() + '#' for _ in range(H)]
L = ['#' * (W + 2)] + L + ['#' * (W + 2)]
[print(i) for i in L]"
"m, n, x = map(int,input().split())
al = list(map(int,input().split()))


cost = 0
for i in range(x,m+1):
  if i in al:
    cost += 1

cost2 = 0
for i in range(x,0,-1):
  if i in al:
    cost2 += 1
    
print(min(cost, cost2))
"
"H, W = map(int, input().split())
a = []
for _ in range(H):
    a.append(list(map(int, input().split())))
#print(a)

cnt = 0
ope=[]
for y in range(H):
    if y != H -1:
        for x in range(W):
            if a[y][x] % 2 == 1:
                a[y][x] -= 1
                a[y + 1][x] += 1
                cnt += 1
                ope.append([y+1,x+1,y+1+1,x+1])
    else:
        for x in range(W-1):
            if a[y][x] % 2 == 1:
                a[y][x] -= 1
                a[y][x+1] += 1
                cnt += 1
                ope.append([y+1,x+1,y+1,x+1+1])
print(cnt)
for el in ope:
    print(' '.join(list(map(str, el))))



"
"from sys import exit
n=int(input())
p=list(map(int,input().split()))
s=sorted(p)
if p==s:
	print(""YES"")
	exit(0)
for i in range(n-1):
	for j in range(i+1,n):
		p[i],p[j] = p[j],p[i]
		if p == s:
			print(""YES"")
			exit(0)
		p[i],p[j] = p[j],p[i]
print(""NO"")"
"import copy
n,m=map(int,input().split())
temp=[[] for i in range(n)]
for i in range(m):
  a,b=map(int,input().split())
  a=a-1
  b=b-1
  temp[a].append(b)
  temp[b].append(a)
count=0
a=[]
c=True
while c:
  c=False
  for i in range(n):
    if len(temp[i])==1 and i not in a:
      temp[temp[i][0]].remove(i)
      a.append(i)
      count=count+1
      c=True
print(count)"
"import sys

n,m=map(int,input().split())
ans=[0]*(m+1)
output=0

for i in range(n):
    k=list(map(int,input().split()))
    for j in range(1,len(k)):
        ans[k[j]]+=1

for i in ans:
    if i==n:
        output+=1

print(output)"
"import sys
input = sys.stdin.readline

def main():
    a = int(input())
    s = input().strip()

    if a >= 3200:
        print(s)
    else:
        print('red')


if __name__ == ""__main__"":
    main()
"
"while True :
	n,x=map(int,raw_input().split())
	if not( n==0 and x==0) :
		p_count = 0
		i,j,k = [1,2,3]
		while i <= n-2 :
			j = i+1
			while j <= n-1:
				k = j+1
				while k <= n:
					if (i+j+k)==x :
						p_count += 1
						k += 1
						break
					else :
						k += 1
				j += 1
			i += 1
		print(p_count)
 	else :
 		break"
"k,t,*aa = map(int, open(0).read().split())
aa.sort(reverse=True)

eligible = min(aa[0], sum(aa[1:]) + 1) + sum(aa[1:])

print(k-min(k,eligible))"
"while True:
    x = [int(z) for z in input().split("" "")]
    if x[0] == 0 and x[1] == 0: break
    for h in range(0,x[0]):
        dot = h % 2
        for w in range(0,x[1]):
            if (dot == 0 and w % 2 == 0) or (dot == 1 and w % 2 == 1):
                print(""#"", end="""")
            else:
                print(""."", end="""")
        print(""\n"", end="""")
    print("""")"
"n=int(input())
s=input().split(' ')

print(' '.join(s))

for i in range(1,n):
	v=int(s[i])
	j=i-1
	while j>=0 and int(s[j])>v:
		s[j+1]=s[j]
		j-=1
	s[j+1]=str(v)
	print(' '.join(s))
"
"a, b = map(int, raw_input().split())
print str(a*b) + "" ""+ str(a*2+b*2)"
"
def main():
    N, Ma, Mb = map(int, input().split())
    ABC = [list(map(int, input().split())) for _ in range(N)]

    INF = 10000000

    dp = [[[INF for _ in range(10*N)] for _ in range(10*N)] for _ in range(N)]

    for i, (a, b, c) in enumerate(ABC):
        a -= 1
        b -= 1
        if i == 0:
            dp[0][a][b] = c
            continue
        for ai in range(10*N):
            for bi in range(10*N):
                if a > ai or b > bi:
                    dp[i][ai][bi] = dp[i-1][ai][bi]
                elif ai == a and bi == b:
                    dp[i][ai][bi] = min(dp[i-1][ai][bi], c)
                else:
                    dp[i][ai][bi] = min(dp[i-1][ai-a-1][bi-b-1]+c, dp[i-1][ai][bi])

    ans = INF
    for i in range(10*N):
        for j in range(10*N):
            if (i+1)*Mb == (j+1)*Ma:
                #print(i, j, dp[N-1][i][j])
                ans = min(dp[N-1][i][j], ans)
    if ans == INF:
        print(-1)
    else:
        print(ans)

if __name__ == ""__main__"":
    main()"
"n, k = map(int,input().split())
f = [int(x)-1 for x in input().split()]

def tortoise_and_hare(s,f):
    tortoise = f[s]
    hare = f[f[s]]

    while tortoise != hare:
        tortoise = f[tortoise]
        hare = f[f[hare]]

    rho = 0
    tortoise = s
    while tortoise != hare:
        tortoise = f[tortoise]
        hare = f[hare]
        rho += 1

    lamb = 1
    hare = f[hare]

    while tortoise != hare:
        hare = f[hare]
        lamb += 1

    return rho,lamb

rho, lamb = tortoise_and_hare(0,f)

if k <= rho:
    s = 0
    for i in range(k):
        s = f[s]
else:
    s = 0
    for i in range(rho):
        s = f[s]
    k = (k-rho)%lamb
    for i in range(k):
        s = f[s]

print(s+1)
"
"N = int(input())
A = list(map(int,input().split()))
K = max(A)
ls = [0 for i in range(K+2)]
for i in range(N):
    if A[i] == 0:
        ls[A[i]] += 1
        ls[A[i]+1] += 1
    else:
        ls[A[i]-1] += 1
        ls[A[i]] += 1
        ls[A[i]+1] += 1
print(max(ls))"
"
import collections
n = int(input())
s = list(input())

ans = 1
c = collections.Counter(s)
for i in set(s):
    ans *= (c[i] + 1)
print((ans - 1) % (pow(10, 9) + 7))
"
"import bisect,collections,copy,itertools,math,string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def main():
    d, g = LI()
    lst = [0 for _ in range(d)]
    for i in range(d):
        p, c = LI()
        lst[i] = (p, c)
    
    ans = float(""inf"")
    bits = itertools.product([0,1],repeat=d)

    for bit in bits:
        point = 0
        cnt = 0
        for i in range(d):
            if bit[i] == 1:
                cnt += lst[i][0]
                point += (i+1)*100*lst[i][0] + lst[i][1]
        for i in range(d-1,-1,-1):
            if point>=g:
                break
            if bit[i] == 0:
                for _ in range(lst[i][0]-1):
                    cnt += 1
                    point += (i+1)*100
                    if point>=g:
                        break
        if point>=g:
            ans = min(ans,cnt)
    print(ans)

main()            
"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from fractions import gcd
from heapq import heappush, heappop
from functools import reduce
from decimal import Decimal
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10**9 + 7
from decimal import *

N = INT()
L = LIST()

cnt = [0]*(10**3+1)
for x in L:
	cnt[x] += 1

cnt = list(accumulate(cnt))

ans = 0
for x, y in combinations(L, 2):
	ans += cnt[min(x+y-1, 1000)] - cnt[abs(x-y)] - (abs(x-y) < x < x+y) - (abs(x-y) < y < x+y)

print(ans//3)"
"#!/usr/bin/env python3
def main():
    from math import gcd

    N = int(input())
    A = []
    INF = 10 ** 6 + 5
    frequency = [0] * INF
    for a in [int(x) for x in input().split()]:
        A.append(a)
        frequency[a] += 1
    
    pairwise = True
    for i in range(2, INF):
        cnt = 0
        for j in range(i, INF, i):
            cnt += frequency[j]
        if cnt > 1:
            pairwise = False
    if pairwise:
        print(""pairwise coprime"")
        return

    g = 0
    for i in range(N):
        g = gcd(g, A[i])
        if g == 1:
            print('setwise coprime')
            return
    
    print('not coprime')


if __name__ == '__main__':
    main()
"
"n, h, w = map(int, input().split())
ab = []
for i in range(n):
    ab.append(list(map(int, input().split())))
cnt = 0
for j in ab:
    if j[0] >= h and j[1] >= w:
        cnt += 1
print(cnt)"
"n=int(input())
x=100000
for i in range(n):
    x=x*1.05
    if x%1000==0:
        x=x
    else:
        x=((x//1000)+1)*1000
print(int(x))


"
"import sys
sys.setrecursionlimit(10**6)
n, a, b = map(int, input().split())
D = [[0]*2 for _ in range(101010)]
E = [[] for _ in range(n)]


def dfs(cur, pre, d, id):
    D[cur][id] = d
    for nv in E[cur]:
        if nv != pre:
            dfs(nv, cur, d+1, id)


a -= 1
b -= 1
for i in range(n-1):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    E[x].append(y)
    E[y].append(x)
dfs(a, a, 0, 0)
dfs(b, b, 0, 1)
max_d = 0
for i in range(n):
    if D[i][0] < D[i][1]:
        max_d = max(max_d, D[i][1]-1)
print(max_d)
"
"S = input()

import sys

for i in range(0,len(S)):
    for j in range(i,len(S)):
        if S[:i] + S[j:] == 'keyence':
            print('YES')
            sys.exit()
        
print('NO')"
"A,B=list(map(int,input().split()))
C,D,s=0,0,B-A+1
C=0 if A%2==0 else A
D=0 if B%2==1 else B
if ((s-(0 if C==0 else 1)-(0 if D==0 else 1))//2)%2==0:
   E=0
else:
   E=1
print(C^D^E)
"
"N, X, M = map(int, input().split())

if N < M:
    ans = 0
    val = X
    for i in range(N):
        ans += val
        val = (val%M)*(val%M)%M
        
    print(ans)
    exit()

until_start_loop = 0
loop_len = 0
cum_sum = [0]
until_start_loop_sum = 0
loop_sum = 0

ls = [0]*M
val = X
cnt = 0 #TimeStamp
while True:
    if ls[val]:
        until_start_loop = ls[val] - 1
        loop_len = cnt - until_start_loop
        # until_start_loop -= 1
        until_start_loop_sum = cum_sum[until_start_loop]
        loop_sum = cum_sum[cnt] - until_start_loop_sum
        break
    cnt += 1
    ls[val] = cnt
    cum_sum.append(cum_sum[-1] + val)
    val = (val%M)*(val%M)%M


how_many_loop = (N-until_start_loop)//(loop_len)
ans = until_start_loop_sum + how_many_loop * loop_sum
remained = N - how_many_loop * loop_len - until_start_loop
ans += cum_sum[until_start_loop + remained] - cum_sum[until_start_loop]
print(ans)"
"def main():
  n=int(input())
  for _ in range(n):
    if int(input())%2==1:
      print(""first"")
      return
  print(""second"")
main()"
"# -*- coding: utf-8 -*-
import sys
sys.setrecursionlimit(10**9)
INF=10**18
MOD=10**9+7
input=lambda: sys.stdin.readline().rstrip()
YesNo=lambda b: bool([print('Yes')] if b else print('No'))
YESNO=lambda b: bool([print('YES')] if b else print('NO'))
int1=lambda x:int(x)-1

def main():
    N=int(input())
    h=sum(list(map(int,list(str(N)))))
    YesNo(N%h==0)

if __name__ == '__main__':
    main()
"
"# no matter what in every operation u will be adding two to the sum of all the numbers
# check when 2*i is divisible by 3 and each no should be greater than the maximum
def main():
	a, b , c = map(int , input().split())
	if a==b and b==c:
		print(0)
	else:
		tot=0
		tot = tot+(a+b+c)
		mx = max(a, max(b, c))
		i = 0
		f=0
		while f==0:
			if((tot+2*i)%3==0):
				p = ((tot+2*i))//3
				if p>=mx:
					f=1
			i = i+1
		print(i-1)
if __name__==""__main__"":
	main()"
"import numpy as np
N, M, K = [int(_) for _ in input().split()]
mod = 998244353


class Factorial:
    def __init__(self, max_fact, mod):
        #mod should be prime number
        #using homogeneous_product(n,r), max_fact ≧ max(n+r-1)
        f = [1] * (max_fact + 1)
        for idx in range(2, max_fact + 1):
            f[idx] = f[idx - 1] * idx
            f[idx] %= mod
        if mod > max_fact:
            fi = [pow(f[-1], mod - 2, mod)]
            for idx in range(max_fact, 0, -1):
                fi += [fi[-1] * idx % mod]
            fi = fi[::-1]
        else:
            fi = [pow(n, mod - 2, mod) for n in f]
        self.mod = mod
        self.f = f
        self.fi = fi

    def factorial(self, n):
        return self.f[n]

    def factorial_inverse(self, n):
        return self.fi[n]

    def combination(self, n, r):
        f = self.f
        fi = self.fi
        return f[n] * fi[r] * fi[n - r] % self.mod

    def permutation(self, n, r):
        return self.f[n] * self.fi[n - r] % self.mod

    def homogeneous_product(self, n, r):
        f = self.f
        fi = self.fi
        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod


max_fact = N
fact_instance = Factorial(max_fact, mod)
comb = fact_instance.combination
ans = 0
for r in range(K + 1):
    ans += comb(N - 1, r) * M * pow(M - 1, N - r - 1, mod)
    ans %= mod
print(ans)
"
"s=list(input())
t=list(input())
l=[]
for i in range(len(s)-1):
    l.append(s[i])
    l.append(t[i])
if len(s)>len(t):
    l.append(s[len(s)-1])
else:
    l.append(s[len(s)-1])
    l.append(t[len(t)-1])

x=''.join(l)
print(x)"
"#! /usr/bin/env python3

import sys
import numpy as np
int1 = lambda x: int(x) - 1
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
sys.setrecursionlimit(500000)

A, B, C, K = map(int, readline().split())

print(A - B) if K % 2 == 0 else print(B - A)
"
"N = int(input())
A = [int(s) for s in input().split()]
S = [[0] * 20 for _ in range(N + 1)]
for i in range(1, N + 1):
    for j in range(20):
        S[i][j] = S[i-1][j] + (1 if A[i-1] & (1 << j) else 0)

ans = 0
i = 0
for j in range(N):
    while not all(S[j + 1][v] - S[i][v] < 2 for v in range(20)):
        i += 1
    ans += j + 1 - i
print(ans)
"
"import sys

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10 ** 8)
INF = float('inf')
MOD = 10 ** 9 + 7


def main():
    N = input()
    print('ABC'+N)

if __name__ == '__main__':
    main()
"
"N, A, B = [int(s) for s in input().split()]
X = [int(s) for s in input().split()]

d1 = [X[i+1] - X[i] for i in range(N-1)]
d2 = [min(d*A,B) for d in d1]

print(sum(d2))"
"#素因数分解して列挙する関数、約数列挙ではない！
from collections import Counter
def factorize(n):
    b = 2
    fct = []
    while b * b <= n:
        while n % b == 0:
            n //= b
            fct.append(b)
        b = b + 1
    if n > 1:
        fct.append(n)
    fct = Counter(fct)
    return fct

mod = 10**9+7
def comb_mod(n,r,mod):
    ans = 1
    for i in range(r):
        ans *= n-i
        ans %= mod
    for i in range(1,r+1):
        ans *= pow(i,mod-2,mod)
        ans %= mod
    return ans

N, M = map(int, input().split())
fact = factorize(M)
ans = 1
for k in fact.values():
    ans *= comb_mod(k+N-1,k,mod)
    ans %= mod
print(ans)"
"import math

n = int(input())

def koch(n,a,b): #a,b:tuple
    if n==0:
        return
    th = math.pi*60/180
    s = ((2*a[0]+b[0])/3,(2*a[1]+b[1])/3)
    t = ((a[0]+2*b[0])/3,(a[1]+2*b[1])/3)
    u = ((t[0]-s[0])*math.cos(th)-(t[1]-s[1])*math.sin(th)+s[0],(t[0]-s[0])*math.sin(th)+(t[1]-s[1])*math.cos(th)+s[1])

    koch(n-1,a,s)
    print(s[0],s[1])
    koch(n-1,s,u)
    print(u[0],u[1])
    koch(n-1,u,t)
    print(t[0],t[1])
    koch(n-1,t,b)

a = (0,0)
b = (100,0)
print(a[0],a[1])
koch(n,a,b)
print(b[0],b[1])
"
"h, w = map(int, input().split())
grid = [input() for _ in range(h)]

def check_row(grid):
    for i in range(len(grid)):
        if ""#"" not in grid[i]:
            return i
    return -1

def check_col(grid):
    grid_inv = []
    for i in range(len(grid[0])):
        grid_inv.append("""".join(row[i] for row in grid))
    return check_row(grid_inv)

while True:
    if check_row(grid) != -1:
        del grid[check_row(grid)]
        continue
    elif check_col(grid) != -1:
        d = check_col(grid)
        for i in range(len(grid)):
            grid[i] = grid[i][:d] + grid[i][d+1:]
    else:
        break

for g in grid:
    print(g)
"
"def fib(n):
    if n == 0 or n == 1:
        return 1
    if A[n] is not None:
        return A[n]
    A[n] = fib(n - 1) + fib(n - 2)
    return A[n]


A = [None] * (44 + 1)
n = int(input())
print(fib(n))"
"from __future__ import print_function

import sys

import re
import array
import copy
import functools
import operator

import math
import string
import fractions
from fractions import Fraction
from fractions import gcd
# fractions.gcd() を用いること
# math.log2()はatcoderでは対応していない．留意せよ．

import collections
import itertools
import bisect

import random
import time

import heapq
from heapq import heappush
from heapq import heappop
from heapq import heappushpop
from heapq import heapify
from heapq import heapreplace
from queue import PriorityQueue as pq
from queue import Queue

from itertools import accumulate

from collections import deque
from collections import Counter

from operator import mul
from functools import reduce

input = sys.stdin.readline


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
    return


def lcm(n, m):
    return int(n * m / gcd(n, m))


def coprimize(p, q):
    common = fractions.gcd(p, q)
    return (p // common, q // common)


def combinations_count(n, r):
    r = min(r, n - r)
    numer = reduce(mul, range(n, n - r, -1), 1)
    denom = reduce(mul, range(1, r + 1), 1)
    return numer // denom


def find_gcd(list_l):
    x = reduce(gcd, list_l)
    return x


def main():
    n,m = map(int,input().strip().split()) # nは行数 # mは列数
    if n>=2 and m>=2:
        print((n-2)*(m-2))
    elif n==1 and m==1:
        print(1)
    else:
        print(n*m-2)




if __name__ == '__main__':
    main()"
"import bisect

N,C = map(int,input().split())
STC = [list(map(int,input().split())) for _ in range(N)]
STC.sort(key=lambda x:x[1])
#print(STC)

P = {}
for p in STC:
  if p[2] not in P:
    P[p[2]] = [p[:2]]
  else:
    pe = P[p[2]][-1]
    if pe[1] == p[0]:
      P[p[2]][-1][1] = p[1]
    else:
      P[p[2]].append(p[:2])
#print(P)

P2 = []
maxt = 0
for val in P.values():
  for v in val:
    P2.append([v[0]-1,v[1]])
    maxt = max(maxt,v[1])
#print(P2)

T = [0 for _ in range(maxt+2)]
for p in P2:
  T[p[0]] += 1
  T[p[1]] -= 1
#print(T)
for i in range(1,maxt+2):
  T[i] += T[i-1]
#print(T)
print(max(T))
"
"n = input()
ans = 0
for i in n:
  if i=='9':
    ans += 1
if ans > 0:
  print(""Yes"")
else:
  print(""No"")"
"from fractions import gcd
def lcm(a,b): return a*b//gcd(a,b)
N=int(input())
ans=1
for i in range(N):
    t=int(input())
    ans=lcm(ans,t)
print(ans)
"
"from collections import*

class UnionFind:
    def __init__(self, n):
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        self.parents[x] = self.find(self.parents[x]) 
        return self.parents[x]  

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x
        
        self.parents[x] += self.parents[y]
        self.parents[y] = x

N, K, L = map(int, input().split())

road = UnionFind(N)
rail = UnionFind(N)

for i in range(K):
    p, q = map(int, input().split())
    road.union(p-1, q-1)
for i in range(L):
    p, q = map(int, input().split()) 
    rail.union(p-1, q-1)

d = defaultdict(int)

for i in range(N):
    d[(road.find(i), rail.find(i))] += 1
print(*[d[(road.find(i), rail.find(i))] for i in range(N)])"
"s = list(input())
top_count = s.count('o')
print(700+100*top_count)"
"import sys

def gcd(a,b):
    if(b):
        return gcd(b,(a%b))
    else:
        return a

def lcm(a,b):
    return a*b/gcd(a,b)

a = """"
for input in sys.stdin:
    a += input
l = a.split()
for i in range(0,len(l),2):
    if(int(l[i]) > int(l[i+1])):
        print gcd(int(l[i]),int(l[i+1])),lcm(int(l[i]),int(l[i+1]))
    else:
        print gcd(int(l[i+1]),int(l[i])),lcm(int(l[i+1]),int(l[i]))
"
"l=input()
n=len(l)
mod=10**9+7
dp=[[0]*2 for i in range(n+1)]
dp[0][0]=1
for i in range(1,n+1):
  dp[i][1]+=dp[i-1][1]*3
  if l[i-1]=='1':
    dp[i][0]+=2*dp[i-1][0]
    dp[i][1]+=dp[i-1][0]
  else:
    dp[i][0]+=dp[i-1][0]
  dp[i][0]%=mod
  dp[i][1]%=mod
print((dp[i][0]+dp[i][1])%mod)"
"while True:
    [n, m] = [int(x) for x in raw_input().split()]
    if [n, m] == [0, 0]:
        break

    hoge = range(1, n + 1)

    data = []
    for x in range(0, n - 2):
        for y in range(x + 1, n - 1):
            for z in range(y + 1, n):
                s = hoge[x] + hoge[y] + hoge[z]
                if s == m:
                    data.append(s)

    print(len(data))"
"X=int(input())

p = X % 100
q = p // 5
r = p % 5
ans = q
if r > 0:
    ans += 1
ans = ans * 100 + p
if X >= ans:
    print(1)
else:
    print(0)"
"def main():
    n = int(input())
    xy = []
    for i in range(n):
        a = int(input())
        xy.append([tuple(map(int, input().split())) for _ in range(a)])

    c = 0
    for i in range(1 << n):
        popcnt = bin(i).count('1')
        if popcnt <= c:
            continue
        all_honest = True
        for j in range(n):
            if (1 << j) & i != 0:
                for x, y in xy[j]:
                    x -= 1  # 人の番号をひとつずらす
                    if ((1 << x) & i) >> x != y:
                        all_honest = False
                        break
            if not all_honest:
                break
        if all_honest:
            c = popcnt

    print(c)


if __name__ == '__main__':
    main()
"
"n = int(input())
A = [int(input()) for _ in range(n)]
cnt = 0
G = [797161,265720,88573,29524,9841,3280,1093,364,121,40,13,4,1]
G = [v for v in G if v <= n]
m = len(G)
def insertionSort(A, n, g):
    global cnt
    for i in range(g, n):
        v = A[i]
        j = i - g
        while j >= 0 and A[j] > v:
            A[j+g] = A[j]
            j = j - g
            cnt += 1
        A[j+g] = v
for g in G:
    insertionSort(A, n, g)
print(m)
print(*G)
print(cnt)
print(*A, sep='\n')
"
"N = int(input())

A = list(map(int, input().split()))

tmp = 0
for i in range(N):
    tmp = A[i] * 2 - tmp

tmp //= 2
ans = []
for i in range(N):
    ans.append(tmp)
    tmp = A[i] * 2 - tmp

print(*ans)"
"import sys
import math
import bisect
def input():
    return sys.stdin.readline()[:-1]
n,k = map(int,input().split())
a = list(map(int,input().split()))
ans = 0
keta = 0
lis = []

tt = k
num=0
while tt!=0:
    tt//=2
    num+=1

if k==0:
    num=1
num=48
for _ in range(num):
    tmp = 0
    for i in range(n):
        if a[i]%2==0:
            tmp+=1
        a[i]//=2
    lis.append([tmp,n-tmp])
    keta+=1
dp = [[0 for i in range(2)]for i in range(num+1)]
dp[0][0]=0
for i in range(1,num+1):
    jum = k>>(num-i)&1
    dp[i][0] += dp[i-1][0]+lis[num-i][1-jum]*2**(num-i)
    if dp[i-1][1] and jum==0:
        dp[i][1] += dp[i-1][1]+max(lis[num-i])*2**(num-i)
    elif dp[i-1][1] and jum==1:
        dp[i][1] += max(dp[i-1][1]+max(lis[num-i])*2**(num-i),dp[i-1][0]+lis[num-i][jum]*2**(num-i))
    elif dp[i-1][1]==0 and jum==1:
        dp[i][1] += dp[i-1][0]+lis[num-i][jum]*2**(num-i)

print(max(dp[-1]))
"
"import sys
from math import factorial
MOD = 10**9+7
h, w, k = [int(i) for i in sys.stdin.readline().split()]
# memo_ls[n] : n本の平行線に対し、あみだくじの条件を満たす組み合わせの数
memo_ls2 = [[0 for x in range(2)] for y in range(8)]
memo_ls2[1][0] = 1
for i in range(2,8):
    memo_ls2[i][0] = memo_ls2[i-1][1] + memo_ls2[i-1][0]
    memo_ls2[i][1] = memo_ls2[i-1][0]
memo_ls = [sum(i) for i in memo_ls2]
# memo_ls3[j][i] : j番目にiにいる通り数
memo_ls3 = [[0 for i in range(w)] for j in range(h+1)]
memo_ls3[0][0] = 1
for j in range(1,h+1):
    for i in range(w):
        if i > 0:
            memo_ls3[j][i] += memo_ls3[j-1][i-1] * memo_ls[max(1, i-1)] * memo_ls[max(1, w-1-i)]
        if i < w-1:
            memo_ls3[j][i] += memo_ls3[j - 1][i + 1] * memo_ls[max(1, i)] * memo_ls[max(1, w-i-2)]
        memo_ls3[j][i] += memo_ls3[j-1][i] * memo_ls[max(1, i)] * memo_ls[max(1, w-i-1)]
        memo_ls3[j][i] %= MOD
print(memo_ls3[-1][k-1])"
"from collections import Counter,defaultdict,deque
from heapq import heappop,heappush,heapify
import sys,bisect,math,itertools,fractions
from decimal import Decimal
sys.setrecursionlimit(10**8)
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n,m,K = inpl()
s = [input() for _ in range(n)]
res = INF
for pat in itertools.product([0,1], repeat=n-1):
    pat = list(pat) + [0]
    group = []
    tmp = []
    for i,j in enumerate(pat):
        tmp += [i]
        if j or i == n-1:
            group += [tmp]
            tmp = []
    
    ln = len(group)
    white = [[0]*ln for _ in range(m)]
    ccc = set()
    cnt = pat.count(1) 
    ok = True
    for i in range(m):
        for j,z in enumerate(group):
            for k in z:
                if s[k][i] == '1':
                    white[i][j] += 1
            if max(white[i]) > K:
                ok = False
                break
    if not ok: continue
    
    now = [0] * ln
    for i in range(m):
        ok = True
        for j in range(ln):
            if now[j] + white[i][j] > K:
                ok = False
                break
        if ok:
            for j in range(ln):
                now[j] += white[i][j]
        else:
            cnt += 1
            for j in range(ln):
                now[j] = white[i][j]
    res = min(res, cnt)
print(res)"
"n, m = map(int, input().split())
py = [list(map(int, input().split())) for i in range(m)]
c = [0]*(n + 1)
id = {}

for p, y in sorted(py, key = lambda x: x[1]):
    c[p] += 1
    id[y] =  format(p, ""06"") + format(c[p], ""06"")

for p, y in py:
    print(id[y])"
"import sys
input = sys.stdin.readline

def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))

def main():
    mod=10**9+7
    N,a,b=MI()
    M=2*(10**5) + 5
    def cmb(n, r):
        if n - r < r: r = n - r
        if r == 0: return 1
        if r == 1: return n

        numerator = [n - r + k + 1 for k in range(r)]
        denominator = [k + 1 for k in range(r)]

        for p in range(2,r+1):
            pivot = denominator[p - 1]
            if pivot > 1:
                offset = (n - r) % p
                for k in range(p-1,r,p):
                    numerator[k - offset] /= pivot
                    denominator[k] /= pivot

        result = 1
        for k in range(r):
            if numerator[k] > 1:
                result *= int(numerator[k])
                result%=mod

        return result
        
    ans=pow(2,N,mod)-1
    ans-=cmb(N,a)
    ans-=cmb(N,b)
    
    print(ans%mod)

main()
"
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
read = sys.stdin.buffer.read
sys.setrecursionlimit(10 ** 7)
INF = float('inf')

A = int(input())
B = int(input())

if A > B:
    print(""GREATER"")
elif A < B:
    print(""LESS"")
else:
    print(""EQUAL"")
"
"import numpy as np
N=input()
M=input()
ans = 0
for i in range(3):
  if N[i]==M[i]:
    ans += 1
print(ans)"
"import sys
from math import gcd
from itertools import combinations


def main():
    input = sys.stdin.buffer.readline
    k = int(input())
    dp = [1]*(k+1)
    for i in range(2, k+1):
        dp[i] = dp[i-1]+i
        for e in combinations(range(1, i), 2):
            dp[i] += 6*gcd(gcd(e[0], e[1]), i)
        for j in range(1, i):
            dp[i] += 6*gcd(i, j)
    print(dp[k])


if __name__ == '__main__':
    main()
"
"def roll(l, command):
    '''
    return rolled list

    l : string list
    command: string
    '''
    res = []
    i = -1
    if command =='N':
        res = [l[i+2], l[i+6], l[i+3], l[i+4], l[i+1], l[i+5]]
    if command =='S':
        res = [l[i+5], l[i+1], l[i+3], l[i+4], l[i+6], l[i+2]]
    if command =='E':
        res = [l[i+4], l[i+2], l[i+1], l[i+6], l[i+5], l[i+3]]
    if command =='W':
        res = [l[i+3], l[i+2], l[i+6], l[i+1], l[i+5], l[i+4]]

    return res

faces = input().split()
commands = list(input())

for command in commands:
    faces = roll(faces, command)

print(faces[0])

"
"a, b = [int(i) for i in input().split()]
tmp = a + b
if tmp >= 24:
  print(tmp % 24)
else:
  print(tmp)"
"""""""Boot-camp-for-Beginners_Easy007_B_Bingo_25-August-2020.py""""""
import numpy as np
import sys

A = list(list(map(int, input().split())) for i in range(3))
N = int(input())
b = list(int(input()) for i in range(N))

MARK = []
for k in range(N):
    for i in range(3):
        for j in range(3):
            if(A[i][j] == b[k]):
                MARK.append([i-1, j-1])
# print(MARK)
count_row_m1, count_row_0, count_row_p1, count_column_m1, count_column_0, count_column_p1, count_backslash, count_slash = 0, 0, 0, 0, 0, 0, 0, 0
for k in range(len(MARK)):
    if MARK[k][0] == -1:
        count_column_m1 += 1
    elif MARK[k][0] == 0:
        count_column_0 += 1
    else:
        count_column_p1 += 1

    if MARK[k][1] == -1:
        count_row_m1 += 1
    elif MARK[k][1] == 0:
        count_row_0 += 1
    else:
        count_row_p1 += 1

    if MARK[k][0] == MARK[k][1]:
        count_backslash += 1
    if MARK[k][0] == -MARK[k][1]:
        count_slash += 1
bingo = count_row_m1 >= 3 or count_row_0 >= 3 or count_row_p1 >= 3 or count_column_m1 >= 3 or count_column_0 >= 3 or count_column_p1 >= 3 or count_backslash >= 3 or count_slash >= 3
""""""
print(""count_column_m1"", count_column_m1)
print(""count_column_0"", count_column_0)
print(""count_column_p1"", count_column_p1)
print(""count_row_m1"", count_row_m1)
print(""count_row_0"", count_row_0)
print(""count_row_p1"", count_row_p1)
print(""count_backslash"", count_backslash)
print(""count_slash"", count_slash)
""""""
if bingo == True:
    print(""Yes"")
else:
    print(""No"")
"
"#%%
import sys
def input():
    return sys.stdin.readline().rstrip()

def main():
    X, A = map(int, input().split())
    print(0) if X < A else print(10)

# %%
if __name__ == '__main__':
    main()

# %%
# from atcoder_test import doTest
# doTest(""abc130"",""a"",main)"
"h,w,m=map(int,input().split())

st=set()
h_b=[0 for i in range(h)]
w_b=[0 for i in range(w)]
for i in range(m):
  th,tw=map(int,input().split())
  th-=1
  tw-=1
  st.add((th,tw))
  h_b[th]+=1
  w_b[tw]+=1

h_max=max(h_b)
w_max=max(w_b)

h_cand=[i for i in range(h) if h_b[i]==h_max]
w_cand=[i for i in range(w) if w_b[i]==w_max]

for i in h_cand:
  for j in w_cand:
    if (i,j) not in st:
      print(h_max+w_max)
      exit()

print(h_max+w_max-1)"
"A, B, C, X, Y = map(int, input().split())
P = []

for i in range(0, max(X, Y)+1):
    if min(X, Y)-i >= 0:
        P.append(A*(X-i) + B*(Y-i) + 2*C*i)
    else:
        if X > Y:
            P.append(A*(X-i) + 2*C*i)
        else:
            P.append(B*(Y-i) + 2*C*i)

print(min(P))
"
"from collections import deque
import numpy as np
N,K = (int(x) for x in input().split())
S = input()
count = []
d = deque(list(S))

now = d.popleft()
cum = 1
for i in range(len(S)-1):
    popped = d.popleft()
    if popped == now:
        cum += 1
    else:
        count.append(cum)
        now = popped
        cum = 1
count.append(cum)
points = [i-1 for i in count]
cs1 = np.array(count).cumsum()
cs2 = np.array(points).cumsum()

if len(count) // 2 <= K:
    print(N-1)
else:
    m = 0
    for i in range(len(count)-2*K):
        if i == 0:
            c = cs1[2*K] - 1
            d = cs2[-1] - cs2[2*K]
        elif i == len(count) - 2*K + 1:
            c = cs1[-1] - cs1[-2*K-2] - 1
            d = cs2[-2*K-2]
        else:
            c = cs1[2*K+i] - cs1[i-1] - 1
            d = cs2[i-1] + (cs2[-1]-cs2[2*K+i])
        m = max(m,c+d)
    print(m)"
"if 2 in list(map(int,input().split())):
    print('No')
else:
    print('Yes')
"
"N = int(input())
T, A = map(int, input().split())
H = list(map(int, input().split()))

index = 0
ans = 10**10
for i in range(N):
  tmp = T - 0.006*H[i]
  if ans > abs(A-tmp):
    ans = abs(A-tmp)
    index = i+1
print(index)
"
"import math


n,a,b=map(int,input().split())
mod=10**9+7

c1=1
c2=1

for i in range(n-a+1,n+1):
    c1*=i
    c1%=mod
for j in range(1,a+1):
    c1*=pow(j,mod-2,mod)
    c1%=mod
    
for i in range(n-b+1,n+1):
    c2*=i
    c2%=mod
for j in range(1,b+1):
    c2*=pow(j,mod-2,mod)
    c2%=mod

ans=pow(2,n,mod)-1

print((ans-c1-c2)%mod)
"
"N = int(input())
S = input()
flag = True if N % 2==0 else False

for i in range(N//2):
    if S[i] != S[N//2 + i]:
        flag = False
if flag:
    print(""Yes"")
else:
    print(""No"")
"
"import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush
    
input = sys.stdin.readline
def RD(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]
    
    
def main():
    X, Y = MI()
    
    exist = False
    for x1 in range(0, X+1):
        y1 = Y - 2 * x1
        if x1 + 2 * y1 == X:
            exist = True
            break
    if not exist:
        print(0)
        sys.exit()

    def cmb(n, r, mod):
        if ( r<0 or r>n ):
            return 0
        r = min(r, n-r)
        return g1[n] * g2[r] * g2[n-r] % mod

    #出力の制限
    mod = 1000000007
    N = 10**6
    g1 = [1, 1] # 元テーブル
    g2 = [1, 1] #逆元テーブル
    inverse = [0, 1] #逆元テーブル計算用テーブル

    for i in range( 2, N + 1 ):
        g1.append( ( g1[-1] * i ) % mod )
        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )
        g2.append( (g2[-1] * inverse[-1]) % mod )

    a = cmb(x1+y1,y1,mod)
    print(a)
    
if __name__ == ""__main__"":
    main()"
"n, a, b = map(int, input().split())
x = list(map(int, input().split()))
ans = 0

for i in range(len(x)-1):
    here = x[i]
    there = x[i+1]
    if (there - here) * a < b:
        ans += (there - here) * a
    else:
        ans += b

print(ans)


"
"# coding:UTF-8
import sys
from math import factorial

MOD = 998244353
INF = 10000000000

def main():
    n, k = list(map(int, input().split()))  # スペース区切り連続数字
    lrList = [list(map(int, input().split())) for _ in range(k)]  # スペース区切り連続数字(行列)

    s = []
    for l, r in lrList:
        for i in range(l, r+1):
            s.append(i)
    s.sort()

    sum = [0] * (n + 1)
    Interm = [0] * (2 * n + 1)
    sum[1] = 1
    for i in range(1, n):
        for j in range(k):
            l, r = lrList[j][0], lrList[j][1]
            Interm[i+l] += sum[i]
            Interm[i+r+1] -= sum[i]
        sum[i+1] = (sum[i] + Interm[i+1]) % MOD

    # result = Interm[n]
    result = (sum[n] - sum[n-1]) % MOD
    # ------ 出力 ------#
    print(""{}"".format(result))

if __name__ == '__main__':
    main()
"
"n=int(input())
a=[]
for i in range(n):
  a.append(int(input()))
b=sorted(a,reverse=True)
a1=b[0]
a2=b[1]
m=a.index(a1)
for i in range(n):
  if i==m:
    print(a2)
  else:
    print(a1)"
"print(""{:.10f}"".format(int(input())**3 / 27))
"
"n=int(input())
j=10501
l=[0 for i in range(j)]
for x in range(1,101):
  for y in range(1,101):
    for z in range(1,101):
      v=x*x+y*y+z*z+y*x+x*z+z*y
      if(v<j):
        l[v]+=1
for i in range(n):
  print(l[i+1])"
"while True:
    s = input()
    if s == ""0"":
        break
    nums = list(s)
    goukei = 0
    for i in range(len(nums)):
        goukei += int(nums[i])
    print(goukei)"
"import collections

L = [3,5,7]
Q = collections.deque(L)
A = []


for i in range (0, 40000):
	V = Q.popleft()
	A.append(V)
	Q.append(V*10+3)
	Q.append(V*10+5)
	Q.append(V*10+7)

import bisect

D = []

for i in range (0, 40000):
	V = str(A[i])
	if V.count('3') > 0 and V.count('5') > 0 and V.count('7') > 0:
		D.append(int(V))

N = int(input())
print(bisect.bisect_right(D, N))"
"import math
while True:
	try:
		a, b = map(int, input().split())
		print(int(math.gcd(a,b)),(a*b) // int(math.gcd(a,b)))
	except:
		break
"
"#!/usr/bin/env python3
import sys


def solve(A: int, B: int, C: int, K: int):
    if K % 2 == 1:
        print(B-A)
    else:
        print(A-B)


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    A = int(next(tokens))  # type: int
    B = int(next(tokens))  # type: int
    C = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    solve(A, B, C, K)

if __name__ == '__main__':
    main()
"
"H, W = map(int, input().split())
grid = [input() for _ in range(H)]
dp = [[float('inf')] * W for i in range(H)]
dp[0][0] = 1 if grid[0][0] == '#' else 0

for i in range(H):
    for j in range(W):
        for y, x in ((1,0), (0,1)):
            ni, nj = i + y, j + x
            if ni >= H or nj >= W:
                continue
            c = 0
            if grid[ni][nj] == '#' and grid[i][j] == '.':
                c = 1
            dp[ni][nj] = min(dp[ni][nj], dp[i][j] + c)

print(dp[H-1][W-1])"
"def resolve():
	ins = []
	for _ in range(4):
		ins.append(int(input()))
	n, k, x, y = ins
	if n - k and n > k:
		print(x*k + y*(n-k))
	else:
		print(x*n)
        
resolve()"
"n = int(input())
if n < 105:
  print(0)
elif n < 135:
  print(1)
elif n < 165:
  print(2)
elif n < 189:
  print(3)
elif n < 195:
  print(4)
else:
  print(5)"
"while True:
    a=str(raw_input())
    if a==""0"": break
    print(sum([int(i) for i in a]))"
"def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10**7)
    from collections import Counter, deque
    #from collections import defaultdict
    from itertools import combinations, permutations, accumulate
    #from itertools import product
    from bisect import bisect_left,bisect_right
    import heapq
    from math import floor, ceil
    #from operator import itemgetter

    #inf = 10**17
    #mod = 10**9 + 7

    x,y,z,n = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    c = list(map(int, input().split()))
    a.sort(reverse=1)
    b.sort(reverse=1)
    c.sort(reverse=1)
    res = []
    hq = [[-(a[0]+b[0]+c[0]), 0, 0, 0]]
    heapq.heapify(hq)
    check = set([(0, 0, 0)])
    for _ in range(n):
        cost, i, j, k = heapq.heappop(hq)
        res.append(-cost)
        if i+1<x and not (i+1, j, k) in check:
            heapq.heappush(hq, [-(a[i+1]+b[j]+c[k]), i+1, j, k])
            check.add((i+1, j, k))
        if j+1<y and not (i, j+1, k) in check:
            heapq.heappush(hq, [-(a[i]+b[j+1]+c[k]), i, j+1, k])
            check.add((i, j+1, k))
        if k+1<z and not (i, j, k+1) in check:
            heapq.heappush(hq, [-(a[i]+b[j]+c[k+1]), i, j, k+1])
            check.add((i, j, k+1))
    for i in res:
        print(i)

if __name__ == '__main__':
    main()"
"s = input()
o = ['R','U','D']
e = ['L','U','D']
ans = 'Yes'
for i in range(len(s)):
    if i % 2 == 0:
        if s[i] not in o:
            ans = 'No'
    else:
        if s[i] not in e:
            ans = 'No'
print(ans)"
"n,m = map(int,input().split())
h =  list(map(int,input().split()))

goto = [[0] for _ in range(n)]

cnt = 0

for i in range(m):
    a,b = map(int,input().split())
    goto[a-1] += [h[b-1]]
    goto[b-1] += [h[a-1]]

for j in range(n):
    if max(goto[j])< h[j]:
        cnt += 1

print(cnt)
"
"def check(pt, brackets):
    brackets.sort(reverse=True)
    for m, t in brackets:
        if pt + m < 0:
            return -1
        pt += t
    return pt


n = int(input())
brackets_p = []  # (始めを0として、( = +1, ) = -1 として、最後はいくつか, 途中の最小値はいくつか)
brackets_m = []
pt = 0
mt = 0
for _ in range(n):
    s = input()
    total = 0
    mini = 0
    for c in s:
        if c == '(':
            total += 1
        else:
            total -= 1
            mini = min(mini, total)

    if total >= 0:
        if mini == 0:
            pt += total
        else:
            brackets_p.append((mini, total))
    else:
        total, mini = -total, mini - total
        if mini == 0:
            mt += total
        else:
            brackets_m.append((mini, total))

pt = check(pt, brackets_p)
mt = check(mt, brackets_m)

if (pt == -1) or (mt == -1) or (pt != mt):
    print('No')
else:
    print('Yes')
"
print(int(input()) ^ 0x01)
"n = int(input())
s = input()

result = 0
for i in range(1000):
    i = str(i).zfill(3)
    # print(i)
    # print(s.find(i[0]), s.find(i[1]), s.find(i[2]))
    index0 = s.find(i[0])
    if -1 < index0:
        index1 = s.find(i[1], index0+1)
        if -1 < index1:
            index2 = s.find(i[2], index1+1)
            if -1 < index2:
                # print(i, 'あたり')
                result += 1

print(result)"
"N, K = map(int, input().split())
V = [0]*N
*V, = map(int, input().split())

ans = []
for i in range(N+1):
    for j in range(N+1):
        if i+j > min(N, K): continue
        out = V[:i] + V[N-j:]
        out.sort()
        r = 0
        while i+j+r < K and r < len(out):
            if out[r] < 0: r += 1
            else: break
        ans.append(sum(out[r:]))

print(max(ans))"
"def show(array):
    for i in range(len(array)):
        if i != len(array) - 1:
            print(array[i], end=' ')
        else:
            print(array[i])


def selectionSort(array):
    count = 0 
    for i in range(len(array)):
        minj = i 
        flag = False
        for j in range(i, len(array)):
            if array[j] < array[minj]:
                minj = j 
                flag = True
        if flag and i != minj:
            array[i], array[minj] = [array[minj], array[i]]
            count += 1
    
    show(array)
    print(count)
    

input()
array = [int(x) for x in input().split()]
selectionSort(array)


"
"a=int(input())
s=input()
print((a<3200)*'red' or s)"
"from collections import defaultdict
import sys


def input(): return sys.stdin.readline().rstrip()


r, c, K = map(int, input().split())

dp = [[[0]*(c+1) for _ in range(r+1)] for i in range(4)]

# dp[N][i][j] := (i,j) にN個目でたどりつく方法
d = [[0 for i in range(c+1)] for j in range(r+1)]

for _ in range(K):
    r_, c_, v = map(int, input().split())
    d[r_][c_] = v
for i in range(1, r+1):
    for j in range(1, c+1):
        v = d[i][j]
        if v > 0:
            maxi = max(dp[k][i-1][j] for k in range(4))
            dp[0][i][j] = max(maxi, dp[0][i][j-1])
            dp[1][i][j] = max(dp[1][i][j-1], dp[0][i][j-1]+v, maxi+v)
            dp[2][i][j] = max(dp[2][i][j-1], dp[1][i][j-1]+v)
            dp[3][i][j] = max(dp[3][i][j-1], dp[2][i][j-1]+v)

        elif v == 0:
            maxi = max(dp[k][i-1][j] for k in range(4))
            dp[0][i][j] = max(dp[0][i][j-1], maxi)
            dp[1][i][j] = dp[1][i][j-1]
            dp[2][i][j] = dp[2][i][j-1]
            dp[3][i][j] = dp[3][i][j-1]


ans = max(dp[k][r][c] for k in range(4))

print(ans)"
"N = int(input())
L = list(map(lambda l: int(l), input().split("" "")))
L.sort()

print(""Yes"") if L[-1] < sum(L[:-1]) else print(""No"")"
"s = list(input())
k = int(input())
ans = 0
count = 1
for i in range(len(s)-1):
    if s[i] == s[i+1]:
        count += 1
    else:
        ans += count//2
        count = 1
ans += count//2
if len(set(s)) == 1:
    print(len(s)*k//2)
    exit()
if s[0] != s[-1]:
    ans *= k
else:
    left = 0
    right = 0
    index = 0
    while index < len(s) and s[0] == s[index]:
        left += 1
        index += 1
    index = len(s)-1
    while index >= 0 and s[-1] == s[index]:
        right += 1
        index -= 1
    ans *= k
    ans -= ((right//2) + (left//2) - (right + left)//2) * (k-1)
print(ans)"
"from itertools import permutations
import sys
input = sys.stdin.readline

def main():
    N, M, RR = map(int, input().split())
    R = list(map(int, input().split()))
    INF = float(""inf"")
    T = [[INF] * N for _ in range(N)]
    for _ in range(M):
        a, b, c = tuple(map(int, input().split()))
        T[a-1][b-1] = c
        T[b-1][a-1] = c
    for k in range(N):
        for i in range(N):
            for j in range(N):
                if T[i][j] > T[i][k]+T[k][j]:
                    T[i][j] = T[i][k]+T[k][j]
    ans = INF
    for rs in permutations(R):
        cost = 0
        for i in range(RR-1):
            cost += T[rs[i]-1][rs[i+1]-1]
        ans = min(ans, cost)
    print(ans)

if __name__ == ""__main__"":
    main()"
"N = int(input())
A = list(map(int,input().split()))
m = min(A)
n = 0
while m != n:
    m = min(A)
    a = [m]
    for i in A:
        i %= m
        if i != 0:
            a.append(i)
    A = a
    n = min(A)
print(n)"
"n,m=list(map(int,input().split()))
mat=[]
for i in range(n):
	mat.append(list(map(int,input().split())))

vec=[]
for i in range(m):
	vec.append(int(input()))

res=[]
for i in range(n):
	c=0
	for j in range(m):
		c+=mat[i][j]*vec[j]
	res.append(c)
for i in res:
	print(i)"
"a,b=map(int,input().split("" ""))
print(max(0,a-b+1))"
"n,d = map(int,input().split())
ans = 0
for _ in range(n) :
    x,y = map(int,input().split())
    distance = (x**2 + y**2)**0.5
    if distance <= d :
        ans += 1
print(ans)"
"cards = [
'S 1', 'S 2', 'S 3', 'S 4', 'S 5', 'S 6', 'S 7', 'S 8', 'S 9', 'S 10', 'S 11', 'S 12', 'S 13',
'H 1', 'H 2', 'H 3', 'H 4', 'H 5', 'H 6', 'H 7', 'H 8', 'H 9', 'H 10', 'H 11', 'H 12', 'H 13',
'C 1', 'C 2', 'C 3', 'C 4', 'C 5', 'C 6', 'C 7', 'C 8', 'C 9', 'C 10', 'C 11', 'C 12', 'C 13',
'D 1', 'D 2', 'D 3', 'D 4', 'D 5', 'D 6', 'D 7', 'D 8', 'D 9', 'D 10', 'D 11', 'D 12', 'D 13'
]

n = int(input())
for i in range(n):
    card = input()
    cards.remove(card)

for i in cards:
    print(i)"
"from functools import reduce
from math import gcd 

n = int(input())
A = list(map(int, input().split()))

def furui(x):
    memo = [0]*(x+1)
    primes = []
    for i in range(2, x+1):
        if memo[i]: continue
        primes.append(i)
        memo[i] = i
        for j in range(i*i, x+1, i):
            if memo[j]: continue
            memo[j] = i
    return memo, primes

memo, primes = furui(10**6+5)

pr = [True]*(10**6+5)
for a in A:
    if a == 1: continue
    while a != 1:
        w = memo[a]
        if not pr[w]:
            break
        pr[w] = False
        while a%w == 0:
            a = a // w
    else:
        continue
    break
else:
    print('pairwise coprime')
    exit()

if reduce(gcd, A) == 1:
    print('setwise coprime')
else:
    print('not coprime')
"
"import sys


def solve():
    input = sys.stdin.readline
    mod = 10 ** 9 + 7
    n, k = list(map(int, input().rstrip('\n').split()))
    a = list(map(int, input().rstrip('\n').split()))
    ls = [0] * 45
    for v in a:
        d = 0
        while True:
            bt = v >> d
            if bt != 0:
                ls[d] += bt & 1
                d += 1
            else:
                break
    t = 0
    for i in range(44, -1, -1):
        if n / 2 >= ls[i]:
            t += 2 ** i
            if t > k:
                t -= 2 ** i
    ans = 0
    for v in a:
        ans += v ^ t
    print(ans)


if __name__ == '__main__':
    solve()
"
"import sys
sys.setrecursionlimit(10**5)

n, x = map(int, input().split())

def func(x, n):
    if n == 0:
        return 1
    if x <= 1:
        return 0
    elif 2 <= x <= 2**(n+1)-2:
        return func(x-1, n-1)
    elif x == 2**(n+1)-1:
        return 2**n-1+1
    elif 2**(n+1) <= x:
        return 2**n-1+1+func(x-(2**(n+1)-1), n-1)

print(func(x, n))
"
"n = list(map(int, list(input())))
k = int(input())
l = len(n)

ans = 0
if k == 1:
    ans = n[0] + (l - 1) * 9
elif k == 2:
    if l == 1:
        ans = 0
    else:
        for i in range(l - 1):
            p = True
            for j in range(i + 1, l):
                if i == 0 and p:
                    ans += (n[i] - 1) * 9 + n[j]
                elif i == 0:
                    ans += n[i] * 9
                else:
                    ans += 9 * 9
                if n[j] != 0:
                    p = False
else:
    if l <= 2:
        ans = 0
    else:
        for i in range(l - 2):
            p1 = True
            for j in range(i + 1, l - 1):
                p2 = True
                for k in range(j + 1, l):
                    if i == 0 and p1 and p2:
                        ans += (n[i] - 1) * 9 * 9
                        ans += (n[j] - 1) * 9 + n[k] if n[j] != 0 else 0
                    elif i == 0 and p1 and not p2:
                        ans += (n[i] - 1) * 9 * 9 + n[j] * 9
                    elif i == 0 and not p1:
                        ans += n[i] * 9 * 9
                    else:
                        ans += 9 * 9 * 9
                    if n[k] != 0:
                        p2 = False
                if n[j] != 0:
                    p1 = False
print(ans)
"
"k = int(input())
a = list(map(int,input().split()))
ansmax = 2
ansmin = 2

for i in reversed(range(k)):
    if ansmax - ansmin < a[i] and (ansmin%a[i])*(ansmax%a[i]) != 0 and (ansmax%a[i]) >= (ansmin%a[i]):
        print(-1)
        exit()
    ansmin = -(-ansmin//a[i])*a[i]
    ansmax = (ansmax//a[i])*a[i] + a[i] - 1
print(str(ansmin) + "" "" + str(ansmax))
"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    N = int(readline())
    S = readline().strip()

    dp = [0] * (N + 1)
    ans = 0

    for i in range(N - 1, -1, -1):
        for j in range(i + 1, N):
            if S[i] == S[j]:
                dp[j] = dp[j + 1] + 1
                if ans < min(dp[j], j - i):
                    ans = min(dp[j], j - i)
            else:
                dp[j] = 0

    print(ans)
    return


if __name__ == '__main__':
    main()
"
"from sys import setrecursionlimit
setrecursionlimit(10 ** 5)

def find(parent, i):
    t = parent[i]
    if t < 0:
        return i
    t = find(parent, t)
    parent[i] = t
    return t


def unite(parent, i, j):
    i = find(parent, i)
    j = find(parent, j)
    if i == j:
        return
    parent[j] += parent[i]
    parent[i] = j

n, m, k = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(m)]
cd = [list(map(int, input().split())) for _ in range(k)]

parent = [-1] * n
friends = [[] for _ in range(n)]

for a, b in ab:
    unite(parent, a-1, b-1)
    friends[a-1].append(b-1)
    friends[b-1].append(a-1)
    
blocks = [[] for _ in range(n)]
for c, d in cd:
    blocks[c-1].append(d-1)
    blocks[d-1].append(c-1)

result = []

for i in range(n):
    p = find(parent, i)
    t = -parent[p] - 1
    t -= len(friends[i])
    for b in blocks[i]:
        if p == find(parent, b):
            t -= 1
    result.append(t)
    
print(*result)"
"n = int(input())
xy = []
for _ in range(n):
    xy.append(list(map(int, input().split())))

tmp1 = []
tmp2 = []
for i in range(n):
    tmp1.append([xy[i][0]+xy[i][1], xy[i][0], xy[i][1]])
    tmp2.append([xy[i][0]-xy[i][1], xy[i][0], xy[i][1]])
tmp1.sort()
tmp2.sort()

if n <= 10:
    ii = n
    jj = n+1
else:
    ii = 10
    jj = 10

ans = 0
for i in range(ii):
    for j in range(1, jj):
        if (tmp1[-j][2]-tmp1[i][2])*(tmp1[-j][1]-tmp1[i][1]) >= 0:
            tmp = tmp1[-j][0]-tmp1[i][0]
            ans = max(tmp, ans)
        if (tmp2[-j][2]-tmp2[i][2])*(tmp2[-j][1]-tmp2[i][1]) <= 0:
            tmp = tmp2[-j][0]-tmp2[i][0]
            ans = max(tmp, ans)

print(ans)"
"n,m=map(int,input().split())

d={}
for i in range(m):
    p,y=map(int, input().split())
    if p not in d:
        d[p]=[[y,p,i]]
    else:
        d[p].append([y,p,i])

bango_list=['0']*m
for key in d:
    d[key].sort()
    for i in range(len(d[key])):
        p_bango=str(key).zfill(6)
        x_bango=str(i+1).zfill(6)
        bango_list[d[key][i][2]]=p_bango+x_bango

for b in bango_list:
    print(b)
"
"n,c=map(int,input().split())
d=[]
for i in range(c):
    d.append(list(map(int,input().split())))
l=[]
for i in range(n):
    l.append(list(map(int,input().split())))
p=[[0 for j in range(c)] for i in range(3)]
for i in range(n):
    for j in range(n):
        p[(i+1+j+1)%3][l[i][j]-1]+=1
ans=10**10
for i in range(c):
    for j in range(c):
        for k in range(c):
            if i!=j and i!=k and j!=k:
                t=0
                for x in range(c):
                    t+=d[x][i]*p[0][x]
                    t+=d[x][j]*p[1][x]
                    t+=d[x][k]*p[2][x]
                ans=min(ans,t)
print(ans)   "
"a,b = list(map(int,input().split()))

ans = -1

for i in range(1,10100):
  if i // 12.5== a and i // 10 == b:
    ans = i
    break

print(ans)"
"import sys
input=lambda: sys.stdin.readline().rstrip()
x=int(input())
print(9-(x-200)//200)"
"n = input()
s , t=input().split()
print(*[s + t for s, t in zip(s, t)],sep='')"
"n=int(input())
w=[int(x) for x in input().rstrip().split()]
SUM=sum(w)

now=0
ans=float('inf')
for i in w:
  now+=i
  ans=min(abs(now-(SUM-now)),ans)
print(ans)
"
"N = int(input())
S,T = map(str,input().split())
slist = list(S)
tlist = list(T)
new = ''
for i in range(N):
    new += slist[i]
    new += tlist[i]
print(new)"
"while True:
    [a,b,c]=[x for x in input().split()]
    [a,c]=[int(a),int(c)]
    op=b
    if op==""?"":
        break
    elif op==""+"":
        print(a+c)
    elif op==""-"":
        print(a-c)
    elif op==""*"":
        print(a*c)
    else:
        print(a//c)"
"def main():
    import sys
    input = sys.stdin.readline
    N, T = map(int, input().split())
    ab = [list(map(int, input().split())) for i in range(N)]
    ab.sort(key=lambda x: x[0])
    t = ab[-1][0]
    dp = [-1 for i in range(T+t + 1)]
    dp[0] = 0
    for a, b in ab:
        for i in range(T+t, 0, -1):
            if i >= a:
                if dp[i-a] >= 0 and i - a < T:
                    dp[i] = max(dp[i], dp[i-a] + b)

    for i in range(1, T+t+1):
        dp[i] = max(dp[i], dp[i-1])
    ans = dp[-1]

    # print(dp)
    print(ans)


main()
"
"import math
import math
N = int(input())
N_MAX = 10 ** 7
table = [1]*N

def get_divisors(n):
  num = 0
  ceil = n
  if n == 1:
    return 1
  for i in range(1, n+1):
    q, mod = divmod(n, i)
    if mod == 0: 
      num += 2
      ceil = q
    if i < ceil: break
  print(n, num)
  return num

ans = 0
for i in range(2,N+1):
  for j in range(1,math.floor(N/i)+1):
    table[i*j-1] += 1

for i, div in enumerate(table):
  ans += (i+1)*div
print(ans)"
"n = int(input())
s1 = int(n * (n+1)/2)
s2 = int(n//3 * (n//3 + 1) * 3/2)
s3 = int(n//5 * (n//5 + 1) * 5/2)
s4 = int(n//15 * (n//15 + 1) * 15/2)
 
print(s1 - s2 - s3 + s4)"
"N, K = map(int,input().split())
v = list(map(int,input().split()))
ans = [0]
for i in range(1,min(K,N)+1):
    for a in range(i+1):
        b = i-a
        if b == 0:
           get = v[:a]
        else:
            get = v[:a]+v[-b:]
        get.sort()
        for j in range(min(K-i,len(get))):
            p = get.pop(0)
            if p >= 0:
                A = p + sum(get)
                break
        else:
            A = sum(get+[0])
        ans.append(A)
print(max(ans))"
"n, m = map(int, input().split())
cnt = {i: 0 for i in range(1, n+1)}
for _ in range(m):
    a, b = map(int, input().split())
    cnt[a] += 1
    cnt[b] += 1

if all(cnt[i] % 2 == 0 for i in range(1, n+1)):
    print('YES')
else:
    print('NO')"
"def solver(x, y):
    ans1 = abs(x) + abs(y)
    ans2 = abs(abs(x) - abs(y))
    res = 0
    if x < y:
        if x * y >= 0:
            res = ans2
        else:
            res = 1 + ans2
    else:
        if 0 < y:
            res = 2 + ans2
        elif x * y <= 0:
            res = 1 + ans2
        else:
            if abs(x) <= abs(y):
                res = 2 + ans2
            else:
                res = 1 + ans1
    return res

x, y = map(int, input().split())
print(solver(x, y))"
"n = int(input())

count = [0 for i in range(n+1)]

for x in range(1, 101):
  for y in range(1, 101):
    for z in range(1, 101):
      f = x ** 2 + y ** 2 + z ** 2 + x*y + y*z + z*x
      if f <= n:
        count[f] += 1

for i in count[1:]:
  print(i)"
"def greatest_common_divisor(x, y):
    if x < y:
        x, y = y, x

    if y == 0:
        return x
    else:
        return greatest_common_divisor(y, x % y)

if __name__ == '__main__':
    x, y = [int(x) for x in input().split()]
    print(greatest_common_divisor(x, y))"
"# -*- coding: utf-8 -*-
A, B, K = map(int, input().split())

def is_even(num):
    return num % 2 == 0

for i in range(K):
    if is_even(i):
        if not is_even(A):
            A = A -1
        A, B = A/2, A/2 + B
    else:
        if not is_even(B):
            B = B -1
        B, A = B/2, B/2 + A
    
print(int(A), int(B))"
"from sys import stdin, setrecursionlimit
from collections import deque


def main():
    input = stdin.buffer.readline
    n = int(input())
    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        u, v, w = map(int, input().split())
        g[u - 1].append([v - 1, w])
        g[v - 1].append([u - 1, w])

    ans = [-1] * n

    q = deque([0])
    ans[0] = 0

    while q:
        u = q.popleft()

        for v, w in g[u]:
            if ans[v] == -1:
                ans[v] = (ans[u] + w) % 2
                q.append(v)

    print(*ans, sep='\n')


if __name__ == ""__main__"":
    setrecursionlimit(10000)
    main()
"
"N = int(input())
lsB = list(map(int,input().split()))

lsA = [0]*N
lsA[0] = lsB[0]
lsA[N-1] = lsB[N-2]
for i in range(1,N-1):
    lsA[i] = min(lsB[i-1],lsB[i])
print(sum(lsA))"
"str1 = input()
str2 = input()
str3 = input()

print(str1[0]+str2[1]+str3[2])"
"s=[0,0,0]
s[0]=list(input())
s[1]=list(input())
s[2]=list(input())
n=0
for i in range(100000):
    if len(s[n])==0:
        break
    tmp=s[n].pop(0)
    if tmp==""a"":
        n=0
    elif tmp==""b"":
        n=1
    else:
        n=2

if n==0:
    print(""A"")
elif n==1:
    print(""B"")
else:
    print(""C"")"
"s=list(input().split(','))
print(s[0],s[1],s[2])"
"s, t = input().split()
s_num , t_num = map(int, input().split())
u = input()

if u == s:
    print(s_num-1, t_num)
else:
    print(s_num, t_num -1)"
"import math

def main():
  N, K = map(int, input().split())
  i = 1
  tmp = 1
  
  while i > -1:
    if N >= K ** i:
      tmp += 1
    else:
      print(tmp)
      return
    
    i += 1
  
  
main()"
"n,k=map(int,input().split())
ok=0
n=n%k
def f(x):
    if abs(x-k)<x:
        f(abs(x-k))
    else:
        print(x)
f(n)"
"A,B = list(map(int,input().split()))
print(int(A*B))"
"import sys
input=sys.stdin.readline
n,ma,mb=map(int,input().split())
med=[]
for i in range(n):
    a,b,c=map(int,input().split())
    med.append((a,b,c))
INF=10000
dp=[[[INF]*401 for j in range(401)] for i in range(n+1)]
dp[0][0][0]=0
for i in range(n):
    for a in range(401):
        for b in range(401):
            if dp[i][a][b]!=INF:
                dp[i+1][a+med[i][0]][b+med[i][1]]=min(dp[i+1][a+med[i][0]][b+med[i][1]],dp[i][a][b]+med[i][2])
                dp[i+1][a][b]=min(dp[i+1][a][b],dp[i][a][b])
minc=INF
for a in range(1,401):
    for b in range(1,401):
        if a*mb==b*ma:
            minc=min(dp[n][a][b],minc)
if minc==INF:
    print(-1)
else:
    print(minc)
"
"n=int(input())
ro=n**0.5
# print( ro )

maxi=1
for i in range(2, int(ro)+1):
    if n%i==0:
        maxi=i

print( maxi-1+n//maxi-1)
"
"a,b = map(int, raw_input().split(' '))
res = a * b * (1 if a < 10 and b < 10 else 0)
print res if res else -1"
"N = int(input())
a = (N + 1000 -1)//1000
print(a*1000-N)"
"#!/usr/bin/env python

h, w = map(int, input().split())
s = ['' for _ in range(h+2)]
for i in range(1, h+1):
    s[i] = input()
for i in range(w):
    s[0] += '.' 
    s[h+1] += '.' 
for i in range(h+2):
    s[i] = ('.'+s[i]+'.')

for i in range(1, h+1):
    for j in range(1, w+1):
        if s[i][j] == '#':
            if s[i][j-1] == '#' or s[i][j+1] == '#' or s[i-1][j] == '#' or s[i+1][j] == '#' :
                continue
            else:
                print('No')
                exit()
        else:
            continue

print('Yes')
"
"from collections import defaultdict
N = int(input())
List = list(map(int,input().split()))
dicL = defaultdict(int)
dicR = defaultdict(int)
for i in range(N):
  dicL[List[i]+i] += 1
  dicR[i - List[i]] += 1
counter = 0
for item in dicL:
  if item in dicR:
    counter += dicL[item]*dicR[item]
print(counter)"
"def f():
    ans,c=0,0
    for t in input().replace('BC','y').replace('A','x'):
        if t=='y':ans+=c
        elif t=='x':c+=1
        else:c=0
    print(ans)
if __name__ == ""__main__"":
    f()"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")


from collections import defaultdict
n,m = map(int, input().split())
ns = defaultdict(set)
for _ in range(m):
    u,v = map(int, input().split())
    u -= 1
    v -= 1
    ns[u].add(v)
    ns[v].add(u)
dp = [[0]*(1<<n) for _ in range(n)]
dp[0][1] = 1
for b in range(1, 1<<n):
    for u in range(n):
        for i in range(n):
            if not (b>>i&1) and i in ns[u]:
                dp[i][b+(1<<i)] += dp[u][b]
ans = sum(dp[u][(1<<n)-1] for u in range(n))
print(ans)"
"from collections import deque

N, K = map(int, input().split(' '))
S = input()
arr = []
idx = 0

while idx < N:
    start = idx
    while idx + 1 < N and S[idx] == S[idx + 1]:
        idx += 1
    if S[start] == '0':
        arr.append(-(idx - start + 1))
    else:
        arr.append(idx - start + 1)
    idx += 1

if arr[0] < 0:
    arr = [0] + arr
if arr[-1] > 0:
    arr.append(0)

l, r = 0, 0     # [l, r)
ans, tmp = max(arr), 0
while l < len(arr) and r < len(arr):
    tmp += abs(arr[r])
    r += 1

    if r - l > 2 * K + 1:
        tmp -= arr[l] - arr[l + 1]
        l += 2

    if r - l <= 2 * K + 1:
        ans = max(ans, tmp)
print(ans)"
"n=[int(input()) for _ in range(int(input()))]
N1,N2=max(n),sorted(n)[-2]
for i in n:
  if i<N1: print(N1)
  elif i==N1: print(N2)"
"a, b = map(int, input().split())

ret = a // (b * 2 + 1)

if a % (b * 2 + 1) != 0:
    ret += 1

print(ret)
"
"r=input().split()
N=int(r[0])
K=int(r[1])
l=[]
while N>=1:
    l.append(N%K)
    N=N//K
print(len(l))"
"a, b = map(int, input().split())

print(int(0.5*(b-a)*(b-a-1)-a))
"
"#!/usr/bin/env python3


def main():
    N = int(input())
    d = len(str(N))
    ansL = [[0 for _ in range(9)] for _ in range(9)]
    for i in range(1,10):
        for j in range(1,10):
            tmp = 0
            # A(1桁)
            if i == j and i <= N:
                tmp += 1
            # AB(2桁)
            if i*10+j <= N:
                tmp += 1
            # A*B(3桁以上d桁未満)
            if d > 2:
                for k in range(3,d):
                    tmp += 10**(k-2)

                # d桁はN以下
                if int(str(N)[0]) > i:
                    tmp += 10**(d-2)
                elif int(str(N)[0]) == i:
                    tmp += int(str(N)[1:-1])
                    if int(str(N)[-1]) >= j:
                        tmp += 1
            ansL[i-1][j-1] = tmp
    
    ans = 0
    for i in range(9):
        for j in range(9):
            ans += ansL[i][j] * ansL[j][i]
    print(ans)
                

if __name__ == ""__main__"":
    main()
"
"import sys


stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


def main():
    n, m = nm()
    cnt = [0] * m
    for i in range(n):
        k, *A = nm()
        for a in A:
            cnt[a - 1] += 1
    print(cnt.count(n))


if __name__ == '__main__':
    main()
"
"N = int(input())

print(int((N * N * 3) / 3)) "
"s = list(input())
l = ['K','I','H','B','R',-1]
j = 0
 
for i in range(len(s)):
    if s[i] == 'A':
        if i == 0:
            pass
        elif s[i-1] == 'A':
            print('NO')
            exit(0)
        elif j == 1 or j == 2:
            print('NO')
            exit(0)
        else:
            pass
    elif s[i] != l[j]:
        print('NO')
        exit(0)
    else:
        j += 1
 
if j == 5:
    print('YES')
else:
    print('NO')"
"def simulator(n, a, b, s):
    print()
    boolean_list = ['No'] * n
    count = 0
    for i in range(n):
        if s[i]=='a' and count < a+b:
            count += 1
            boolean_list[i] = 'Yes'
        if s[i]=='b' and count < a+b and s[:i].count('b') <b :
            count += 1
            boolean_list[i] = 'Yes'
    
    for _ in boolean_list:
        print(_)

n, a, b = map(int,input().split())
s = input()
simulator(n, a, b, s)"
"n = int(input())
count = [0] * n
for i in range(1, n + 1):
    num = i
    while num % 2 == 0:
        num //= 2
        count[i - 1] += 1
print(count.index(max(count)) + 1)"
"from math import gcd
from collections import Counter, deque, defaultdict
from heapq import heappush, heappop, heappushpop, heapify, heapreplace, merge
from bisect import bisect_left, bisect_right, bisect, insort_left, insort_right, insort
from itertools import accumulate, product, permutations, combinations

def main():
    A,B,C = map(int, input().split())

    if A == B:
        print(C)
    elif A == C:
        print(B)
    else:
        print(A)

if __name__ == '__main__':
    main()"
"n,m=map(int,input().split())
e=[[]for _ in range(n)]
py=[]
for _ in range(m):
  p,y=map(int,input().split())
  py.append((p,y))
  e[p-1].append(y)
for i in range(n):e[i].sort()
xy=lambda x,y:y*1000000+x
d={}
for i in range(n):
  for j in range(len(e[i])):
    d[xy(i+1,e[i][j])]=str(i+1).zfill(6)+str(j+1).zfill(6)
for p,y in py:
  print(d[xy(p,y)])
"
"l = list(map(int,input().split()))

l.sort()

if  l[0] != l[1]:
    print((l[1] * 2 ) - 1)

elif l[0] == l[1]:
    print(l[1] * 2)
"
"N = int(input())
L = list(map(int, input().split()))

L.sort()

count = 0
for i in range(N):
    count += min(L[2*i], L[2*i+1])

print(count)"
"import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy

sys.setrecursionlimit(10**7)
inf=10**20
mod=998244353
dd=[(-1,0),(0,1),(1,0),(0,-1)]
ddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
# def LF(): return [float(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def LS(): return sys.stdin.readline().split()
def S(): return input()

def main():
  n,k=LI()
  field=[LI() for _ in range(k)]

  dp=[0]*(n+1)
  dpsum=[0]*(n+1)
  dp[1]=1
  dpsum[1]=1

  for i in range(2,n+1):
    for l,r in field:
      li=i-r
      ri=i-l
      if ri<=0:
        continue
      li=max(1,li)
      dp[i]+=dpsum[ri]-dpsum[li-1]
      dp[i]%=mod
    dpsum[i]=dp[i]+dpsum[i-1]
    dpsum[i]%=mod
  
  return dp[n]%mod

# main()
print(main())
"
"from collections import deque
import sys
input = sys.stdin.readline  #文字列入力では注意！

N,M = map(int,input().split())
Graph = [[] for _ in range(N)]
for _ in range(M):
    L,R,D = map(int,input().split())
    L -= 1; R -= 1
    Graph[L].append((R,D))
    Graph[R].append((L,-D))

num = dict()
for i in range(N):
    if i not in num:
        num[i] = 0
        Q = deque(Graph[i])
        x = 0
        while Q:
            now,d = Q.popleft()
            if now in num:
                if num[now] != d:
                    print(""No"")
                    exit()
            else:
                num[now] = d
                for node,Di in Graph[now]:
                    Q.append((node,d+Di))
print(""Yes"")
"
"n,k = map(int,input().split())
ans = 0
for i in range(1,n+1):
    j = 0
    if i < k:
        while i*(2**j) < k:
            j += 1
        ans += (1/n)*1/(2**j)
    else:
        ans += (1/n)
print(ans)"
"def count_section_by_zero(data):
  count = 0
  flg = False
  start = 0
  for i, d in enumerate(data):
    if flg is False and d != 0:
      count += 1
      flg = True
      
    if d == 0:
      flg = False
  return count

def input_list():
  return list(map(int, input().split()))

def input_list_str():
  return list(map(str, input().split()))

def lcm_base(x, y):
    return (x * y) // fractions.gcd(x, y)

def lcm_list(numbers):
    return reduce(lcm_base, numbers, 1)

def gcd(*numbers):
    return reduce(fractions.gcd, numbers)

def gcd_list(numbers):
    return reduce(fractions.gcd, numbers)

def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))

# 2で割り切れる回数
def divide_two(arg):
  c = 0
  while True:
    if c >= 2:
      break
    if arg % 2 != 0:
      break
    arg //= 2
    c += 1
  return c

# 素因数分解
def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a

def main():
  n, a, b, c, d = input_list()
  s = input()
  dp = []
  has_space = False
  if s[c-1] == '#':
    print('No')
    exit(0)
  if s[d-1] == '#':
    print('No')
    exit(0)
  if c < d:
    for i in range(a-1, c):
      if s[i] == '#' and s[i+1] == '#':
        print('No')
        exit(0)
    for i in range(b-1, d):
      if s[i] == '#' and s[i+1] == '#':
        print('No')
        exit(0)
  else:
    for i in range(a-1, c):
      if s[i] == '#' and s[i+1] == '#':
        print('No')
        exit(0)
     
    for i in range(b-1, d):
      if s[i] == '#' and s[i+1] == '#':
        print('No')
        exit(0)
      if s[i-1] == '.' and s[i+1] == '.' and s[i] == '.':
        has_space = True
    if has_space is False:
      print('No')
      exit(0)

  print('Yes')
  
import math
import fractions
import collections
import itertools
from functools import reduce
main()"
"def judge(c):
    if len(c) == 0:
        return 1, c, ""-1""
    else:
        return 0, c[0], c[1:]


def main():
    sa = input()
    sb = input()
    sc = input()
    card = {""a"": sa, ""b"": sb, ""c"": sc}
    next_player = ""a""
    while True:
        now = next_player
        is_finish, next_player, card[now] = judge(card[now])
        if is_finish:
            print(now.upper())
            break


if __name__ == '__main__':
    main()

"
"def ii():return int(input())
def iim():return map(int,input().split())
def iil():return list(map(int,input().split()))

x,y = iim()
if y>=x:
    if x*y>=0:
        ans = y-x
    else:
        ans = abs(x+y)+1
else:
    if y == 0:
        ans = x+1
    elif x*y>0:
        ans = x-y+2
    else:
        ans = abs(y+x)+1
print(ans)
"
"n=int(input())
csf=[list(map(int, input().split())) for _ in range(n-1)]

l=[]
for i in range(n-1):
    cnt=0
    for j in range(i,n-1):
        if cnt>=csf[j][1]:
            tmp_cnt=(cnt-csf[j][1]-1)//csf[j][2]
            cnt=csf[j][1]+(tmp_cnt+1)*csf[j][2]
        else:
            cnt=csf[j][1]
        cnt+=csf[j][0]
    l.append(cnt)

l.append(0)
for l_i in l:
    print(l_i)
"
"N = int(input())
B_List = list(map(int,input().split()))
A_List = [[] for i in range(N)]
A_List[0] = B_List[0]
A_List[1] = B_List[0]
for i in range(1,N - 1):
    if B_List[i] <= B_List[i-1]:
        A_List[i] = B_List[i]
    A_List[i+1] = B_List[i]
        
        

print(sum(A_List))"
"def main():
    W,H,x,y = [int(x) for x in input().split()]
    area = W*H/2
    if x == W/2 and y == H/2:
        print(area,1)
    else:
        print(area,0)

if __name__ == '__main__':
    main()"
"arr = input().split()
p,q,r=int(arr[0]),int(arr[1]),int(arr[2])
print(min(p+q,p+r,q+r))"
"arr = map(int,raw_input().split())
arr.sort()
arr = map(str,arr)
print ' '.join(arr)"
"values = []
for n in range(10):
    values.append(int(input()))

values.sort(reverse=True)
for v in values[:3]:
    print(v)"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7 
#mod = 998244353
from decimal import *
#import numpy as np
#decimal.getcontext().prec = 10

N, C = MAP()
stc = [LIST() for _ in range(N)]
stc.sort(key=lambda x:(x[2], x[0]))

tmp_s = stc[0][0]
tmp_t = stc[0][1]
tmp_c = stc[0][2]

stc = stc[1:]
stc_new = []

for s, t, c in stc:
	if c == tmp_c and s == tmp_t:
		tmp_t = t
	else:
		stc_new.append((tmp_s, tmp_t))
		tmp_s = s
		tmp_t = t
		tmp_c = c
stc_new.append((tmp_s, tmp_t))

now = [0]*(10**5+1)

for s, t in stc_new:
	now[s-1] += 1
	now[t] -= 1

now_acc = list(accumulate(now))

print(max(now_acc))"
"n = int(input())
A = [*map(int, input().split())] + [0]
dp_yen = [1000]*(n+1)
for day in range(n):
    dp_yen[day+1] = max(dp_yen[day], dp_yen[day] + dp_yen[day]//A[day] * (A[day+1] - A[day]))
print(dp_yen[n])
"
"nk = input().split()
n = int(nk[0])
k = int(nk[1])

dtlist = []
for i in range(n):
    td = input().split()
    t = int(td[0])
    d = int(td[1])
    dtlist.append((d, t))
dtlist.sort(reverse=True)


t_to_maxidx = {}
for idx, dt in enumerate(dtlist):
    d, t = dt
    if t not in t_to_maxidx:
        t_to_maxidx[t] = idx


selected = []
count = 0
tcount = {}

candidate = [(dtlist[idx][0], idx) for t, idx in t_to_maxidx.items()]
candidate.sort(reverse=True)
for d, idx in candidate:
    if count >= k:
        break
    d, t = dtlist[idx]
    selected.append(dtlist[idx])
    count += 1
    tcount[t] = 1 if t not in tcount else tcount[t] + 1
    dtlist[idx] = None

new_dtlist = []
for dt in dtlist:
    if dt is not None:
        new_dtlist.append(dt)
dtlist = new_dtlist


if k - count > 0:
    for i in range(k - count):
        dt = dtlist.pop(0)
        selected.append(dt)
        d, t = dt
        tcount[t] = 1 if t not in tcount else tcount[t] + 1

selected.sort()

score = 0
for d, t in selected:
    score += d

len_tcount = len(tcount)
score += len_tcount * len_tcount

for i in range(0, 2**32):
    next_score = score
    try:
        d_new, t_new = dtlist.pop(0)
        d_old, t_old = selected.pop(0)
    except IndexError:
        print(score)
        break
    next_score += d_new
    next_score -= d_old

    tcount[t_old] -= 1
    if tcount[t_old] <= 1:
        next_score -= len_tcount * len_tcount
        len_tcount -= 1
        next_score += len_tcount * len_tcount
        del tcount[t_old]

    if t_new not in tcount:
        next_score -= len_tcount * len_tcount
        len_tcount += 1
        next_score += len_tcount * len_tcount
        tcount[t_new] = 1
    else:
        tcount[t_new] += 1

    if next_score <= score:
        print(score)
        break
    score = next_score
"
"n = int(input())
l = list(range(1, n+1))
for i in range(len(l)):
    if l[i] % 3 == 0 or l[i] % 5 == 0:
        l[i] = 0

print(sum(l))
"
"s=str(input())
count=0
L=[]
for i in range(0,len(s)):
	if(s[i]==""R""):
		count+=1
	else:
		count=0
	L.append(count)
print(max(L))"
"N, M = list(map(int,input().split()))

x = M - 2 * N
if x > 0:
  N += x // 4

print(min(N, M // 2))"
"n=int(input())
f=False
c=0
for i in range(n):
  a,b=map(int,input().split())
  if a==b:
    c+=1
    if c==3:
      f=True
      break
  else:
    c=0
if f:
  print(""Yes"")
else:
  print(""No"")"
"#coding:utf-8
s = input()
w = int(input())
print(s[0::w])"
"x,a=list(map(int,input().split()))
if x<a:print(0)
else:print(10)"
"import sys

sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    n, a, b = map(int, input().split())
    print(min(a, b), 0 if n > a + b else abs(n - (a + b)))


if __name__ == '__main__':
    resolve()
"
"s=str(input())
if s==""Sunny"":
  print(""Cloudy"")
elif s==""Cloudy"":
  print(""Rainy"")
elif s==""Rainy"":
  print(""Sunny"")"
"def solve():
    A, B, C = map(int, input().split())
    if A <= C <= B:
        print('Yes')
    else:
        print(""No"")


if __name__ == ""__main__"":
    solve()"
"# Aizu Problem ITP_1_6_D: Matrix Vector Multiplication
#
import sys, math, os

# read input:
PYDEV = os.environ.get('PYDEV')
if PYDEV==""True"":
    sys.stdin = open(""sample-input.txt"", ""rt"")


n, m = [int(_) for _ in input().split()]
A = [[int(_) for _ in input().split()] for __ in range(n)]
V = [int(input()) for _ in range(m)]

for row in range(n):
    print(sum([A[row][k] * V[k] for k in range(m)]))"
"n = int(input())

#big+small*1000から出る辺の先
edge = [[] for _ in range(2*(10**6))]
#used -1:点なし else:入力本数
used = [-1]*(2*(10**6))

for i in range(1,n+1):
    a = tuple(map(int,input().split()))
    fr = None
    for e in a:
        go = max(i,e) + min(i,e)*1000

        if fr != None:
            if used[fr] < 0:
                used[fr] = 0
            if used[go] < 0:
                used[go] = 0
            edge[fr].append(go)
            used[go] += 1
        fr = go


res = 0
ctr = 0
tank = []
new = []
for i,e in enumerate(used):
    if e == 0:
        new.append(i)
        ctr += 1

while len(new) > 0:
    tank = []
    for p in new:
        for e in edge[p]:
            used[e] -= 1
            if used[e] == 0:
                tank.append(e)
                ctr += 1
    new = tank
    res += 1

if ctr < n*(n-1)//2:
    print(-1)
else:
    print(res)

"
"import sys
from collections import deque
input = sys.stdin.readline

def main():
  h, w = map(int, input().split())
  s = [input() for _ in range(h)]
  
  ans = 0
  already = [[False]*w for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if already[i][j] or s[i][j] == ""."":
        continue
      already[i][j] = True
      black, white = 0, 0
      not_yet = deque([(i, j)])
      while not_yet:
        p, q = not_yet.pop()
        if s[p][q] == ""#"":
          black += 1
        else:
          white += 1
        if p > 0 and s[p-1][q] != s[p][q] and not already[p-1][q]:
          not_yet.append((p-1, q))
          already[p-1][q] = True
        if p < h-1 and s[p+1][q] != s[p][q] and not already[p+1][q]:
          not_yet.append((p+1, q))
          already[p+1][q] = True
        if q > 0 and s[p][q-1] != s[p][q] and not already[p][q-1]:
          not_yet.append((p, q-1))
          already[p][q-1] = True
        if q < w-1 and s[p][q+1] != s[p][q] and not already[p][q+1]:
          not_yet.append((p, q+1))
          already[p][q+1] = True
      ans += black*white
  
  print(ans)

  
if __name__ == ""__main__"":
  main()"
"a,b=map(int,input().split())
if a ==1:
    a=a+13
if b==1:
    b=b+13
if a>b:
    print('Alice')
elif a<b:
    print('Bob')
else:
    print('Draw')"
"#!/usr/bin/env python3
# coding:utf-8

def main():
    stdIn1, stdIn2 = map(int, input().split())
    stdOut = solve(stdIn1, stdIn2)
    print(stdOut)


""""""
方針
x,y,zそれぞれを3重ループで0からkまで回す
(O(N^3)だが、k<=2500なので気にならない)
x+y+zが等しければパターンを1追加

TLEになったので、もう少し節約するパターンを考える必要あり
ひとまずx,x+y,x+y+zがsより大きなった場合はbreakさせてループを抜ける処理にしてみる
まだTLEになるので、もう少し考える
実はzはループする必要はなく z = s - (x + y) <= k であれば +1, > k であれば continueでよい
これでO(N^2)に計算量を抑えられる

""""""


def solve(k, s):
    pattern = 0
    for x in range(k+1):
        if x > s:
            break
        for y in range(k+1):
            if x + y > s:
                break
            z = s - x - y
            if z <= k:
                pattern += 1

    return pattern


if __name__ == ""__main__"":
    main()
"
"d = input()
d = d.split()
a = int(d[0])
b = int(d[1])
c = int(d[2])
k = int(d[3])
f = 0
if a < k:
    f = f + a
    k = k - a
    if b < k:
        k = k - b
        f = f - k
    else:
        f = f
else:
    f = k
print(f)"
"# ABC 057: A – Remaining Time
a, b = [int(s) for s in input().split()]
print(a + b if a + b <= 23 else a + b - 24)"
"n=int(input())
x=list(map(int,input().split()))
mi=min(x)
ma=max(x)
ans = sum(x)**2
for i in range (mi,ma+1):
  hp=0
  for j in x:
    hp+= (i-j)**2
  ans = min(hp,ans)
print(ans)
"
"def main():
    nm = [int(_x) for _x in input().split()]
    n = nm[0]
    m = nm[1]
    a = [int(_x) for _x in input().split()]
    result = n - sum(a)
    if result < 0:
        print(-1)
    else:
        print(result)


main()
"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    x1, y1, x2, y2 = map(int, readline().split())
    
    dx = x2 - x1
    dy = y2 - y1
    
    x3, y3 = x2 - dy, y2 + dx
    x4, y4 = x1 - dy, y1 + dx
    
    print(x3, y3, x4, y4)
    
    return


if __name__ == '__main__':
    main()
"
"def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]
def input():
    return sys.stdin.readline().rstrip()
def rand_N(ran1, ran2):
    return random.randint(ran1, ran2)
def rand_List(ran1, ran2, rantime):
    return [random.randint(ran1, ran2) for i in range(rantime)]
def rand_ints_nodup(ran1, ran2, rantime):
  ns = []
  while len(ns) < rantime:
    n = random.randint(ran1, ran2)
    if not n in ns:
      ns.append(n)
  return sorted(ns)

def rand_query(ran1, ran2, rantime):
  r_query = []
  while len(r_query) < rantime:
    n_q = rand_ints_nodup(ran1, ran2, 2)
    if not n_q in r_query:
      r_query.append(n_q)
  return sorted(r_query)

from collections import defaultdict, deque, Counter
from sys import exit
from decimal import *
import heapq
from math import sqrt, pi
from fractions import gcd
import random
import string
import copy
from itertools import combinations, permutations, product
from operator import mul, itemgetter
from functools import reduce
from bisect import bisect_left, bisect_right

import sys
sys.setrecursionlimit(1000000000)
mod = 10 ** 9 + 7

#############
# Main Code #
#############

N, M = getNM()
que = []
for i in range(M):
    a, b = getNM()
    que.append([a - 1, b - 1])
ball = [1] * N
red = [0] * N
red[0] = 1

for a, b in que:
    ball[b] += 1
    if red[a] == 1:
        red[b] = 1
    ball[a] -= 1
    if ball[a] == 0:
        red[a] = 0
print(sum(red))"
"N,*L=map(int,open(0).read().split());L.sort();print(sum(min(a,b)for a,b in zip(L[::2],L[1::2])))"
"num = sorted([ int(v) for v in input().split() ])
if num == [1,4,7,9]:
    print(""YES"")
else:
    print(""NO"")"
"n = int(input())
print(len(set([input() for _ in range(n)])))"
"from itertools import accumulate
import sys

input=sys.stdin.readline

H,W,D=map(int,input().split())
A=[[] for i in range(0,H)]
for i in range(0,H):
    A[i]=list(map(int,input().split()))
Q=int(input())
L=[0 for i in range(0,Q)]
R=[0 for i in range(0,Q)]
for i in range(0,Q):
    L[i],R[i]=map(int,input().split())

data=[(0,0) for i in range(0,H*W+1)]
for i in range(0,H):
    for j in range(0,W):
        data[A[i][j]]=(i+1,j+1)
anstable=[[] for i in range(0,D+1)]
for i in range(1,D+1):
    x=(H*W-i)//D
    for j in range(0,x):
        s=data[i+j*D][0]
        t=data[i+j*D][1]
        s2=data[i+(j+1)*D][0]
        t2=data[i+(j+1)*D][1]
        anstable[i].append(abs(s2-s)+abs(t2-t))
    anstable[i]=list(accumulate(anstable[i]))

for i in range(0,Q):
    x=L[i]%D
    if x==0:
        x=D
    if D>=L[i]:
        if R[i]==L[i]:
            print(0)
        else:
            if x!=D:
                print(anstable[x][R[i]//D-1])
            else:
                print(anstable[x][R[i]//D-2])
    else:
        if x!=D:
            print(anstable[x][R[i]//D-1]-anstable[x][L[i]//D-1])
        else:
            print(anstable[x][R[i]//D-2]-anstable[x][L[i]//D-2])
"
"import sys

sys.setrecursionlimit(10 ** 8)
ini = lambda: int(sys.stdin.readline())
inm = lambda: map(int, sys.stdin.readline().split())
inl = lambda: list(inm())
ins = lambda: sys.stdin.readline().rstrip()
debug = lambda *a, **kw: print(""\033[33m"", *a, ""\033[0m"", **dict(file=sys.stderr, **kw))

n = ini()
a = [ini() for _ in range(n)]
a.sort()


def solve():
    i = 0
    j = n - 1
    is_odd = n % 2 == 1
    a0 = a[i]
    a1 = a[j]
    s = a[j] - a[i]
    i += 1
    j -= 1
    while i < j:
        s += a[j] - a0
        s += a1 - a[i]
        a0 = a[i]
        a1 = a[j]
        i += 1
        j -= 1
    if is_odd and i == j:
        s += max(a1 - a[i], a[i] - a0)
    return s


print(solve())
"
"S = input()
cnt = 0
for c in S:
    cnt += (c == 'o')
print(700+100*cnt)"
"K = int(input())
S = list(input())
S2 = []

if len(S) <= K:
    print(''.join(S))
else:
    for i in range(K):
        n = S[i]
        S2.append(n)
if len(S2) == K:
    print(''.join(S2) + '...')"
"# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect


def gcd(a, b):
    """"""最大公約数""""""
    a, b = (a, b) if a >= b else (b, a)
    if b == 0:
        return a
    return gcd(b, a % b)


def lcm(a, b):
    """"""最小公倍数""""""
    # from math import gcd
    return (a * b) // gcd(a, b)


# from decorator import stop_watch
#
#
# @stop_watch
def solve(A, B):
    print(lcm(A, B))


if __name__ == '__main__':
    A, B = map(int, input().split())
    solve(A, B)
"
"import collections

d,g =  map(int, raw_input().split())
cc = {0:0}
picis = [map(int,raw_input().split()) for _ in range(d)]

pisum = sum([pi for pi,ci in picis] or [0])
for i in range(len(picis)):
	pi,ci = picis[i]
	for p in range(1, pisum + 1)[::-1]:
		for q in range(1, pi + 1):
			if p - q >= 0 and (p - q) in cc:
				cc[p] = max(cc[p] if p in cc else -float('inf'),  cc[p - q] + (100 * q * (i + 1)) + (ci if pi == q else 0))

for k in range(pisum+1):
	if cc[k] >= g:
		print k
		break"
"import math
a, b, h, m = map(int, input().split())
theta_h = 2 * math.pi * (h + m / 60) / 12
theta_m = 2 * math.pi * m / 60
d_theta = abs(theta_h - theta_m)
answer = math.sqrt(a**2 + b**2 - 2*a*b*math.cos(d_theta))
print(answer)"
"mod = 1000000007
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    if N == 1:
        print(""Hello World"")
    else:
        a = int(input())
        b = int(input())
        print(a+b)


if __name__ == '__main__':
    main()
"
"n = int(input())
a = sorted([list(map(int, input().split())) for _ in range(n)])
cnt = a[0][0] - 1 + n + a[-1][1]

for i in range(n - 1):
    cnt += min(a[i + 1][0] - a[i][0], a[i][1] - a[i + 1][1]) - 1
print(cnt)"
"import sys
stdin = sys.stdin
sys.setrecursionlimit(10**6)
ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
nn = lambda: list(stdin.readline().split())
ns = lambda: stdin.readline().rstrip()

n = ni()
a = 2
ans = ''

if n==0:
    print(0)
    exit()

while n != 0:
    if n%a == 0:
        ans = '0' + ans
    else:
        ans = '1' + ans
        n-=(a//2)
    a*=(-2)

print(ans)"
"a, b, c = map(int, input().split())

sum1 = a + b
sum2 = a + c
sum3 = b + c

print(min(sum1, sum2, sum3))"
"import sys
from itertools import combinations_with_replacement, product
import numpy as np
def input(): return sys.stdin.readline().rstrip()

def main():
    N=int(input())
    task=[]
    for _ in range(N):
        A,B=map(int, input().split())
        task.append([A,B])
    task.sort(key=lambda x: x[1])
    task=np.array(task)
    task[:,0]=task[:,0].cumsum()
    if all(task[:,0] <= task[:,1]):
        print('Yes')
    else:
        print('No') 

if __name__ == '__main__':
    main()"
"n = input()
maxi = -1 * 10**9
mini = input()


for i in range(n-1):
  tmp = input()
  maxi = max(maxi, tmp - mini)
  mini = min(mini, tmp)

print maxi"
"x = int(input())
print((x**3)/27)"
"n, k = map(int, input().split())
h = [int(x) for x in input().split()]

ans = 0
for hi in h:
    if hi >= k: ans += 1

print(ans)
"
"n = int(input())
length = list(map(int,input().split()))

# n = 1 or 2
if n == 1 or n == 2:
  print(0)
  exit()

# n >= 3
len_count = {}
for l in length:
  if l not in len_count:
    len_count[l] = 1
  else:
    len_count[l] += 1

uniq_len = sorted(list(set(length)))
n_len = len(uniq_len)
triangle = []

from itertools import combinations
for c in combinations(uniq_len,3):
  c = sorted(list(c))
  if c[0] + c[1] > c[2]:
    triangle.append(c)
      
ans = 0
for t in triangle:
  ans += len_count[t[0]] * len_count[t[1]] * len_count[t[2]]

print(ans)"
"import numpy as np
X1,Y1,X2,Y2 = (int(T) for T in input().split())
MoveV  = np.array([X2-X1,Y2-Y1]).T
Rotate = np.array([[0,-1],[1,0]])

MoveV = np.dot(Rotate,MoveV)
X3,Y3 = X2+MoveV[0],Y2+MoveV[1]

MoveV = np.dot(Rotate,MoveV)
X4,Y4 = X3+MoveV[0],Y3+MoveV[1]

print('{} {} {} {}'.format(X3,Y3,X4,Y4))"
"import sys
input = sys.stdin.readline
from itertools import accumulate


def read():
    
    N, C, K = map(int, input().strip().split())
    T = []
    for i in range(N):
        t = int(input().strip())
        T.append(t)
    return N, C, K, T


def solve(N, C, K, T):
    T.sort()
    i = 0
    ans = 0
    while i < N:
        tk = T[i] + K
        j0 = i
        for j in range(j0, min(j0+C, N)):
            if T[j] <= tk:
                i += 1
            else:
                break
        ans += 1
    return ans


if __name__ == '__main__':
    inputs = read()
    print(""%s"" % solve(*inputs))
"
"N = int(input())
H = list(map(int,input().split()))
cnt = 1
maxH = H[0]
for i in range(1,N):
  if H[i] >= maxH:
    cnt+=1
    maxH = max(maxH,H[i])
print(cnt)

"
"def primes(n):
	is_prime = [True] * (n+1)
	is_prime[0] = False
	is_prime[1] = False
	for i in range(2, int(n**0.5)+1):
		if not is_prime[i]:
			continue
		for j in range(i*2, n+1, i):
			is_prime[j] = False
	return [i for i in range(n+1) if is_prime[i]]

N=int(input())
ans=[]
prime_numbers=primes(55555)
while True:
    cnt=0
    for n in prime_numbers:
        if n%5==1:
            ans.append(n)
            cnt+=1
        if cnt==N:
            break
    break
print(*ans)"
"import itertools

A = [int(input())for i in range(0,5,1)]

ans = 10**10
for Atmp in list(itertools.permutations(A)):
    time = 0
    for i in range(0,5,1):
        if time%10 != 0:
            time += (10-time%10)
        time += Atmp[i]
    ans = min(ans,time)
print(ans)
"
"import re
S=input()
print(""NYoe s""[len(re.sub(""[RUD]"",'',S[0::2]))==0==len(re.sub(""[LUD]"",'',S[1::2]))::2])"
"s=input()
n=len(s)
ans=0

for bit in range(1<<(n-1)):
    f=s[0]
    
    for i in range(n-1):
        
        if bit & 1<<i:
            f+=""+""
        
        f+=s[i+1]
    
    ans+=sum(map(int,f.split(""+"")))

print(ans)"
"# print('input >>')
N, K = map(int,(input().split()))
ps = list(map(int,(input().split())))
ps.sort()

# print('-----output-----')
print(sum(ps[:K]))"
"x,y=map(int,input().split());print(-(x%y<1)or x)"
"a,b,c = map(int,input().split())

if(a < b):
    if(a < c and c < b):
        print('Yes')
    else:
        print('No')
else:
    if(b < c and c < a):
        print('Yes')
    else:
        print('No')"
"H, W = map(int, input().split())
n = int(input())
a = map(int, input().split())

alist = []
i = 1
for ai in a:
  alist.extend([str(i)]*ai)
  i += 1

i = 0
for h in range(H):
  start = h * W
  end = start + W
  if h % 2 == 0:
    print(' '.join(alist[start:end]))
  else:
    print(' '.join(alist[end-1:start-1:-1]))

  
"
"# 2020/05/04
# AtCoder Beginner Contest 102 - C

# Input
n = int(input())
a = list(map(int,input().split()))
ami = list()

for i in range(n):
    ami.append(a[i] - (i+1))

ami.sort()
medi = ami[n // 2]

wk_val = 0
for j in range(n):
    wk_val = wk_val + abs(a[j]-(medi+j+1))

ans = wk_val

# Output
print(ans)
"
"s = input()
t = input()
sl = len(s)
ss = """"
used = [False]*26
cnt = 0
for i in range(sl):
    if used[(ord(s[i])-97)%26]:
        ss += str(used[(ord(s[i])-97)%26])
    else:
        cnt += 1
        ss += str(cnt)
        used[(ord(s[i])-97)%26] = cnt

used = [False]*26
tt = """"
cnt = 0
for i in range(sl):
    if used[(ord(t[i])-97)%26]:
        tt += str(used[(ord(t[i])-97)%26])
    else:
        cnt += 1
        tt += str(cnt)
        used[(ord(t[i])-97)%26] = cnt

if ss==tt:
    print(""Yes"")
else:
    print(""No"")"
"k = int(input())

t = 7
flag = True
for i in range(k):
  if t % k == 0:
    print(i + 1)
    flag = False
    break
  else:
    t = (t * 10 + 7) % k
if flag:
  print('-1')"
"r, c = map(int, input().split())
a = [[0 for i in range(c+1)] for j in range(r+1)]
for i in range(r):
    l = list(map(int, input().split()))
    for j in range(c):
        a[i][j] = l[j]
        a[i][c] += a[i][j]

for i in range(c+1):
    for j in range(r):
        a[r][i] += a[j][i]

for i in range(r+1):
    for j in range(c+1):
        if j == c:
            print(str(a[i][j]))
        else:
            print(str(a[i][j]) + "" "", end="""")"
"n = int(input())

graphs = []

for _ in range(n):
    graphs.append(list(map(int, input().split()))[2:])


def bfs(graphs, seen_points, score, scores, queue):
    while len(queue) > 0:
        start_point = queue.pop(0)
        if seen_points[start_point - 1] == 2:
            continue
        else:
            next_points = [
                point for point in graphs[start_point - 1] if seen_points[point - 1] == 0]
            if len(next_points) >= 1:
                score += 1
                for point in next_points:
                    queue.append(point)
                    if seen_points[point - 1] == 0:
                        seen_points[point - 1] = 1
                        scores[point - 1] = scores[start_point - 1] + 1
                seen_points[start_point - 1] = 2


seen_points = [0 for _ in range(n)]
scores = [-1 for _ in range(n)]
scores[0] = 0
queue = [1]
bfs(graphs, seen_points, 0, scores, queue)

for index, score in enumerate(scores):
    print(index + 1, score)

"
"N=int(input())
A=input()
B=input()
C=[]
count=1
for i in range(N-1):
  if A[i]!=A[i+1]:
    C.append(count)
    count=1
  else:
    count+=1
if N==1:
  print(3)
  exit()
  
if A[-1]==A[-2]:
  C.append(2)
else:
  C.append(1)

ans=3
if C[0]==2:
  ans*=2
d=len(C)
for i in range(1,d):
  if C[i]==1 and C[i-1]==2:
    ans*=1
    ans%=10**9+7
  elif C[i]==2 and C[i-1]==2:
    ans*=3
    ans%=10**9+7
  else:
    ans*=2
    ans%=10**9+7
print(ans%(10**9+7))"
"def resolve():
    n = int(input())
    a = list(map(int, input().split()))
    cuma = [0]
    for i in range(n):
        cuma.append(cuma[-1]+a[i])
    dict = {}
    for i in cuma:
        if i in dict:
            dict[i] += 1
        else:
            dict[i] = 1
    ans = 0    
    for i in dict:
        ans += dict[i]*(dict[i]-1)//2
    print(ans)
resolve()"
"x = int(input())
i = 0
while x >= 500:
    x = x - 500
    i = i + 1000
while x >= 5:
    x = x - 5
    i = i + 5
print(int(i))"
"N = int(input())
AB = [list(map(int,input().split())) for _ in range(N)]

scores = [(A+B, A, B) for A,B in AB]
scores.sort(key=lambda x:x[0], reverse=True)
takahashi = 0
aoki = 0
takahashi_turn = True
for score in scores:
    if takahashi_turn:
        takahashi += score[1]
    else:
        aoki += score[2]
    takahashi_turn = not takahashi_turn
print(takahashi-aoki)"
"n, k, s = map(int, input().split())
print(*([ s ] * k + [ s + 1 if s < 10**9 else 1 ] * (n - k)))"
"import sys
import numpy as np
from collections import Counter, deque

sys.setrecursionlimit(10 ** 7)
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    s = input()
    red = s.count(""0"")
    blue = s.count(""1"")
    print(min(red, blue) * 2)


if __name__ == '__main__':
    resolve()
"
"n=(int)(input())
a = [list(map(int, input().split("" ""))) for i in range(2)]
maxi = 0
for i in range(n):
  temp = sum(a[0][:i + 1]) + sum(a[1][i:])
  if maxi < temp:
    maxi = temp
print(maxi)"
"l, r, d = map(int, input().split())

if l % d == 0:
    a = l // d
    b = r // d
    print(b-a+1)
else:
    a = l // d
    b = r // d
    print(b-a)"
"n = int(input())

ans = []
while n:
    r = n % 2
    if r < 0:
        r += 2
    ans.append(str(r))
    n = (n-r) // -2
ans.reverse()

if len(ans) == 0:
    print(0)
else:
    print("""".join(map(str, ans)))
"
"N = str(input())

if (N[0]==N[1]==N[2]) or (N[1]==N[2]==N[3]):
  print(""Yes"")
else:
  print(""No"")"
"def main():
    s = input()
    cr = 0
    cp = 0
    score = 0
    for c in s:
        if c == 'g':
            if cr > cp:
                score += 1
                cp += 1
            else:
                cr += 1
        else:
            if cr > cp:
                cp += 1
            else:
                cr += 1
                score -= 1
    print(score)
    

if __name__ == '__main__':
    main()"
"H = int(input())
W = int(input())
N = int(input())

hi = max(H, W)
print((N+hi-1)//hi)
"
"import sys
import math
import bisect

def main():
    a, b, x = map(int, input().split())
    if x >= a and x <= a + b:
        print('YES')
    else:
        print('NO')

if __name__ == ""__main__"":
    main()
"
"data = int(input())
for i in range(1, data+1):
    if (i % 3 == 0) or (""3"" in str(i)):
        print("""", i, end="""")
print()"
"ini = lambda : int(input())
inm = lambda : map(int,input().split())
inl = lambda : list(map(int,input().split()))
gcd = lambda x,y : gcd(y,x%y) if x%y else y
def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
    if temp!=1:
        arr.append([temp, 1])
    if arr==[]:
        arr.append([n, 1])
    return arr
def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    divisors.sort()
    return divisors

#maincode-------------------------------------------------
k = ini()
ans = 0
for a in range(1,k+1):
    for b in range(1,k+1):
        d = gcd(a,b)
        for c in range(1,k+1):
            ans += gcd(d,c)
print(ans)"
"n = int(input())
A = list(map(int,input().split()))

ans = 3**n
aa = 1
for i in A:
    if i%2==0:aa*=2

print(ans-aa)"
"N,M=map(int,input().split())
*A,=map(int,input().split())
A=sorted(A)

while M:
    A[-1]//=2
    M-=1
    i=-2
    while M and (-N<=i and A[i]>=A[-1]):
        A[i]//=2
        M-=1
        i-=1
    A.sort()

print(sum(A))"
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
input = sys.stdin.readline().rstrip

A,B = map(int, input().split())

ans = "":("" if A > 8 or B > 8 else ""Yay!""
print(ans)

"
"print([""Heisei"",""TBD""][input()[5:7]>""04""])"
"s = input().split()
print(int(int(s[0])+(int(s[1])/2)))"
"n, x = map(int, input().split())
a = list(map(int, input().split()))

res = 0
for i in range(n-1):
    if a[i] + a[i+1] <= x:
        continue

    candy = a[i] + a[i+1] - x
    res += candy
    a[i+1] = max(0, a[i+1] - candy)

print(res)"
"while True:
    try:
        n = int(input())
        if n==0:
            break
        S = list(map(int,input().split()))
    except:
        break
    mean = sum(S)/len(S)
    tmp = 0
    for s in S:
        tmp += ((s-mean)**2)/n
    print(tmp**0.5)
"
"import sys
def LS2(): return list(sys.stdin.readline().rstrip())  #空白なし


A = LS2()
N = len(A)

# 答えは、(Ai != Aj たる 1 <= i < j <= N の個数) +1

from collections import defaultdict

d = defaultdict(int)
for i in range(N):
    d[A[i]] += 1

ans = 0
for key in d.keys():
    ans += d[key]*(N-d[key])

ans //= 2
ans += 1
print(ans)
"
"if """".join(sorted(input().split())) == ""557"":
    print(""YES"")
else:
    print(""NO"")
"
"N=int(input())
A=list(map(int,input().split()))
B=[]
for i in range(N):
  B.append(A[i]-(i+1))
B.sort()
b=B[N//2]
ans=0
for i in range(N):
  ans+=abs(B[i]-b)
print(ans)"
"import sys
import itertools
# import numpy as np
import time
import math
 
sys.setrecursionlimit(10 ** 7)
 
from collections import defaultdict
 
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines


N, M = map(int, readline().split())

adj = [[] for _ in range(N)]
for i in range(M):
    x, y, z = map(int, readline().split())
    x -= 1
    y -= 1
    adj[x].append(y)
    adj[y].append(x)

visited = [False for _ in range(N)]
def dfs(v):
    if visited[v]:
        return False
    visited[v] = True
    for u in adj[v]:
        dfs(u)
    return True


ans = 0
for i in range(N):
    if dfs(i):
        ans += 1
print(ans)"
"A = [1,3,5,7,8,10,12]
B = [4,6,9,11]
a,b = map(int, input().split())
if ((a in A)and(b in A)) or ((a in B) and (b in B)) or a == b == 2:
    print(""Yes"")
else:
    print(""No"")"
"a, b = list(map(int, input().split()))
c, d = list(map(int, input().split()))

print( (a-c) * (b-d) )"
"import sys
from operator import itemgetter
read = sys.stdin.read

N, K, *td = map(int, read().split())
td = sorted(zip(*[iter(td)] * 2), key=itemgetter(1), reverse=True)

stack = []
taste = 0
neta_group = set()
for t, d in td[:K]:
    taste += d
    if t in neta_group:
        stack.append(d)
    else:
        neta_group.add(t)

variety = len(neta_group)
candidates = [taste + variety ** 2]

if N == K:
    print(candidates[0])
    exit()

rest = list(reversed(td[K::]))

while rest and stack:
    t1, d1 = rest.pop()
    if t1 not in neta_group:
        neta_group.add(t1)
        d2 = stack.pop()
        variety += 1
        taste = taste - d2 + d1

        candidates.append(taste + variety ** 2)

print(max(candidates))"
"def atc_131a(input_value: str) -> str:
    for i in range(0, len(input_value) - 1):
        if input_value[i] == input_value[i + 1]:
            return ""Bad""
    return ""Good""

input_value = input()
print(atc_131a(input_value))"
"import heapq

N=int(input())
A=sorted(list(map(int,input().split())), reverse=True)
ans=0
H=[-1*A[0]]
heapq.heapify(H)
for a in A[1:]:
  ans-=heapq.heappop(H)
  heapq.heappush(H,-1*a)
  heapq.heappush(H,-1*a)
print(ans)"
"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')"
"def algae(r, d, x):

    ans = []
    count = x
    for i in range(1, 11):
        count = r*count - d
        ans.append(count)
    return ans

def main():
    r, d, x = map(int, input().split())
    ans = algae(r, d, x)
    for i in ans:
        print(i)

if __name__ == '__main__':
    main()"
"# -*- coding: utf-8 -*-
# E

N, K = map(int, input().split())
A = list(map(int, input().split()))
A.sort()
mod = 10**9 + 7


class Cmb(object):
    def cmb_precalc(self, n, r, mod: int = 10 ** 9 + 7):
        if (r < 0) or (r > n):
            return 0
        r = min(r, n - r)
        return self.g1[n] * self.g2[r] * self.g2[n - r] % mod

    def cmb_prep(self, N: int, mod: int = 10 ** 9 + 7):
        self.g1 = [1, 1]  # 元テーブル
        self.g2 = [1, 1]  # 逆元テーブル
        inverse = [0, 1]  # 逆元テーブル計算用テーブル

        for i in range(2, N + 1):
            self.g1.append((self.g1[-1] * i) % mod)
            inverse.append((-inverse[mod % i] * (mod // i)) % mod)
            self.g2.append((self.g2[-1] * inverse[-1]) % mod)


ans = 0
cmb = Cmb()
cmb.cmb_prep(N + 5)

for i in range(N):
    if i >= K-1:
        ans += A[i] * cmb.cmb_precalc(i, i-K+1)
    if N - i - 1 >= K-1:
        ans -= A[i] * cmb.cmb_precalc(N-i-1, K-1)

print(ans % mod)
"
"#38 B - Problem Set
import collections
N = int(input())
D = list(map(int,input().split()))
M = int(input())
T = list(map(int,input().split()))

cntD = collections.Counter(D)
cntT = collections.Counter(T)

result = 'YES'
for t in cntT.keys():
    if not(t in cntD):
        result = 'NO'
        break
    if cntT[t] > cntD[t]:
        result = 'NO'
        break
print(result)"
"from sys import stdin
from collections import deque
input = stdin.readline

nodelist = deque()
N = int(input())
for i in range(N):
    command = input().split()
    if command[0] == 'insert':
        nodelist.appendleft(command[1])
    elif command[0] == 'delete':
        try:
            nodelist.remove(command[1])
        except:
            continue
    elif command[0] == 'deleteFirst':
        nodelist.popleft()
    else:
        nodelist.pop()
print(*nodelist)
"
"arr=['MON','TUE','WED','THU','FRI','SAT','SUN']
s=input()
if s=='SUN':
    print (7)
else:
    k=arr.index(s)
    print (6-k)"
"N = int(input())
A = list(map(int, (input() for i in range(N))))
B = sorted(A, reverse=True)
a = B[0]
a1 = B[1]


for x in A:  
  if x != a:
    print(a)
  else:
    print(a1)"
"a = int(input())
res = a+a**2+a**3
print(res)
"
"s = input()

while True:
    l = len(s)
    s = s[:l - 1]
    if len(s) % 2 != 0:
        pass
    else:
        if s[:len(s) // 2] == s[len(s) // 2:]:
            print(len(s))
            break
"
"# -*- coding: utf-8 -*-

def main():

    N = int(input())
    S = input()

    listS = list(S)
    x = 0
    listNum = [x]

    for i in listS:
        if i == 'I':
            x += 1
            listNum.append(x)

        elif i == 'D':
            x += -1
            listNum.append(x)

    ans = max(listNum)
    print(ans)


if __name__ == ""__main__"":
    main()"
"N=int(input())
v=list(map(int,input().split()))
while len(v)!=1:
    v=sorted(v)
    x=(v[0]+v[1])/2
    v.pop(0)
    v.pop(0)
    v.append(x)
print(v[0])"
"n = int(input())
a = list(map(int,input().split()))
a=sorted(a)
print(sum(a[-n*3+n:-1:2]))"
"from collections import Counter
n=int(input())
s=[]
for _ in range(n):
    temp=sorted(list(input()))
    s.append("""".join(temp))
s_count=Counter(s)
ans=0
for i in s_count:
    ans+=((s_count[i])*(s_count[i]-1))//2
print(ans)"
"#from collections import deque
#from heapq import heapify, heappop, heappush
#from bisect import insort
#from math import gcd
#from decimal import Decimal
#mod = 1000000007
#mod = 998244353
#N = int(input())
N, K = map(int, input().split())
S = input()
#A = list(map(int, input().split()))
#flag = True
if N==1:
  print(0)
  exit()
cnt = 0
if S[0] == 'R':
  if S[1] == 'R':
    cnt += 1
if S[-1] == 'L':
  if S[-2] == 'L':
    cnt += 1
for k in range(1,N-1):
  if S[k] == 'L':
    if S[k-1] =='L':
      cnt += 1
  else:
    if S[k+1] == 'R':
      cnt += 1

ans = min(N-1, cnt+2*K)

print(ans)
#print('Yes')
#print('No')"
"a,b,c,d,e,k = map(int,open(0).read().split())

if e-a<=k:
  print(""Yay!"")
else:
  print("":("")"
"N = int(input())
V = list(map(int,input().split()))
O = []
E = []
nums_O = []
nums_E = []

for i in range(0,N,2):
  O.append(V[i])
  E.append(V[i+1])

for j in range(100000):
  nums_O.append([0,j])
  nums_E.append([0,j])

for k in range(N//2):
  nums_O[O[k]-1][0] += 1
  nums_E[E[k]-1][0] += 1
  
nums_O.sort()
nums_E.sort()
##print(O,E,nums_O[-1],nums_E[-1])
if nums_O[-1][1] != nums_E[-1][1]:
  print(N-(nums_O[-1][0] + nums_E[-1][0]))
else:
  print(N-max(nums_E[-2][0]+nums_O[-1][0],nums_O[-2][0]+nums_E[-1][0]))"
"N = int(input())

ans = 0
for i in range(1, N):
    for j in range(1, N):
        if i * j < N:
            ans += 1
        else:
            break

print(ans)"
"n, a, b = map(int, input().split())
ans = min(a*n, b)
print(ans)"
"num = str(input())
op = ['+', '-']

for i in range(2**3):
    ans = int(num[0])
    t_op = []
    for j in range(3):
        if (i >> j)&1:
            ans -= int(num[j+1])
            t_op.append('-')
        else:
            ans += int(num[j+1])
            t_op.append('+')
    if ans == 7:
        ans_l = [num[0], t_op[0], num[1], t_op[1], num[2], t_op[2], num[3], '=7']
        print(*ans_l,sep='')
        break"
"from collections import defaultdict
d = defaultdict(int)
r = 1
p = """"
for _ in range(int(input())):
  c = input()
  if c != p:
    r = (r + d[c]) % (10**9 + 7)
    d[c] = r
  p = c
print(r)

"
"S = input()
N = len(S)
mod = 10**9+7
P = 13
 
dp = [[0 for _ in range(P)] for _ in range(N+1)]
dp[0][0] = 1
 
for i in range(N):
    x = S[-1-i]
    if x == '?':
        base = pow(10, i, P)
        for j in range(10):
            r = base*j % P
            for m in range(P):
                dp[i+1][(m+r)%P] = (dp[i+1][(m+r)%P] + dp[i][m]) % mod
    else:
        r = pow(10, i, P) * int(x) % P
        for j in range(P):
            dp[i+1][(j+r)%P] = max(dp[i+1][(j+r)%P], dp[i][j])
 
print(dp[-1][5])
"
"N = int(input())
arr = list(map(int, input().split()))
 
count =0
while True:
    if sum(arr) == 0:
        break
    count +=1
    start = False
 
    for i in range(N):
        if arr[i] != 0:
            arr[i] -= 1
            start = True
            continue
        if arr[i] == 0 and start == True:
            break
print(count)"
"import bisect,collections,copy,heapq,itertools,math,string
import sys
def I():
    #1 line 1 int
     return int(sys.stdin.readline().rstrip())
def LI():
    #1 line n int
     return list(map(int,sys.stdin.readline().rstrip().split()))
def S():
    #1 line 1 string
     return sys.stdin.readline().rstrip()
def LS():
    #1 line n strings
     return list(sys.stdin.readline().rstrip().split())

A=S()

if A[0] == A[1] == A[2] or A[1] == A[2] == A[3]:
    print(""Yes"")
else:
    print(""No"")"
"def main():
    S = list(input().rstrip())
    if len(S) == len(set(S)):
        print(""yes"")
    else:
        print(""no"")


if __name__ == '__main__':
    main()
"
"from collections import Counter


def solve(string):
    n, *aqbc = map(int, string.split())
    a, _, bc = aqbc[:n], aqbc[n], aqbc[n + 1:]
    s = sum(a)
    t = Counter(a)
    ans = []
    for b, c in zip(*[iter(bc)] * 2):
        if b not in t.keys():
            ans.append(s)
            continue
        if c in t.keys():
            t[c] += t[b]
        else:
            t[c] = t[b]
        s += (c - b) * t[b]
        del t[b]
        ans.append(s)
    return ""\n"".join(map(str, ans))


if __name__ == '__main__':
    import sys
    print(solve(sys.stdin.read().strip()))
"
"k = int(input())

e = k // 2

print(e * (k - e))"
"import sys
while True:
    (n, x) = [int(i) for i in sys.stdin.readline().split()]
    if n == x == 0:
        break
    count = 0
    for i in range(1, n + 1):
        if i >= x: break
        for j in range(i + 1, n + 1):
            if i + j >= x: break
            for k in range(j + 1, n + 1):
                if i + j + k == x: count += 1
                elif i + j + k > x: break
    print(count)"
"import sys, math
lines = [s.rstrip(""\n"") for s in sys.stdin.readlines()]
x, = [int(num) for num in lines.pop(0).split("" "")]
max_base = int(math.sqrt(x))
max = 1
for base in range(2, max_base + 1):
    i = 2
    while True:
        tmp_max = base ** i
        if tmp_max <= x:
            if tmp_max > max:
                max = tmp_max
            i += 1
        else:
            break
print(max)
"
"pqr = list(map(int, input().split()))
pqr.sort()
print(pqr[0] + pqr[1])
"
"s = int(input())
MOD = 10**9 + 7
C = [0]*(s + 1)
C[0] = 1
for n in range(3, s+1): C[n] = (C[n-1] + C[n-3]) % MOD
print(C[s])
"
"x = input()
s = input()

n, a, b = map(int, x.split())

p = 0
wp = 0

for char in s:
    if char == 'c' or p >= a+b:
        print('No')
        continue
    if char == 'a':
        p += 1
        print('Yes')
        continue
    if wp < b:
        p += 1
        wp += 1
        print('Yes')
    else:
        print('No')"
"INF = 10 ** 15


def bellman_ford(v, G):
    ret = [INF] * len(G)
    ret[v] = 0

    for _ in range(len(G) - 1):
        for u, g in enumerate(G):
            for w, l in g:
                if not ret[u] == INF and ret[w] > ret[u] + l:
                    ret[w] = ret[u] + l

    for _ in range(len(G)):
        for u, g in enumerate(G):
            for w, l in g:
                if not ret[u] == INF and ret[w] > ret[u] + l:
                    ret[w] = -INF

    return ret


N, M = map(int, input().split())
G = [[] for _ in range(N)]
for _ in range(M):
    a, b, c = map(int, input().split())
    G[a - 1].append((b - 1, -c))

ans = bellman_ford(0, G)[-1]
print('inf' if ans == -INF else -ans)
"
"n, m = map(int, input().split())
s = input()

dp = [float('inf')] * (n + 1)
dp[0] = 0

N = n + 1
N0 = 2 ** (N - 1).bit_length()
data = [float('inf')] * (2 * N0)

# a_k の値を x に更新
def update(k, x):
    k += N0 - 1
    data[k] = x
    while k >= 0:
        k = (k - 1) // 2
        data[k] = min(data[2 * k + 1], data[2 * k + 2])

# [a_l, a_(l+1), ..., a_(r-1)]の最小値を求める
def query(l, r):
    L = l + N0
    R = r + N0
    s = float('inf')
    while L < R:
        if R & 1:
            R -= 1
            s = min(s, data[R - 1])

        if L & 1:
            s = min(s, data[L - 1])
            L += 1
        L >>= 1
        R >>= 1
    return s

update(0, 0)
for i in range(1, n + 1):
    if s[i] == '1':
        continue

    dp[i] = query(max(0, i - m), i) + 1
    update(i, dp[i])

if dp[-1] == float('inf'):
    print(-1)
else:
    cur = n
    target = dp[n] - 1
    arr = [n]

    while cur > 0:
        for i in range(max(0, cur - m), cur):
            if dp[i] == target:
                cur = i
                target -= 1
                arr.append(i)
                break

    arr = arr[::-1]
    ans = []
    for i in range(len(arr) - 1):
        ans.append(arr[i+1] - arr[i])

    for _ans in ans:
        print(_ans)
"
"s=list(input())
ans=0
for i in range(len(s)):
    if len(s)<=1:
        break
    if s[0]==s[-1]:
        del s[0]
        del s[-1]
    else:
        if s[0]==""x"":
            ans+=1
            del s[0]
        elif s[-1]==""x"":
            ans+=1
            del s[-1]
        else:
            ans=-1
            break
print(ans)
"
"A,B,C=input().split();print((A[0]+B[0]+C[0]).upper())"
"import sys
sys.setrecursionlimit(10 ** 7)

N = input()

# TLE (Python3 3.4.3)
# AC  (PyPy3 (2.4.0))

# DP
INF = pow(10, 8)
L = len(N)
dp = [[INF] * 2 for _ in range(L+2)]
dp[0][0] = 0

# reverse
N = N[::-1] + '0'


for i in range(L+1):
    n = int(N[i])

    # 更新後のdp
    ni = i + 1

    # 前の桁で繰り下がりなし
    # 同じだけ払う
    dp[ni][0] = min(dp[ni][0], dp[i][0] + n)

    # 繰り下がりあり
    if n > 0:
        dp[ni][1] = min(dp[ni][1], dp[i][0] + (10 - n))
    else:
        dp[ni][0] = min(dp[ni][0], dp[i][0])

    # 前の桁で繰り下がりあり
    n += 1

    # 同じだけ払う
    if n == 10:
        dp[ni][1] = min(dp[ni][1], dp[i][1])
    else:
        dp[ni][0] = min(dp[ni][0], dp[i][1] + n)

    # 繰り下がりあり
    dp[ni][1] = min(dp[ni][1], dp[i][1] + (10 - n))


ans = min(dp[L+1][0], dp[L+1][1])

print(ans)
"
"n = input(); n = int(n)
a = n//2 -1 if n % 2 == 0 else n//2
print(a)
"
"import sys
readline = sys.stdin.buffer.readline

N = int(readline())
S = [readline().rstrip().decode() for _ in range(N)]

def count_cb_ob(s):
    st = []
    for i, si in enumerate(s):
        if si == '(' or len(st) == 0 or st[-1] != '(':
            st.append(si)
        else:
            st.pop()
    return st.count(')'), st.count('(')

cb_obs = list(map(count_cb_ob, S))
f = list(filter(lambda cb_ob: cb_ob[0] < cb_ob[1] , cb_obs))
b = list(filter(lambda cb_ob: cb_ob[0] > cb_ob[1] , cb_obs))
s = list(filter(lambda cb_ob: cb_ob[0] == cb_ob[1] , cb_obs))

f = sorted(f)
b = sorted(b, key=lambda x:x[1], reverse=True)

count = 0
ans = 'Yes'
for down, up in (*f, *s, *b):
    count -= down
    if count < 0:
        ans = 'No'
    count += up

if count != 0:
    print('No')
else:
    print(ans)"
"N = int(input())
xy = [list(map(int,input().split())) for _ in range(N)]
if N == 1:
  print(1)
  exit()
d = []
for i in range(N):
  for j in range(N):
    if i == j:
      continue
    X = xy[i][0] - xy[j][0]
    Y = xy[i][1] - xy[j][1]
    d.append([X,Y])
d.sort()
#print(d)
cnt = 1
tmp = 1
std = d[0]
for i in range(1,len(d)):
  if d[i] == std:
    tmp += 1
  else:
    tmp = 1
  std = d[i]
  cnt = max(cnt,tmp)
print(N - cnt)"
"n = int(input())
k = int(input())

def re_def(num, c, n=n, k=k):
    if c==n:
        return num
    for i in range(2):
        if i==0:
            num1 = re_def(num*2, c+1)
        else:
            num2 = re_def(num+k, c+1)
    return min([num1, num2])
print(re_def(1,0))"
"N,i = map(int,input().split())
print(max(1,N-i+1))"
"import sys
import math
import copy
from heapq import heappush, heappop, heapify
from functools import cmp_to_key
from bisect import bisect_left, bisect_right
from collections import defaultdict, deque, Counter
# sys.setrecursionlimit(1000000)

# input aliases
input = sys.stdin.readline
getS = lambda: input().strip()
getN = lambda: int(input())
getList = lambda: list(map(int, input().split()))
getZList = lambda: [int(x) - 1 for x in input().split()]

INF = float(""inf"")
MOD = 10**9 + 7
divide = lambda x: pow(x, MOD-2, MOD)

def nck(n, k, kaijyo):
    return (npk(n, k, kaijyo) * divide(kaijyo[k])) % MOD

def npk(n, k, kaijyo):
    if k == 0 or k == n:
        return n % MOD
    return (kaijyo[n] * divide(kaijyo[n-k])) % MOD

def fact_and_inv(SIZE):
    inv = [0] * SIZE  # inv[j] = j^{-1} mod MOD
    fac = [0] * SIZE  # fac[j] = j! mod MOD
    finv = [0] * SIZE  # finv[j] = (j!)^{-1} mod MOD
    inv[1] = 1
    fac[0] = fac[1] = 1
    finv[0] = finv[1] = 1
    for i in range(2, SIZE):
        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD
        fac[i] = fac[i - 1] * i % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    return fac, finv

def renritsu(A, Y):
    # example 2x + y = 3, x + 3y = 4
    # A = [[2,1], [1,3]])
    # Y = [[3],[4]] または [3,4]
    A = np.matrix(A)
    Y = np.matrix(Y)
    Y = np.reshape(Y, (-1, 1))
    X = np.linalg.solve(A, Y)

    # [1.0, 1.0]
    return X.flatten().tolist()[0]

class TwoDimGrid:
    # 2次元座標 -> 1次元
    def __init__(self, h, w, wall=""#""):
        self.h = h
        self.w = w
        self.size = (h+2) * (w+2)
        self.wall = wall
        self.get_grid()
        # self.init_cost()

    def get_grid(self):
        grid = [self.wall * (self.w + 2)]
        for i in range(self.h):
            grid.append(self.wall + getS() + self.wall)

        grid.append(self.wall * (self.w + 2))
        self.grid = grid
    def init_cost(self):
        self.cost = [INF] * self.size

    def pos(self, x, y):
        # 壁も含めて0-indexed 元々の座標だけ考えると1-indexed
        return y * (self.w + 2) + x
    def getgrid(self, x, y):
        return self.grid[y][x]
    def get(self, x, y):
        return self.cost[self.pos(x, y)]
    def set(self, x, y, v):
        self.cost[self.pos(x, y)] = v
        return
    def show(self):
        for i in range(self.h+2):
            print(self.cost[(self.w + 2) * i:(self.w + 2) * (i+1)])
    def showsome(self, tgt):
        for t in tgt:
            print(t)
        return
    def showsomejoin(self, tgt):
        for t in tgt:
            print("""".join(t))
        return

    def search(self):
        grid = self.grid
        move = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        move_eight = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        # for i in range(1, self.h+1):
        #     for j in range(1, self.w+1):
        #         cx, cy = j, i
        #         for dx, dy in move_eight:
        #             nx, ny = dx + cx, dy + cy

def solve():
    n = getN()
    g = []
    for i in range(n):
        g.append(getList())

    ans = 0
    for i in range(n):
        for j in range(i+1, n):
            cc = g[i][j]
            fl = True
            for k in range(n):
                if k == i or k == j:
                    continue
                if g[i][k] + g[j][k] < cc:
                    print(-1)
                    return
                elif g[i][k] + g[j][k] == cc:
                    fl = False

            if fl:
                ans += cc

    print(ans)

def main():
    n = getN()
    for _ in range(n):
        solve()

    return
if __name__ == ""__main__"":
    # main()
    solve()"
"import sys
read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N = int(readline())

    print(N * (N - 1) // 2)


if __name__ == ""__main__"":
    main()
"
"A=sorted(list(map(int,input().split())))
N=int(input())
A[-1]=A[-1]*2**N
print(sum(A))"
"#-*-coding:utf-8-*-
import sys
input=sys.stdin.readline

def main():
    n = int(input())
    ans=10**12
    tmp=[]
    for a in range(1,10**6+1):
        if n%a==0 and n >=a:
            b=n//a
        elif n <a:
            break
        #a,bの最小値を記憶してくれてる？
        ans=min(ans,a+b-2)
    print(ans)

if __name__==""__main__"":
    main()"
"n=input()[::-1]
n+=""0""
lt=len(n)
dp=[[float('inf') for _ in range(2)] for j in range(lt+1)]
dp[0][0]=0

for i in range(0,lt):
    for j in range(2):
        x=int(n[i])
        x+=j #繰り上がり処理，あとに+11でもOK
        for num in range(0,10):
            ni = i + 1
            nj = 0
            b=num-x
            if b<0:
                b+=10
                nj=1
            dp[ni][nj]=min(dp[ni][nj],dp[i][j]+num+b)

print(dp[lt][0])"
"from copy import deepcopy
from collections import deque
from itertools import product
import numpy as np
class Grid:
    def __init__(self, grid, w=0, h=0, function=lambda x: x):
        self.w = w = w if w else len(grid[0])
        self.h = h = h if h else len(grid)
        dtype = type(function(grid[0][0]))
        self.grid = np.empty((h, w), dtype=dtype)
        for i, row in zip(range(h), grid):
            for j, val in zip(range(w), row):
                self.grid[i][j] = function(val)
    
    def is_valid_x(self, x):
        return 0 <= x < self.w
    def is_valid_y(self, y):
        return 0 <= y < self.h
    def is_valid_xy(self, x, y):
        return self.is_valid_x(x) and self.is_valid_y(y) 
    
    def __iter__(self):
        return iter(self.grid)
    def __repr__(self):
        return '\n'.join([' '.join(map(str, row)) for row in self.grid]) + '\n'
    def __getitem__(self, x):
        return self.grid[x]
    def __setitem__(self, x, val):
        self.grid[x] = val

def longest_path(grid, root):
    def restore_path(prev, p):
        A = deque()
        while p:
            A.appendleft(p)
            p = prev[p]
        return list(A)
    
    x, y = root
    prev = {root:None}
    grid[y, x] = '!'
    queue = deque([root])
    while queue:
        x, y = queue.popleft()
        for dx, dy in zip([1, 0, -1, 0], [0, 1, 0, -1]):
            nx, ny = x+dx, y+dy
            if grid.is_valid_xy(nx, ny) and grid[ny, nx] in 'sg.':
                prev[nx, ny] = x, y
                queue.append((nx, ny))
                grid[ny, nx] = '!'
    return restore_path(prev, (x, y))

h, w = map(int, input().split())
grid = Grid([input() for s in range(h)])
ans = 0
for y, x in product(range(h), range(w)):
    if grid[y, x] == '.':
        path = longest_path(deepcopy(grid), (x, y))
        ans = max(ans, len(path)-1)
print(ans)"
"s = list(input())
n = len(s)

ans = []
for i in range(n):
    if s[i] == '0':
        ans.append('0')
    if s[i] == '1':
        ans.append('1')
    if s[i] == 'B':
        if ans:
            ans.pop()

print("""".join(ans))
"
"p,q,r=[int(x) for x in input().split()]
a=p+q
b=p+r
c=q+r
print(min(a,b,c))"
"N, M = map(int,input().split())
a = []
b = []
for i in range(M):
    L, R = map(int,input().split())
    a.append(L)
    b.append(R)
a = sorted(a)
b = sorted(b)
A = a[M - 1]
B = b[0]
if A <= B:
    print(B - A + 1)
else:
    print(0)"
"n = int(input())
s = input()

count = s.count('E')
ans = s.count('E')
for i in range(len(s)):
    if s[i] == 'E':
        count -=1
    else:
        count+=1
    ans = min(count,ans)
print(ans)"
"n, k = map(int, input().split())
h = []
for i in range(n):
  h_ = int(input())
  h.append(h_)
h.sort()
#print(h)
ans = float('inf')
for i in range(n-k+1):
  ans = min(ans, h[i+k-1]-h[i])
print(ans)"
"s = list(input())
box = []
for i in range(len(s)):
  if s[i] == ""0"":
    box.append(""0"")
  elif s[i] == ""1"":
    box.append(""1"")
  else:
    if box == []:
      pass
    else:
      box.pop(-1)
print("""".join(box))"
"s = input()
k = int(input())
n = len(s)

s = list(s)
ans = []
for i in range(n + 1):
    for j in range(i + 1, min(i + 1 + k, n + 1)):
        ans.append(str(''.join(s[i:j])))

ans = sorted(list(set(ans)))
print(ans[k - 1])
"
"a, b, c = input()
d, e, f = input()

cnt = 0
if a == d:
    cnt += 1
if b == e:
    cnt += 1
if c == f:
    cnt += 1

print(cnt)"
"import sys

N, K = map(int, input().split())
A = list(map(int, sys.stdin.readline().rsplit()))
mod = 10 ** 9 + 7

cnt = 0
for i in range(N - 1):
    for j in range(i + 1, N):
        if A[i] > A[j]:
            cnt += 1
res = (K * cnt) % mod
cnt2 = 0
for i in range(N):
    for j in range(i):
        if A[i] > A[j]:
            cnt2 += 1
    for j in range(i + 1, N):
        if A[i] > A[j]:
            cnt2 += 1
res += (cnt2 * ((K * (K - 1)) // 2)) % mod
print(res % mod)"
"S = list(map(int, list(input())))

pops = 0
digi = 1
cnt = [0] * 2019
cnt[0] = 1

while S:
    s = S.pop()

    pops = (pops + s * digi) % 2019
    digi = (10 * digi) % 2019

    cnt[pops] += 1

ans = 0

for i in range(2019):
    ans += cnt[i] * (cnt[i] - 1) // 2

print(ans)"
"n = int(input())
li = list(map(int, input().split()))

l = sorted(li)
lis = []
for i in range(2*n):
    if (i%2 == 0):
        lis.append(l[i])

a = sum(lis)
print(a)"
"import math
def ip():return int(input())
def inp():return map(int,input().split())

H,W=inp()
h,w=inp()
print((H-h)*(W-w))"
"a, b, t = map(int, input().split())
if a > t:
    print(""0"")
else:
    s = t//a
    print(b*s)"
"import math
a,b,c,d = map(int,input().split())
a -= 1
ans = b-a
ans -= b//c - a//c
ans -= b//d - a//d
e = c*d//math.gcd(c,d)
ans += b//e - a//e
print(ans)
"
"n, m = (input().split())
if n == m:
    print('Yes')
else:
    print('No')
"
"n = int(input())
T = list(map(int, input().split()))
A = list(map(int, input().split()))

MOD = 10 ** 9 + 7

# T -> の向きでみて増加している場合と初項は対応するAの要素はa >= t
# 同様に、A <- の向きでみて増加している場合と初項は対応するTの要素はa <= t


cap = [min(t, a) for t, a in zip(T, A)]

if max(A) != max(cap) or max(T) != max(cap):
  print(0)
  exit()

capm = max(cap)

cm = cap.count(capm)

ans = 1

if cm > 2:
  for _ in range(cm - 2):
    ans *= capm
    ans %= MOD

for i in range(1, n - 1):
  if cap[i] == capm:
    break
  if cap[i - 1] == cap[i] and cap[i] <= cap[i + 1]:
    if cap[i] < cap[i + 1] or not cap[i + 1] == capm: 
      ans *= cap[i]
      ans %= MOD

for i in reversed(range(1, n - 1)):
  if cap[i] == capm:
    break
  if cap[i + 1] == cap[i] and cap[i] <= cap[i - 1]:
    if cap[i] < cap[i - 1] or not cap[i - 1] == capm: 
      ans *= cap[i]
      ans %= MOD
      
print(ans)"
"a, b, c, k = list(map(int, input().split()))
count = 0
if a >= k:
  count += min(a, k)
elif a+b >= k:
  count += a
else:
  count += (a-(k-a-b))
print(count)"
"class SortingThreeNumbers:
    def __init__(self, n):
        n.sort()
        print ""%(a)d %(b)d %(c)d"" % {'a':n[0],'b':n[1],'c':n[2]}
        return

if __name__ == ""__main__"":
    n = (map(int, raw_input().split()))
    SortingThreeNumbers(n)"
"import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy

N = int(input())

m = {}

for i in range(N):
    s = input()
    if s[0] not in ""MARCH"":
        continue

    m[s[0]] = m.get(s[0], 0) + 1

ans = 0
for i in range(5):
    for j in range(i + 1, 5):
        for k in range(j + 1, 5):
            ans += m.get(""MARCH""[i], 0) * m.get(""MARCH""[j], 0) * m.get(""MARCH""[k], 0)

print(ans)"
"import sys
N,K = map(int,input().split())
int_array = list(map(int,input().split()))

if N < 0 or K < 0 or N > 50 or K > 50:
    sys.exit()
for I in int_array:
    if I > 50:
        sys.exit()

rev_sort_int_array = sorted(int_array,reverse=True)
result = 0
for J in range(K):
    result += rev_sort_int_array[J]

print(result)"
"import sys
sys.setrecursionlimit(10**9)


class RollingHash:

    def __init__(self,string):
        base1 = 1007
        mod1 = 10**9+7

        base2 = 2009
        mod2 = 10**9+9

        self.string = string
        n = len(string)
        hash1 = [0]*(n+1)
        power1 = [1]*(n+1)

        hash2 = [0]*(n+1)
        power2 = [1]*(n+1)
        for i,e in enumerate(string):
            hash1[i+1] = (hash1[i]*base1 + ord(e))%mod1
            power1[i+1] = (power1[i]*base1)%mod1
            hash2[i+1] = (hash2[i]*base2 + ord(e))%mod2
            power2[i+1] = (power2[i]*base2)%mod2

        self.hash1 = hash1
        self.power1 = power1
        self.hash2 = hash2
        self.power2 = power2
        self.base1 = base1
        self.mod1 = mod1
        self.base2 = base2
        self.mod2 = mod2

    def calc(self,i,j):
        ans = ((self.hash1[j]-self.hash1[i]*self.power1[j-i]%self.mod1)%self.mod1)*(10**10)
        ans += (self.hash2[j]-self.hash2[i]*self.power2[j-i]%self.mod2)%self.mod2
        return ans

def main():
    N = int(input())
    S = input()

    rh = RollingHash(S)


    ans = 0
    l = 0
    r = N


    while r-l > 1:
        mid = (l+r)//2
        seen = set()
        dic = {}
        found = False
        for i in range(N-mid+1):
            if not i < i+mid-1: continue

            hash = rh.calc(i,i+mid-1)
            # print(hash,i,i+mid-1,mid)
            if hash in seen:
                for _i,j in dic[hash]:
                    if j < i and S[_i:j+1] == S[i:i+mid]:
                        ans = max(ans,mid)
                        found = True
                        break
                else: continue

                dic[hash].append((i,i+mid-1))
                break
            else:
                dic[hash] = [(i,i+mid-1)]
                seen.add(hash)


        if found:
            l = mid
        else:
            r = mid

    print(ans)



if __name__ == ""__main__"":
  main()"
"from collections import deque

N = int(input())
a = deque(sorted(map(int, input().split())))


max_a = a.pop()
min_a = a.popleft()

ans_s = """"
while True:
    if len(a) <= 0:
        ans_s += ""{} {}\n"".format(max_a, min_a)
        ans = max_a - min_a
        break

    if max_a <= 0:
        ans_s += ""{} {}\n"".format(max_a, min_a)
        max_a -= min_a

        min_a = a.popleft()
    elif min_a >= 0:
        ans_s += ""{} {}\n"".format(min_a, max_a)
        min_a -= max_a

        max_a = a.pop()
    else:
        w = a.pop()
        if w < 0:
            ans_s += ""{} {}\n"".format(max_a, w)
            max_a -= w
        else:
            ans_s += ""{} {}\n"".format(min_a, w)
            min_a -= w

print(ans)
print(ans_s, end="""")

"
"input()
print(""Four"" if 'Y' in input() else ""Three"")"
"import sys
input = sys.stdin.readline
N = int(input().rstrip())
lis = {}
for _ in range(N):
  a = input().rstrip()
  if a in lis:
    lis[a] += 1
  else:
    lis[a] = 1
print(len(lis))"
"from itertools import permutations
n,ma, mb = map(int, input().split())
abc = []
inf = float('INF')
hw = 400 + 1
dp = [[inf for i in range(hw)] for j in range(hw)]
dp[0][0] = 0
for _ in range(n):
    a,b,c = map(int, input().split())
    abc.append((a,b,c))

abc.sort(key = lambda x:(-x[0],x[1]))
for a,b,c in abc:
    for i in range(hw-a)[::-1]:
        for j in range(hw-b)[::-1]:
            if dp[i+a][j+b] > dp[i][j] + c:
                dp[i+a][j+b] = dp[i][j] + c

a,b = ma, mb
ans = [dp[a*i][b*i] for i in range(1,hw // max(a,b)) if dp[a*i][b*i] < inf]
print(min(ans) if len(ans) else -1)
# [print(i, f) for i,f in enumerate(dp[200:])]
# print(ans)"
"n, *ABCD = map(int, open(0).read().split())
AB = sorted([(a, b) for a, b in zip(ABCD[:2*n:2], ABCD[1:2*n:2])], key=lambda x:-x[1])
CD = sorted([(c, d) for c, d in zip(ABCD[2*n::2], ABCD[2*n+1::2])])

for c, d in CD:
    for i in range(len(AB)):
        a, b = AB[i]
        if a < c and b < d:
            _ = AB.pop(i)
            break
print(n-len(AB))"
"n, k = map(int, input().split())
if k == 0:
    print(n**2)
    exit()

ans = 0
# 割る値bを固定して該当するaの個数を足し上げる
for b in range(k+1, n + 1):
    q = n // b
    r = n % b
    if r < k:
        ans += q * (b-k)
    else:
        ans += q * (b-k) + (r-k+1)
print(ans)
"
"N = int(input())
print(1/sum([1/a for a in list(map(int,input().split()))]))"
"N = int(input())
S = input()

from collections import defaultdict

memo = [defaultdict(int) for j in range(N+1)]

ans = 0



for i,s in enumerate(S):
    memo[i+1][""R""] = memo[i][""R""]
    memo[i+1][""G""] = memo[i][""G""]
    memo[i+1][""B""] = memo[i][""B""]
    memo[i+1][s]+=1
    others = set([""R"",""G"",""B""])
    others.remove(s)
    others = list(others)
    ans += memo[i+1][others[0]] * memo[i+1][others[1]]

rgb = set([""R"",""G"",""B""])
# print(rgb)

if N > 2:
    if N %2 == 1:
        length = N // 2
    else:
        length = N // 2 - 1

    # print(length)
    
    for skip in range(length):
        for i in range(len(S)):
            # print(i)
            if i+2+skip*2 > len(S)-1:

                break
            a,b,c = S[i],S[i+1+skip],S[i+2+skip*2]
            # print(set([a,b,c]))
            if set([a,b,c]) == rgb:
                ans -= 1
        

print(ans)
"
"import sys

def II(): return int(input())
def MI(): return map(int,input().split())
def LI(): return list(map(int,input().split()))
def TI(): return tuple(map(int,input().split()))
def RN(N): return [input().strip() for i in range(N)]


def main():
    H, N = MI()
    N = LI()
    Nsum = sum(N)


    if H<=Nsum:
        print(""Yes"")
    else:
        print(""No"")


if __name__ == ""__main__"":
	main()"
"def main():
    n, m = map(int, input().split())
    ks = []
    for _ in range(m):
        ks.append(list(map(int, input().split())))
    p = list(map(int, input().split()))

    ans = 0
    for i in range(2**n):
        ls = [0]*m
        for j in range(n):
            if i & (1 << j):
                for k in range(m):
                    if j+1 in ks[k][1:]:
                        ls[k] += 1
        cnt = 0
        for l in range(m):
            if ls[l] % 2 == p[l]:
                cnt += 1
        if cnt == m:
            ans += 1

    print(ans)


if __name__ == ""__main__"":
    main()
"
"n=int(input())
a,b=[],[]
for i in range(n):
  aa,bb=map(int,input().split())
  a.append(aa)
  b.append(bb)

a.sort()
b.sort()
if n%2==1:
  print(b[n//2]-a[n//2]+1)
else:
  a_cnt=a[n//2]+a[n//2-1]
  b_cnt=b[n//2]+b[n//2-1]
  print(b_cnt-a_cnt+1)"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# FileName: 	D_fix_2
# CreatedDate:  2020-02-21 20:39:32 +0900
# LastModified: 2020-02-21 23:32:20 +0900
#


import heapq
def initial_signal(i,adj,N):
    d = [float(""inf"") for _ in range(N)]
    d[i] = 0
    Q = [(0,i)]
    return d,Q

def relax(n_cost, u, v, adj,d,Q):
    if d[v] > d[u]+n_cost:
        d[v]=d[u]+n_cost
        heapq.heappush(Q,(d[v],v))



def dijkstra(i,adj,N):
    d,Q = initial_signal(i,adj,N)
    while Q:
        cost, u = heapq.heappop(Q)
        for n_cost, v in adj[u]:
            relax(n_cost, u, v, adj, d, Q)
        
    return d



def main():
    N, M = map(int, input().split())
    adj = [[] for _ in range(N)]
    for _ in range(M):
        a,b,c = map(int, input().split())
        adj[a-1].append((c,b-1))
        adj[b-1].append((c,a-1))
    shortest = []
    for i in range(N):
        shortest.append(dijkstra(i,adj,N))
    ans = 0
    for i in range(N):
        for cost, j in adj[i]:
            if cost>shortest[i][j]:
                ans+=1
    print(ans//2)


if __name__ == ""__main__"":
    main()
"
"N, X = map(int, input().split())
A = list(map(int, input().split()))
ans = 0
if(A[0] > X):
  ans += (A[0]-X)
  A[0] = X
for i in range(1,N):
  S = A[i-1] + A[i]
  if(S > X):
    ans += S-X
    A[i] -= S-X
print(ans)"
"import sys
## io ##
def IS(): return sys.stdin.readline().rstrip()
def II(): return int(IS())
def MII(): return list(map(int, IS().split()))
#======================================================#
def main():
    N = II()
    MAX=3500
    for h in range(1,MAX+1):
        for n in range(1,MAX+1):
            d = 4*h*n-N*h-N*n
            if d > 0 and (N*h*n)%d==0:
                print('{} {} {}'.format(h, n, (N*h*n)//d))
                return None

if __name__ == '__main__':
    main()"
"import copy
N, M = map(int, input().split())
K = []
for i in range(N):
    x, y, z = map(int, input().split())
    K.append([x, y, z])

ans = 0
for i in range(2**3):
    dp = [[-10**12] * (M + 1) for _ in range(N + 1)]
    for u in range(N):
        dp[u][0] = 0
    P = copy.deepcopy(K)
    for l in range(3):
        if ((i >> l) & 1):
            for t in range(N):
                P[t][l] *= -1
    for j in range(1, N+1):
        for k in range(1, M+1):
            if k <= j:
                dp[j][k] = max([dp[j-1][k], dp[j-1][k-1] + sum(P[j-1])])
            else:
                dp[j][k] = dp[j-1][k]
    ans = max(ans, dp[N][M])

print(ans)"
"while 1:
	input_data = [i for i in input().split()]
	if input_data[1] == '?':
		break;
	a = int(input_data[0])
	op = input_data[1]
	b = int(input_data[2])
	if op == '+':
		print(a+b)
	elif op == '-':
		print(a-b)
	elif op == '*':
		print(a*b)
	elif op == '/':
		print(int(a/b))"
"import sys

sys.setrecursionlimit(10 ** 6)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    a=II()
    b=II()
    if a>b:print(""GREATER"")
    elif a==b:print(""EQUAL"")
    else:print(""LESS"")
main()"
"from math import gcd

n = int(input())
ans = 1
for _ in range(n):
    t = int(input())
    ans = ans * t // gcd(ans, t)
print(ans)"
"while True:
        k=map(int,raw_input().split())
        H=k[0]
        W=k[1]
        if H+W==0:
                break
#       
        if W%2==0:
                pattern=""even""
        else:
                pattern=""odd""
#
        if pattern==""even"":
                f_line=""#.""*(W/2)
                s_line="".#""*(W/2)
        if pattern==""odd"":
                f_line=""#.""*((W-1)/2)+""#""
                s_line="".#""*((W-1)/2)+"".""
        for i in range(H):
                if i%2==0:
                        print f_line
                else:
                        print s_line
#
        print """""
"n=int(input())
d=[int(input())for i in range(n)]
num=[0 for i in range(max(d)+1)]
for i in d:
    num[i]+=1
ans=len(num)-num.count(0)
print(ans)"
"N,x=map(int,input().split())
a=list(map(int,input().split()))
ans=0
if sum(a)==x:
    print(N)
else:
    a.sort()
    s=0
    i=0
    while True:
       s+=a[i]
       if i==N-1 and s!=x:
           print(N-1)
           break
       if s>x:
           print(i)
           break
       i+=1
       if i>=N:
           print(N)
           break

"
"d=int(input())
c='Christmas'
l=' Eve'
n=d%22
print(c+l*(3-n))"
"while True:
    x=input()
    if x==""-"":
        break
    else:
        m=int(input())
        for i in range(int(m)):
            n=int(input())
            y=x[:n]
            x=x+y
            x=x[n:]
    print(x)
"
"N, T = map(int, input().split())


AB_array = [list(map(int, input().split())) for _ in range(N)]

AB_array = sorted(AB_array, key=lambda x: x[0])

dp = [[0] * T for _ in range(N)]

ans = 0

for i in range(1, N):
    for j in range(T):
        if j >= AB_array[i - 1][0]:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1]
                           [j - AB_array[i - 1][0]] + AB_array[i - 1][1])
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    ans = max(ans, dp[i - 1][-1] + AB_array[i - 1][1])
ans = max(ans, dp[-1][-1] + AB_array[-1][1])
print(ans)
"
"N = int(input())
S = input()

if N % 2 == 0:
  n = N // 2
  s = S[0:n]

  if S == s * 2:
    print('Yes')
  else:
    print('No')
    
else:
  print('No')"
"import sys
def input(): return sys.stdin.readline().strip()

def resolve():
    a,b=map(int, input().split())
    if a*b%2==0:
        print('Even')
    else:
        print('Odd')
resolve()"
"# -*- coding: utf-8 -*-
import sys
sys.setrecursionlimit(10**9)
INF=10**18
MOD=10**9+7
input=lambda: sys.stdin.readline().rstrip()
YesNo=lambda b: bool([print('Yes')] if b else print('No'))
YESNO=lambda b: bool([print('YES')] if b else print('NO'))
int1=lambda x:int(x)-1

def main():
    a=input().split()
    print('A'+a[1][0]+'C')

if __name__ == '__main__':
    main()
"
"import sys


def solve():
    readline = sys.stdin.buffer.readline
    mod = 10 ** 9 + 7
    x, y = list(map(int, readline().split()))
    if x == 1 and y == 1:
        print(300000 * 2 + 400000)
    else:
        t = 0
        if x == 1:
            t += 300000
        elif x == 2:
            t += 200000
        elif x == 3:
            t += 100000
            
        if y == 1:
            t += 300000
        elif y == 2:
            t += 200000
        elif y == 3:
            t += 100000
        print(t)


if __name__ == '__main__':
    solve()
"
"L = list(input())
w = int(input())
i = 0
while i<len(L):
  print(L[i],end="""")
  i+=w"
"
s=list(input())
s.sort()
print(""Yes"" if s[0]==s[1] and s[2]==s[3] and s[1]!=s[2] else ""No"")"
"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def roots(self):
        return [i for i,x in enumerate(self.parents) if x < 0]

N,M = map(int, input().split())
towns = UnionFind(N)
for i in range(M):
    a,b= map(lambda x: int(x)-1, input().split())
    towns.union(a,b)

print(len(towns.roots())-1)
"
"a,b=map(int,input().split())
print('Yes' if a%2==1 and b%2==1 else 'No')
"
"#104B
s = input()
c_list = []
c_count = 0
answer = ""WA""
for i in range(2,len(s)-1):
    if s[i] == ""C"":
        c_list.append(i)
    if s[i].islower() == False:
        c_count += 1
if s[0]==""A"" and s[1].islower()==True and s[-1].islower()==True and len(c_list)==1 and c_count==1:
    answer=""AC""
print(answer)"
"a = int(input()) // 2
N = input().split("" "")
N = (int(s) for s in N)
N = sorted(N)
bet = N[a] - N[a - 1]
print(bet)
"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
cnt=1
A=sum(a)
l=[]
for i in range(1,int(A**(1/2))+1):
    if A%i!=0:continue
    l.append(i)
    if  A// i != i:
        l.append(A // i)
for i in l:
    x=[0]*n
    for j in range(n):
        x[j]=a[j]%i
    s=sum(x)
    l=0
    x.sort(reverse=True)
    for j in range(n):
        if s<=k and l<=k:
            if (s-l)%i==0:
                if i>cnt:
                    cnt=i
                break
        l+=i-x[j]
        s-=x[j]

print(cnt)"
"H, N, *A = map(int, open(0).read().split())
print(""Yes"") if H <= sum(A) else print(""No"")
"
"a=list(input().split("" ""))
x=int(a[1])
y=int(a[2])
 
if abs(x-y)%2==0:
  print(""Alice"")
else:
  print(""Borys"")"
"
def resolve():
    INF = 10 ** 18
    N, M = map(int, input().split())

    Box_key = []
    for i in range(M):
        a, b = map(int, input().split())
        C = list(map(int, input().split()))
        s = sum(1 << (c - 1) for c in C)
        Box_key.append((s, a))

    # dp[i]: 集合iの宝箱を開ける最小コスト
    dp = [INF] * (1 << N)
    dp[0] = 0

    for s in range(1 << N):
        for i in range(M):
            ns = s | Box_key[i][0]
            cost = dp[s] + Box_key[i][1]
            dp[ns] = min(dp[ns], cost)

    if dp[(1 << N) - 1] == INF:
        print(-1)
    else:
        print(dp[(1 << N) - 1])


if __name__ == ""__main__"":
    resolve()"
"n, s, k = open(0)
j = s[int(k)-1]
print("""".join([""*"",j][i==j] for i in s)[:-1])"
"import sys

def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #空白あり

N,M,P = LI()

import collections

class BellmanFord():
    def __init__(self,N):  # Nは頂点の個数
        self.N = N
        self.e = collections.defaultdict(list)
    def add(self,u,v,d,directed = False):
        if directed is False:  # 無向グラフの場合
            self.e[u].append((v,d))
            self.e[v].append((u,d))
        else:  # 有向グラフの場合
            self.e[u].append((v,d))
    def BellmanFord_negative_bool2(self,s,t):  # sから辿り着ける負の閉路で、tにたどり着けるものは存在するか
        d = collections.defaultdict(lambda: float('inf'))
        d[s] = 0
        for i in range(self.N):
            for u in self.e.keys():
                for v,c in self.e[u]:
                    if d[v] > d[u] + c:
                        if i != self.N - 1:
                            d[v] = d[u] + c
                        else:
                            d[v] = -float('inf')
                            for i in range(self.N):
                                for u in self.e.keys():
                                    for v, c in self.e[u]:
                                        if d[v] > d[u] + c:
                                            d[v] = d[u] + c
                            if d[t] == -float('inf'):
                                return True, d
                            else:
                                return False, d
        return False,d

G = BellmanFord(N)

for i in range(M):
    a,b,c = LI()
    G.add(a,b,P-c,directed=True)

bool,d = G.BellmanFord_negative_bool2(1,N)

if not bool:
    print(max(0,-d[N]))
else:
    print(-1)"
"N, M, K = map(int, input().split())
A = [0] + list(map(int, input().split()))
B = [0] + list(map(int, input().split()))

for i in range(1, N+1):
    A[i] += A[i-1]
for i in range(1, M+1):
    B[i] += B[i-1]

ans = 0

b_index = M

for a_index in range(N+1):
    left = K - A[a_index]
    if left < 0: continue

    while left - B[b_index] < 0:
        b_index -= 1

    ans = max(ans, a_index + b_index)

print(ans)"
"n = int(input())
a = list(map(int, input().split()))

a_dict = {}
for i in a:
    if a_dict.get(i, False):
        a_dict[i] += 1
    else:
        a_dict[i] = 1

def mC2(m):
    return m * (m - 1) // 2

sum = 0
for v in a_dict.values():
    sum += mC2(v)

for i, k in enumerate(a):
    ans = sum - (a_dict[k] - 1)
    print(ans)"
"from collections import Counter
import numpy as np

h, w = map(int, input().split())
arr = [list(map(str, input().rstrip())) for _ in range(h)]

arr = sum(arr, [])

arr = Counter(arr)
arr = np.array(list(arr.values()))


def solve(arr):
    # 偶数×偶数なら、制約がかなりきつい
    if h % 2 == 0 and w % 2 == 0:
        return np.all(arr % 4 == 0)

    # 奇数×奇数なら、
    elif h % 2 == 1 and w % 2 == 1:
        even = (h + w) // 2 - 1
        if (arr % 2 == 1).sum() != 1:
            return False
        odd = arr[np.where(arr % 2 == 1)].sum()
        if odd % 4 == 3:
            even -= 1
        arr = arr[np.where(arr != odd)]
        ans = (arr % 4 == 2).sum() <= even
        ans &= np.all(arr[np.where(arr % 4 != 2)] % 4 == 0)
        return ans

    #　どちらかの辺が偶数なら
    else:
        even = h // 2 if h % 2 == 0 else w // 2
        ans = (arr % 4 == 2).sum() <= even
        ans &= np.all(arr[np.where(arr % 4 != 2)] % 4 == 0)
        return ans


print(""Yes"" if solve(arr) else ""No"")"
"A=[int(input()) for _ in range(5)]
print('Yay!' if A[4]-A[0]<=int(input()) else ':(')"
"n, k = map( int, input().split() )
mod = 10 ** 9 + 7

f = [ 1 ] * ( n + 1 ) 
inv = [ 1 ] * ( n + 1 )

for i in range( 1, n + 1 ):
  f[ i ] = ( f[ i - 1 ] * i ) % mod
  
inv[ n ] = pow( f[ n ], mod - 2, mod )
for i in range( n, 0, - 1 ):
  inv[ i - 1 ] = ( inv[ i ] * i ) % mod
  
def nCr( n, r ):
  if r < 1:
    return 1
  return ( f[ n ] * inv[ r ] % mod ) * inv[ n - r ] % mod

ans = 0
for i in range( min( k, n - 1 ) + 1 ):
  ans = ( ans + nCr( n, i ) * nCr( n - 1, i ) ) % mod
  
print( ans )


"
"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf
from itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement
from collections import deque,defaultdict,Counter
from bisect import bisect_left,bisect_right
from operator import itemgetter
from heapq import heapify,heappop,heappush
from queue import Queue,LifoQueue,PriorityQueue
from copy import deepcopy
from time import time
import string
import sys
sys.setrecursionlimit(10 ** 7)
def input() : return sys.stdin.readline().strip()
def INT()   : return int(input())
def MAP()   : return map(int,input().split())
def LIST()  : return list(MAP())

n = INT()
a = LIST()
s = accumulate(a)

d = defaultdict(int)
for x in s:
    d[x] += 1

ans = d[0]
for x in d:
    ans += d[x]*(d[x]-1)//2

print(ans)"
"S = input()
L = len(S)
ans = 0
for i in range(L):
    c = 0
    for s in S[i:]:
        if s in ['A', 'C', 'G', 'T']:
            c += 1
        else:
            break
    ans = max(ans, c)

print(ans)"
"ab,bc,ca = map(int, input().split())
s = ab*bc*0.5
print(int(s))"
"import itertools
import numpy as np

N, M, Q = map(int, input().split())
abcd = [list(map(int, input().split())) for i in range(Q)]


ans = 0
for A in itertools.combinations_with_replacement(range(1, M+1), N):
  score = []
  for i in range(Q):
    a = abcd[i][0]
    b = abcd[i][1]
    c = abcd[i][2]
    d = abcd[i][3]
    if A[b-1]-A[a-1] == c:
      score.append(d)
  ans = max(ans,sum(score))
print(ans)
"
"n = int(input())
a_list = list(map(int,input().split()))
print(sum(a_list)-n)"
"import sys, math

def calcweight_tree(N_vertices, edges, times, inf):

    """"""
    edges: [start, dest, cost] -> [cost, start, end]
    """"""

    distance = 0

    passed = [False] * N_vertices

    travel_max = -inf
    for i in range(N_vertices):
        if(passed[i] == False):
            distance = 0
            left = i
            cost_sum = 0
            costs = []
            min_distance = inf
            while(True):
                dest = edges[left][1]
                cost = edges[dest][0]
                if(passed[dest]==False):
                    #passed[left] = True
                    passed[dest] = True
                    cost_sum += cost
                    costs.append(cost_sum)
                    left = dest
                    if(min_distance > cost):
                        min_distance = cost
                else:
                    period = len(costs)
                    increase_period = cost_sum
                    break
            # 2 period項準備
            remainder = times%period
            cost_minus = [0]
            for j in range(period-1):
                cost_minus.append(costs[j])
            if(increase_period <= 0):
                """"""
                for j in range(period):
                    costs.append(costs[j]+increase_period)
                maxindex = 0
                maxindex_start = 0
                maxvalue = -inf

                if(remainder==0):
                    remainder += period

                for st in range(period):
                    maxvalue_candidate = max(costs[st:st+period])
                    if(maxvalue_candidate - cost_minus[st] > maxvalue):
                        maxvalue = maxvalue_candidate - cost_minus[st]
                        maxindex = costs[st:st+period].index(maxvalue_candidate) + st
                        maxindex_start = st
                """"""
                costs_last = []
                # a_0は0なので。そしてこれは最大値を考えるときには数えないので
                remainder2 = remainder % period

                #print(""x"", costs, increase_period, remainder2)
                """"""
                for j in range(remainder2, period):
                    costs_last.append(costs[j])
                for j in range(0, remainder2):
                    costs_last.append(costs[j]+increase_period)
                for j in range(period):
                    costs_last.append(costs_last[j]+increase_period)
                """"""
                for j in range(period):
                    costs_last.append(costs[j])
                for j in range(period):
                    costs_last.append(costs_last[j]+increase_period)
                maxvalue = -inf
                #print(costs_last, cost_minus)
                for j in range(period):
                    maxvalue_candidate = max(costs_last[j:j+period])
                    if(maxvalue_candidate-cost_minus[j] > maxvalue):
                        maxvalue = maxvalue_candidate-cost_minus[j]

                travel_max = max(maxvalue, travel_max)
            else:
                costs_last = []
                # a_0は0なので。そしてこれは最大値を考えるときには数えないので
                remainder2 = remainder % period
                times_period = times//period-1
                add_n = times_period * increase_period
                #print(costs, increase_period, remainder2, times_period, add_n)
                for j in range(remainder2, period):
                    costs_last.append(costs[j]+add_n)
                for j in range(0, remainder2):
                    costs_last.append(costs[j]+add_n+increase_period)
                for j in range(period):
                    costs_last.append(costs_last[j]+increase_period)
                maxvalue = -inf
                #print(costs_last, cost_minus)
                for j in range(period):
                    maxvalue_candidate = max(costs_last[j:j+period])
                    if(maxvalue_candidate-cost_minus[j] > maxvalue):
                        maxvalue = maxvalue_candidate-cost_minus[j]
                travel_max = max(maxvalue, travel_max)






    return travel_max







if(__name__ == ""__main__""):
    """"""
    N = int( input().strip() )
    Length = list( map(int, input().strip().split() ) )

    edges = [ [] for _ in range(N+2) ]
    for i in range(N):
        edges[0].append([0, i]) #[cost, edge]
    for i in range(1, N+1):
        edges[i].append([0, N+1])
    for i in range(N):
        edges[i].append([ CList[i]*(-1), PList[i] ])
    """"""
    N, K= map(int, input().strip().split() )
    PList = list( map(int, input().strip().split() ) )
    CList = list( map(int, input().strip().split() ) )
    inf = 10**10


    N_vertices = N

    edges3 = []
    costs = []
    for i in range(N):
        edges3.append([ CList[i], PList[i]-1 ])

    weight = calcweight_tree(N_vertices, edges3, K, inf)

    #weight= calcweight_bellman_ford(N_vertices, 0, edges3, K+2, cost, inf)


    print( weight)
"
"def readInt():
    return int(input())
def readList():
    return list(map(int,input().split()))
def readMap():
	return map(int,input().split())
def readStr():
    return input()
inf=float('inf')
mod = 10**9+7
import math
from itertools import permutations
class DSU:
    def __init__(self,n):
        self.par=list(range(n))
        self.sz=[1]*(n)
    def find(self,x):
        if x!=self.par[x]:
            self.par[x]=self.find(self.par[x])
        return self.par[x]
    def union(self,x,y):
        x,y=self.find(x),self.find(y)
        if x!=y:
            if self.sz[y]>self.sz[x]:
                x,y=y,x
            self.par[y]=x
            self.sz[x]+=self.sz[y]
            self.sz[y]=self.sz[x]
            return True
        return False
    def parent(self,x):
        return self.par[x]

def solve(N,A):
    dsu=DSU(N)
    for a,b in A:
        dsu.union(a-1,b-1)
    cnt=0
    for i in range(N):
        if dsu.parent(i)==i:
            cnt+=1
    return cnt-1



N,M=readMap()
A=[]
for _ in range(M):
    a,b=readMap()
    A.append((a,b))
print(solve(N,A))"
"x,n=[int(i) for i in input().split()]
p=[int(i) for i in input().split()]
p.sort()
p_non=[]


for i in range(102):
    if i not in p:
        p_non.append(i)
p_non.sort()

zettaiti=1000000
ans=None
for i in p_non:
    if abs(i-x)<zettaiti:
        ans=i
        zettaiti=abs(i-x)

print(ans)"
"A, B = map(int, input().split())
def factorization(n):
  M = n
  k = 1
  faclist = [1]
  while(k**2 <= M):
    k += 1
    if M%k == 0:
      count = 0
      while M%k == 0:
        M //= k
        count += 1
      faclist.append(k)
  if M > 1:
    faclist.append(M)
  return faclist

a = factorization(A)
b = factorization(B)
from collections import deque

a = deque(a)
ans = 0
def binary_search(list, item):
  low = 0
  high = len(list) - 1
  while low <= high:
    mid = (low + high) //2
    guess = list[mid]
    if guess == item:
      return 1
    if guess > item:
      high = mid -1
    else:
      low = mid + 1
  return 0
while a:
  item = a.popleft()
  ans += binary_search(b, item)
print(ans)
  
"
"#
# abc087 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""5
3 2 2 4 1
1 2 2 2 1""""""
        output = """"""14""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""4
1 1 1 1
1 1 1 1""""""
        output = """"""5""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""7
3 3 4 5 4 5 3
5 3 4 4 2 3 2""""""
        output = """"""29""""""
        self.assertIO(input, output)

    def test_入力例_4(self):
        input = """"""1
2
3""""""
        output = """"""5""""""
        self.assertIO(input, output)


def resolve():
    N = int(input())
    A = [list(map(int, input().split())) for _ in range(2)]

    ans = 0
    if N == 1:
        ans = A[0][0]+A[1][0]
    else:
        #        for i in range(N):
        #            ans = max(ans, sum(A[0])+A[1][N-1],
        #                      sum(A[0][:N-1-i])+sum(A[1][N-1-i-1:]))

        for i in range(N):
            ans = max(ans, sum(A[0])+A[1][-1],
                      sum(A[0][:-2-i+1])+sum(A[1][-2-i:]))

    print(ans)


if __name__ == ""__main__"":
    # unittest.main()
    resolve()
"
"n = int(input())
a, b = [list(map(int, input().split())) for i in range(2)]

ap = bp = 0
for i in range(n):
        if a[i]>b[i]: bp += a[i]-b[i]
        else:
                if (b[i]-a[i])%2: bp += 1
                ap += (b[i]-a[i]+1)//2
print(""YNeos""[ap<bp::2])"
"import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 19
MOD = 10 ** 9 + 7
EPS = 10 ** -10

class ModTools:
    """""" 階乗・逆元用のテーブルを構築する """"""

    def __init__(self, MAX, MOD):

        # nCrならn、nHrならn+rまで作る
        MAX += 1
        self.MAX = MAX
        self.MOD = MOD
        factorial = [1] * MAX
        factorial[0] = factorial[1] = 1
        for i in range(2, MAX):
            factorial[i] = factorial[i-1] * i % MOD
        inverse = [1] * MAX
        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)
        for i in range(MAX-2, -1, -1):
            inverse[i] = inverse[i+1] * (i+1) % MOD
        self.fact = factorial
        self.inv = inverse

    def nCr(self, n, r):
        """""" 組み合わせ """"""

        if n < r: return 0
        r = min(r, n-r)
        numerator = self.fact[n]
        denominator = self.inv[r] * self.inv[n-r] % self.MOD
        return numerator * denominator % self.MOD

K = INT()
S = input()
N = len(S)

mt = ModTools(2*10**6, MOD)
ans = 0
for x in range(0, K+1):
    ans += mt.nCr(N+K-x-1, N-1) * pow(25, K-x, MOD) * pow(26, x, MOD) % MOD
ans %= MOD
print(ans)
"
"l = input()

ans = 1
mod = 10**9+7
strict = 1
# st_m = 0
easy = 0
# ea_m = 0
for i in range(len(l)):
    if l[i] == ""1"":
        easy *= 3
        easy %= mod

        easy = easy + strict
        # ea_m += st_m
        strict *= 2
        # st_m *= 2
        # st_m += strict//mod
        strict %= mod

    else:
        easy *= 3
        # ea_m *= 3
        # ea_m += easy//mod
        easy %= mod
    # print(easy,strict)

# print(easy,strict)

print((easy+strict)%mod)"
"n,r = map(int, raw_input().split(' '))
def f(n,r):
  if n >= 10:
    return r
  else:
    return r + 100 * (10 - n)
print f(n,r)"
"a= int(input())
b= int(input())
h= int(input())
eq= (a+b)*h/2
print(int(eq))"
"s = input()
print(s + ('s' if s[-1] != 's' else 'es'))
"
"import sys
sys.setrecursionlimit(10**8)
def ii(): return int(sys.stdin.readline())
def mi(): return map(int, sys.stdin.readline().split())
def li(): return list(map(int, sys.stdin.readline().split()))
def li2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]
def dp2(ini, i, j): return [[ini]*i for i2 in range(j)]
def dp3(ini, i, j, k): return [[[ini]*i for i2 in range(j)] for i3 in range(k)]
#import bisect #bisect.bisect_left(B, a)
#from collections import defaultdict #d = defaultdict(int) d[key] += value
#from collections import Counter # a = Counter(A).most_common()
#from itertools import accumulate #list(accumulate(A))

N = ii()
XL = li2(N)
R = dp2(0, 2, N)

for i in range(N):
    R[i][0] = XL[i][0] - XL[i][1]
    R[i][1] = XL[i][0] + XL[i][1]


R = sorted(R, key=lambda x:x[1])
m = -float('inf')
cnt = 0
for i in range(N):
    if R[i][0] >= m:
        cnt += 1
        m = R[i][1]

print(cnt)"
"N, P = map(int, input().split())
A = list(map(int, input().split()))
even = 0
odd = 0
for i in range(N):
    if A[i]%2==0:
        even += 1
    else:
        odd += 1
if odd>=1:
    ans = pow(2,even+odd-1)
elif P==0:
    ans = pow(2,even)
else:
    ans = 0
print(ans)"
"a=list(map(int, input().split()))
s=[[1,3,5,7,8,10,12],[4,6,9,11],[2]]
ans=[]
for i in a:
  for j in range(len(s)):
    if i in s[j]:
      ans.append(j)
      break
if len(set(ans))==1:
  print('Yes')
else:
  print('No')"
"import sys
input = sys.stdin.readline

cs_view = input().rstrip('\r\n')
list_v = list(cs_view)

stack1 = []
all_sum = 0
sum_stack = []
for i, elem in enumerate(list_v):
    if elem == '\\':
        stack1.append(i)
    elif len(stack1) > 0 and elem == '/':
        j = stack1.pop()
        all_sum += i - j
        a = i - j
        while len(sum_stack) > 0 and sum_stack[-1][0] > j:
            a += sum_stack.pop()[1]
        sum_stack.append([j, a])

print(all_sum)
esum = []
for a in sum_stack:
    esum.append(a[1])
esum.insert(0, len(esum))
maped_esum = map(str, esum)
str_esum = ' '.join(maped_esum)
print(str_esum)

"
"n,m=map(int,input().split())
send=2**m
time = 1900*m + 100*(n-m)
print(send*time)
"
"import math
from math import gcd,pi,sqrt
INF = float(""inf"")

import sys
sys.setrecursionlimit(10**6)
import itertools
from collections import Counter,deque
def i_input(): return int(input())
def i_map(): return map(int, input().split())
def i_list(): return list(i_map())
def i_row(N): return [i_input() for _ in range(N)]
def i_row_list(N): return [i_list() for _ in range(N)]
def s_input(): return input()
def s_map(): return input().split()
def s_list(): return list(s_map())
def s_row(N): return [s_input for _ in range(N)]
def s_row_str(N): return [s_list() for _ in range(N)]
def s_row_list(N): return [list(s_input()) for _ in range(N)]

def main():
    n = i_input()
    a = i_list()

    total = 0
    now = 0
    for i in a:
        total += abs(now-i)
        now = i
    total += abs(i)
    a.insert(0,0)
    a.append(0)

    ans = []

    for i,k in enumerate(a[1:-1], start=1):
        # print(i,k)

        if a[i-1] <= k and k <= a[i+1] or a[i-1] >= k and  k >= a[i+1]:
            ans.append(total)
        else:
            ans.append(total - abs(k-a[i-1]) - abs(k-a[i+1]) + abs(a[i-1]-a[i+1]))

    for i in ans:
        print(i)




if __name__==""__main__"":
    main()
"
"n=int(input())
while True:
    if str(n)[0]==str(n)[1]==str(n)[2]:
        print(n)
        break
    n+=1"
"import math
def main():
 a = int(input())
 print(a * 2 // math.gcd(a,2))
main()"
"N = int(input())
A = [int(i) for i in input().split()]
A_tupple = [(idx+1, value) for idx, value in enumerate(A)]
A_tupple.sort(key=lambda x:x[1])
for a in A_tupple:
  print(a[0], end="" "")
"
"def resolve():
    A, B = map(int, input().split())

    ans = 0
    for _ in [1, 2]:
        if (A <= B):
            ans += B
            B -= 1
        elif (A > B):
            ans += A
            A -= 1

    print(ans)


resolve()"
"def main():
    n = int(input())
    x = 0
    y = 0
    for _ in range(n):
        a, b = map(int, input().split())
        if x < a:
            x = a
            y = b
    print(x + y)

if __name__ == ""__main__"":
    main()
"
"import math
a,b,c,d=map(int,input().split())
ans=""""
for i in range (c-a):
    ans+=""R""
for i in range (d-b):
    ans+=""U""
for i in range (c-a):
    ans+=""L""
for i in range (d-b):
    ans+=""D""
ans+=""D""
for i in range (c-a+1):
    ans+=""R""
for i in range (d-b+1):
    ans+=""U""
ans+=""LU""
for i in range (c-a+1):
    ans+=""L""
for i in range (d-b+1):
    ans+=""D""
ans+=""R""
print(ans)"
"def main():
    S = input()
    ans = 0
    before_c = S[0]
    for c in S:
        if c != before_c:
            ans += 1
            before_c = c
    print(ans)


if __name__ == '__main__':
    main()"
"import sys


def input():
    return sys.stdin.readline().rstrip()


def main():
    N = int(input())
    d = list(map(int,input().split()))
    d.sort()
    print(d[N//2]-d[N//2-1])




if __name__ == ""__main__"":
    main()
"
"W,H,x,y,r = map(int,raw_input().split())
print ['No','Yes'][r<=x<=W-r and r<=y<=H-r]"
"n,m,k=map(int,input().split())
a=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]
ar=[0]
br=[0]
for i in range(n):
  ar.append(ar[i]+a[i])
for i in range(m):
  br.append(br[i]+b[i])

ans=0
j=0
cnt=0
# print(ar)
# print(br)
for i in range(n+1):
  now=ar[i]
  cnt=i
  nokori=k-now

  if nokori<0:
    continue

  while(br[j]<=nokori):
    if j<m:
      j+=1
    else:
      break
    
  if nokori<br[j]:
    j-=1


  ans=max(ans,j+i)
print(ans)



"
"N = int(input())
ans = 0
q = 1
while(q ** 2 + q < N):
  m = (N - q) / q
  if(m.is_integer()):
    ans += int(m)
  q += 1
print(ans)"
"# row = [int(x) for x in input().rstrip().split("" "")]
# n = int(input().rstrip())
# s = input().rstrip()
# row = [int(input().rstrip()) for _ in range(n)]

def resolve():
    import sys
    input = sys.stdin.readline

    n = int(input().rstrip())

    a_list = [int(x) for x in input().rstrip().split("" "")]
    length = sum(a_list)
    center = length * 0.5

    # できるだけ中心に近い切れ目
    center_cut = 0
    cut = 0
    for a in a_list:
        cut += a
        if abs(center_cut - center) > abs(cut - center):
            center_cut = cut
        if cut > center:
            break

    # 中心に近い切れ目を中心に一致させる
    print(int(abs(center_cut - center) * 2))


if __name__ == ""__main__"":
    resolve()
"
"N = int(input())
dic = {}
for _ in range(N):
    s = input()
    if s in dic:
        dic[s] += 1
    else:
        dic[s] = 1
ma = max(dic.values())
for i,j in sorted(dic.items()):
    if j == ma:
        print(i)"
"n = int(input())
a = [0]
for i in range(n):
    a.append(int(input()))
#print(a)
tmp = 1
isOK = -1
for i in range(1,n+1):
    if a[tmp]==2:
        isOK = i
        break
    tmp = a[tmp]

print(isOK)"
"
A = list(input())
n = int(input())

for _ in range(n):
	command = input().split("" "")
	st = int(command[1])
	en = int(command[2]) + 1

	if command[0] == ""replace"":
		A[st:en] = list(command[3])
	elif command[0] == ""reverse"":
		A[st:en] = reversed(A[st:en])
	else:
		print(*A[st:en],sep="""")

"
"N = int(input())
T,A = map(int,input().split())
for i in range(N-1):
    t,a = map(int,input().split())
    T1 = (T+t-1)//t*t
    A1 = (T+t-1)//t*a
    T2 = (A+a-1)//a*t
    A2 = (A+a-1)//a*a
    if A1 < A:
        T,A = T2,A2
    else:
        T,A = T1,A1
print(T+A)
"
"n, m = map(int, input().split())
L = [[0, 0, 0] for _ in range(n)]
for i in range(n):
    x, y, z = map(int, input().split())
    L[i][0], L[i][1], L[i][2] = x, y, z

ans = 0
for i in range(2**3):
    temp = [0]*n
    for k in range(n):
        for j in range(3):
            if (i >> j) & 1:
                temp[k] += L[k][j]
            else:
                temp[k] += L[k][j]*(-1)
    temp.sort(reverse=True)
    ans = max(ans, sum(temp[0:m]))
print(ans)    
"
"n = int(input())
S = ["""".join(sorted(input())) for _ in range(n)]
counters = {}

for s in S:
    if s in counters:
        counters[s] += 1
    else:
        counters[s] = 1

ans = 0
for v in counters.values():
    if v == 1: continue
    ans += int(v * (v - 1) / 2)
print(ans)"
"# -*- coding: utf-8 -*-
""""""
Created on Wed May 13 14:30:59 2020

@author: shinba
""""""

a,b = map(str,input().split())

if a == ""H"":
    if b == ""H"":
        print(""H"")
    else:
        print(""D"")
else:
    if b == ""H"":
        print(""D"")
    else:
        print(""H"")
    
"
"n,k=map(int,input().split())
s,p,r=map(int,input().split()) #筐体の手に対する勝利ポイント
t=list(input())
ans=0
for i in range(n):
    if t[i]==""s"":
        tmp=s
    elif t[i]==""p"":
        tmp=p
    else:
        tmp=r
    if i>=k:
        if t[i]==t[i-k]:
            tmp=0
            t[i]=None
    ans+=tmp
print(ans)"
"n = int(input())
ans = ""Christmas""
for _ in range(25-n):
    ans += "" Eve""

print(ans)"
"X,A,B = [int(input()) for i in range(3)]
print(X-A-((X-A)//B)*B)"
"import sys
input = sys.stdin.readline
mod = 10**9 +7
N = int(input())
C = [input() for _ in range(N)]
dic ={}
lis = [1]
before =C.pop(0)
dic[before]=[0]

for i,s in enumerate(C):
    lis.append(lis[-1])
    if s in dic.keys():
        if s != before:
            lis[-1] += lis[dic[s][-1]+1]
            #for j in dic[s]:
            #    lis[-1] += lis[j]
            dic[s].append(i)
    else:
        dic[s] = [i]
    before = s
    lis[-1] = lis[-1]%mod
print(lis[-1])"
"N,A,B=map(int,input().split())
s=0
a=N//(A+B)
s+=A*a
b=N-a*(A+B)
if b>=A:
    s+=A
else:
    s+=b
print(s)"
"#!/usr/bin/env python3
import sys
from itertools import accumulate
sys.setrecursionlimit(10**8)
INF = float(""inf"")

import math


def array(*args, initial=0):
    pre = ""[""*len(args)
    post = """"
    for a in args[::-1]:
        post += "" for _ in range(""+str(a)+"")]""
    S = pre + str(initial) + post
    return eval(S)


def solve(N: int, A: ""List[int]""):

    if N % 2 == 0:
        K = 2
    else:
        K = 3

    DP = array(N, K, initial=-10**9)
    DP[0][0] = A[0]
    DP[1][1] = A[1]
    if K == 3:
        DP[2][2] = A[2]
    for i in range(1, N):
        for k in range(K):
            if i == k and i < K:
                continue
            DP[i][k] = DP[i-2][k]
            if k-1 >= 0:
                DP[i][k] = max(DP[i][k], DP[i-3][k-1])
            if k-2 >= 0:
                DP[i][k] = max(DP[i][k], DP[i-4][k-2])
            DP[i][k] += A[i]
    if N % 2 == 0:
        print(max(DP[-1][1], DP[-2][0]))
    else:
        print(max(DP[-1][2], DP[-2][1], DP[-3][0]))
    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: ""List[int]""
    solve(N, A)


if __name__ == '__main__':
    main()
"
"S = input()

L = {}

ans = ""Yes""
for s in S:
    if s in L.keys():
        L[s] += 1
        if L[s] > 2:
            ans = ""No""
    else:
        L[s] = 1
if len(L.keys()) != 2:
    ans = ""No""

print(ans)
"
"a = int(raw_input())
b = int(raw_input())
c = int(raw_input())
x = int(raw_input())

def dfs(x, i, a, b , c):
  	if x < 0:
  		return 0
  	if x == 0:
  		return 1
  	
  	if i == 3:
  		return 1 if x == 0 else 0
  	r = 0
  	m = {0:a,1:b,2:c}
  	v = {0:500,1:100,2:50}

  	for k in range(0, m[i] + 1):
  		r += dfs(x - k * v[i], i+1, a,b,c)
  	return r

print dfs(x,0,a,b,c)
"
"input()
a = list(map(int,input().split()))
b = sorted(a)
print(""Yes"" if b[-1] < (sum(b)-b[-1]) else ""No"")"
"N,A,B = map(int,input().split())

if B < A:
  print(0)
  exit()
num = B-A+1
mi = A*(N-1) + B
ma = B*(N-1) + A
ans = ma - mi + 1

print(max(ans,0))"
"import sys

while True:
	nums = [ int( val ) for val in sys.stdin.readline().split( "" "" ) ]
	if 0 == nums[0] and 0 == nums[1]:
		break
	for i in range( nums[0] ):
		print( ""#""*nums[1] )
	print"
"s = int(input())
a = int(s/100)
c = s%10
d = (s-c)/10
b = d%10
if a ==7 or b ==7 or c ==7:
  print(""Yes"")
else:
  print(""No"")"
"def func(l, r, same) -> int:
    """"""
    X(l,r)X -> same=True
    X(l,r)y -> same=False
    次の送信クエリ候補を返す
    """"""
    parity = (r - l + 1) % 2
    if parity ^ same:
        ret = (l + r) // 2
    else:
        ret = -1
    return ret


def main():
    n = int(input())

    seat = [''] * n

    print(0, flush=True)
    response = input()
    if response[0] == 'V':
        print(0)
        return
    seat[0] = response[0]

    l, r = 0, n
    x = func(l, r, same=True)
    for _ in range(19):
        print(x, flush=True)
        response = input()
        if response[0] == 'V':
            print(x)
            return
        seat[x] = response[0]

        res = func(l, x, seat[l] == seat[x])
        if res != -1:
            r = x
            x = res
            continue

        res = func(x, r, seat[x] == seat[r % n])
        if res != -1:
            l = x
            x = res


if __name__ == '__main__':
    main()
"
"print(8-__import__(""math"").floor((int(input())-400)/200))"
"# -*- coding: utf-8 -*-


# 入力を整数に変換して受け取る
def input_int():
    return int(input())


# マイナス1した値を返却
def int1(x):
    return int(x) - 1


# 半角スペース区切り入力をIntに変換してMapで受け取る
def input_to_int_map():
    return map(int, input().split())


# 半角スペース区切り入力をIntに変換して受け取る
def input_to_int_tuple():
    return tuple(map(int, input().split()))


# 半角スペース区切り入力をIntに変換してマイナス1した値を受け取る
def input_to_int_tuple_minus1():
    return tuple(map(int1, input().split()))


def main():
    n, m = input_to_int_map()

    ret = ""No""
    if n == m:
        ret = ""Yes""

    return ret


if __name__ == ""__main__"":
    print(main())
"
"import sys
from sys import exit
from collections import deque
from copy import deepcopy
from bisect import bisect_left, bisect_right, insort_left, insort_right
from heapq import heapify, heappop, heappush
from itertools import product, permutations, combinations, combinations_with_replacement
from functools import reduce
from math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians

sys.setrecursionlimit(10**6)
INF = 10**20
eps = 1.0e-20
MOD = 10**9+7

def lcm(x,y):
    return x*y//gcd(x,y)
def lgcd(l):
    return reduce(gcd,l)
def llcm(l):
    return reduce(lcm,l)
def powmod(n,i,mod=MOD):
    return pow(n,mod-1+i,mod) if i<0 else pow(n,i,mod)
def div2(x):
    return x.bit_length()
def div10(x):
    return len(str(x))-(x==0)
def intput():
    return int(input())
def mint():
    return map(int,input().split())
def lint():
    return list(map(int,input().split()))
def ilint():
    return int(input()), list(map(int,input().split()))
def judge(x, l=['Yes', 'No']):
    print(l[0] if x else l[1])
def lprint(l, sep='\n'):
    for x in l:
        print(x, end=sep)
def ston(c, c0='a'):
    return ord(c)-ord(c0)
def ntos(x, c0='a'):
    return chr(x+ord(c0))
class counter(dict):
    def __init__(self, *args):
        super().__init__(args)
    def add(self,x,d=1):
        self.setdefault(x,0)
        self[x] += d
    def list(self):
        l = []
        for k in self:
            l.extend([k]*self[k])
        return l
class comb():
    def __init__(self, n, mod=None):
        self.l = [1]
        self.n = n
        self.mod = mod
    def get(self,k):
        l,n,mod = self.l, self.n, self.mod
        k = n-k if k>n//2 else k
        while len(l)<=k:
            i = len(l)
            l.append(l[i-1]*(n+1-i)//i if mod==None else (l[i-1]*(n+1-i)*powmod(i,-1,mod))%mod)
        return l[k]
def pf(x,mode='counter'):
    C = counter()
    p = 2
    while x>1:
        k = 0
        while x%p==0:
            x //= p
            k += 1
        if k>0:
            C.add(p,k)
        p = p+2-(p==2) if p*p<x else x
    if mode=='counter':
        return C
    S = set([1])
    for k in C:
        T = deepcopy(S)
        for x in T:
            for i in range(1,C[k]+1):
                S.add(x*(k**i))
    if mode=='set':
        return S
    if mode=='list':
        return sorted(list(S))

######################################################

N=intput()
node=[list() for _ in range(N+1)]
done=[False]*(N+1)
color=[0]*(N+1)
ans=[0]*(N-1)
S=dict()
for i in range(N-1):
    u,v=mint()
    node[u].append(v)
    node[v].append(u)
    S[(u,v)]=i
    S[(v,u)]=i
q=deque([1])
done[1]=True
while q:
    u=q.popleft()
    c=1
    for v in node[u]:
        if not done[v]:
            if c==color[u]:
                c+=1
            color[v]=c
            ans[S[(u,v)]]=c
            done[v]=True
            q.append(v)
            c+=1
print(max(ans))
lprint(ans)"
"from itertools import accumulate
n,m=map(int,input().split())
a=list(map(int,input().split()))
a.sort(reverse=True)
b=[0]*(2*a[0]+1)
for i in range(n):
  b[a[i]]+=1
b=list(accumulate(b[::-1]))[::-1]
s=list(accumulate([0]+a))
ok=0
ng=2*a[0]+1
while ng-ok>1:
  mid=(ng+ok)//2
  cnt=0
  for i in range(n):
    cnt+=b[max(0,mid-a[i])]
  if cnt>=m:
    ok=mid
  else:
    ng=mid
cnt=0
ans=0
for i in range(n):
  t=min(b[max(0,ng-a[i])],m-cnt)
  ans+=s[t]+a[i]*t
  cnt+=t
ans+=(m-cnt)*ok
print(ans)"
"N, W = map(int, input().split())
w = []
v = []
for i in range(N):
    wi, vi = map(int, input().split())
    w.append(wi)
    v.append(vi)
ww = [w[0], w[0]+1, w[0]+2, w[0]+3]
d = {}
for i in range(4):
    d[ww[i]] = []
for i in range(N):
    d[w[i]].append(v[i])
for i in range(4):
    d[ww[i]] = sorted(d[ww[i]], reverse=True)
    
ans = 0
for i in range(N+1):
    if len(d[ww[0]]) < i:
        # print('break i: {}'.format(i))
        break
    for j in range(N+1):
        if i + j > N or len(d[ww[1]]) < j:
            # print('break i, j: {}, {}'.format(i, j))
            break
        for k in range(N+1):
            if i + j + k > N or len(d[ww[2]]) < k:
                # print('break i, j, k: {}, {}, {}'.format(i, j, k))
                break
            for l in range(N+1):
                # print(ww[0] * i + ww[1] * j + ww[2] * k + ww[3] * l)

                if i + j + k + l > N or\
                        len(d[ww[3]]) < l or\
                        ww[0] * i + ww[1] * j +\
                        ww[2] * k + ww[3] * l > W:
                    # print('break i, j, k: {}, {}, {}, {}'.format(i, j, k, l))
                    break

                av = sum([d[ww[0]][p] for p in range(i)])
                bv = sum([d[ww[1]][p] for p in range(j)])
                cv = sum([d[ww[2]][p] for p in range(k)])
                dv = sum([d[ww[3]][p] for p in range(l)])
                ans = max(ans, av+bv+cv+dv)
print(ans)


"
"n = int(input())
l = [list(map(int, input().split())) for _ in range(n)]

a = [0] * n
b = [0] * n
c = [0] * n

a[0], b[0], c[0] = l[0][0], l[0][1], l[0][2]

for i in range(1,n):
    a[i] = max(l[i][0]+b[i-1], l[i][0]+c[i-1])
    b[i] = max(l[i][1]+a[i-1], l[i][1]+c[i-1])
    c[i] = max(l[i][2]+a[i-1], l[i][2]+b[i-1])

print(max(a[-1],b[-1],c[-1]))"
"s = input()
oza = 'hi'
flag = 0
for i in range(0,len(s),2):
    if s[i:i+2] == oza:
        continue
    else:
        flag = 1
        print('No')
        break
if flag == 0:
    print('Yes')
"
"a,b,c=input().split()
print(""YES"" if a[-1]==b[0]and b[-1]==c[0] else ""NO"")"
"import math
import numpy as np
import queue
from collections import deque
import heapq

def cmb(n,r):
    c = 1
    for i in range(r):
        c *= (n-i)
    for i in range(r):
        c //= (i+1)
    return c

n = input()
k = int(input())
ln = len(n)
ans = 0

nn0 = 0
for i in range(ln):
    if int(n[i]) > 0:
        ans += cmb(ln-i-1,k-nn0)*(9**(k-nn0))
        nn0 += 1
        ans += (int(n[i])-1)*cmb(ln-i-1,k-nn0)*(9**(k-nn0))
    if nn0 == k:
        ans += 1
        break

print(ans)
"
"def check_RGB(c1, c2, c3):
    l = [c1, c2, c3]
    return (""R"" in l) and (""G"" in l) and (""B"" in l)
    
N = int(input())
S = input()

R, G, B = 0, 0, 0
for i, s in enumerate(S):
    if s == ""R"":
        R += 1
    elif s == ""G"":
        G += 1
    else:
        B += 1

result = R * G * B

width = 1
while width * 2 < N:
    i = 0
    first = i
    mid = i + width
    last = i + width*2

    while last < N:
        if check_RGB(S[first], S[mid], S[last]):
            result -= 1

        i += 1
        first = i
        mid = i + width
        last = i + width*2

    width += 1

print(result)
"
"def slove(n, a_list):

    dp = [[0]*(n+1) for i in range(n+1)]
    for i in range(n):
        for j in range(n-i):
            dp[i+1][j] = max(dp[i+1][j],
                         dp[i][j]+a_list[i+j][0]*abs(a_list[i+j][1]-i))
            dp[i][j+1] = max(dp[i][j+1],
                         dp[i][j]+a_list[i+j][0]*abs((n-1-j)-a_list[i+j][1]))

    return max([max(i) for i in dp])

if __name__ == ""__main__"":
    n = int(input())
    k = sorted([(int(x),i) for i,x in enumerate(input().split())], reverse=True)
    print(slove(n, k))
"
"dic = {}
n = int(input())
for i in range(n):
    op, key = input().split()
    if op == ""insert"":
        dic[key] = 1
    else:
        if key in dic:
            print(""yes"")
        else:
            print(""no"")"
"#k = int(input())
#s = input()
#a, b = map(int, input().split())
#s, t = map(str, input().split())
#l = list(map(int, input().split()))
#l = [list(map(int,input().split())) for i in range(n)]
#a = [list(input()) for _ in range(n)]


x1,y1,x2,y2 = map(int, input().split())

dis_x = x2 - x1
dis_y = y2 - y1

x3 = x2 - dis_y
y3 = y2 + dis_x
x4 = x3 - dis_x
y4 = y3 - dis_y

print(x3,y3,x4,y4)


"
"from typing import List


def get_value(card: str) -> int:
    return card[1]


def bublle_sort(C: List[str]) -> None:
    for i in range(len(C)):
        for j in reversed(range(i + 1, len(C))):
            if get_value(C[j]) < get_value(C[j - 1]):
                C[j], C[j - 1] = C[j - 1], C[j]


def selection_sort(C: List[str]) -> None:
    for i in range(len(C)):
        min_j = i
        for j in range(i, len(C)):
            if get_value(C[j]) < get_value(C[min_j]):
                min_j = j
        C[i], C[min_j] = C[min_j], C[i]


def is_stable(A_in, A_out) -> bool:
    for i in range(len(A_in)):
        for j in range(i + 1, len(A_in)):
            for a in range(len(A_out)):
                for b in range(a + 1, len(A_out)):
                    if get_value(A_in[i]) == get_value(A_in[j]) and A_in[i] == A_out[b] and A_in[j] == A_out[a]:
                        return False
    return True


N = int(input())
C = [str(i) for i in input().split()]
C1 = [i for i in C]
C2 = [i for i in C]

bublle_sort(C1)
print(' '.join(C1))
if is_stable(C, C1):
    print('Stable')
else:
    print('Not stable')

selection_sort(C2)
print(' '.join(C2))
if is_stable(C, C2):
    print('Stable')
else:
    print('Not stable')

"
"a = int(input())
total = a + a*a + a*a*a
print(total)"
"def resolve():
    S = list(input())
    T = list(input())

    count = 0
    for i in range(len(S)):
        if S[i] != T[i]:
            count += 1
    print(count)


if __name__ == ""__main__"":
    resolve()"
"T1,T2,A1,A2,B1,B2=map(int, open(0).read().split())
D1,D2 = (A1-B1)*T1, (A1-B1)*T1+(A2-B2)*T2
if D1*D2 > 0:     print(0)
elif D2 == 0:     print(""infinity"")
elif -D1%D2 == 0: print(-D1//D2*2)
else:             print(-D1//D2*2+1)"
"K,A,B = map(int,input().split())

if B-A < 2:
    print(1+K)
    exit()

cnt = A-1
K -= cnt
print(A+((B-A)*(K//2)+K%2))"
"n, k = map(int, raw_input().split())
W = [input() for _ in xrange(n)]

def check(p):
    i = 0
    for j in xrange(k):
        s = 0
        while s + W[i] <= p:
            s += W[i]
            i += 1
            if (i == n):
                return n
    return i

def solve():
    left = 0
    right = 100000 * 10000
    while right - left > 1:
        mid = int((right + left) / 2)
        v = check(mid)
        if v >= n:
            right = mid
        else:
            left = mid

    return right

def main():
    ans = solve()
    print ans
    return 0

main()"
"h, w = map(int, input().split())
S = [input() for _ in range(h)]

ans = [[-1]*w for _ in range(h)]

dy = [-1, 1, 0, 0, -1, 1, -1, 1]
dx = [ 0, 0,-1, 1, -1, 1,  1,-1]

for i in range(h):
    for j in range(w):
        if S[i][j] == '#': continue
        ans[i][j] = 0
        for k in range(8):
            y = i + dy[k]
            x = j + dx[k]
            if y<0 or h<=y: continue
            if x<0 or w<=x: continue
            if S[y][x] == '#':
                ans[i][j] += 1

for i in range(h):
    for j in range(w):
        if ans[i][j] == -1:
            print('#',end='')
        else:
            print(ans[i][j],end='')
    print('')

# print(h,w)
# print(*S,sep='\n')
# print(*ans,sep='\n')
"
"n = int(input())
u = list(map(int,input().split()))
u.sort()
value = (u[0] + u[1]) / 2
for i in range(2,n):
    value = (value + u[i]) / 2
print(value)"
"from collections import Counter

N, M = map(int, input().split(' '))
records = [tuple(map(int, input().split(' '))) for _ in range(M)]
s_records = sorted(records)

counter = Counter()
d = {}

for p, y in s_records:
    counter[p] += 1
    d[(p, y)] = '{:06}{:06}'.format(p, counter[p])

for p, y in records:
    print(d[(p, y)])
"
"import sys
import numpy as np

n, a, *x = map(int, sys.stdin.read().split())

def main():
    m = 2500
    dp = np.zeros((n + 1, m + 1), dtype=np.int64)
    dp[0, 0] = 1
    for i in range(n):
        ndp = np.copy(dp)
        ndp[1:, x[i]:] += dp[:-1, :m-x[i]+1]
        dp = ndp
    i = np.arange(1, n + 1)
    print(np.sum(dp[i, i * a]))

if __name__ ==  '__main__':
    main()"
"N, L = map(int, input().split())
a = list(map(int, input().split()))

idx = -1
for i in range(N - 1):
  if a[i] + a[i + 1] >= L:
    idx = i
    break

if idx == -1:
  print(""Impossible"")
else:
  print(""Possible"")
  for i in range(idx):
    print(i + 1)
  for i in range(N - 1, idx, -1):
    print(i)"
"def main(N,X,T):
    count=0
    ans = 0
    while count < N:
        count += X
        ans += T
    return ans

N,X,T=map(int, input().split())
print(main(N,X,T))"
"import sys
sys.setrecursionlimit(10**6)

a,b,k=map(int,input().split())

i=0
for j in range(max(a,b),0,-1):
    if a%j==0 and b%j==0:
        i+=1
    if i==k:
        print(j)
        exit()

"
"def get_h_list(S):
    H = len(S)
    n_offset_rows = 0
    while '#' not in S[n_offset_rows]:
        n_offset_rows += 1
    assert n_offset_rows < H
    h_list = list()
    for h in range(n_offset_rows, H):
        if '#' in S[h]:
            h_list.append(h)
    h_list[0] = 0
    h_list.append(H)
    return h_list


def get_w_list(S, h_from, h_to):
    W = len(S[0])
    n_offset_columns = 0
    while '#' not in [S[h][n_offset_columns] for h in range(h_from, h_to + 1)]:
        n_offset_columns += 1
    assert n_offset_columns < W
    w_list = list()
    for w in range(n_offset_columns, W):
        if '#' in [S[h][w] for h in range(h_from, h_to + 1)]:
            w_list.append(w)
    w_list[0] = 0
    w_list.append(W)
    return w_list


def main():
    H, W, K = map(int, input().split())
    ans = [[0 for _ in range(W)] for _ in range(H)]
    color = 1
    S = [input() for _ in range(H)]
    h_list = get_h_list(S)
    for i in range(len(h_list) - 1):
        h_from, h_to = h_list[i], h_list[i + 1] - 1
        w_list = get_w_list(S, h_from, h_to)
        for j in range(len(w_list) - 1):
            w_from, w_to = w_list[j], w_list[j + 1] - 1
            # 塗る
            for h in range(h_from, h_to + 1):
                for w in range(w_from, w_to + 1):
                    ans[h][w] = color
            color += 1
    for a in ans:
        print(' '.join(map(str, a)))


if __name__ == '__main__':
    main()"
"A,B = map(str,input().split())

def comp(A,B):
    if A > B:
        return '>'
    elif A<B:
        return '<'
    else:
        return '='

ans = comp(A,B)
print(ans)
"
"n=int(input())
d=sorted(map(int,input().split()))
m=int(input())
t=sorted(map(int,input().split()))

d_dic = dict()
t_dic = dict()

for i in range(n):
    d1 = d[i]
    if d1 not in d_dic.keys():
        d_dic[d1] = 1
    else:
        d_dic[d1] += 1

ans = 0

for i in range(m):
    t1 = t[i]
    if t1 in d_dic.keys():
        d_dic[t1] -= 1
        if d_dic[t1] < 0:
            ans = 1
            break
    else:
        ans = 1
        break
    
if ans == 1:
    print(""NO"")
else:
    print(""YES"")"
"n = int(input())
if (n//10**(len(str(n))-1)+1)*10**(len(str(n))-1)-1 > n:
  mx = (n//10**(len(str(n))-1))*10**(len(str(n))-1)-1
else:
  mx = (n//10**(len(str(n))-1)+1)*10**(len(str(n))-1)-1
print(sum(list(map(int,str(mx)))))"
"import sys,queue,math,copy,itertools,bisect,collections,heapq
sys.setrecursionlimit(10**7)
INF = 10**18
MOD = 10**9 + 7
LI = lambda : [int(x) for x in sys.stdin.readline().split()]
_LI = lambda : [int(x)-1 for x in sys.stdin.readline().split()]
NI = lambda : int(sys.stdin.readline())

N = NI()

dp = [[[[0 for _ in  range(4)] for _ in range(4)] for _ in range(4)] for _ in range(N+1)]
for i in range(4):
    for j in range(4):
        for k in range(4):
            if i == 0 and j == 2 and k == 1 or \
                i == 0 and j == 1 and k == 2 or \
                i == 2 and j == 0 and k == 1:
                dp[3][i][j][k] = 0
            else:
                dp[3][i][j][k] = 1

for x in range(4,N+1):
    for i in range(4):
        for j in range(4):
            for k in range(4):
                for l in range(4):
                    if dp[x-1][i][j][k] == 0: continue
                    if j == 0 and k == 2 and l == 1 or \
                        j == 0 and k == 1 and l == 2 or \
                        j == 2 and k == 0 and l == 1: continue
                    if i == 0 and k == 2 and l == 1 or \
                        i == 0 and j == 2 and l == 1: continue
                    dp[x][j][k][l] = (dp[x][j][k][l] + dp[x-1][i][j][k]) % MOD

ans = 0
for i in range(4):
    for j in range(4):
        for k in range(4):
            ans += dp[-1][i][j][k]

print (ans % MOD)"
"n = int(input())
a = []
for i in range(n):
  a.append(int(input()))
a.sort()
jud = 1
q = a[0]
ans = 0
for i in range(1,n):
  if(q==a[i]):
    jud += 1
  else: 
    if(jud%2==1):
      ans += 1
    jud = 1
    q = a[i]
if (jud%2==1):
  ans += 1
if(n==1):
  ans = 1
print(ans)
"
"n = int(input())
s = set(input().split())
l = len(s)
if l==4:
    print(""Four"")
elif l==3:
    print(""Three"")"
"# -*- coding: utf-8 -*-
""""""
Created on Mon Sep  7 10:51:17 2020

@author: liang
""""""
A, B = map(int, input().split())

res = B*10

for i in range(10):
    tmp =int((res + i)*0.08)
    if  tmp == A:
        print(res+i)
        break
else:
    print(-1)"
"s = input()
print('Yes' if s[0] != s[1] or s[1] != s[2] else 'No')"
"a,b,c=map(int,input().split())
if c>=a and c<=b:
  print('Yes')
else:print('No')"
"def resolve():
    N, K = list(map(int, input().split()))
    P = sorted(list(map(int, input().split())))
    print(sum(P[:K]))

if '__main__' == __name__:
    resolve()"
"#!/usr/bin/python
# -*- coding: utf-8 -*-

A,B,M = map(int,input().split())

a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
xyc = []
for _ in range(0,M):
    xyc.append([int(x) for x in input().split()])

ans = 0

ans = min(a) + min(b)

coupon = []

for i in range(0,M):
    coupon.append(a[xyc[i][0]-1] + b[xyc[i][1]-1] - xyc[i][2])

ans = min(ans,min(coupon))

print(ans)"
"li = list(map(str, input()))
S=0
for i in range(4):
  if li[i]==""+"":
    S=S+1
  else:
    S=S-1
print(S)"
"n = int(input())
ans = ''
for i in range(1, n+1):
 if i%3 == 0:
  ans += "" "" + str(i)
 elif i%10 == 3:
  ans += "" "" + str(i)
 else:
  div = i
  while div//10:
   div = div//10
   if div%10 == 3:
    ans += "" "" + str(i)
    div = 0
print(ans)"
"# -*- coding:utf-8 -*-
n,m,c = map(int,input().split())
b_list = list(map(int,input().split()))
a_list =[]
for i in range(n):
    a_list.append(list(map(int,input().split())))

ret_num = 0
sum = 0

for N in range(n):
    sum = 0
    for M in range(m):
        sum += a_list[N][M] * b_list[M]
    if sum + c > 0:
        ret_num += 1

print(ret_num)

        
"
"import sys

readline = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)


def main():
    n, a, b = map(int, readline().split())
    ans = max(b * (n - 2) - a * (n - 2) + 1, 0)
    print(ans)


if __name__ == '__main__':
    main()
"
"n = int(input())
c = [int(input()) for _ in range(n)]

mod = 10**9 + 7

if n <= 2:
    print(1)
    exit()

# 圧縮
a = [c[0]]
m = 1
for c1, c2 in zip(c, c[1:]):
    if c2 != c1:
        a.append(c2)
        m += 1

memo = [-1] * (2 * 10**5 + 1)
ans = 1
dp = [0] * (m+1)
dp[0] = 1

for i in range(m):
    if memo[a[i]] == -1:
        memo[a[i]] = i
        dp[i+1] = dp[i]
    else:
        idx = memo[a[i]] + 1
        dp[i+1] += dp[i] + dp[idx]
        dp[i+1] %= mod
        memo[a[i]] = i

print(dp[m] % mod)"
"a=int(input())
b=[int(i) for  i in input().split()]
c=sorted(b,reverse=True)
x=0
y=0
for j in range(len(c)):
  if j%2==0:
    x+=c[j]
  else:
    y+=c[j]
print(x-y)"
"import sys
sys.setrecursionlimit(10**7)
limit = 100000
mod = 10**9+7
lpow = [False] * (limit+1)
lpow[0] = 1
def pow(n,p):
    if p<0:return 0
    if lpow[p]:
        return lpow[p]
    else:
        if p % 2 == 0:
            ret = (pow(n,p//2)**2) % mod
        else:
            ret = ((pow(n,p//2)**2)*n) % mod
        lpow[p] = ret
        return ret

def main():
    s=input()
    res = 0
    ca = 0
    cc = s.count(""C"")
    cw = 0
    aw = s.count(""?"")
    for c in s:
        if c == ""A"":
            ca += 1
        elif c == ""C"":
            cc -= 1
        elif c == ""B"":
            res += ca*cc*pow(3,aw)+ca*(aw-cw)*pow(3,aw-1)+cw*cc*pow(3,aw-1)+cw*(aw-cw)*pow(3,aw-2)
            res %= mod
        elif c == ""?"":
            res += ca*cc*pow(3,aw-1)+ca*(aw-cw-1)*pow(3,aw-2)+cw*cc*pow(3,aw-2)+cw*(aw-cw-1)*pow(3,aw-3)
            res %= mod
            cw += 1

    print(res)

main()"
"count=0
n=int(input())

for i in range(4):
    if n%10 == 2:
        count = count+1
    n = int(n/10)
        
print(count)
"
"n, m = map(int,input().split())
if m >= 3 and n >= 3:
    print((m-2) * (n-2))
elif (m == 2 or n == 2):
    print(0)
elif m >= 3 or n >= 3:
    print((max(m,n)-2) * min(m,n))
else:
    if (m * n) % 2 == 0:
        print(0)
    else:
        print(m * n)"
"from sys import stdin
input = stdin.readline
from time import time
from random import randint
from copy import deepcopy

start_time = time()

def calcScore(t, s, c):
    scores = [0]*26
    lasts = [0]*26
    for i in range(1, len(t)):
        scores[t[i]] += s[i][t[i]]
        dif = i - lasts[t[i]]
        scores[t[i]] -= c[t[i]] * dif * (dif-1) // 2
        lasts[t[i]] = i
    for i in range(26):
        dif = len(t) - lasts[i]
        scores[i] -= c[i] * dif * (dif-1) // 2
    return scores

def greedy(c, s):
    day_lim = len(s)
    socres = [0]*26
    t = [0]*day_lim
    lasts = [0]*26
    for i in range(1, day_lim):
        pls = [v for v in socres]
        mns = [v for v in socres]
        for j in range(26):
            pls[j] += s[i][j]
            mns[j] -= c[j] * (i - lasts[j])
        sum_mns = sum(mns)
        pt = sum_mns - mns[0] + pls[0]
        idx = 0
        for j in range(1, 26):
            tmp = sum_mns - mns[j] + pls[j]
            if pt < tmp:
                pt = tmp
                idx = j
        t[i] = idx
        lasts[idx] = i
        for j in range(26):
            if j == idx:
                socres[j] = pls[j]
            else:
                socres[j] = mns[j]
    return socres, t

D = int(input())
c = list(map(int, input().split()))
s = [[0]*26 for _ in range(D+1)]
for i in range(1, D+1):
    s[i] = list(map(int, input().split()))

scores, t = greedy(c, s)
sum_score = sum(scores)

while time() - start_time < 1.8:
    tmp_t = deepcopy(t)
    for _ in range(5):
        tmp_t[randint(1, D)] = randint(0, 25)
    tmp_scores = calcScore(tmp_t, s, c)
    sum_tmp_score = sum(tmp_scores)
    if sum_score < sum_tmp_score:
        sum_score = sum_tmp_score
        t = tmp_t
        scores = tmp_scores

for v in t[1:]:
    print(v+1)
"
"from collections import Counter
n = int(input())
list_A = list(map(int, input().split()))
l = Counter(list_A)

list_B = l.values()

value_1 = 0
value_2 = 0
value_0 = 0

for num in list_B:
    a = num
    while True:
        a = a % 3 + a // 3
        if a < 3:
            break
    if a == 2:
        value_2 += 1
    elif a == 1:
        value_1 += 1
    else:
        value_0 += 1

ans = value_1 + 2*(value_2//2) + value_0

print(ans)"
"N = int(input())
a = list(map(int, input().split()))

min_diff = float('inf')
a_sum = sum(a)
l_sum = 0

for i in range(N - 1):
  l_sum += a[i]
  min_diff = min(min_diff, abs(l_sum * 2 - a_sum))

print(min_diff)
"
"import itertools
import math
import fractions
import functools
import copy

n = int(input())
p = []
for i in range(n):
    p.append(int(input()))

print(sum(p)-max(p)//2)"
"import numpy as np

n, m = map(int, input().split())
a = np.array(sorted(list(map(int, input().split()))), dtype=np.int64)
bc = sorted([list(map(int, input().split())) for _ in range(m)], key=lambda x: -x[1])

p = 0
for b, c  in bc:
    a[p:p+b] = np.maximum(a[p:p+b], c)
    p += b
print(np.sum(a))"
"N, K = map(int, input().split())

ans = 0

ans_1 = N//K
ans_2 = ans_1 + 1

ans = min(abs(N-ans_1*K), abs(N-ans_2*K))
print(ans)"
"n = int(input())
s = input()
print(max(len(set(s[:i]) & set(s[i:])) for i in range(1, n)))"
"n, k = map(int, input().split())
a = list(map(int, input().split()))
MOD = 10**9+7
a.sort()

def prepare(n, MOD):
    """"""
    nCr mod MOD
    :param n:
    :param MOD:
    :return:
    """"""
    facts = [1]*(n+1)
    for i in range(1, n+1):
        facts[i] = facts[i-1]*i%MOD
    invs = [1]*(n+1)
    _invs = [1]*(n+1)
    invs[n] = pow(facts[n], MOD-2, MOD)
    for i in range(0, n)[::-1]:
        invs[i] = invs[i+1] * (i+1) % MOD
    return facts, invs
facts, invs = prepare(n, MOD)
max_sum = 0
min_sum = 0
for i, v in enumerate(a):
    under = i
    upper = n-1-i
    if i >= k-1:
        max_sum += v*facts[i]*invs[k-1]*invs[i-k+1]
        max_sum %= MOD
    if n-1-i >= k-1:
        min_sum += v*facts[n-1-i]*invs[k-1]*invs[n-i-k]
        min_sum %= MOD

print((max_sum-min_sum)%MOD)"
"N, A, B = map(int, input().split())
H = [0] * N
for i in range(N):
    H[i] = int(input())

sorted_H = sorted(H, reverse=True)

def is_enough(num):
    cnt = 0
    for x in range(N):
        if sorted_H[x] - num * B > 0:
            cnt += (sorted_H[x] - num * B) // (A - B)
            if (sorted_H[x] - num * B) % (A - B) != 0:
                cnt += 1
        else:
            break
    return cnt <= num

limit = (sorted_H[0] // B) + 1

i = 0
j = limit
while True:
    k = (j + i) // 2
    if is_enough(k):
        if i + 1 == k:
            print(k)
            break
        j = k
    else:
        if k + 1 == j:
            print(k + 1)
            break
        i = k
"
"import sys
from itertools import accumulate
read = sys.stdin.read

N, T, *A = map(int, read().split())
a_maximum = list(reversed(list(accumulate(A[::-1], max))[:-1]))
a = [j - i for i, j in zip(A, a_maximum)]
minimum = max(a)

print(a.count(minimum))"
"def solve():
    x = int(input())
    if x == 7 or x == 5 or x == 3:
        print('YES')
    else:
        print('NO')


if __name__ == '__main__':
    solve()
"
"n,m = map(int, input().split())
b1 = []
b2 = []
for i in range(m):
    a,b = map(int, input().split())
    if a == 1:
        b1.append(b)
    if b == n:
        b2.append(a)
if len(b1) + len(b2) == len(list(set(b1+b2))):
    print('IMPOSSIBLE')
else:
    print('POSSIBLE')"
"n = int(input())
a = n * 800
b = n // 15 * 200

print(a - b)
"
"N = int(input())
P = list(map(int, input().split()))
m = P[0]
c = 1
for i in range(1, N):
    if P[i] <= m:
        c += 1
        m = P[i]
print(c)"
"antennas = [int(input()) for _ in range(5)]
k = int(input())

flag = True

for i in range(4):
    for j in range(i + 1, 5):
        if antennas[j] - antennas[i] > k:
            flag = False
            break

if flag:
    print('Yay!')
else:
    print(':(')"
"def selectionSort(A, N):
    count = 0
    for i in xrange(0,N):
        minj = i
        for j in xrange(i,N):
            if A[j] < A[minj]:
                minj = j
                
        if minj != i:
            tmp = A[i]
            A[i] = A[minj]
            A[minj] = tmp
            count += 1
    return A, count

def main():
    N = int(raw_input())
    A = map(int,raw_input().split())
    newA, count = selectionSort(A, N)
    print ' '.join(map(str,newA))
    print count
    return 0

if __name__ == ""__main__"":
    main()"
"s = list(input())
t = list(input())
s.sort()
t.sort(reverse=True)
ans_s = """".join(map(str, s))
ans_t = """".join(map(str, t))
print(""Yes"" if ans_s < ans_t else ""No"")
"
"n = int(input())
dp = [i for i in range(n+1)]

for i in range(n):
    dp[i+1] = min(dp[i+1],dp[i] + 1)
    cou = 1
    while True:
        if i + 6**cou <= n:
            dp[i+6**cou] = min(dp[i+6**cou],dp[i]+1)
            cou += 1
        elif i + 6**cou > n:
            break
    cou = 1
    while True:
        if i + 9**cou <= n:
            dp[i+9**cou] = min(dp[i+9**cou],dp[i]+1)
            cou += 1
        elif i + 9**cou > n:
            break
print(dp[n])"
"N, M = [int(x) for x in input().split()]
H = [int(x) for x in input().split()]
AB = [[int(x) for x in input().split()] for _ in range(M)]

tenbo = [[] for j in range(N + 1)]

for a, b in AB:
    tenbo[a].append(b)
    tenbo[b].append(a)

ans = 0
for i in range(1, N + 1):
    x = H[i - 1]
    f = True
    for t in tenbo[i]:
        if x > H[t - 1]:
            continue
        else:
            f = False
            break
    if f:
        ans += 1

print(ans)

"
"N,M,K = map(int, input().split())

p = 998244353

factorial = [1]
counter = 0
for i in range(1,N+1):
    factorial.append(factorial[i-1]*i%p)



for k in range(K+1):
    counter += factorial[N-1]*pow(factorial[k],p-2,p)*pow(factorial[N-k-1],p-2,p)*M*pow(M-1,N-1-k,p)
print(counter%p)
"
"#!/usr/bin/env python3
import sys


def solve(T: ""List[int]"", A: ""List[int]"", B: ""List[int]""):
    dif1 = T[0]*(A[0] - B[0])
    dif2 = T[1]*(A[1] - B[1])

    if dif1+dif2 == 0:
        print('infinity')
        return
    
    if dif1*dif2>0 or abs(dif1)>abs(dif2):
        print(0)
        return
    
    ## tが抜かれる方
    t = abs(dif1)
    a = abs(dif2)

    if t%abs(t-a)==0:
        print(2*(t//abs(t-a)))
    else:
        print(2*(t//abs(t-a))+1)
    return


def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    T = [int(next(tokens)) for _ in range(2)]  # type: ""List[int]""
    A = [int(next(tokens)) for _ in range(2)]  # type: ""List[int]""
    B = [int(next(tokens)) for _ in range(2)]  # type: ""List[int]""
    solve(T, A, B)

if __name__ == '__main__':
    main()
"
"from collections import defaultdict

def readInt():
	return int(input())
def readInts():
	return list(map(int, input().split()))
def readChar():
	return input()
def readChars():
	return input().split()

k = int(input())
a,b  = readInts()

for i in range(a,b+1):
	if i%k==0:
		print(""OK"")
		exit()

print(""NG"")"
"def factor(N):
    res = []
    for i in range(1,int(N**0.5)+1):
        if N%i == 0:
            res.append(i)
            res.append(N//i)
    return sorted(list(set(res)))

N = int(input())
f = factor(N)
f.pop(0)

ans = 0
for n in f:
    tmp = n-1
    if N//tmp == N%tmp:
        ans += tmp
        
print(ans)"
"N=input()
n=N[-1]
if n in ['2','4','5','7','9']:
  print(""hon"")
elif n in ['0','1','6','8']:
  print(""pon"")
else:
  print(""bon"")"
"n = int(input())
x = list(map(int,input().split()))
y = list(map(int,input().split()))

ans,num = [],0
for i in range(n):
    num += abs(x[i] - y[i])
ans += num,

num = 0
for i in range(n):
    num += (x[i] - y[i])**2
num **= 1/2
ans += num,

num = 0
for i in range(n):
    num += (abs(x[i] - y[i]))**3
num **= 1/3
ans += num,

num = []
for i in range(n):
    num += abs(x[i] - y[i]),
num = max(num)
ans += num,

print(*ans, sep = ""\n"")
"
"N = int(input())
T = list(map(int, input().split()))
M = int(input())
T_copy = T.copy()

for _ in range(M):
    T = T_copy.copy()
    P, X = map(int, input().split())
    T[P-1] = X
    print(sum(T))



"
"a,b = map(int,input().split())
if a <= 0 <= b:
    print(""Zero"")
else:
    if a < 0 and (b-a+1) % 2 != 0:
        print(""Negative"")
    else:
        print(""Positive"")"
"n = input()
 
A = list(map(int, input().split()))
 
counts = 0
while all(a%2==0 for a in A):
  A = [a/2 for a in A]
  counts += 1
print(counts)"
"K,A,B=map(int,input().split())
c=1

if A+2<B:
    if K<=A:
        print(1+K)
    else:
        K-=A-1
        c+=A-1
    #    print(c)
        if K%2:
            K-=1
            c+=1
        c+=K//2*(B-A)
        print(c)
else:
    print(1+K)
"
"K = int(input())
S = input()
words = int(len(S))

if K < words:
    print(S[0:K] + ""..."")

else:
    print(S)"
"N, M = map(int, input().split())
a_and_b = [list(map(int, input().split())) for i in range(M)]
for i in range(N):
    ans = 0
    for j in range(M):
        ans += a_and_b[j].count(i+1)
    print(ans)"
"n=int(input())
d={}
l=[]
for i in range(n):
  s=input()
  if s not in d:
    d[s]=1
  else:
    d[s]=d[s]+1
k=max(d.values())
for i,j in d.items():
  if j==k:
    l.append(i)
l.sort()
for i in range(len(l)):
  print(l[i])"
"def YesNo(b):
    print(""Yes"" if b else ""No"")


def solve(l, t0, t):
    s = {t0}
    for v in l:
        s, ps = set(), s
        for a in ps:
            s.add(a+v)
            s.add(a-v)
    return t in s


s = input()
x, y = map(int, input().split())

f = s.split('T')
x0 = len(f[0])
xl = [len(v) for v in f[2::2]]
yl = [len(v) for v in f[1::2]]

YesNo(solve(xl, x0, x) and solve(yl, 0, y))"
"n,y=map(int,input().split())

flag=0
total = 0

for i in range(n+1):
    for j in range(n+1):
        k=n-i-j
        if k<0:
            break

        total=10000*i+5000*j+1000*k
        if total==y:
            print(i,j,k)
            flag=1
            break 
    if flag == 1:
        break
if flag == 0:
    print('-1 -1 -1')"
"N = int(input())
S = [input() for _ in range(N)]
M = int(input())
T = [input() for _ in range(M)]

ans = 0
for s in S:
  ans = max(ans, S.count(s)-T.count(s))

print(ans)
"
"# -*- coding: utf-8 -*-
import itertools

import numpy as np


# 読み込み
n, m = map(int, input().split())
swicthes = np.zeros((m, n), dtype=int)

for i in range(m):
    _, *s = map(lambda x: int(x) - 1, input().split())
    swicthes[i, np.array(s, dtype=int)] = 1

l = list(map(int, input().split()))
p = np.array(l, dtype=int)

# bit全探索
count = 0
for on in itertools.product([0, 1], repeat=n):
    _on = np.array(on, dtype=int)
    status = np.sum(swicthes * _on, axis=1) % 2
    if np.sum(p == status) == m:
        # 全ての電球が点灯している
        count += 1

print(count)
"
"N = int(input())
l = [2, 1]
for i in range(2, N+1):
    l0, l1 = l
    l[0] = l1
    l[1] = l1+l0
print(l[1])
"
"import sys
import math
import itertools
import collections
import heapq
import re
import numpy as np

rr = lambda: sys.stdin.readline().rstrip()
rs = lambda: sys.stdin.readline().split()
ri = lambda: int(sys.stdin.readline())
rm = lambda: map(int, sys.stdin.readline().split())
rl = lambda: list(map(int, sys.stdin.readline().split()))
inf = float('inf')
mod = 10**9 + 7

a, b, c = rm()
if b >= c:
  print('delicious')
elif c-b > a:
  print('dangerous')
else:
  print('safe')







"
"def main():
    ab = [_x for _x in input().split()]
    n = ab[1]
    bb = (int(n[0])*100 + int(n[2])*10 + int(n[3]))
    aa = int(ab[0])
    if aa == 0:
        print(0)
        return
    if bb == 0:
        print(0)
        return
    result = str(aa*bb)

    if len(result) <= 2:
        print(0)
    else:
        print(str(result)[:-2])


main()
"
"a = [1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51]
print a[input() - 1]"
"from collections import Counter 
from collections import defaultdict
from collections import deque
from functools import reduce
import math
import itertools
import heapq
#import numpy as np
import bisect
import sys
#import sympy
sys.setrecursionlimit(10**6)


def bfs(s,n,node):
    #頂点が探索済みかどうかのチェック配列
    check=[False for _ in range(n)]
    check[s]=True
    #次見る頂点を格納するキュー
    queue=deque([s])
    visited_num=1

    #問題固有の配列
    #color_check=[[True for _ in range(l)] for _ in range(n)]
    color=[-1 for _ in range(n)]
    color[s]=0
    
    while visited_num<n:
        #グラフが全連結ではない場合
        if len(queue)==0:
            #空配列を返す
            #現状までの計算済み配列を返してもいいと思う
            return color

        now_vertex=queue.popleft()
        #インデックスがない場合は
        for next_vertex in node[now_vertex]:


            if check[next_vertex]==True:
                continue

            queue.append(next_vertex)
            check[next_vertex]=True

            #問題固有の計算
            color[next_vertex]=color[now_vertex]+1
            visited_num+=1

    return color

mod=10**9+7
#n=int(input())
#n,m=list(map(int,input().split()))
#a=list(map(int,input().split()))
ceil=lambda x,y: (x+y-1)//y
input_list = lambda : list(map(int,input().split()))

n=int(input())
tmp=list(map(int,input().split()))
a=[]
al=0
for each in tmp:
    al^=each
    a.append(each)

ans=[]
for each in (tmp):
    ans.append(str(each^al))

print("" "".join(ans))
"
"nums = list(map(int, input().split()))
if nums[0] < nums[1] < nums[2]:
    print(""Yes"")
else:
    print(""No"")"
"n = int(input())
A = list(map(int, input().split()))
mod = 10**9+7
s = 0
ans = 0
for a in A:
    ans += s*a
    ans %= mod
    s += a
    s %= mod
print(ans)
"
"s = input()

s = "" "" + s

ans = 0

if len(s) % 2 == 0:
    for i in range(1, len(s) // 2 + 1):
        if s[i] != s[i * -1]:
            ans += 1
else:
    for i in range(1, len(s) // 2 + 1):
        if s[i] != s[i * -1]:
            ans += 1

print(ans)"
"A, B = map(int, raw_input().split())
if B % A == 0:
    ans = A + B
else:
    ans = B - A

print str(ans)"
"a = list(map(int, input().split()))
b = a[0]
c = 0
while b > 0:
  b = b // a[1]
  c += 1
print(c)
"
"import sys

def solve():
    input = sys.stdin.readline
    N = input().strip(""\n"")
    K = int(input())
    dig = len(N)
    DP = [[0] * (K + 1) for _ in range(dig)]
    DP[0][0] = 1
    DP[0][1] = int(N[0]) - 1
    for i in range(1, dig):
        DP[i][1] = 9
        if N[i] != ""0"": 
            DP[i][0] = DP[i-1][0] + 1
            if DP[i-1][0] <= K: DP[i][DP[i-1][0]] += 1
            if DP[i-1][0] <= K - 1: DP[i][DP[i-1][0] + 1] += int(N[i]) - 1     
        else: DP[i][0] = DP[i-1][0]
        for j in range(1, K): DP[i][j+1] += DP[i-1][j] * 9
        for j in range(1, K + 1): DP[i][j] += DP[i - 1][j]
    if DP[dig - 1][0] == K: DP[dig - 1][K] += 1
    print(DP[dig - 1][K])
    #print(DP)

            
    return 0

if __name__ == ""__main__"":
    solve()"
"from math import gcd

def gcd3(a, b, c):
  return gcd(gcd(a, b), c)

K = int(input())

res = 0
for a in range(1, K+1):
  for b in range(1, K+1):
    for c in range(1, K+1):
      res += gcd3(a, b, c)
      
print(res)"
"def get_divisor(num, max_val):
    ret = []
    num_sq = int(num**0.5)
    for k in range(1, num_sq+1):
        if num % k == 0:
            if k <= max_val: ret.append(k)
            if num//k <= max_val: ret.append(num//k)
            
    return ret

# 下からmodが低いのを取ってきてマッチングを取る
def solve():
    N,K = map(int, input().split())
    A = list(map(int, input().split()))
    sum_A = sum(A)
    max_A = max(A)
    div = get_divisor(sum_A, max_A+K)
    ret = 1
    for d in div:
        sum_k = 0
        red_k = 0
        flag = True
        mod_d = [a%d for a in A]
        mod_d.sort()
        # print(d, mod_d)
        for a in mod_d:
            if sum_k+a <= K:
                sum_k += a
            else: 
                red_k += d-a
            if sum_k-red_k < 0:
                break

        if (sum_k-red_k)%d == 0: ret = max(ret, d)
            
    print(ret)
    
solve()"
"N = int(input())
map_T = map(int, input().split())
list_T = list(map_T)
M = int(input())
sumtime = sum(list_T)

for i in range(M):
  map_PX = map(int, input().split())
  list_PX = list(map_PX)
  sumtime_drink = sumtime- list_T[list_PX[0]- 1]+ list_PX[1]
  print(sumtime_drink)"
"S = input()
N = len(S)

Rcnt = 0
SR = [0]*N
for i in range(N):
    if S[i] == 'R':
        Rcnt += 1
    elif Rcnt== 0:
        continue
    else:
        SR[i] = Rcnt//2
        SR[i-1] = Rcnt - Rcnt//2
        Rcnt = 0
        
SL = [0]*N
SS = S[-1::-1]
Lcnt = 0
for i in range(N):
    if SS[i] == 'L':
        Lcnt += 1
    elif Lcnt ==0:
        continue
    else:
        SL[i] = Lcnt//2
        SL[i-1] = Lcnt - Lcnt//2
        Lcnt = 0

for i in range(N):
    print(SR[i]+SL[N-i-1], end = "" "")
"
"a = input()

if a == 'A':
    print('T')
elif a == 'T':
    print('A')
elif a == 'C':
    print('G')
elif a == 'G':
    print('C')
"
"N = int(input())
K = 0
k = 0
while K < N:
  k += 1
  K += k
while N > 0:
  if N >= k:
    print(k)
    N -= k
  k -= 1"
"n = int(input())
a = list(map(int,input().split()))
a.sort()
ma = a[-1]

dp = [0]*(ma+1)

for i in range(1,n):
    if a[i]==a[i-1]:
        dp[a[i]]=1

for i in a:
    for j in range(i*2,ma+1,i):
        #if dp[j]==1:
            #break
        dp[j]=1
        
ans = 0
for i in a:
    if dp[i]==0:
        ans+=1
        
print(ans)"
"n,x=map(int, input().split())
a=list(map(int, input().split()))
a.sort()

if sum(a)==x:
    print(n)
elif sum(a)<x:
    print(n-1)
else:
    total=0
    cnt=0
    for a_i in a:
        if total+a_i<=x:
            total+=a_i
            cnt+=1
        else:
            break
    print(cnt)
"
"def resolve():
    A, B = map(int, input().split())
    ans = []
    for i in range(1, min(A, B)+1):
        if A%i == 0 and B%i == 0:
            ans.append(i)
    print(A*B//ans[-1])
resolve()"
"N=int(input())
ans=N
for i in range(N+1):
  cnt=0
  t=i
  while t>0:
    cnt+=t%6
    t//=6
  j=N-i
  while j>0:
    cnt+=j%9
    j//=9
  ans=min(ans,cnt)
print(ans)
"
"x = int(input())
print(0 if x == 1 else 1)"
"class Imos_1:
    def __init__(self,N):
        self.len=N
        self.list=[0]*(N+1)

    def Add(self,F,T,C=1):
        self.list[F]+=C
        self.list[T+1]-=C

    def Cumulative_Sum(self):
        Y=[0]*(self.len)
        S=0
        for i in range(self.len):
            S+=self.list[i]
            Y[i]=S

        return Y
#================================================
N,M=map(int,input().split())
I=Imos_1(N)

for _ in range(M):
    a,b=map(int,input().split())
    a,b=min(a,b),max(a,b)
    I.Add(a,b-1,1)

J=I.Cumulative_Sum()

F=True
for k in J:
    F&=not(k%2)

if F:
    print(""YES"")
else:
    print(""NO"")

"
"
s = input()

if len(s) % 2 ==1:
	print('No')
	exit()

if s == ""hi""* (len(s) // 2):
	print('Yes')
else:
	print('No')"
"r, g, b, n = map(int, input().split())
ans = 0
for i in range(0, n+1, r):
    for j in range(0, n+1, g):
        if n < (i+j):
            break
        elif (n-(i+j))%b == 0:
            ans += 1

print(ans)"
"#import sys
#import numpy as np
#import math
#import itertools
#from fractions import Fraction
#import itertools
from collections import deque
#import heapq
#from fractions  import gcd
#input=sys.stdin.readline
#import bisect

n,m=map(int,input().split())
edge=[list(map(int,input().split())) for _ in range(m)]
           
inf=10**9
nextm=[[inf]*n for _ in range(n)]

for i in range(n):
    nextm[i][i]=0
for i in range(m):
    to,f,weight=edge[i]
    nextm[to-1][f-1]=weight
    nextm[f-1][to-1]=weight

for k in range(n):
    for i in range(n):
        for j in range(n):
            if nextm[i][j]>nextm[i][k]+nextm[k][j]:
                nextm[i][j]=nextm[i][k]+nextm[k][j]
res=0               
for i in range(m):
  a,b,c=edge[i]
  if c>nextm[a-1][b-1]:
    res+=1
print(res)"
"k = int(input())
s = input()
l = len(s)
if k >= l:
  print(s)
else:
  print(s[0:k] + ""..."")"
"S = input()
print('Heisei' if S <= '2019/04/30' else'TBD')"
"N = int(input())
m = {
    'S': list(range(1, 14)),
    'H': list(range(1, 14)),
    'C': list(range(1, 14)),
    'D': list(range(1, 14))
}
for i in range(N):
    shape, num = input().strip().split(' ')
    num = int(num)
    m[shape].remove(num)
for k in ['S', 'H', 'C', 'D']:
    if len(m[k]) > 0:
        for x in m[k]:
            print('%s %d' % (k, x))"
"n = int(input())
print(48-n)"
"a, b, c, d = map(int, input().split())

check = False
if abs(a-c) <= d:
    check = True
else:
    if abs(a-b) <= d and abs(b-c) <= d:
        check = True

if check:
    print('Yes')
else:
    print('No')"
"import sys
sys.setrecursionlimit(10**9)


N, Q = map(int, input().split())
to = [[] for _ in range(N)]
ans = [0] * N

for _ in range(N - 1):
    a, b = map(lambda x:int(x) - 1, input().split())
    to[a].append(b)
    to[b].append(a)


def dfs(v, p=-1):
    global ans
    for nv in to[v]:
        if nv == p:
            continue
        ans[nv] += ans[v]
        dfs(nv, v)


def main():
    global ans
    for _ in range(Q):
        p, x = map(int, input().split())
        p -= 1
        ans[p] += x
    dfs(0)
    print(*ans)


if __name__ == ""__main__"":
    main()"
"def binary_search(ok, ng, error, test):
    """"""
    :param ok: solve(x) = True を必ず満たす点
    :param ng: solve(x) = False を必ず満たす点
    """"""
    while abs(ok - ng) > error:
        mid = (ok + ng) / 2
        if test(mid):
            ok = mid
        else:
            ng = mid
    return ok

def max2(x,y):
    return x if x > y else y

def min2(x,y):
    return x if x < y else y

def test(y):
    return (a**3*tan(y)/2 + (b-a*tan(y))*cos(y)*a**2/cos(y) if b-a*tan(y) >= 0 else b**2*a*tan(pi/2-y)/2 ) >= x

from math import *
a, b, x = map(int, input().split())


print(binary_search(0,pi/2,10**(-8), test)*180/pi)






"
"s1=input()
s2=input()
n1,n2=len(s1),len(s2)
dp=[[-1 for j in range(n2+1)] for i in range(n1+1)]
for i in range(n1,-1,-1):
    for j in range(n2,-1,-1):
        if i==n1 or j==n2:
            dp[i][j]=0
        else:
            if s1[i]==s2[j]:
                dp[i][j]=1+dp[i+1][j+1]
            else:
                dp[i][j]=max(dp[i][j+1],dp[i+1][j])
n=""""
i,j=0,0
while i<n1 and j<n2:
    if dp[i][j]==dp[i+1][j]:
        i+=1
    elif dp[i][j]==dp[i][j+1]:
        j+=1
    else:
        n+=s1[i]
        i+=1
        j+=1
print(n)"
"##C - Sum of product of pairs
##累積和
N = int(input())
A = list(map(int,input().split()))
S = sum(A)
ans = 0
for i in range(N-1):
    ans += A[i]*(S - A[i])
    S -= A[i]
print(ans % (10**9+7))"
"n = int(input())
blue = [input() for i in range(n)]
m = int(input())
red = [input() for i in range(m)]

ans = 0
for i in range(n):
    tmp = blue.count(blue[i]) - red.count(blue[i])
    ans = max(ans, tmp)
print(ans)"
"import sys

# import bisect
# from collections import Counter, deque, defaultdict
# import copy
# from heapq import heappush, heappop, heapify
# import itertools
# from operator import attrgetter, itemgetter
# import math

# from numba import jit
# import numpy as np

readline = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)


def main():
    n = int(input())
    a = [0] + list(map(int, readline().split()))

    if n == 2:
        print(max(a[1],a[2]))
        sys.exit()

    dp = [[0] * 2 for _ in range(n + 1)]

    # 普通に選ぶ場合
    dp[1][0] = 0
    dp[2][0] = max(a[1], a[2])
    dp[3][0] = max(a[1], a[2], a[3])

    # 1個多く選ぶ場合（奇数個のみ）
    dp[1][1] = a[1]
    dp[3][1] = a[1] + a[3]

    i = 4

    while i < n + 1:
        cur1 = a[i]

        # 偶数だよ
        dp[i][0] = max(dp[i - 1][1], dp[i - 2][0] + cur1)

        if i == n:
            break

        i += 1
        cur2 = a[i]

        # 奇数だよ
        dp[i][0] = max(dp[i - 2][0] + cur2, dp[i - 3][0] + cur2, dp[i - 1][0], dp[i - 2][1])
        dp[i][1] = dp[i - 2][1] + cur2

        i += 1

    print(dp[n][0])


if __name__ == '__main__':
    main()
"
"n,d = map(int, input().split())
a = []
ans = 0

for i in range(n):
    a.append(list(map(int, input().split())))

for i in range(n):
    for j in range(i+1,n):
        sum = 0
        for v1, v2 in zip(a[i], a[j]):
            sum += (v1-v2)**2
        sum**=0.5
        #print(sum)
        if sum == int(sum):
            ans += 1

print(ans)"
"S,w=input(),int(input())
N=0
while N<len(S):
   print(S[N],end="""")
   N+=w
"
"# import numpy as np
# import math
# import copy
# from collections import deque
import sys
input = sys.stdin.readline
# sys.setrecursionlimit(10000)
# from numba import njit,i8
 
 
# @njit(i8(i8,i8,i8,i8[:,:],i8[:],i8,i8))
def give_dp(N,K,mod,LR,dp,l,r):
    for i in range(N):
        if i > 0:
            dp[i] += dp[i-1]
            dp[i] %= mod
        for k in range(K):
            l = LR[k][0]
            r = LR[k][1]
            if i + l < N:
                dp[i+l] += dp[i]
                dp[i+1] %= mod
            if i + r + 1 < N:
                dp[i+r+1] -= dp[i]
                dp[i+1] %= mod
    return dp[-1]
 
 
def main():
    N,K = map(int,input().split())
    LR = [list(map(int,input().split())) for i in range(K)]
    # LR = np.array(LR)
 
    mod = 998244353
 
    dp = [0 for i in range(N)]
    dp[0] = 1
    dp[1] = -1
    # dp = np.array(dp)
 
    res = give_dp(N,K,mod,LR,dp,0,0)
    res %= mod
 
    print(res)
 
 
 
main()"
"mod = 10**9 + 7
n, k = map(int, input().split())

a = list(map(int, input().split()))

inside = [0] * n
outside = [0] * n

for i in range(n):
    for j in range(i + 1, n):
        if a[i] > a[j]:
            inside[i] += 1

for i in range(n):
    for j in range(n):
        if a[i] > a[j]:
            outside[i] += 1

ans = 0
ans += sum(inside) * k
ans %= mod
ans += sum(outside) * k * (k - 1) // 2
ans %= mod
print(ans)
"
"x, y = map(int,input().split())
li = list(map(int,input().split()))

if (x-1)%(y-1) == 0:
    print((x-1)//(y-1))
else:
    print((x-1)//(y-1)+1)"
"import sys
readline = sys.stdin.readline

N, S = map(int, readline().split())
A = list(int(x) for x in readline().split())
MOD = 998244353

dp = [[0] * (S+1) for _ in range(N+1)]
dp[0][0] = 1

for i in range(N):
    for j in range(S+1):
        # 1,2のケース。jが変わらない遷移が2通りある。
        dp[i+1][j] = (dp[i+1][j] + dp[i][j] * 2) % MOD
        # 3のケース。j+A[i] <= Sならば、j+A[i]に遷移する。
        if j + A[i] <= S:
            dp[i+1][j+A[i]] = (dp[i+1][j+A[i]] + dp[i][j]) % MOD
print(dp[N][S])"
"s=input()
print(s[0],len(s[1:-1]),s[-1],sep="""")"
"s=int(input())
cnt=1
x=[s]
while True:
  cnt+=1
  if s%2==0:
    s//=2
  else:
    s=3*s+1
  if s not in x:
    x.append(s)
  else:
    print(cnt)
    break"
"import sys
def solve():
  n = int(raw_input())
  print n**3
  
if __name__ == ""__main__"":
  solve()"
"n = int(input())
x = list(map(int,input().split()))
HP = 10**6
for i in range(1,101):
    hp = 0
    for j in range(n):
        hp += (i - x[j])**2
    HP = min(HP,hp)
print(HP)"
"a=int(input())
b=int(input())
s=a*a
tp=s-b
print(tp)"
"import collections

N = int(input())
tree = [[] for _ in range(N)] #i行目には、i番目のマスと隣り合っているマスの番号が加えられる
for _ in range(N-1):
    a, b = map(int, input().split())
    tree[a-1].append(b-1)
    tree[b-1].append(a-1)

color = [0] * N #色が塗られていなければ0、黒は1、白は-1
color[0] = 1
color[N-1] = -1
que = collections.deque() #色が塗られたマスの番号を、隣り合うマスが全て塗られるまでここに入れる
que.append(0)
que.append(N-1)
while que: #塗るべきマスがなくなるまで繰り返す
    i = que.popleft() #「左から」が重要 #n回でたどり着けるマスはn回目に全て塗って良い
    for x in tree[i]:
        if color[x] == 0:
            color[x] = color[i]
            que.append(x) #塗ったマスは調べるリストに入れる

if sum(color) > 0: #合計が正、つまり黒が多い場合は先手の勝ち
    print(""Fennec"")
else: #合計が0でも先手の塗るマスがないため後手の勝ち
    print(""Snuke"")
"
"n=int(input())
a=list(map(int,input().split()))
mod=10**9+7
ans=0
k=1
for i in range(61):
    count0=0
    count1=0
    for j in a:
        if not (j>>i & 1):
            count0+=1
        if j>>i & 1:
            count1+=1
    ans+=((count0*count1)*(k))%mod
    k=(2*k)%mod
    
    
print(ans%mod)"
"n=int(input())
ans=0
for i in range(1,10):
    if n%i==0 and n/i<10:
        ans=1
if ans==0:
    print(""No"")
else:
    print(""Yes"")"
"N = int(input())
ans = []
x = 6
while len(ans) < N:
    for y in range(2, int(x**0.5)+1):
        if x % y == 0:
            break
    else:
        ans.append(x)
    x += 5
print(*ans)
"
"#coding:utf-8
import sys,os
from collections import defaultdict, deque
from fractions import gcd
from math import ceil, floor
sys.setrecursionlimit(10**6)
write = sys.stdout.write
dbg = (lambda *something: print(*something)) if 'TERM_PROGRAM' in os.environ else lambda *x: 0
def main(given=sys.stdin.readline):
    input = lambda: given().rstrip()
    LMIIS = lambda: list(map(int,input().split()))
    II = lambda: int(input())
    XLMIIS = lambda x: [LMIIS() for _ in range(x)]
    YN = lambda c : print('Yes') if c else print('No')
    MOD = 10**9+7

    N = II()
    g = {'Vacant':0, 'Male':1, 'Female':2}



    print(0,flush=True)
    sl = g[input()]
    if sl == 0:
        return

    print(N-1,flush=True)
    sr = g[input()]
    if sr == 0:
        return
    
    l = 0
    r = N-1
    while r-l>1:

        m = (l+r)//2
        print(m,flush=True)
        a = g[input()]
        if a == 0:
            return
        
        if (m-l) % 2 == 1:
            if sl == a:
                r = m
                sr = a
            else:
                l = m
                sl = a

        else:
            if a != sl:
                r = m
                sr = a
            else:
                l = m
                sl = a
        

    print(-1)


if __name__ == '__main__':
    main()"
"n,m = map(int,input().split())
voyage = [set() for i in range(n+1)]
for i in range(m):
  a,b = map(int,input().split())
  voyage[a].add(b)
  voyage[b].add(a)
ans = 0
for v in voyage[1]:
  if v in voyage[n]:
    ans = 1
print('POSSIBLE' if ans else 'IMPOSSIBLE')"
"# -*- coding: utf-8 -*-
import sys
from collections import deque

N,M=map(int, sys.stdin.readline().split())
al=[ [] for _ in range(N+1) ]   #隣接リスト
rev_al=[ [] for _ in range(N+1) ]   #戻りを調べる用の隣接リスト
edge=[] #辺の集合
for _ in range(M):
    a,b,c=map(int, sys.stdin.readline().split())
    al[a].append(b)
    rev_al[b].append(a) #逆向きにも辺を張る
    edge.append((a,b,c))


go=[0 for _ in range(N+1)]
back=[0 for _ in range(N+1)]

#頂点１からNに行くまでに使用する頂点を調べる
q=deque()
q.append(1) #スタート地点
go[1]=1

while q:
    fro=q.popleft()
    for to in al[fro]:
        if go[to]==0:
            go[to]=1
            q.append(to)


#頂点Nから1に戻る際に使用する頂点を調べる
q=deque()
q.append(N) #スタート地点
back[N]=1

while q:
    fro=q.popleft()
    for to in rev_al[fro]:
        if back[to]==0:
            back[to]=1
            q.append(to)


new_edge=[]     #有効な辺のみ抽出

for a,b,c in edge:
    if go[a]==1 and back[b]==1:
        new_edge.append((a,b,c))


#ベルマンフォード
dp=[ float(""-inf"") for _ in range(N+1) ]
dp[1]=0

for i in range(N):
    for fro,to,cost in new_edge:
        alt=dp[fro]+cost
        if dp[to]<alt:
            if i==N-1:
                print float(""inf"")
                quit()
            dp[to]=alt

print dp[N]"
"x,cal,y = input().split()
print(int(x)+int(y) if cal == '+' else int(x)-int(y))"
"s=input()
s=s+'0'
K=int(input())
p=set()
for i in range(len(s)):
  for j in range(1,6):
    if i+j<=len(s)-1:
      p.add(s[i:j+i])
p=sorted(p)
print(p[K-1])"
"n,m = (int(x) for x in input().split())
if n == m:
  print('Yes')
else:
  print('No')"
"# エラトステネスの篩
def make_prime_table(n):
    sieve = list(range(n + 1))
    sieve[0] = -1
    sieve[1] = -1
    for i in range(2, int(n ** 0.5) + 1):
        if sieve[i] != i:
            continue
        for j in range(i * i, n + 1, i):
            if sieve[j] == j:
                sieve[j] = i
    return sieve


def prime_factorize(n):
    result = []
    while n != 1:
        p = prime_table[n]
        c = 0
        while n % p == 0:
            n //= p
            c += 1
        result.append((p, c))
    return result


N = int(input())

prime_table = make_prime_table(N)
d = {}
for i in range(2, N + 1):
    for p, c in prime_factorize(i):
        d.setdefault(p, 0)
        d[p] += c

# 75 = 5 * 5 * 3
#    = 15 * 5
#    = 25 * 3
#    = 75
n74 = 0
n24 = 0
n14 = 0
n4 = 0
n2 = 0
for k in d:
    if d[k] >= 74:
        n74 += 1
    if d[k] >= 24:
        n24 += 1
    if d[k] >= 14:
        n14 += 1
    if d[k] >= 4:
        n4 += 1
    if d[k] >= 2:
        n2 += 1

result = 0
# x ^ 4 * y ^ 4 * z ^ 2 の約数の個数は75個
result += n4 * (n4 - 1) // 2 * (n2 - 2)
# x ^ 14 * y ^ 4 の約数の個数は75個
result += n14 * (n4 - 1)
# x ^ 24 * y ^ 2 の約数の個数は75個
result += n24 * (n2 - 1)
# x ^ 74 の約数の個数は75個
result += n74
print(result)
"
"a=int(input())
print((a-a//2)/a)"
"N=int(input())
S=[''.join(sorted(input())) for _ in range(N)]
ans=0
import collections
from math import factorial
c = collections.Counter(S)
for i in c.values():
    if 2<=i:
        ans+=factorial(i)//(factorial(i-2)*factorial(2))

print(ans)"
"n,k = map(int, open(0).read().split())

left = right = 0
ans = 0
MOD = 10**9+7

for c,(i,j) in enumerate(zip(range(n+1), range(n,-1,-1))):
    left += i
    right += j
#     print(i,j, right, left,c)
    if c >= k-1:
        ans += (right-left+1)
        ans %= MOD

print(ans)"
"n = int(input())
c = input()
x = 0
for i in range(n):
    if c[i] == ""R"":
        x += 1

y = 0
if x != 0:
    for j in range(x):
        if c[j] == ""W"":
            y += 1

print(y)"
"ABCD = input()
for i in ('-1','+1'):
    for j in ('-1','+1'):
        for k in ('-1','+1'):
            if int(ABCD[0]) + (int(i)) * int(ABCD[1]) + (int(j)) * int(ABCD[2]) + + (int(k)) * int(ABCD[3]) == 7:
                print(ABCD[0]+i[0]+ABCD[1]+j[0]+ABCD[2]+k[0]+ABCD[3]+'=7')
                exit()
"
"N,M=[int(x) for x in input().split()]
A=[]
B=[]
C=[]

for i in range(M):
	a,b,c=[int(x) for x in input().split()]
	A.append(a-1)
	B.append(b-1)
	C.append(-c)
INF=10000000000000
dist=[INF for i in range(N)]

dist[0]=0


for temp in range(N-1):
	for i in range(M):
		if dist[A[i]]!=INF:
			if dist[B[i]]>dist[A[i]]+C[i]:
				dist[B[i]]=dist[A[i]]+C[i]

checker=[0 for i in range(N)]
ans=dist[N-1]

for temp in range(N):
	for i in range(M):
		if dist[A[i]]!=INF:
			if dist[B[i]]>dist[A[i]]+C[i]:
				dist[B[i]]=dist[A[i]]+C[i]
				checker[B[i]]=1
			if checker[A[i]]==1:
				checker[B[i]]=1

if checker[N-1]==1:
	print(""inf"")
else:
	print(-ans)
"
"from functools import lru_cache

(K,) = [int(x) for x in input().split()]


def solve(K):
    def getNext(x):
        if x == 0:
            return [0, 1]
        if x == 9:
            return [8, 9]
        return [x - 1, x, x + 1]

    @lru_cache(maxsize=None)
    def getNum(begin, digits):
        if digits == 0:
            assert False
            return 0
        if digits == 1:
            return 1
        ans = 0
        for x in getNext(begin):
            ans += getNum(x, digits - 1)
        return ans

    ans = []
    count = 0
    for digits in range(1, 30):
        for i in range(1, 10):
            delta = getNum(i, digits)
            if count < K <= count + delta:
                ans.append(i)
                while digits > 1:
                    for x in getNext(ans[-1]):
                        delta = getNum(x, digits - 1)
                        if count < K <= count + delta:
                            ans.append(x)
                            digits -= 1
                            break
                        count += delta
                return """".join(map(str, ans))

            count += delta


print(solve(K))
"
"n = int(input())
s = input()
ans = """"
for str in s:
  ords = ord(str)
  if ords + n > 90:
    ords -= 26
  ans += chr(ords + n)
print(ans)  "
"S = input().strip()
if S==""keyence"":
    print(""YES"")
else:
    flag = 0
    for i in range(len(S)):
        for j in range(i,len(S)):
            x = S[:i]+S[j+1:]
            if x==""keyence"":
                flag = 1
                break
        if flag==1:break
    if flag==1:
        print(""YES"")
    else:
        print(""NO"")"
"n,k=map(int,input().split())
c=list(map(int,input().split()))
a=[]
for x in range(n):
  s=c[x]
  t=(s+1)/2
  a.append(t)
  
ans=0
b=[]
b.append(a[0])

for y in range(n-1):
  c=b[y]
  d=b[y]+a[y+1]
  b.append(d)
  
dd=b[k-1]
for z in range(1,n+1-k):
  e=b[z+k-1]-b[z-1]
  
  dd=max(dd,e)

print(dd)"
"def main():
    n,m = map(int,input().split())
    if abs(n-m) > 1:
        print(0)
    else:
        from math import factorial
        mod = 10**9+7
        res = factorial(n)*factorial(m)%mod
        if n == m:
            print(2*res%mod)
        else:
            print(res)
 
if __name__ == '__main__':
    main()
"
"A, B, C = map(int,input().split())

water = A - B
answer = C - water
if answer < 0:
    print(0)
else:
    print(answer)
"
"n=int(input())
a=list(map(int,input().split()))

cnt=0
for i in range(n):
    if a[i] >= 0 and a[a[i] - 1] == i + 1:
        cnt+=1
        a[a[i] - 1] = -1
print(cnt)"
"N = int(input())
a = []
 
for x in range(1, N):
    y = N-x
    if x == y:
        continue
    if x > y:
        break
    a.append([x, y])
 
print(len(a))"
"x,y=input().split()
x=int(x)
y=int(y)
if x==2 | y==2:
    print('No')
    exit()
lt1=[1,3,5,7,8,10,12]
lt2=[4,6,9,11]
if (lt1.count(x)==1 and lt1.count(y)==1) or (lt2.count(x)==1 and lt2.count(y)==1):
    print('Yes')
else:
    print('No')"
"s = input()
n = len(s)
flag = False
 
 
def palind(S):
    size = len(S)
    for i in range(size//2):
        if S[i] != S[-1-i]:
            return False
    return True
 
 
 
if palind(s):
    m = (n-1)//2
    sb = s[:m]
    if palind(sb):
        sa = s[m+1:]
        flag = palind(sa)
 
print(""Yes"" if flag else ""No"")
"
"a=int(input())
b=int(input())
print(a*a-b)"
"r, d, x = [int(i) for i in input().split()]
for i in range(10):
    print(r * x - d)
    x = r * x - d"
"A,B,K=map(int,input().split())
ans=[]
for i in range(A,A+K):
    if A<=i<=B:
        ans.append(i)
    else:
        break
for t in range(B-K+1,B+1):
    if A<=t<=B: 
        ans.append(t)
    else:
        break
for z in sorted(set(ans)):
    print(z)"
"from collections import Counter

n = int(input())
mn = [100 for x in range(26)]
exist = [True for x in range(26)]
for _ in range(n):
    l = list(input())
    d = Counter(l)
    for i in range(26):
        if d[chr(i+97)] == 0:
            exist[i] = False

    for key, val in d.items():
        mn[ord(key)-97] = min(mn[ord(key)-97], val)
for i in range(26):
    if exist[i]:
        print(chr(i+97)*mn[i], end='')
"
"import sys
#DEBUG=True
DEBUG=False
if DEBUG:
    f=open(""202007_2nd/A_input.txt"")
else:
    f=sys.stdin
l,h,d=map(int,f.readline().split())
ans=0
for _ in range(l,h+1):
    ans=ans+1 if _%d==0 else ans
print(ans)"
"# 初期入力　　２０２０－０７２７　21：50
import math
import sys
input = sys.stdin.readline  #文字列では使わない
N = int(input())
ans ="":(""
for i in range(1,50001):
    a =int( i *1.08 )
    if a==N:
        ans =i
        break
print(ans)"
"n = int(input())
a = sum(list(map(lambda x:1-int(x)%2,input().split())))
print(3**n-2**a)
"
"import math

def main():
    a, b = map(int, input().split())
    print(math.ceil((a + b)/2))
main()"
"def p(n, k):
    if n >= k:
        return 1
    num = 0
    while n < k:
        n *= 2
        num += 1
    return 1 / 2 ** num

N, K = map(int, input().split())

ans = 0
for n in range(1, N + 1):
    ans += p(n, K)

ans /= N

print(ans)"
"S=input()
D=['SUN','MON','TUE','WED','THU','FRI','SAT']
Today=D.index(S)
print(7-Today)"
"N, Y = map(int, input().split())

for i in range(N + 1):
    for j in range(N + 1):
        if i + j > N:
            continue
        k = N - i - j
        if 10000 * i + 5000 * j + 1000 * k == Y:
            print(i, j, k)
            exit()
print(-1, -1, -1)"
"n=int(input())
s=input()
k=int(input())
s_=str()
for i in range(n):
  if s[i]!=s[k-1]:
    s_+='*'
  else:
    s_+=s[i]
print(s_)"
"n = int(input())
a = list(map(int, input().split()))

s = 0

for x in a:
    s += 1 / x

print(1/s)"
"# AtCoder Grand Contest 033
# https://atcoder.jp/contests/agc033
import sys

s2nn = lambda s: [int(c) for c in s.split(' ')]
ss2nn = lambda ss: [int(s) for s in list(ss)]
ss2nnn = lambda ss: [s2nn(s) for s in list(ss)]
i2s = lambda: sys.stdin.readline().rstrip()
i2n = lambda: int(i2s())
i2nn = lambda: s2nn(i2s())
ii2ss = lambda n: [sys.stdin.readline() for _ in range(n)]
ii2nn = lambda n: ss2nn(ii2ss(n))
ii2nnn = lambda n: ss2nnn(ii2ss(n))



def main():
    N, K = i2nn()
    print(N - K + 1)
main()
"
"a,b,c,k=map(int,input().split())
ans=0

if a>0:
    if (a<k):
        ans+=a
        k-=a
    else:
        ans=k
        print(ans)
        exit()

if b>0:
    if (b<k):
        k-=b
    else:
        print(ans)
        exit()

ans+=(-1)*k
print(ans)"
"x = int(input())
time = 0
 
for i in range(1,10**10):
  time += i
  if time >= x:
    print(i)
    exit()"
"s=input()
x=s.find('A')
s2=s[x:]
y=s.rfind('Z')
print(y-x+1)"
"N,A,B=map(int,input().split(' '))
if abs(B-A)%2==0:
    print(abs(B-A)//2)
else:
     l = min(A-1,B-1)+1+(abs(A-B)-1)//2
     r = min(N-A,N-B)+1+(abs(A-B)-1)//2
     print(min(l,r))"
"import sys
import math
import itertools
import collections
from collections import deque
 
sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
input = lambda: sys.stdin.readline().strip()
 
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()
 
def main():
    N = NI()
    h = NLI()
    
    dp = [0 for _ in range((10**5)+10)]
    dp[0] = 0
    dp[1] = abs(h[1]-h[0])
    
    for n in range(2,N):
        dp[n] = min(dp[n-2]+abs(h[n]-h[n-2]),dp[n-1]+abs(h[n]-h[n-1]))
    print(dp[N-1])
 
 
if __name__ == '__main__':
    main()"
"N, M = map(int, input().split())
A = [input() for _ in range(N)]
B = [input() for _ in range(M)]
for i in range(N-M+1):
    for j in range(N-M+1):
        flg = True
        for k in range(M):
            for l in range(M):
                flg = flg & (B[k][l] == A[i+k][j+l])
        
        if flg:
            ans = 'Yes'
            print(ans)
            exit()

ans = 'No'
print(ans)"
"import collections

S = input()

c = collections.Counter(S)
K = c.keys()

if len(K) == 4:
    print('Yes')
elif len(K) == 2:
    if 'N' in K and 'S' in K:
        print('Yes')
    elif 'W' in K and 'E' in K:
        print('Yes')
    else:
        print('No')
else:
    print('No')"
"from collections import deque


def main():
    n, m = map(int, input().split())
    adj = [[] for _ in range(n)]

    for _ in range(m):
        l, r, d = map(int, input().split())
        adj[l - 1].append((r - 1, d))
        adj[r - 1].append((l - 1, -d))

    x = [None] * n

    for i in range(n):
        if x[i] is not None:
            continue
        x[i] = 0
        q = deque()
        q.append(i)

        while q:
            u = q.popleft()
            for v, d in adj[u]:
                if x[v] is None:
                    q.append(v)
                    x[v] = x[u] + d
                elif x[v] != x[u] + d:
                    print(""No"")
                    exit()
    print(""Yes"")


if __name__ == ""__main__"":
    main()
"
"#from pprint import pprint
#from collections import deque
#from collections import defaultdict
#from collections import Counter
#from copy import deepcopy
#from itertools
#import sys 
#sys.setrecursionlimit(N) #N回まで再起を許可する。
 
# = map(int,input().split())
 
# = list(map(int,input().split()))
 
# = [list(map(int,input().split())) for _ in range(XXXX)]
from sys import stdin


def main():
    input = stdin.readline
    
    h,n = map(int,input().split())
    
    ab= [list(map(int,input().split())) for _ in range(n)]
    
    dp = [[100000001 for _ in range(h+1)] for _ in range(n+1)]
    #dp[i][j]はi番目のものを選んだ時かつダメージ送料がjだったときの最小MP、
    
    
    for i in range(1,n+1):
        dp[i][0] = 0
        for j in range(h+1):
            a = ab[i-1][0]
            b = ab[i-1][1]
            dp[i][j] = min(dp[i][j],dp[i-1][j])
            if j+a <= h:
                dp[i][j+a] = min(dp[i][j] + b, dp[i-1][j+a], dp[i][j+a])
            elif j+a > h:
                dp[i][h] = min(dp[i][j] + b, dp[i-1][h], dp[i][h])

    
    print(dp[-1][-1])

if __name__ == ""__main__"":
    main()"
"
S = input()
T = input()

N = len(S)

S = [S[i:i+1] for i in range(len(S))]
T = [T[i:i+1] for i in range(len(T))]

ans = 0

for k in range(N):
    if S[k] != T[k]:
        ans += 1

print(ans) "
"#!/usr/bin/env python3
n = int(input())
c = [0] * (n + 1)
for i in range(1, n + 1):
    for j in range(1, n // i + 1):
        c[j * i] += 1
print(sum(c[i] == 8 for i in range(1, n + 1, 2)))
"
"n, m, c = map(int, input().split())
b = list(map(int, input().split()))

ans = 0
for i in range(n):
    a = list(map(int, input().split()))
    if sum([a[i] * b[i] for i in range(m)]) + c > 0:
        ans += 1
print(ans)"
"n = int(input())
aa, bb = [i for i in input().split()]
ret = ''
for a, b in zip(aa, bb):
	ret = ret + a + b
print(ret)"
"n = int(input())
print('YES' if n in (3,5,7) else 'NO')"
"t = input()

ans = """"

for i in range(len(t)):
    if t[i] == '1':
        ans+='9'
    elif t[i] == '9':
        ans+='1'

print(ans)"
"import sys
sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline

n, m = map(int, input().split())
s = input() #sys.stdin.readlineは最後が改行
t = input() #sys.stdin.readlineは最後が改行

from fractions import gcd

gcdnm = gcd(n, m)
L = (n * m) // gcdnm

gcdd = gcd(L//n, L//m)
l = (L//n *L//m) // gcdd


if s[0]!=t[0]:
    print(-1)
    exit()

i = 1


while l//(L//n)*i < n and l//(L//m)*i <m:
    if s[l//(L//n)*i] != t[l//(L//m)*i]:
        print(-1)
        exit()
    i+=1

print(L)



"
"x = int(input())
if x % 2 == 0:
    print(x // 2)
else:
    print(x // 2 + 1)
"
"s=int(input())
if s<6:
  print(int(s>2))
  exit()
dp=[0]*(s+1)
dp[3]=1
dp[4]=1
dp[5]=1
for i in range(6,s+1):
  dp[i]=dp[i-1]+dp[i-3]
print(dp[s]%(10**9+7))"
"N = list(input())
n = [int(num) for num in N]
s = sum(n)

if s % 9 == 0:
  print(""Yes"")
else:
  print(""No"")"
"def scoring(d, t):
    last[t] = d
    return S[d][t] - sum((d - l) * c for l, c in zip(last, C))

D = int(input())
C = list(map(int, input().split()))
S = []
for _ in range(D):
    s = list(map(int, input().split()))
    S.append(s)
T = [int(input()) - 1 for _ in range(D)]
last = [-1] * 26
score = 0
for i in range(D):
    score += scoring(i, T[i])
    print(score)"
"#!/usr/bin/env python3
import sys
def input():
    return sys.stdin.readline()[:-1]

def main():
    N, M = map(int, input().split())
    A = [input() for _ in range(N)]
    B = [input() for _ in range(M)]

    for w in range(N - M + 1):
        for h in range(N - M + 1):
            count = 0
            for i in range(M):
                if B[i] == A[i + h][w: w + M]:
                    count += 1
            if count == M:
                print('Yes')
                exit()
    print('No')


if __name__ == '__main__':
    main()
"
"import math
r=float(input())
print(""{:0.6f} {:0.6f}"".format(r**2*math.pi,r*2*math.pi))"
"s = input()
print(''.join(['x' for _ in range(len(s))]))
"
"def main():
    h,w,a,b=map(int,input().split(' '))
    mod = 10**9+7
    mx=max(h,w)
    fac=[1]*(h+w+1)
    for i in range(1,h+w+1):
        fac[i]=fac[i-1]*i%mod
    rev=[1]*(mx+1)
    rev[-1]=pow(fac[mx],mod-2,mod)
    for i in range(mx-1,-1,-1):
        rev[i]=rev[i+1]*(i+1)%mod
    const=rev[h-a-1]*rev[a-1]%mod
    ans = sum(fac[h - a + i - 1] * rev[i] * fac[a + w - 2 - i] * rev[w - i - 1] % mod for i in range(b, w))
    print(ans * const % mod)



if __name__ == '__main__':
    main()
"
"import numpy as np
N = int(input())
alist = np.array(list(map(int, input().split())))
mean = sum(alist) / N
alist = np.abs(alist - mean)
print(np.argmin(alist))
"
"x, a, b = [int(i) for i in input().split()]
print(""AB""[abs(x - a) > abs(x - b)])"
"x=int(input())
m=100
y=0
while m<x:
    m=(101*m)//100
    y=y+1
print(y)"
"def main():
    S = input()

    if S == ""ABC"":
        ans = ""ARC""
    else:
        ans = ""ABC""

    print(ans)


if __name__ == ""__main__"":
    main()
"
"from collections import Counter
from itertools import combinations

N = int(input())
S = [input()[0] for _ in range(N)]
C = Counter(S)

ans = 0
for x, y, z in combinations(""MARCH"", 3):
  ans += C[x]*C[y]*C[z]

print(ans)"
"k = int(input())
ans = [i for i in range(50)]
# print(ans)
def inv_process(arr,i):
    arr[i] += 50
    for j in range(50):
        if j == i:
            continue
        else:
            arr[j]-=1
loop = k//50
sup = k-loop*50

for i in range(50):
    ans[i] += loop


for i in range(sup):
    inv_process(ans,i)

print(50)
for i in range(49):
    print(ans[i],end="" "")
print(ans[-1])"
"X = int(input())
Ans = 0
for A in range(1,1000):
    for B in range(-A,A):
        Tar = A**5 - B**5
        if Tar == X:
            Ans = [A,B]
            break
    if Ans != 0:
        break
print(*Ans)"
"# A,Restaurnat
# すぬけくんはレストランに通うのが好きです。
# すぬけくんの行きつけのレストランは何を食べても1食800円で、15食食べる毎にその場で200円もらえます。
# すぬけくんは今まで合計N食食べました。今までに払った金額をｘ円、レストランにもらった金額をｙとして、x - yを求めなさい。
# 1 <= N <= 100

# N = 食数

N = int(input())

# x:今までに支払った金額
x = 800 * N
# print(x)

# y:レストランにもらった金額
y = int((N // 15) * 200)

answer = int(x - y)
print(answer)"
"# 問題：https://atcoder.jp/contests/abc146/tasks/abc146_b

n = int(input())
s = input()

res = ''

for letter in s:
    res += chr(ord('A') + (ord(letter)-ord('A')+n) % 26)

print(res)
"
"n, k = map(int, input().split())

L = list(map(int, input().split()))

t = 0
for i in range(n):
    for j in range(i + 1, n):
        if L[i] > L[j]:
            t += 1

t = (t * k) % (10**9 + 7)

L = sorted(L)
s = 0
for i in range(n):
    for j in range(i + 1, n):
        if L[i] < L[j]:
            s += 1
k = k - 1
sum = (k * (k + 1)//2)% (10**9 + 7)
s = (s * sum) % (10**9 + 7)
print((t + s) % (10**9 + 7))"
"s = input()
q = int(input())
hanten=False
mae=""""
usiro=""""
for i in range(q):
    tmp=input()
    if len(tmp)==1:
        hanten=not(hanten)
    else:
        if hanten==False:
            if tmp[2]==""1"":
                mae=tmp[4]+mae
            else:
                usiro=usiro+tmp[4]
        else:
            if tmp[2]==""1"":
                usiro=usiro+tmp[4]
            else:
                mae=tmp[4]+mae
                
ans=mae+s+usiro
if hanten==False:
    print(ans)
else:
    print(ans[::-1])"
"a, b, c = map(int, input().split(' '))
print('YES' if c - b == b - a else 'NO')
"
"a = [1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14,
     1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51]

num = input()
num = int(num) - 1

if 0 <= num <= 31:
    print(a[num])
else:
    pass
"
"N=input()

S=N[::-1]
ans=0
for i in range(len(N)):
    if N[i]==S[i]:
        ans+=1

if ans==len(N):
    print(""Yes"")
else:
    print(""No"")
"
"class Dice:
    def __init__(self, a, b, c, d, e, f):
        # サイコロの現在一番上にある面
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f

        self.n_list = [0, self.a, self.b, self.c, self.d, self.e, self.f]

    def is_right_surface(self, top, front):
        swapped = False
        """"""
        print(f""{top=}"")
        print(f""{front=}"")
        print(f""{self.n_list.index(top)=}"")
        print(f""{self.n_list.index(front)=}"")
        """"""
        if self.n_list.index(top) > self.n_list.index(front):
            tmp = front
            front = top
            top = tmp
            swapped = True

        if self.n_list.index(top) == 1 and self.n_list.index(front) == 2:
            return self.c, self.d, swapped
        if self.n_list.index(top) == 1 and self.n_list.index(front) == 3:
            return self.e, self.b, swapped
        if self.n_list.index(top) == 1 and self.n_list.index(front) == 4:
            return self.b, self.e, swapped
        if self.n_list.index(top) == 1 and self.n_list.index(front) == 5:
            return self.d, self.c, swapped
        if self.n_list.index(top) == 2 and self.n_list.index(front) == 3:
            return self.a, self.f, swapped
        if self.n_list.index(top) == 2 and self.n_list.index(front) == 4:
            return self.f, self.a, swapped
        if self.n_list.index(top) == 2 and self.n_list.index(front) == 6:
            return self.c, self.d, swapped
        if self.n_list.index(top) == 3 and self.n_list.index(front) == 5:
            return self.a, self.f, swapped
        if self.n_list.index(top) == 3 and self.n_list.index(front) == 6:
            return self.e, self.b, swapped
        if self.n_list.index(top) == 4 and self.n_list.index(front) == 5:
            return self.f, self.a, swapped
        if self.n_list.index(top) == 4 and self.n_list.index(front) == 6:
            return self.b, self.e, swapped
        if self.n_list.index(top) == 5 and self.n_list.index(front) == 6:
            return self.d, self.c, swapped

    def move(self, move_str):
        for i in move_str:
            if i == ""N"":
                self.move_N()
            elif i == ""E"":
                self.move_E()
            elif i == ""W"":
                self.move_W()
            elif i == ""S"":
                self.move_S()

    def move_N(self):
        tmp1 = self.a
        tmp2 = self.e
        self.a = self.b
        self.b = self.f
        self.e = tmp1
        self.f = tmp2

    def move_E(self):
        tmp1 = self.a
        tmp2 = self.c
        self.a = self.d
        self.c = tmp1
        self.d = self.f
        self.f = tmp2

    def move_W(self):
        tmp1 = self.a
        tmp2 = self.d
        self.a = self.c
        self.c = self.f
        self.d = tmp1
        self.f = tmp2

    def move_S(self):
        tmp1 = self.a
        tmp2 = self.b
        self.a = self.e
        self.b = tmp1
        self.e = self.f
        self.f = tmp2


a, b, c, d, e, f = map(int, input().split())
dice = Dice(a, b, c, d, e, f)

n = int(input())
for i in range(n):
    x, y = map(int, input().split())
    right, left, is_swap = dice.is_right_surface(x, y)
    if is_swap:
        print(left)
    else:
        print(right)


"
"string = input()
if(string == 'ABC'):
  print('ARC')
else:
  print('ABC')
"
"from operator import mul
from functools import reduce


def combinations_count(n, r, P):
    r = min(r, n - r)
    inv_y = 1
    for i in range(1, r + 1):
        inv_y = (inv_y * i) % P
    inv_y = pow(inv_y, P - 2, P)
    x = 1
    for i in range(n - r + 1, n + 1):
        x = x * i % P
    return (x * inv_y) % P



n, a, b = map(int, input().split())
P = int(1e9+7)
ans = pow(2, n, P) - 1  # 1本以上の花束の種類


ans = (ans - combinations_count(n, a, P))
ans = (ans - combinations_count(n, b, P))
print(ans%P)
"
"A,op,B=(str(x) for x in input().split())
if op==""+"":
    print(int(A)+int(B))
elif op==""-"":
    print(int(A)-int(B))"
"def ii():return int(input())
def iim():return map(int,input().split())
def iil():return list(map(int,input().split()))

n = ii()
l = iil()
count = 0
for i in l:
    if i%2 == 1:
        count += 1
if count%2 == 0:
    print('YES')
else:
    print('NO')"
"n = int(input())
s_p = [ list(map(str, input().split())) for i in range(n)  ]

d = {}
for i, v in enumerate(s_p):
    s = v[0]
    p = v[1]
    if s not in d.keys():
        d[s] = [(i, p)]
    else:
        d[s] = sorted(d[s] + [(i,p)], key=lambda x: int(x[1]), reverse=True)

for key in sorted(d.keys()):
    for i,j in d[key]:
        print(i+1)"
"n = int(input())
ans = 0
for i in range(1, int(n ** 0.5) + 1):
    if n % i == 0:
        k = (n // i) - 1
        if k > i:
            ans += k
print(ans)"
"def main():
    N = int(input())
    A = list(map(int, input().split()))
    n_odd = 0
    n_4mul = 0
    n_2mul = 0
    for a in A:
        if a % 2 == 1:
            n_odd += 1
        elif a % 4 == 0:
            n_4mul += 1
        else:
            n_2mul += 1
    if n_odd == 0:
        print('Yes')
    elif n_odd <= n_4mul and n_2mul > 0:
        print('Yes')
    elif n_odd == n_4mul + 1 and n_2mul == 0:
        print('Yes')
    else:
        print('No')


if __name__ == '__main__':
    main()
"
"#!/usr/bin/env python3
import sys
sys.setrecursionlimit(200002)

n, m = list(map(int, input().split()))

graph = [[] for i in range(n)]
for i in range(m):
    l, r, d = list(map(int, input().split()))

    graph[l-1].append([r-1, d])
    graph[r-1].append([l-1, -d])
# print(graph)


def dfs(s):
    for t, d in graph[s]:
        if x[t] is None:
            x[t] = x[s]+d
            if not dfs(t):
                return False
        else:
            if x[t]-x[s] != d:
                return False
    return True


x = [None]*n
ans = True
for i in range(n):
    if x[i] is None:
        x[i] = 0
        if not dfs(i):
            ans = False

print(('No', 'Yes')[ans])
"
"line = input()
num_a, num_b = [int(n) for n in line.split()]
is_it_possible = ""Yay!""
if num_a > 8 or num_b > 8:
    is_it_possible = "":(""
print(is_it_possible)"
"s=list(input())
n=len(s)
a=s.count('1')
b=n-a
c=abs(a-b)
print(n-c)
"
"#2019/10/10
N = int(open(0).read())
i = 0
while(N*i <= 10**9):
    i+=1
    #print(i)
    if (N*i)%2 == 0:
        print(N*i)
        break"
"n = int(input())
A = list(map(int, input().split()))

t = 0
for a in A:
    t ^= a
ans = []
for a in A:
    ans += [t ^ a]
    
print(*ans, sep="" "")
"
"#!/usr/bin/env python3
import sys

YES = ""Yes""  # type: str
NO = ""No""  # type: str


def solve(a: int, b: int):
    c = int(str(a) + str(b))
    for i in range(400):
        if c == i*i:
            print(YES)
            break
    else:
        print(NO)
    return


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    a = int(next(tokens))  # type: int
    b = int(next(tokens))  # type: int
    solve(a, b)

if __name__ == '__main__':
    main()
"
"s = sorted(list(input()))
t = sorted(list(input()), reverse=True)
if s == t:
  print('No')
else:
  c = sorted([s, t])
  if c[0] == s:
    print('Yes')
  else:
    print('No')"
"from collections import Counter
n = int(input())
x = []
for i in range(n):
    s = input()
    t = Counter(s)
    x.append(t)
ans = """"
for i in ""abcdefghijklmnopqrstuvwxyz"":
    tmp = []
    for j in x:
        tmp.append(j[i])
    ans += i*min(tmp)
print(ans)"
"from collections import Counter
n = int(input())
d = list(map(int, input().split()))
mod = 998244353
if d[0] != 0:
    print(0)
else:
    a = Counter(d)
    ans = 1
    if a[0] > 1:
        print(0)
    else:
        for i in range(1, max(d)+1):
            ans *= a[i-1]**a[i]
            ans %= mod
        print(ans)
    
"
"N = int(input())
d = [
    ""pon"",
    ""pon"",
    ""hon"",
    ""bon"",
    ""hon"",
    ""hon"",
    ""pon"",
    ""hon"",
    ""pon"",
    ""hon""
]
print(d[N%10])
"
"N = int(input())
a = int(input())

q, r = divmod(N, 500)

if r <= a:
    print('Yes')
else:
    print('No')"
"def main():
    print(['Yes', 'No'][int(input()) < 30])


if __name__ == '__main__':
    main()
"
"import sys
pin=sys.stdin.readline

S=pin()[:-1]
Q=int(pin())
now=1
ans1=""""
ans2=""""
for i in range(Q):
  D=pin().split()
  T=0
  F=0
  C=""""
  if len(D)==1:
    T=int(D[0])
  else:
    T=int(D[0])
    F=int(D[1])
    C=D[2]
  if T==1:
    now*=-1
  else:
    if F==1:
      if now==1:
        ans1=C+ans1
      else:
        ans2=ans2+C
    else:
      if now==1:
        ans2=ans2+C
      else:
        ans1=C+ans1
if now==1:
  print(ans1+S+ans2)
else:
  print(ans2[::-1]+S[::-1]+ans1[::-1])

"
"A,B,C,X,Y = map(int,input().split())

#全部Cで買うとき
a = 2*C*min(X,Y) + 2*C*(max(X,Y)-min(X,Y))

#片方を全部Cで買うとき
if X > Y:
    b = 2*C*Y + (X-Y)*A
elif Y > X:
    b = 2*C*X + (Y-X)*B
else:
    b = a
    
#全部AとBで買うとき
c = A*X + B*Y

print(min(a,b,c)) "
"a,b,c=sorted(list(map(int, input().split())))
print(""Yes"" if (a==b and b!=c) or (a!=b and b==c) else ""No"")"
"n=int(input())
memo=[0]*110
memo[1]=1
for i in range(2,105):
    memo[i]=memo[i-1]+i
print(memo[n])"
"n = int(input())
a = input().split()
print("" "".join(a[::-1]))"
"a = input()

b = a.upper()

if a == b:
  print(""A"")
  
if a != b:
  print(""a"")"
"if __name__ == '__main__':
    x = int(input())
    if x == 1:
        print(0)
    else:
        print(1)

"
"A, B = map(int, input().split())
hours = [i for i in range(24)]
res = hours[(A+B)%24]
print(res)"
"a,b,c = list(map(int,input().split()))

if a>c or a+b<c:
    print(""NO"")
else:
    print(""YES"")"
"a = []
count = 0
while True:
    a.append(int(input()))
    if a[count] == 0:
        break
    count += 1
for i in range(count):
    print('Case %d'%(i+1)+': %d'%a[i])
"
"import copy

N = input()
S = list(map(int, input()[:]))
left = [False for i in range(10)]
right = [0 for i in range(10)]

for n in S[1:]:
    right[n] += 1
left[S[0]] = True
flag = [[[False for i in range(10)] for j in range(10)] for k in range(10)]
for n in S[1:-1]:
    right[n] -= 1
    for i, l in enumerate(left):
        if l:
            for j, r in enumerate(right):
                if r > 0:
                    flag[n][i][j] = True
    left[n] = True
count = 0
for i in flag:
    for j in i:
        for k in j:
            if k:
                count += 1
print(count)
"
"def mi(): return map(int,input().split())
def lmi(): return list(map(int,input().split()))
def ii(): return int(input())
def isp(): return input().split()
from collections import deque
n,m=mi()
adjacent_list=[[] for i in range(n+1)]
for i in range(m):
  a,b=mi()
  adjacent_list[a].append(b)
  adjacent_list[b].append(a)
#print(adjacent_list)

dp=[0]*(n+1)

que=deque()
que.append(1)
while que:
  p=que.popleft()
  for i in adjacent_list[p]:
    if dp[i]==0:
      dp[i]=p
      que.append(i)
      
print('Yes')
for i in range(2,n+1):
  print(dp[i])"
"s = input()
n = len(s)
ans = float(""Inf"")
for i in range(n):
    x = s[i]
    t = list(s)
    c = 0
    for j in range(n-1):
        if t.count(x) == len(t):
            break
        for k in range(len(t)-1):
            if t[k+1] == x:
                t[k] = x
        c += 1
        t = t[:len(t)-1]
    ans = min(ans, c)
print(ans)"
"n = int(raw_input())
T = set(map(int, raw_input().split()))
n = int(raw_input())
S = set(map(int, raw_input().split()))
print len(T&S)"
"a,v = list(map(int,input().split()))
b,w = list(map(int,input().split()))
t = int(input())

if w >= v:
    print('NO')
elif abs(a-b)/(v-w) <= t:
    print('YES')
else:
    print('NO')
"
"n=int(input())
y=[]
t=[]
l=[]
for i in range(n):
    x,u=input().split()
    y.append(float(x))
    t.append(u)
for i in range(n):
    if t[i]=='JPY':
        l.append(y[i])
    else:
        l.append(y[i]*380000.0)
print(sum(l))"
"n,m,x = map(int,input().split())
ca = [list(map(int,input().split())) for _ in range(n)]

sum = 0
for i in range(n):
    sum += ca[i][0]
ans = sum + 1

for i in range(2**n) :
    cnt = 0
    a = [0]*m
    for j in range(n) :
        if ((i>>j)&1) :
            for k in range(m) :
                a[k] += ca[j][k+1]
            cnt += ca[j][0]
    if cnt > 0 and min(a) >= x :
        ans = min(cnt,ans)

if ans == sum + 1 :
    print(-1)
else :
    print(ans)
"
"S = input()
n = len(S)
p = 10**9+7
DP = [[0]*13 for i in range(n+1)]
DP[0][0] = 1
for i in range(1, n+1):
    for j in range(13):
        if S[i-1] == '?':
            DP[i][j] = sum([DP[i-1][(4*(j-k)) % 13] for k in range(10)]) % p
        else:
            k = int(S[i-1])
            DP[i][j] = DP[i-1][(4*(j-k)) % 13]
print(DP[n][5])
"
"n=int(input())
m=-1
for i in range(2,10**5):
  if n==i*(i-1)//2:
    m=i
    break
if m==-1:print(""No"");exit()
print(""Yes"")
ans=[[]for _ in range(m)]
for i in range(m-1):
  if i==0:x=1
  else:x=ans[0][i]
  for j in range(m-1):
    ans[i].append(x)
    if i<=j:x+=j+1
    else:x+=1
x=1
for j in range(m-1):
  ans[-1].append(x)
  x+=j+2
print(m)
for i in ans:
  print(m-1,end="" "")
  print(*i)"
"N = int(input())

con = True
for h in range(1,3500):
    for n in range(h,3500):
        memo1 = N*h*n
        memo2 = 4*h*n-N*n-N*h
        if memo2 != 0:
            memo3 = memo1/memo2
            memo4 = memo1%memo2
            if (memo4==0) and (memo3>=1):
                print(h,n,int(memo3))
                con = False
                break
    if not(con):
        break
"
"a,b = map(int,input().split())
print(1+(b-2)//(a-1))"
"n = int(input())
a = list(map(int, input().split()))
 
xs = [0] * (max(a) + 1)
 
for v in a:
    if xs[v] == 0:
        for j in range(v, len(xs), v):
            xs[j] += 1
    else:
        xs[v] += 1
print(len(list(filter(lambda v: xs[v] == 1, a))))"
"h, w = map(int, input().split())
n = int(input())
a = list(map(int, input().split()))
col = []
for i in range(n):
    for j in range(a[i]):
        col.append(i+1)
cnt = 0
for i in range(h):
    p = col[cnt: cnt+w]
    if i%2 == 0:
        print(*p)
    else:
        p = p[::-1]
        print(*p)
    cnt += w"
"A, B = map(str, input().split())
l = list(range(int(A), int(B)+1))
c = 0
for i in l:
  t = str(i)
  if t[0] == t[4] and t[1] == t[3]:
    c += 1
print(c)"
"N, K = map(int, input().split())
p = list(map(int, input().split()))
prospect = []
for k in range(N):
  if p[k]%2 == 1:
    prospect.append((p[k]+1)>>1)
  else:
    prospect.append((p[k]+1)/2)
S = sum(prospect[:K])
ans = 0 + S
for k in range(N-K):
  S += prospect[k+K] - prospect[k]
  ans = max(ans, S)
print(ans) "
"import sys
stdin = sys.stdin
sys.setrecursionlimit(10**6)
ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
nn = lambda: list(stdin.readline().split())
ns = lambda: stdin.readline().rstrip()

n,m = na()
s = list(ns())
s = s[::-1] #n+1

ans = []
i = 0
while True:
    j = i+m if i+m < n else n
    for k in reversed(range(i+1,j+1)):
        if s[k] == '0':
            ans.append(k-i)
            i = k
            break
    else:
        print(-1)
        exit()
    if i == n:
        break

print(*ans[::-1],sep=' ')"
"s = input()
if len(set(s)) - len(s) == 0:
    print('yes')
else:
    print('no')"
"import sys
import itertools
# import numpy as np
import time
import math
import heapq
from collections import defaultdict
from collections import Counter
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())

N = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
sa = sum(A)
sb = sum(B)

if sb > sa:
    print(-1)
    exit()

has_margin = []
need_point = []
for a, b in zip(A, B):
    if a == b:
        continue

    if a < b:
        need_point.append(b - a)
    else:
        has_margin.append((a - b, False))

has_margin = sorted(has_margin)
ans = len(need_point)
for x in need_point:
    while x > 0:
        y = has_margin[-1][0]
        if y >= x:
            has_margin[-1] = (y - x, True)
            x = 0
        else:
            has_margin.pop()
            x -= y
            ans += 1
if has_margin[-1][1]:
    ans += 1
print(ans)

"
"a,b=map(int,input().split())
A=[int(x) for x in input().split()]
A.sort()
if a>=b:
  print(sum(A[:(a-b)]))
else:
  print(0)"
"# -*- coding: utf-8 -*-
""""""
Created on Tue Feb 03 11:58:46 2015

@author: hirose
""""""

n = map(int, raw_input().split())

a = n[0]
b = n[1]

#print a/b, a%b, float(a)/b
print '%d %d %f' %(a/b, a%b, float(a)/b)"
"n, m, d = map(long, raw_input().split())
c = n if d == 0 else 2 * (n -d)
print float(c)*(m-1)/n**2

"
"a,p=map(int,input().split())
b=3*a+p
if b%2==0:
  print(b//2)
else:
  print((b-1)//2)
"
"K = int(input())
S = input()
L = len(S)
MOD = 10**9+7

MAXN = K+L+5
fac = [1,1] + [0]*MAXN
finv = [1,1] + [0]*MAXN
inv = [0,1] + [0]*MAXN
for i in range(2,MAXN+2):
    fac[i] = fac[i-1] * i % MOD
    inv[i] = -inv[MOD%i] * (MOD // i) % MOD
    finv[i] = finv[i-1] * inv[i] % MOD

def comb(n,r):
    if n < r: return 0
    if n < 0 or r < 0: return 0
    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD

ans = 0
for i in range(K+1):
    ans += comb(L-1+i,i) * pow(25,i,MOD) * pow(26,K-i,MOD)
    ans %= MOD
print(ans)"
"# -*- coding: utf-8 -*-


def converter(a, b):
    if a == 0:
        return b
    else:
        return converter(b % a, a)


def main():
    a, b = sorted([int(x) for x in raw_input().strip().split(' ')])
    print converter(a, b) 


if __name__ == '__main__':
    main()"
"N = input()
S = [raw_input() for _ in range(2)]

T = [[[0]*3 for i in range(3)] for j in range(N)]

for i in range(3):
  for j in range(3):
    if S[0][0]==S[1][0] and i==j or S[0][0]!=S[1][0] and i!=j:
      T[0][i][j] += 1

for i in range(1, N):
  for p0 in range(3):
    for p1 in range(3):
      for c0 in range(3):
        for c1 in range(3):
          if ((S[0][i-1]==S[0][i] and p0==c0 or S[0][i-1]!=S[0][i] and p0!=c0) and
              (S[1][i-1]==S[1][i] and p1==c1 or S[1][i-1]!=S[1][i] and p1!=c1) and
              (S[0][i]==S[1][i] and c0==c1 or S[0][i]!=S[1][i] and c0!=c1)):
            T[i][c0][c1] += T[i-1][p0][p1]
            T[i][c0][c1] %= 1000000007
ans = 0
for i in range(3):
  for j in range(3):
    ans += T[-1][i][j]
    ans %= 1000000007
print ans
"
"word = input()*2
p = input()
if p in word:
    print('Yes')
else:
    print('No')"
"s = input()

for i in range(len(s)):
    if i % 2 == 0:
        if s[i] != ""h"":
            print(""No"")
            exit()
    else:
        if s[i] != ""i"":
            print(""No"")
            exit()
    if i == len(s) - 1:
        if i % 2 == 1:
            print(""Yes"")
        else:
            print(""No"")"
"import copy
N = int(input())
X = list(map(int, input().split()))
tmp_X = copy.deepcopy(X)
tmp_X.sort()
m1 = tmp_X[N // 2]
m2 = tmp_X[N // 2 - 1]
for x in X:
    if x < m1:
        print(m1)
    else:
        print(m2)"
"
def main():
    N,P = map(int,input().split())
    s = list(input())[::-1]
    ary_mod = [0] * P
    ary_mod[0] = 1
    now = 0
    digit = 1
    ans = 0
    if P == 2:
        for i, ss in enumerate(s):
            if int(ss) % 2 == 0:
                ans += N-i
        print(ans)
        return
    if P == 5:
        for i, ss in enumerate(s):
            if int(ss) % 5 == 0:
                ans += N-i
        print(ans)
        return

    for i, ss in enumerate(s):
        now += int(ss) * digit % P
        digit *= 10
        digit %= P
        remind = now % P
        ary_mod[remind] += 1
    ans = 0
    for i, n in enumerate(ary_mod):
        ans += (n*(n-1)) // 2
    print(ans)
if __name__=='__main__':
    main()
"
"n = int(input())
a = list(map(int,input().split()))
cnt = 0
for i in a:
    if(i % 2 != 0):
        cnt = cnt + 1
if (cnt % 2 == 0): print(""YES"")
else: print(""NO"")"
"n,m=map(int,input().split())
al=[]
bl=[]
for i in range(m):
  a,b=map(int,input().split())
  al.append(a)
  bl.append(b)

for i in range(1,n+1):
  print(al.count(i)+bl.count(i))
"
"N = int(input())

nodes = [tuple(map(int, input().split(' '))) for _ in range(N)]
d = [-1 for _ in range(N + 1)]
f = [-1 for _ in range(N + 1)]

clock = 0


def dfs(node):
    global clock
    if d[node] == -1:
        clock += 1
        d[node] = clock
    neighbors = sorted(nodes[node - 1][2:])

    for neighbor in neighbors:
        if d[neighbor] == -1:
            dfs(neighbor)

    if f[node] == -1:
        clock += 1
        f[node] = clock


for i in range(1, N + 1):
    dfs(i)
    print(i, d[i], f[i])

"
"x,n=map(int,input().split())
s=list(map(int,input().split()))
for i in range(101):
    if x-i not in s:
        print(x-i)
        break
    elif x+i not in s:
        print(x+i)
        break      "
"def solve():
    MOD = 10**9 + 7

    N = int(input())
    As = list(map(int, input().split()))

    ans = 0
    for d in range(60):
        nums = [0, 0]
        for A in As:
            b = (A>>d) & 1
            nums[b] += 1
        v = nums[0]*nums[1]
        v *= pow(2, d, MOD)
        ans += v
        ans %= MOD

    print(ans)


solve()
"
"n = int(input())
a = list(map(int, input().split()))
INF = 10 ** 20

dp = [{} for i in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for j in range(max((i + 1) // 2 - 4, 0), (i + 1) // 2 + 3):
        dp[i + 1][j + 1] = -INF
        if j in dp[max(0, i - 1)]:
            dp[i + 1][j + 1] = max(dp[max(0, i - 1)][j] + a[i], dp[i + 1][j + 1])
        if j in dp[max(0, i - 2)]:
            dp[i + 1][j + 1] = max(dp[max(0, i - 2)][j] + a[i], dp[i + 1][j + 1])
        if j in dp[max(0, i - 3)]:
            dp[i + 1][j + 1] = max(dp[max(0, i - 3)][j] + a[i], dp[i + 1][j + 1])
            
ans = -INF
for i in range(n + 1):
    if n // 2 in dp[i]:
        ans = max(ans, dp[i][n // 2])
print(ans)"
"a, b = map(int, input().split())
ans = []
for i in range(50):
    ans.append([""."" for i in range(100)])
for i in range(50):
    ans.append([""#"" for i in range(100)])

for i in range((a - 1) // 50):
    for j in range(50):
        ans[51 + i * 2][2 * j] = "".""
for i in range((a - 1) % 50):
    ans[99][2 * i] = "".""
for i in range((b - 1) // 50):
    for j in range(50):
        ans[i * 2][2 * j] = ""#""
for i in range((b - 1) % 50):
    ans[48][2 * i] = ""#""

print(100, 100)
for i in range(100):
    print("""".join(ans[i]))"
"import sys
for i in sys.stdin.readlines(): 
    nums = list(map(int,i.split()))
    h = nums[0]
    w = nums[1]
    if h == 0 and w == 0:
        break
    for j in range(1,h+1):
        if j == 1 or j == h:
            print(""#""* w)
        else:
            print(""#"" + "".""*(w-2) + ""#"")
    print("""")"
"def main():
    n = int(input())
    a_lst = list(map(int, input().split()))
    count = 0

    for i in range(n):
        a = a_lst[i]

        while a % 2 == 0:
            count += 1
            a //= 2

    print(count)


if __name__ == '__main__':
    main()"
"S = input()

ans = S[0:4] == ""YAKI""

print(""Yes"" if ans else ""No"")
"
"s=input()
n=len(s)

count0=0
for i in range(n):
    if s[i]=='0':
        count0+=1

count1=n-count0

if count0<=count1:
    ans=count0*2
else:
    ans=count1*2

print(ans)"
"X =int(input())
def jug(n):
    if n>0:
        return 1
    else:
        return -1

ALL = [i**5 for i in range(-200,200+1)]
for a in ALL:
    for b in ALL:
        if a-b ==X:
            ans =[jug(a)*int(abs(a)**(1.0/5)),jug(b)*int(abs(b)**(0.2))]
            print(ans[0],ans[1])
            exit()"
"h,w = map(int,input().split())

s = [list('.'*(w+2))]
for _ in range(h):
    s.append(list('.'+input()+'.'))
s.append(list('.'*(w+2)))

for i in range(h):
    for j in range(w):
        if s[i+1][j+1] == '#':
            if s[i+2][j+1] == '.' and s[i][j+1] == '.' and s[i+1][j+2] == '.' and s[i+1][j] == '.':
                print('No')
                exit()
print('Yes')"
"n,k = map(int,input().split())
p = [0]*n
a = []
ans = 0
for i in range (k):
  a = []
  d = input()
  a = list(map(int,input().split()))
  for j in a:
    p[j-1] +=1
  
for i in p:
  if i == 0:
    ans +=1
print(ans)"
"from sys import stdin
import sys
import math
from functools import reduce
import functools
import itertools
from collections import deque,Counter,defaultdict
from operator import mul
import copy
# ! /usr/bin/env python
# -*- coding: utf-8 -*-
import heapq
sys.setrecursionlimit(10**6)
# INF =  float(""inf"")
INF = 10**18
import bisect
import statistics
mod = 10**9+7
# mod = 998244353

L, R = map(int, input().split())

if R-L >=2018:
    print(0)
else:
    ans = ((L%2019)*(R%2019))%2019
    for i in range(L,R+1):
        for j in range(i+1,R+1):
            ans = min(ans, ((i%2019)*(j%2019))%2019)
    print(ans)
"
"s = [i for i in input()]
t = str(len(s)-2)
print(s[0]+t+s[-1])"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-

num=int(input())
quo=num//15

x=800*num
y=200*quo

print(x-y)
"
"n=int(input())
k=int(input())
x=int(input())
y=int(input())
if n>=k:
    a=k*x
    a+=(n-k)*y
else:
    a=n*x
print(a)"
"n=int(input())
v=list(map(int,input().split()))
temp1=[]
temp2=[]
for i in range(0,n):
  if i%2==0:
    temp1.append(v[i])
  else:
    temp2.append(v[i])
count=0
from collections import Counter
c1=Counter(temp1)
values1,counts1=zip(*c1.most_common())
counts1=list(counts1)
mode1=counts1[0]
if len(counts1)>1:
  mode1s=counts1[1]
c2=Counter(temp2)
values2,counts2=zip(*c2.most_common())
counts2=list(counts2)
mode2=counts2[0]
if len(counts2)>1:
  mode2s=counts2[1]
if len(counts1)==1 and len(counts2)==1 and c1.most_common()[0][0]==c2.most_common()[0][0]:
  count=min(mode1,mode2)
elif c1.most_common()[0][0]==c2.most_common()[0][0]:
  if len(temp1)-mode1s>=len(temp2)-mode2s:
    count=len(temp1)-mode1+len(temp2)-mode2s
  else:
    count=len(temp2)-mode2+len(temp1)-mode1s
else:
  count=len(temp1)-mode1+len(temp2)-mode2
print(count)"
"n, m = map(int, input().split())
a = list(map(int, input().split()))
memo = [0]
d = {0: 1}
for ai in a:
  memo.append((memo[-1] + ai) % m)
  mi = memo[-1]
  if mi in d:
    d[mi] += 1
  else:
    d[mi] = 1
ans = 0
for k in d:
  c = d[k]
  ans += c * (c-1) // 2
print(ans)
  
"
"import sys
from collections import deque

input = sys.stdin.readline


def main():
    N = int(input())
    G = [[] for _ in range(N)]
    for _ in range(N - 1):
        a, b = map(int, input().split())
        a -= 1
        b -= 1
        G[a].append(b)
        G[b].append(a)
    C = list(map(int, input().split()))
    C.sort(reverse=True)

    M = sum(C[1:])
    d = [0] * N
    i = 0
    queue = deque([(i, -1)])
    while queue:
        u, p = queue.popleft()
        d[u] = C[i]
        i += 1
        for v in G[u]:
            if v == p: continue
            queue.append((v, u))

    print(M)
    print("" "".join(map(str, d)))


if __name__ == ""__main__"":
    main()
"
"import sys

input = lambda :sys.stdin.readline().rstrip()

def main():
    n, m, Q = map(int, input().split())
    Train= [[0 for _ in range(n)] for _ in range(n)]
    
    for i in range(m):
        l, r = map(int, input().split())
        l, r = l - 1, r - 1
        Train[l][r] += 1
    
    P_Train = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(n):
            P_Train[i + 1][j + 1] = P_Train[i][j + 1] + P_Train[i + 1][j] + Train[i][j] - P_Train[i][j]
    
    #print(*P_Train, sep = '\n')

    for i in range(Q):
        p, q = map(int, input().split())
        p, q = p - 1, q - 1
        ans = solve(P_Train, p, q)
        print(ans)

def solve(P_Train, p, q):
    ans = 0
    ans = P_Train[q + 1][q + 1] -P_Train[p][q + 1] - P_Train[q + 1][p] + P_Train[p][p]
    return ans


if __name__ == '__main__':
    main()"
"s = input()
n = len(s)

def f(s):
    return s == s[::-1]

if f(s) and f(s[:(n-1)//2]) and f(s[(n+3)//2-1:]):
    print(""Yes"")
else:
    print(""No"")"
"import sys
sys.setrecursionlimit(3000)
N, K = map(int,input().split())
def comb(n,k):
    if n == 0:
        return 1
    if n < 0:
        return 0
    if k < 0:
        return 0
    if k == 0:
        return 1
    return comb(n-1,k-1) * n // k
R = N-K
MOD = 10**9+7
A = K-1
B = R-1
if N == K:
    print(1)
    for i in range(2, K+1):
        print(0)
else:
    for i in range(1, K+1):
        x = comb(A, i-1)
        y = comb(B, i-2)
        z = comb(B, i-1)
        w = comb(B, i)
        ans = x*(y+2*z+w)
        print(ans % MOD)"
"# input()
# int(input())
# map(int, input().split())
# list(map(int, input().split()))
# list(map(int, list(input()))) # スペースがない数字リストを読み込み
import math
import fractions
import sys
import bisect
import heapq  # 優先度付きキュー(最小値取り出し)
import collections
from collections import Counter
from collections import deque
import pprint
import itertools

sr = lambda: input()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

""""""nを素因数分解""""""
""""""2以上の整数n => [[素因数, 指数], ...]の2次元リスト""""""


def factorization(n):
    arr = []
    temp = n
    if n == 1:
        return arr

    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):
        if temp % i == 0:
            cnt = 0
            while temp % i == 0:
                cnt += 1
                temp //= i
            arr.append([i, cnt])

    if temp != 1:
        arr.append([temp, 1])

    if arr == []:
        arr.append([n, 1])

    return arr


# a^n
def power(a, n, mod):
    x = 1
    while n:
        if n & 1:
            x *= a % mod
        n >>= 1
        a *= a % mod
    return x % mod


# n*(n-1)*...*(l+1)*l
def kaijo(n, l, mod):
    if n == 0:
        return 1
    a = n
    tmp = n - 1
    while (tmp >= l):
        a = a * tmp % mod
        tmp -= 1
    return a

# Union Find
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

# 約数生成
def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)

    divisors.sort()
    return divisors


inf = 10 ** 18
mod = 10 ** 9 + 7

n,m,q = lr()
abcd = [lr() for i in range(q)]
def getAns(s, num, l):
    if l == n:
        ret = 0
        for a,b,c,d in abcd:
            a-=1
            b-=1
            if s[b]-s[a] == c:
                ret+=d
        return ret
    else:
        ret = 0
        for i in range(num, m+1):
            tmp = s.copy()
            tmp.append(i)
            ret = max(ret, getAns(tmp, i, l+1))
        return ret
print(getAns([], 1, 0))"
a=[int(input()) for _ in range(5)];k=int(input());print(':(' if max(a)-min(a)>k else 'Yay!')
"x=[1,2,3,4,5,6,7,8,9]
for i in x:
    for j in x:
        print u""%dx%d=%d""%(i,j,i*j)"
"from collections import deque
n = int(input())
s = input()
A = deque([])
l = 0
r = 0
for i in range(n):
  if s[i]=='(':
    A.append(s[i])
    l += 1
  else:
    if l!=0:
      A.append(s[i])
      l -=1
    else:
      A.appendleft(""("")
      A.append(s[i])

for j in range(l):
  A.append("")"")
  
print("""".join(A))"
"N = int(input())
A = list(map(int, input().split()))

k = len(set(A))
print(k - (k + 1) % 2)
"
"N=int(input())
A=list(map(int,input().split()))
ans=0
mins=10**10
ct=0
for i in A:
 ans+=abs(i)
 mins=min(mins,abs(i))
 if i<0:
  ct+=1
if ct%2==1:
 ans-=2*mins
print(ans)"
"import sys
input=sys.stdin.readline
sys.setrecursionlimit(10 ** 6)
from collections import defaultdict
#d = defaultdict(int)
import fractions
import math
from collections import deque
from bisect import bisect_left
from bisect import insort_left
#N = int(input())
#A = list(map(int,input().split()))
#S = list(input())
#S.remove(""\n"")
#N,M = map(int,input().split())
#S,T = map(str,input().split())
#A = [int(input()) for _ in range(N)]
#S = [input() for _ in range(N)]
#A = [list(map(int,input().split())) for _ in range(N)]
import itertools
from heapq import heapify
from heapq import heappop
from heapq import heappush
import numpy as np
X,Y,A,B,C = map(int,input().split())
p = list(map(int,input().split()))
q = list(map(int,input().split()))
r = list(map(int,input().split()))
p.sort(reverse=True)
q.sort(reverse=True)
s = p[:X]+q[:Y]+r
n = len(s)
for i in range(n):
    s[i] *= -1
heapify(s)
ans = 0
for i in range(X+Y):
    ans -= heappop(s)
print(ans)"
"def main():
    A = list(map(int,input().split()))
    A.sort(reverse=True)
    if A[0] == A[1] + A[2]:
        print('Yes')
    else:
        print('No')


if __name__ == '__main__':
    main()"
"n, m, d = map(int, input().split())
if d == 0:
  print((m - 1) / n)
else:
  print(2 * (n - d) * (m - 1) / (n * n))"
"H1, M1, H2, M2, K = map(int,input().split())
import math

time1=H1*60+M1
time2=H2*60+M2
a=time2-K
if a<=0:
    print(0)
    exit()

if time1<=a:
    print(a-time1)
else:
    print(0)"
"import bisect
A,B,Q=map(int,input().split())
INF=10**12
S=[-INF]
for i in range(A):
  S.append(int(input()))
S.append(INF)
T=[-INF]
for i in range(B):
  T.append(int(input()))
T.append(INF)
for i in range(Q):
  x=int(input())
  sh=S[bisect.bisect_left(S,x)]
  sl=S[bisect.bisect_left(S,x)-1]
  th=T[bisect.bisect_left(T,x)]
  tl=T[bisect.bisect_left(T,x)-1]
  a1=abs(x-sh)+abs(sh-th)
  a2=abs(x-sl)+abs(sl-th)
  a3=abs(x-sh)+abs(sh-tl)
  a4=abs(x-sl)+abs(sl-tl)
  a5=abs(x-th)+abs(th-sh)
  a6=abs(x-tl)+abs(tl-sh)
  a7=abs(x-th)+abs(th-sl)
  a8=abs(x-tl)+abs(tl-sl)
  print(min(a1,a2,a3,a4,a5,a6,a7,a8))"
"s = input()
p = input()

if p in s + s:
	print(""Yes"")
else:
	print(""No"")"
"import math

def sum_of_gcd_of_tuples():
    # 入力
    K = int(input())
    # 初期処理
    sum_gcd = 0
    # 処理
    for a in range(1,K+1):
        for b in range(1,K+1):
            for c in range(1,K+1):
                gcd_num = math.gcd(a,b)
                gcd_num = math.gcd(gcd_num,c)
                sum_gcd += gcd_num
    return sum_gcd

result = sum_of_gcd_of_tuples()
print(result)"
"n, m = map(int, input().split())

time_of_try = 100 * (n-m) + 1900 * m
count_of_try = 2 ** m

ans = time_of_try * count_of_try
print(ans)"
"n = input()
s = input()

slime = s[0]
for index in range(1,len(s)):
  if s[index] != s[index-1]:
    slime += s[index]
print(len(slime))"
"from math import degrees,atan2
a,b,x = map(int, input().split())
ans = 0
if (a*a*b/2 >= x):
    ans = degrees(atan2(a*b*b,2*x))
else:
    x = a*a*b - x
    ans = degrees(atan2(2*x,a*a*a))

print(ans)
"
"l,r = map(int,input().split())
p = 2019
if r - l >= 2019:
    for i in range(l,l+2019):
        for j in range(i+1,l+2020):
            p = min(p,i*j%2019)
            if p == 0:
                print(0)
                exit(0)
else:
    for i in range(l,r):
        for j in range(i+1,r+1):
            p = min(p,i*j%2019)
            if p == 0:
                print(0)
                exit(0)
print(p)"
"n = int(input())
p = (n+1)*[0]

for i in range(2, n+1):
    now = i
    for j in range(2, i+1):
        while now % j == 0:
            p[j] += 1
            now //= j


def cnt(m):
    return len(list(filter(lambda x: x >= m, p)))


ans = 0
ans += cnt(74)
ans += cnt(24)*(cnt(2)-1)
ans += cnt(14)*(cnt(4)-1)
ans += cnt(4)*(cnt(4)-1)*(cnt(2)-2)//2
print(ans)
"
"n = int(input())
h = list(map(int, input().split()))
ans, val0, val1 = 0, 0, 0

for j, i in enumerate(h):
    if val0 > i:
        ans += val0-val1
        val1 = i
    elif j == len(h)-1:
        val0 = i
        ans += val0-val1
    val0 = i
print(ans)
"
"import os, sys, re, math

N,i = map(int,input().split(' '))

print(N-i+1)
"
"import sys
input = sys.stdin.readline

h, w = map(int,input().split())
C = [input() for i in range(h)]
mod = 10**9 + 7

D = [[0] * w for i in range(h)]
D[0][0] = 1
for i in range(h):
    for j in range(w):
        if (i!=0 or j!=0) and C[i][j]==""."":
            if i-1 >= 0:
                D[i][j] += D[i-1][j]
            if j-1 >= 0:
                D[i][j] += D[i][j-1]
            D[i][j] %= mod
print(D[-1][-1])"
"from math import sqrt
x1, y1, x2, y2 = map(float, input().split())
r = sqrt((x2 - x1)**2 + (y2 - y1)**2)
print(r)"
"N,K = map(int, input().split())
S = input()

A = []
pre = S[0]
cnt = 1
for i in range(1,N):
  if pre == S[i]:
    cnt += 1
  else:
    pre = S[i]
    A.append(cnt)
    cnt = 1
A.append(cnt)
if len(A) == 1:
  print(N-1)
  exit(0)
ans = sum(A) - len(A)
# X は真ん中。Yは端っこ。引数はIndexのMOD2。
X,Y = [0,0], [0,0]
for i in range(len(A)):
  if i == 0 or i == len(A)-1:
    Y[i%2] += 1
  else:
    X[i%2] += 1
    
wk = [0,0]
for i in range(2):
  if K <=X[i]:
    wk[i] = K * 2
  elif K <= X[i] + Y[i]:
    wk[i] = X[i] * 2 + (K-X[i])
  else:
    wk[i] = X[i] * 2 + Y[i]

print(ans + max(wk))
exit(0)
print(ans, wk)
print(A)
print(X)
print(Y)"
"N = int(input())
N_List = sorted(list(map(int,input().split())))
flg = 0
ans = 1
if N % 2 == 1:
    if N_List[0] != 0:
        flg = 1
    else:
        for i in range(2,N,2):
            if i*2 != sum(N_List[i-1:i+1]):
                flg = 1
                break
            else:
                ans = (ans * 2) % ((10**9) +7)
        

else:
    for i in range(1,N,2):
        if i*2 != sum(N_List[i-1:i+1]):
            flg = 1
            break
        else:
            ans = (ans * 2) % ((10**9) +7)

if flg == 0:
    print(ans)
else:
    print(0)

                
"
print((int(input())-1)//2)
"n,i = map(int, input().split())
a = n-i+1
print(a)"
"n,k = map(int,input().split())
r,s,p = map(int,input().split())
T = input()

#dp[i][j]:i回目にjを出した時のそれまでの合計点の最大値。j:0グー1チョキ2パー
dp = [[0 for j in range(3)] for i in range(n)]
for i in range(0,k):
    if T[i] == 'r':
        dp[i][2] = p 
    elif T[i] == 's':
        dp[i][0] = r 
    else:
        dp[i][1] = s 
    for j in range(k,n-i,k):
        if T[i+j] == 'r':
            dp[i+j][2] = max(dp[i+j-k][0]+p,dp[i+j-k][1]+p)
            dp[i+j][1] = max(dp[i+j-k][0],dp[i+j-k][2])
            dp[i+j][0] = max(dp[i+j-k][1],dp[i+j-k][2])
        elif T[i+j] == 's':
            dp[i+j][0] = max(dp[i+j-k][1]+r,dp[i+j-k][2]+r)
            dp[i+j][1] = max(dp[i+j-k][0],dp[i+j-k][2])
            dp[i+j][2] = max(dp[i+j-k][0],dp[i+j-k][1])
        else:
            dp[i+j][1] = max(dp[i+j-k][2]+s,dp[i+j-k][0]+s)
            dp[i+j][0] = max(dp[i+j-k][1],dp[i+j-k][2])
            dp[i+j][2] = max(dp[i+j-k][0],dp[i+j-k][1])
    
total = 0
#print(dp)
for i in range(n-1,max(0,n-1-k),-1):
    total += max(dp[i])
print(total)
        
    

"
"N = int(input())
ans = 0

l, m = [], []

for _ in range(N):
    s, t = input().split()
    t = int(t)
    l.append(s)
    m.append(t)

X = input()

idx = l.index(X)
for i in range(idx+1, N):
    ans += m[i]

print(ans)"
"N = int(input())
restaurants = []
for i in range(N):
    name, rating = input().split()
    restaurants.append([name, -int(rating), i])
restaurants.sort()
for i in restaurants:
    print(i[2] + 1)
"
"n,k=map(int,input().split())
ans=[""1 ""+str(i) for i in range(2,n+1)]
c=(n-1)*(n-2)//2
if k>c:
	print(-1)
	exit()
for i in range(2,n):
	for j in range(i+1,n+1):
		if c==k:
			break
		ans+=[""{} {}"".format(i,j)]
		c-=1
	else:
		continue
	break
print(len(ans))
print(*ans,sep=""\n"")"
"s = list(input())
import collections
import sys
a = collections.Counter(s)

for i in range(97,97+26):
    if chr(i) not in a:
        print(chr(i))
        sys.exit()
else:
    print(""None"")"
"def popcount(x):
    return bin(x).count('1')

def initialize(N):
    i=1
    while i<N:
        i*=2
    return [0]*(2*i-1),i

def update(i,x):
    i+=d-1
    bit=ord(x)-97
    SEG[i]=0 | (1<<bit)
    while i>0:
        i=(i-1)//2
        SEG[i]=SEG[i*2+1]|SEG[i*2+2]
        
def find(a,b,k,l,r):
    if r<=a or b<=l:
        return 0
    if a<=l and r<=b:
        return SEG[k]
    else:
        c1=find(a,b,2*k+1,l,(l+r)//2)
        c2=find(a,b,2*k+2,(l+r)//2,r)
        return c1|c2
        
N=int(input())
S=input()
Q=int(input())
SEG,d=initialize(N)
for i in range(N):
    update(i,S[i])
for i in range(Q):
    com,s,t=map(str,input().split())
    if(com=='1'):
        update(int(s)-1,t)
    else:
        print(popcount(find(int(s)-1,int(t),0,0,d)))"
"S,W=map(int,input().split())
print(""safe"" if S>W else ""unsafe"")"
"# B - Training Camp
def main():
    import math
    n = int(input())
    
    
    print(math.factorial(n)%(10**9+7))

  
        
if __name__ == '__main__':
    main()"
"h,w=map(int,input().split())
s=[]
for i in range(h):
    s.append(list(input()))

dp=[[99999999 for i in range(w)] for i in range(h)]


if(s[0][0]=='#'):
    dp[0][0]=1
else:
    dp[0][0]=0

for i in range(h):
    for j in range(w):

        if(s[i][j-1] != s[i][j]):
            left = dp[i][j-1]+1
        else:
            left = dp[i][j-1]

        if(s[i-1][j] != s[i][j]):
            top = dp[i-1][j]+1
        else:
            top = dp[i-1][j]

        dp[i][j] = min(dp[i][j],left,top)

print((dp[h-1][w-1]+1)//2)"
"x=int(input())
t=0
p=0
while p<x:
    t+=1
    p+=t
print(t)"
"n,k = map(int, input().split())
def modinv(a, mod=10**9+7):
    return pow(a, mod-2, mod)
def comb(n, r, mod=10**9+7):
    r = min(r, n-r)
    res = 1
    for i in range(r):
        res = res * (n - i) * modinv(i+1, mod) % mod
    return res
cm = comb(n-1,2)

if n==2 and k>=1:
    print(-1)
    exit()

if cm < k:
    print(-1)
    exit()

ans=[]
for i in range(1,n):
    ans.append([1,i+1])

from itertools import *
cnt=0
for e in combinations(range(2,n+1),2):
    if cnt== cm-k:
        break
    cnt+=1
    ans.append([e[0],e[1]])

print(len(ans))
for a in ans:
    print(*a)"
"N = int(input())
if N == 1:print(1);exit()
A = [int(hoge) for hoge in input().split()]
ans = 1
cur = A[0]
Decided = A[0] != A[1]
Flat = A[0] == A[1]
Up = A[0] < A[1]

for n in range(1,N):
    if Decided:
        if A[n] == cur:
            continue
        if (A[n]>=cur) == Up:#数列が続く
            cur = A[n]
        else:
            cur = A[n]
            Up = 1 - Up
            Decided = False
            ans += 1
    else:
        if A[n] != cur:
            Up = A[n] > cur
            cur = A[n]
            Decided = True
print(ans) "
"N = int(input())

masu = [int(i) for i in input().split(' ')]

count = 0
for i in range(len(masu)):
  if (i+1)%2 == 1 and masu[i]%2 == 1:
    count += 1
    
print(count)"
"N = int(input())
A = list(map(int, input().split()))

money = 1000
for i in range(N - 1):
    if A[i] < A[i+1]:
        num = money // A[i]
        profit = num * (A[i+1] - A[i])
        money += profit
print(money)
"
"'''
Created on 2020/08/20

@author: harurun
'''
def main():
  import sys
  pin=sys.stdin.readline
  pout=sys.stdout.write
  perr=sys.stderr.write
  
  S=pin()[:-1]
  ans=0
  T=""CODEFESTIVAL2016""
  for i in range(16):
    if S[i]==T[i]:
      continue
    ans+=1
  print(ans)
  return 

main()"
"#-------------
N = int(input())
#-------------

C_list=[]

for i in range(26):
  for j in range(15):
    C_list.append(4*i + 7*j)

cnt = 0
for i in range(len(C_list)):
  if C_list[i] == N:
    cnt += 1

if cnt >= 1:
  print(""Yes"")
else:
  print(""No"")"
"""""""
author : halo2halo
date : 24, Jan, 2020
""""""

import sys

# import numpy as np

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

a, b, c, d = map(int, readline().split())

if abs(c - a) <= d:
    bl = True
elif abs(b - a) <= d and abs(c - b) <= d:
    bl = True
else:
    bl = False
print(""Yes"" if bl else ""No"")
"
"N, A = [int(input()) for _ in range(2)]
if A < N % 500:
  print('No')
else:
  print('Yes')"
"n = int(input())
t = []
p = [0, 0, 0]
while(n):
    a, b, c = input().split(' ')
    t.append([int(a), int(b), int(c)])
    n-=1
for i in t:
    while(p[0] < i[0]):
        p[0]+=1
        if i[1] > p[1]:
            p[1]+=1
        elif i[2] > p[2]:
            p[2]+=1
        elif i[1] < p[1]:
            p[1]-=1
        elif i[2] < p[2]:
            p[2]-=1
        else:
            p[1]-=1
    if p != i:
        print('No')
        exit()
print('Yes')"
"import networkx as nx

N, M = map(int, input().split())
G = nx.Graph()
G.add_nodes_from(range(1, N + 1))
G.add_edges_from([tuple(map(int, input().split())) for _ in range(M)])

print(len(tuple(nx.bridges(G))))
"
"import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
def main():
    K=ii()
    L=list(range(10))

    if K <= 9:
        print(K)
        exit()
    
    # print(L)
    head_i = 1
    while len(L) < K+10:
        assert head_i < len(L)
        head = L[head_i]
        head_tail = head % 10
        for x in [head_tail-1,head_tail,head_tail+1]:
            if x < 0 or x >= 10: continue
            
            # print(head_i,head,head_tail)
            # assert not head * 10 + x in L
            L.append(head * 10 + x)
        
        head_i += 1

    # print(L)
    print(L[K])

    


if __name__ == ""__main__"":
    main()"
"print(""second"" if all(i % 2 == 0 for i in map(
    int, open(0).read().split()[1:])) else ""first"")"
"H, W = [int(i) for i in input().split()]

masu_sum = H * W

if H == 1 or W == 1:
    ans = 1
elif masu_sum % 2 == 0:
    ans = masu_sum // 2
else:
    ans = masu_sum // 2 + 1

print(ans)"
"a = list(map(int, input().split()))
print(""Draw"" if a[0] == a[1] else (""Alice"" if a[0] > a[1] and a[1] != 1 or a[0] == 1 else ""Bob""))"
"def a_to_b(A):
    c = [0] * N
    for i, a in enumerate(A):
        lb = max(0, i - a)
        c[lb] += 1
        ub = i + a + 1
        if ub < N:
            c[ub] -= 1
    tmp = 0
    B = []
    for ci in c:
        tmp += ci
        B.append(tmp)
    return B


N, K = map(int, input().split())
A = list(map(int, input().split()))

ans = A
for _ in range(K):
    ans = a_to_b(ans)
    if sum(ans) == N ** 2:
        break

print(*ans)"
"S=[0 if c =='0' else 1 for c in input()]
a = S[0::2]
b = S[1::2]
x = a.count(1)
y = b.count(1)
if x > y:
    ans = (len(a)-x) + (y)
else:
    ans = (len(b)-y) + (x)
print(ans)
"
"s=input()
n=len(s)
for i in range(n):
    tmp=s[:i]+s[i+n-7:]
    if tmp==""keyence"":
        print(""YES"")
        exit()
print(""NO"")"
"n = int(input())
s = input()
k = int(input())

v = s[k-1]

ary = []

for i in s:
  if i != v:
    ary.append('*')
  else:
    ary.append(v)
print (''.join(ary))
"
"N = int(input())
S = input()
T = input()
ans = 2 * N
for i in range(N):
    for j in range(1, N + 1):
        if (S[i:] == T[:j]):
            ans = min(ans, 2 * N - j)
print(ans)
"
"import sys
x,k,d = map(int,input().split())

# x:位置　k：回数　d:距離

#往復に辿りつく前に終わるパターン
if(abs(x)-d*k >= 0):
    print(abs(abs(x)-d*k))
#0またいで往復するパターン
else:
    #往復直前までにかかる回数
    r_count = abs(x)//d
 
    #残り捜査回数
    rest = k - r_count

    #残り回数の奇遇によって計算を判断
    #残り回数が偶数の時はr_count分動かした時と変わらない
    if(rest %2 == 0):
        print(abs(abs(x) - d*r_count))
    #残り回数が奇数:さらにD移動した分？
    else:
        print(abs(abs(abs(x) - d*r_count)-d))


#通らない.....



"
"import sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**20
def I(): return int(input())
def F(): return float(input())
def S(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LS(): return input().split()

def resolve():
    A, B = LI()

    if 1 <= A <= 9 and 1 <= B <= 9:
        print(A * B)
    else:
        print('-1')

if __name__ == '__main__':
    resolve()"
"from math import ceil

n, a, b = map(int, input().split())
hs = [int(input()) for _ in range(n)]


def defeatable(k):
    hb = [max([h - k * b, 0]) for h in hs]
    n_attack = sum([ceil(h / (a - b)) for h in hb])
    return n_attack <= k


l, r = 0, ceil(max(hs) / b)

while r - l > 1:
    m = (l + r) // 2

    if defeatable(m):
        r = m
    else:
        l = m

print(r)

"
"import sys
import itertools
# import numpy as np
import time
import math
from heapq import heappop, heappush
from collections import defaultdict
from collections import Counter
from collections import deque
from itertools import permutations
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())
N, K = map(int, input().split())
MAX = 10 ** 6 + 5
MOD = 10 ** 9 + 7

fac = [0 for i in range(MAX)]
finv = [0 for i in range(MAX)]
inv = [0 for i in range(MAX)]

def comInit(mod):
    fac[0], fac[1] = 1, 1
    finv[0], finv[1] = 1, 1
    inv[1] = 1
    for i in range(2, MAX):
        fac[i] = fac[i - 1] * i % mod
        inv[i] = mod - inv[mod % i] * (mod // i) % mod
        finv[i] = finv[i - 1] * inv[i] % mod


def com(n, r, mod):
    if n < r:
        return 0
    if n < 0 or r < 0:
        return 0
    return fac[n] * (finv[r] * finv[n - r] % mod) % mod

def p(n, r, mod):
    return fac[n] * finv[n - r] % mod
    
comInit(MOD)

ans = 0
if K + 1 >= N:
    ans = com(N + N - 1, N - 1, MOD)
else:
    for i in range(K + 1):
        ans += com(N, i, MOD) * com(i + N - i - 1, i, MOD) % MOD
        ans %= MOD
print(ans % MOD)"
"n,k = map(int,input().split())

l = []
for i in range(n):
    a,b = map(int,input().split())
    l.append([a,b])

l = sorted(l, key = lambda x:x[0])
cnt = 0    
for a,b in l:
    cnt += b
    
    if cnt >= k:
        print(a)
        break"
"n=int(input())
w=[]
flag=True
for i in range(n):
    w.append(input())
    
for i in range(n-1):
    if w[i][-1]!=w[i+1][0]:
        #print(i,""out1"")
        flag=False

for i in range(n-1):
    for j in range(i+1,n):
        if(w[i]==w[j]):
            #print(i,j,""out2"")
            flag=False

if flag==True:
    print(""Yes"")
else:
    print(""No"")


"
"s = input()
k = int(input())
s = s + '0'

e = 1
l = []
for i in range(len(s)-1):
    if s[i]==s[i+1]:
        e+=1
    else:
        l.append(e)
        e=1

s = s[:-1]

if len(s)==1:
    print(k//2)    
else:
    if s[0]!=s[-1]:
        print(k*sum([i//2 for i in l]))
    else:
        if k==1:
            print(k*sum([i//2 for i in l]))
        else:
            if len(l)==1:
                print((k*l[0])//2)
            else:
                a = l.pop(0)
                b = l.pop(-1)
                l.append(a+b)
                print(k*sum([i//2 for i in l])-(a+b)//2+a//2+b//2)"
"x1,y1,x2,y2 = map(int,input().split())
x3,y3 = x2 - (y2-y1), y2 + x2-x1
x4,y4 = x1 - (y2-y1), y1 + x2-x1

ans = [x3,y3,x4,y4]
print(*ans)"
"from collections import Counter
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

n = int(readline())
c = Counter(readline().decode().rstrip())
for i in range(1, n):
    c2 = Counter(readline().decode().rstrip())
    for k, v in c.items():
        c[k] = min(c[k], c2[k])
l = sorted(c.items())
ans = ''
for k, v in l:
    ans += k * v
print(ans)"
"N=int(input())
A=[int(a) for a in input().split()]
A.sort(reverse=True)
print(sum(A[2*i-1] for i in range(1,N+1)))"
"N = int(input())
A = [int(input()) for _ in range(N)]
ans = 0
if A[0] != 0:
    print(-1)
    exit()

for i in range(1, N):
    if A[i] - A[i-1] > 1:  # 前の数に+1することでしか数を生成することができないため、2以上離れている場合は無理
        print(-1)
        exit()

now = A[0]
for i in range(1, N):
    if A[i] == now+1:
        ans += 1
        now = A[i]
    else:
        ans += A[i]
        now = A[i]
print(ans)
"
"S=input()
l=len(S)

if l <=25:
    for i in range(26):
        ch=chr(ord('a')+i)
        if ch not in S:
            S+=ch
            break
elif S=='zyxwvutsrqponmlkjihgfedcba':
    S=-1
else:
    index=24
    tmp=[ord(S[25])]
    while ord(S[index]) > ord(S[index+1]):
        tmp.append(ord(S[index]))
        index -= 1

    re=max(tmp)
    for ch in tmp:
        if ch < re and ch > ord(S[index]) :
            re = ch
    S=S[:index]+chr(re)

print(S)"
"r = int(input())

standard_area = 1

ans_area = r ** 2

ans = ans_area // standard_area

print(ans)"
"n = int(input())
p = list(map(int, input().split()))
cn = 0
for i in range(n - 2):
    if (p[i] < p[i+1] and p[i+1] < p[i+2]) or (p[i] > p[i+1] and p[i+1] > p[i+2]):
        cn = cn + 1
        
print(cn)"
"n = int(input())
ab = [input() for _ in range(n)] #数字1*複数列入力

l = len(set(ab))

if n != l:
    print(""No"")
    exit()
for i in range(1,n):
    if ab[i-1][-1] == ab[i][0]:
        pass
    else:
        print(""No"")
        exit()
print(""Yes"")    "
"import math
import sys
import bisect
readline = sys.stdin.readline


def main():
    n = int(readline().rstrip())
    A = list(map(int, readline().rstrip().split()))
    k = 0

    if A.count(1) == 0:
        print(-1)
        return

    for i in range(n):
        if A[i] == k + 1:
            k += 1

    print(n - k)


if __name__ == '__main__':
    main()
"
"s = input()
tmp = 0
max = 0
def check(i):
  if s[i] == ""A"" or s[i] == ""C"" or s[i] == ""G"" or s[i] == ""T"":
    return True
  else:
    return False
for i in range(len(s)):
  if check(i):
    tmp += 1
  else:
    tmp = 0
  if tmp > max:
    max = tmp
print(max)"
"n, k = map(int, input().split())
sunuke_set = set(i for i in range(1, n + 1))

for i in range(k):
    d = int(input())
    sunuke_list = list(map(int, input().split()))
    for sunuke in sunuke_list:
        sunuke_set.discard(sunuke)

print(len(sunuke_set))
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N = int(input())
As = list(mapint())
HALF = sum(As)/2

from itertools import accumulate
from bisect import bisect_left
cum = list(accumulate(As))
idx = bisect_left(cum, HALF)
L = abs(sum(As[:idx])-sum(As[idx:]))
R = abs(sum(As[:idx+1])-sum(As[idx+1:]))
print(min(L, R))"
"N=int(input())
List = list(map(int, input().split()))
flg = True
if N ==1: print(""Yes"")
else:
  for i in range(1,N):
    if List[i]==List[i-1]:
      pass
    elif List[i]>List[i-1] or List[i]-1>=List[i-1]:
      List[i] = List[i]-1
    else:
      flg=False
      break
  if flg:
    print(""Yes"")
  else:
    print(""No"")"
"N = int(input())
H = list(map(int, input().split()))

ans = 1

for i in range(1,N):
    for j in range(i):
        if H[j] <= H[i]:
            if j == i-1:
                ans += 1
            continue
        else:
            break


print(ans)
"
"N = int(input())
T = tuple(map(int, input().split()))
M = int(input())
drinks = [list(map(int, input().split())) for _ in range(M)]
for drink in drinks:
    total_time = sum(T) - (T[drink[0]-1] - drink[1])
    print(total_time)
"
"import math
#import numpy as np
import queue
from collections import deque,defaultdict
import heapq as hpq
from sys import stdin,setrecursionlimit
#from scipy.sparse.csgraph import dijkstra
#from scipy.sparse import csr_matrix
ipt = stdin.readline
setrecursionlimit(10**7)

def main():
    n = int(ipt())
    a = [int(i) for i in ipt().split()]
    a.sort()

    if n == 2:
        print(a[1]-a[0])
        print(a[1],a[0])
    else:
        if a[1] > 0:
            ans = a[0]-a[-1]
            op = [(a[0],a[-1])]
        else:
            ans = a[-1]-a[0]
            op = [(a[-1],a[0])]
        f = True
        for i in range(1,n-2):
            if f and a[i+1] > 0:
                f = False
            if f:
                op.append((max(ans,a[i]),min(ans,a[i])))
                ans = max(ans,a[i])-min(ans,a[i])
            else:
                op.append((min(ans,a[i]),max(ans,a[i])))
                ans = min(ans,a[i])-max(ans,a[i])
        op.append((max(ans,a[n-2]),min(ans,a[n-2])))
        ans = max(ans,a[n-2])-min(ans,a[n-2])
        print(ans)
        for x,y in op:
            print(x,y)


if __name__ == '__main__':
    main()
"
"n = int(input())
a = list(map(int, input().split()))

d = [0]*n
for i in a:
    d[i-1] += 1

ans = 0
for i in range(n):
    ans += int((d[i]*(d[i]-1))/2)

for i in range(n):
    print(ans-(d[a[i]-1]-1))"
"n = int(input())
c,s,f = [],[],[]
for _ in range(n-1):
    x,y,z = map(int,input().split())
    c.append(x)
    s.append(y)
    f.append(z)
    
ans = []
for i in range(n-1): #出発地点
    time = 0
    for j in range(i,n-1): #現在地
        if time <= s[j]:
            time = s[j]+c[j]
        else:
            time += c[j] + f[j]*(0!=time%f[j]) - time%f[j]
    ans.append(time)
        
print('\n'.join(map(str,ans)),'\n0')"
"marks='SHCD'
n=input()
card=[raw_input().split() for _ in range(n)]
m={}
for mk,rk in card:
    m.setdefault(mk,[0]*14)
    m[mk][int(rk)]=1
for i in range(len(m)):
    k=marks[i]
    v=m[k]
    for j in range(1,14):
        if not v[j]: print k,j"
"from functools import reduce
import math

def main():
    # N! を求める
    # f = math.factorial(N)
    
    # 切り捨て
    # 4 // 3
    # 切り上げ
    #-(-4 // 3)
    
    # 初期値用:十分大きい数(100億)
    # 1e10

    # 初期値用:十分小さい数(-100億)
    # -1e10
    
    # 1文字のみを読み込み
    # 入力:2
    # a = input().rstrip()
    # 変数:a='2'
    
    # スペース区切りで標準入力を配列として読み込み
    # 入力:2 4 5 7
    # a, b, c, d = (int(_) for _ in input().split())  
    # 変数:a=2 b=4 c=5 d =7
    
    # 1文字ずつ標準入力を配列として読み込み
    # 入力:2 4 5 7
    # a = list(int(_) for _ in input().split())
    # 変数:a = [2, 4, 5, 7]    

    # 1文字ずつ標準入力を配列として読み込み
    # 入力:2457
    # a = list(int(_) for _ in input())
    # 変数:a = [2, 4, 5, 7]    
    a, b, c = (int(_) for _ in input().split())
    if b-a == c-b:
        print('YES')
    else:
        print('NO')
    
if __name__ == '__main__':
    main()
"
"N, M = map(int, input().split())


def make_divisors(n):
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]

div_list = make_divisors(M)
div_list = div_list[::-1]
for div in div_list:
    if N * div <= M:
        print(div)
        exit()
"
"a,b,c = map(int,input().split())
left = 4 * a * b
right = c - a - b
if right < 0:
    print('No')
    exit()
right = right*right
if left < right:
    print('Yes')
else:
    print('No')
"
"n = int(input())
a = list(map(int, input().split()))

# 4で割り切れる場合と、2で割り切れる場合、どちらでも割り切れない場合の値の数を求める
# どちらでも割り切れない場合の値は4で割り切れる値の場合との組み合わせで4の倍数の積になる
# 達成できるかの判定はどちらでも割り切れない値の数が、4で割り切れる値の数以下であった場合に成立する
b1 = b2 = b4 = 0
for i in range(n):
  if a[i]%4 == 0: b4 += 1
  elif a[i]%2 == 0: b2 += 1
  else: b1 += 1

# 2で割り切れる値が存在しない場合、
# どちらでも割り切れない値の数が、4で割り切れる値の数+1以下であった場合に成立する
if b2 == 0: b4 += 1 
  
if b1 <= b4: print(""Yes"")
else: print(""No"")"
"from math import cos, pi, sqrt
A, B, H, M = map(int, input().split())
t = abs((H+M/60)/12 - M/60)*2*pi
print(sqrt(A**2 + B**2 - 2*A*B*cos(t)))"
"import sys

input = sys.stdin.readline


def main():
    S = input().rstrip()

    i = 0
    x_cnt = [0]
    T = """"
    for s in S:
        if s == ""x"":
            x_cnt[i] += 1
        else:
            T = """".join((T, s))
            i += 1
            x_cnt.append(0)

    is_palindrome = True
    for i in range(len(T) // 2):
        if T[i] != T[-(i+1)]:
            is_palindrome = False

    if is_palindrome:
        ans = 0
        for i in range(len(x_cnt) // 2):
            ans += abs(x_cnt[i] - x_cnt[-(i+1)])
    else:
        ans = -1
    print(ans)


if __name__ == ""__main__"":
    main()
"
"ary = ['A', 'C', 'G', 'T']
ans = ['T', 'G', 'C', 'A']

b = input()

print(ans[ary.index(b)])"
"import sys
mod=10**9+7
n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))


if a[0]>b[0] or b[n-1]>a[n-1]: print(0);sys.exit()
elif n<=2: print(1);sys.exit()

ans=1
for i in range(1,n-1):
    if a[i]==a[i-1] and b[i]==b[i+1]:
        ans=ans*min(a[i],b[i])%mod
    else:
        if a[i]!=a[i-1] and a[i]>b[i]: print(0);sys.exit()
        if b[i]!=b[i+1] and b[i]>a[i]: print(0);sys.exit()
print(ans)"
"S = input()
dir = [0]*4
move = ""NWSE""
for i in S:
    dir[move.index(i)] += 1
p1 = (dir[0] > 0 and dir[2] > 0) or (dir[0] == 0 and dir[2] == 0)
p2 = (dir[1] > 0 and dir[3] > 0) or (dir[1] == 0 and dir[3] == 0)
print(""Yes"" if p1 and p2 else ""No"")"
"s = input()
l = len(s)
for i in range(l):
	for j in range(i, l):
		if s[:i] + s[j:] == ""keyence"":
			print(""YES"")
			exit()
else:
	print(""NO"")"
"t,x=[int(i) for i in input().split()]

print(t/x)"
"while True:
    h,w = map(int,raw_input().split())
    if h == 0 and w == 0:
        break
    for i in range(h):
        if i % 2 == 0:
            a = '#.'
        else :
            a = '.#'
        if w % 2 == 0:
            print a*(w/2)
        else:
            print a*(w/2)+a[0]
    print ''"
"A,B,N = map(int,input().split())
if N<B:
    print(int(A*N/B)-A*int(N/B))
if B<=N:
    print(int(A*(B-1)/B)-A*int((B-1)/B))"
"a = list(map(int, list(input())))
sum = sum(a)
if sum % 9 == 0:
    print(""Yes"")
else:
    print(""No"")"
"n = int(input())
p = list(map(int,input().split()))
ans = 0
for j in range(n-2):
	if p[j] < p[j+1] < p[j+2] or p[j+2] < p[j+1] < p[j]:
		ans += 1
print(ans)"
"def calc():
  H,W,M = map(int, input().split())
  s = []
  hcount = [0]*H
  wcount = [0]*W
  for m in range(M):
    h,w = map(int, input().split())
    h = h - 1
    w = w - 1
    hcount[h] = hcount[h] + 1
    wcount[w] = wcount[w] + 1
    s.append((h,w))
  hmax = max(hcount)
  wmax = max(wcount)
  hmode = [h for h, x in enumerate(hcount) if x == hmax]
  wmode = [w for w, y in enumerate(wcount) if y == wmax]
  s = tuple(s)
  S = set(s)
  for h in hmode:
    for w in wmode:
      if ((h,w) not in S):
        return hmax + wmax
  return hmax + wmax - 1
  
if __name__ == '__main__':
    print(calc())"
"import sys
input = sys.stdin.buffer.readline

MOD = 10**9+7

n = int(input())
a = list(map(int, input().split()))

rgb = [0, 0, 0]

ans = 1
for i in range(n):
    ans *= rgb.count(a[i])
    ans %= MOD
    # print(rgb, a[i], ans)
    for j in range(3):
        if rgb[j] == a[i]:
            rgb[j] += 1
            break
print(ans)
"
"INF = float('inf')
n, ma, mb = map(int, input().split())
t = [[INF] * 401 for _ in range(401)]
t[0][0] = 0
for _ in range(n):
  a, b, c = map(int, input().split())
  for aa in range(400, -1, -1):
    for bb in range(400, -1, -1):
      if t[aa][bb] == INF:
        continue
      if t[a + aa][b + bb] > t[aa][bb] + c:
        t[a + aa][b + bb] = t[aa][bb] + c
result = INF
for a in range(400, 0, -1):
  for b in range(400, 0, -1):
    if a * mb == b * ma and t[a][b] < result:
      result = t[a][b]
if result == INF:
  result = -1
print(result)
"
"N = int(input())
A1 = [int(X) for X in input().split()]
A2 = [int(X) for X in input().split()]
CumSumA1 = [A1[0]]*N
CumSumA2 = [A2[(N-1)]]*N
Disp = [0]*N
for T in range(0,N-1):
    CumSumA1[T+1] = CumSumA1[T]+A1[T+1]
    CumSumA2[(N-1)-(T+1)] = CumSumA2[(N-1)-T]+A2[(N-1)-(T+1)]
for T in range(0,N):
    Disp[T] = CumSumA1[T]+CumSumA2[T]
print(max(Disp))"
"dice = input().rstrip().split(' ')
indication = ""EEENEEENEEESEEESEEENEEENSWWSWWWNWWWNWWWSWWWSWWW""
indic = list(indication)
length = len(indic)
num = int(input())
for j in range(num):
  s = input().rstrip().split(' ')
  top = int(s[0])
  front = int(s[1])
  for i in range(length):
    newdice = [0] * 6
    if str(indic[i]) == ""N"":
      newdice[0] = dice[1]
      newdice[1] = dice[5]
      newdice[2] = dice[2]
      newdice[3] = dice[3]
      newdice[4] = dice[0]
      newdice[5] = dice[4]
      dice = newdice
      if int(dice[0]) == top and int(dice[1]) == front:
        print(int(dice[2]))
        break;
    elif str(indic[i]) == ""S"":
      newdice[0] = dice[4]
      newdice[1] = dice[0]
      newdice[2] = dice[2]
      newdice[3] = dice[3]
      newdice[4] = dice[5]
      newdice[5] = dice[1]
      dice = newdice
      if int(dice[0]) == top and int(dice[1]) == front:
        print(int(dice[2]))
        break;
    elif str(indic[i]) == ""E"":
      newdice[0] = dice[3]
      newdice[1] = dice[1]
      newdice[2] = dice[0]
      newdice[3] = dice[5]
      newdice[4] = dice[4]
      newdice[5] = dice[2]
      dice = newdice
      if int(dice[0]) == top and int(dice[1]) == front:
        print(int(dice[2]))
        break;
    elif str(indic[i]) == ""W"":
      newdice[0] = dice[2]
      newdice[1] = dice[1]
      newdice[2] = dice[5]
      newdice[3] = dice[0]
      newdice[4] = dice[4]
      newdice[5] = dice[3]
      dice = newdice
      if int(dice[0]) == top and int(dice[1]) == front:
        print(int(dice[2]))
        break;

"
"import sys

input = sys.stdin.readline


def main():
    N = int(input())
    A = [0] * N
    for i in range(N):
        A[i] = int(input())

    if N == 1:
        ans = A[0] // 2
    else:
        ans = 0
        for i in range(N - 1):
            if A[i + 1] == 0:
                ans += A[i] // 2
            else:
                q, r = divmod(A[i] + A[i + 1], 2)
                ans += q
                A[i + 1] = r

    print(ans)


if __name__ == ""__main__"":
    main()
"
"from decimal import *
a, b, c = map(int, input().split())
print('Yes' if Decimal(a).sqrt() + Decimal(b).sqrt() < Decimal(c).sqrt() else 'No')
"
"S = input()
S = S[::-1]
S += '0'

n = len(S)
dp = [[10**20 for j in range(2)] for i in range(n + 1)]
dp[0][0] = 0

for i in range(n):
    for j in range(2):
        x = ord(S[i])-ord('0')
        x += j
        for a in range(10):
            ni = i+1
            nj = 0
            b = a-x
            if b < 0:
                nj = 1
                b += 10
            dp[ni][nj] = min(dp[ni][nj], dp[i][j]+a+b)

print(dp[n][0])
"
"A,B,C=map(int,input().split())
count=0
while B>0:
   if A>B:
      break
   B=B-A
   count+=1
   if count>=C:
      break
print(count)"
"a = '1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51'
k = int(input())
b = a.split("", "")
print(b[k-1])
"
"n = int(input())
abcde = [int(input()) for _ in range(5)]

print(4-(-n//min(abcde)))"
"X,T =map(int,input().split())
print(max(0,X-T))"
"n=int(input())
m=1000000007
print((pow(10,n)%m-2*pow(9,n)%m+pow(8,n)%m)%m)"
"H, W = map(int, input().split())
S = []
for _ in range(H):
    S.append(list(input()))

for i in range(H):
    for j in range(W):
        if S[i][j] == ""."":
            cnt = 0
            for di in range(-1, 2):
                for dj in range(-1, 2):
                    tmp_i = i+di
                    tmp_j = j+dj
                    if (0 <= tmp_i <= H-1) and (0 <= tmp_j <= W-1) and (S[tmp_i][tmp_j]==""#""):
                        cnt += 1
            S[i][j] = cnt

for s in S:
    for i in s:
        print(i, end="""")
    print()"
"A, B, C, D = map(int, input().split())
a = (A + D - 1) // D
c = (C + B - 1) // B
if c <= a:
  print('Yes')
else:
  print('No')"
"from copy import deepcopy
s = list(input())    
N = len(s)
count= 0
counter = []
ans = []
real = deepcopy(s)
syurui = set(s)
for j in syurui:
    while True:
        #終了条件
        if N == s.count(j):
            counter.append(count)
            count = 0
            s = deepcopy(real)
            N = len(s)
            break

        for i in range(N-1):
            if s[i]==j or s[i+1]==j:
                ans.append(j)
            else:
                ans.append(s[i])
        #値の更新
        N = len(ans)
        s = deepcopy(ans)
        count += 1

        #変数のリセット
        ans = []
print(min(counter))
"
"S = input()
a,b = int(S[:2]),int(S[2:])
if (1<=a and a<=12) or (1<=b and b<=12):
    if (1<=a and a<=12) and (1<=b and b<=12): 
        print(""AMBIGUOUS"")
    elif (1<=b and b<=12):
        print(""YYMM"")
    elif  (1<=a and a<=12): 
        print(""MMYY"")
  
else:
    print(""NA"")




"
"n,k = map(int,input().split())
l = list(map(int,input().split()))

# xは求める長さ
def C(x):
    num = 0
    for i in range(n):
        # (a[i]-1)//x 回切る必要がある
        num += (l[i]-1)//x
    # k回以内に収まるか
    return num <= k

lb,ub = 0,max(l)
for i in range(100):
    mid = (lb + ub) / 2
    # 条件を満たすならxを小さくしていく
    if C(mid):
        ub = mid
    else:
        lb = mid
    # print(lb,ub)

import math
ans = math.ceil(ub)
print(ans)"
"N = [i for i in input()]
print(N.count(""2""))"
"import collections

N = int(input())
a = [int(i) for i in input().split()]
g = a[:]
for i in g:
    a.append(i-1)
    a.append(i+1)



dict = collections.Counter(a)

for a, b in dict.most_common():
    print(b)
    break
"
"N = int(input())
a_list = list(map(int,input().split()))

cnt = 0
tmp_cnt = 0
tmp_a = 0
for a in a_list:
    if a == tmp_a:
        tmp_cnt += 1
        if tmp_cnt % 2 == 0:
            cnt += 1
    else:
        tmp_a = a
        tmp_cnt = 1
        
print(cnt)"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solve():
    P, Q, R = map(int, input().split())
    ans = min(P + Q, Q + R, R + P)
    print(ans)


if __name__ == '__main__':
    solve()
"
"num = sum(list(map(int,input().split())))
print('error' if num>=10 else num)"
"N = int(input())
for n in range(100000):
    x = int(n*1.08)
    if N==x:
        print(n)
        exit()
    if x > N:
        break
print(':(')
"
"

def read_int():
    return int(input().strip())


def read_ints():
    return list(map(int, input().strip().split(' ')))


def solve():
    N = read_int()
    table = [
        [1 for _ in range(N)] for _ in range(N)
    ]
    if N%2 == 0:
        for i in range(N//2):
            table[i][N-i-1] = table[N-i-1][i] = 0
    else:
        for i in range(N//2):
            table[i][N-i-2] = table[N-i-2][i] = 0
    size = 0
    answer = []
    for i in range(N):
        for j in range(i+1, N):
            if table[i][j]:
                answer.append((i+1, j+1))
                size += 1
    print(size)
    for a in answer:
        print(*a)


if __name__ == '__main__':
    solve()
"
"n = int(input())
a = list(map(int,input().split()))
b = []
b = a+a+b
b.sort(reverse=1)
print(sum(b[2:n])+b[0])"
"n,m = map(int,input().split())
if n == 2 or m == 2:
  print(0)
elif n == 1:
  if m == 1:
    print(1)
  else:
    print(m-2)
elif m == 1:
  if n == 1:
    print(1)
  else:
    print(n-2)
else:
  print((n-2)*(m-2))"
"n = int(input())
A = list(map(int, input().split()))

ans = float(""INF"")
for i in range(min(A), max(A)+1):
    tmp = 0
    for a in A:
        tmp += (i - a) ** 2
    ans = min(tmp, ans)

print(ans)"
"def main():
    a1, a2, a3 = map(int, input().split())
    if a1 + a2 + a3 >= 22:
        print('bust')
    else:
        print('win')
        
if __name__ == '__main__':
    main()"
"a,b=map(int,input().split())
d = a+b
e = a-b
f= a*b
g = max(d,e,f)
print(g)
"
"N,D=map(int,input().split())
X=[list(map(int,input().split())) for i in range(N)]
l=len(X)
c=0
for i in range(l):
 for j in range(i+1,l):
  t=sum((X[i][d]-X[j][d])**2for d in range(D))**0.5
  c+=t==int(t)
print(c)"
"a, b, c = [int(temp) for temp in input().split()]
Ans     = 'Yes' if a < b < c else 'No'
print(Ans)"
"input_l = input().rstrip().split(' ')
input_l = list(map(int,input_l))

if(input_l[0] > input_l[1] * 2):
    print(input_l[0]-input_l[1]*2)
else:
    print(0)"
"cmd = []
d = set()

n = int(input())
for i in range(n):
    cmd.clear()
    cmd = input().split()
    if cmd[0] =='insert':
        d.add(cmd[1])
    else:
        if cmd[1] in d:
            print('yes')
        else:
            print('no')
"
"a,b=input().split()
if a=='H':
    if b=='H':print('H')
    else: print('D')
else:
    if b=='H':print('D')
    else: print('H')
"
"import sys
from collections import deque
input = sys.stdin.readline
H, W = map(int, input().split())
S = [input()[:-1] for _ in [0]*H]
dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def bfs(h, w, H, W):
    visited = [False]*(W*H)
    q = deque()
    q.append((0, h, w))
    while q:
        d, h, w = q.popleft()
        if visited[h*W+w]:
            continue
        visited[h*W+w] = True

        for dh, dw in dirs:
            nh, nw = h+dh, w+dw
            if 0 <= nh < H and 0 <= nw < W:
                if visited[nh*W+nw] or  S[nh][nw] == '#':
                    continue
                q.append((d+1, nh, nw))
    return d, h, w

ans = 0
for h, _S in enumerate(S):
    for w, s in enumerate(_S):
        if s == '.':
            d, _, _ = bfs(h, w, H, W)
            if d > ans:
                ans = d

print(ans)
"
"N = int(input())

ans = [0 for _ in range(10**4+50)]

for x in range(1, 105):
    for y in range(1, 105):
        for z in range(1, 105):
            tmp = x**2 + y**2 + z**2 + x*y + y*z + z*x
            if tmp < 10**4+50:
                ans[tmp] += 1

for i in range(1, N+1):
    print(ans[i])"
"l=[int(input()) for i in range(4)]

if(l[0]>l[1]):
    a=l[1]*l[2]+(l[0]-l[1])*l[3]
else:
    a=l[0]*l[2]

print(a)"
"# coding: utf-8

import math

ans = []

while True:
    if int(input()) == 0:
        break
    data = list(map(int, input().strip().split()))
    ave_data = sum(data) / len(data)
    ans += [math.sqrt(sum([(i - ave_data) ** 2 for i in data]) / len(data))]
    
print('\n'.join(map(str, ans)))"
"import sys
import math
from collections import deque
from collections import defaultdict

def main():
    n,r = list(map(int,sys.stdin.readline().split()))
    if n>=10:
        ans = r
    else: ans = 100*(10-n)+r
    print(ans)
if __name__ == ""__main__"":
    main()"
"import numpy

class UnionFind:
    def __init__(self, N):
        self.N = N

        # the parent of all node is itself
        # self.parent = list(range(N))
        self.parent = [-1] * N

    def root(self, i):
        if self.parent[i] < 0:
            return i

        r = self.root(self.parent[i])
        self.parent[i] = r
        return r

    def unite(self, i, j):
        # print('root {}, {} = '.format(i, j), end='')
        i = self.root(i)
        j = self.root(j)
        # print(i, j)

        if i == j:
            return

        if i > j:
            i, j = j, i

        self.parent[i] += self.parent[j]
        self.parent[j] = i
        # print(self.parent)

    def same(self, i, j):
        return self.root(i) == self.root(j)

    def size(self, i):
        return -self.parent[self.root(i)]

N, M = map(int, input().split())
R = numpy.array([[int(r) for r in input().split()] for _ in range(M)]) - 1

forest = UnionFind(N)
for p1, p2 in R:
    forest.unite(p1, p2)

s = [forest.size(i) for i in range(N)]
print(max(s))"
"x,a,b=map(int,input().split())
ad=abs(x-a)
bd=abs(x-b)

if ad > bd:
    print(""B"")
elif ad < bd:
    print(""A"")"
"import sys
s = list(str(input()))
if len(s)<4:
    print('No')
    sys.exit()
if s[0]=='Y' and s[1]=='A' and s[2]=='K' and s[3]=='I':
    print('Yes')
else:
    print('No')"
"N = int(input())
A = list(map(int, input().split()))
memo = {1:0,2:0,4:0}

for a in A:
    if a % 4 == 0:
        memo[4] += 1
    elif a % 2 == 0:
        memo[2] += 1
    else:
        memo[1] += 1

if memo[4] >= (N//2):
    print(""Yes"")
elif memo[4] >= memo[1]:
    print(""Yes"")
else:
    print(""No"")
"
"import sys
from heapq import heappush, heappop, heapify
import math
from math import gcd
import itertools as it
from collections import deque 

input = sys.stdin.readline

def inp():
    return int(input())
def inpl():
    return list(map(int, input().split()))

INF = 1001001001

# ---------------------------------------

def main():
    n = inp()
    k = inp()
    x = inp()
    y = inp()
    if n > k:
        print(x * k + y * (n - k))
    else:
        print(x * n)

main()
"
"n, a, b = map(int, input().split(' '))
if a+b <= n:
    min_p = 0
else:
    min_p = abs(n-a-b)
max_p = min([a,b])
print(max_p, min_p)"
"print(""ACL""*(int(input())))"
"c = [list(map(int,input().split())) for i in range(3)]
for i in range(2):
    if (c[i+1][0]-c[i][0]) == (c[i+1][1]-c[i][1]) == (c[i+1][2]-c[i][2]):
        continue
    else:
        print('No')
        exit(0)
for j in range(2):
    if (c[0][j+1]-c[0][j]) == (c[1][j+1]-c[1][j]) == (c[2][j+1]-c[2][j]):
        continue
    else:
        print('No')
        exit(0)
print('Yes')
"
"import math

a, b, x = map(int, input().split())
t = 2 * b - (2 * x) / (a ** 2)
ans = 0
if t > b:
    t = 2 * x / (a * b)
    ans = math.degrees(math.atan2(b, t))
else:
    ans = math.degrees(math.atan2(t, a))
print(ans)
"
"N, H = map(int, input().split())
A = []
B = []
for i in range(N):
    a, b = map(int,input().split())
    A.append(a)
    B.append(b)
A_sorted = sorted(A, reverse=True)
B_sorted = sorted(B, reverse=True)

ans = 0
attack_sum = 0
for i in range(N):
    if B_sorted[i] >= A_sorted[0]:
        if H > attack_sum:
            attack_sum += B_sorted[i]
            ans += 1
        else:
            print(ans)
            exit(0)
    else:break
ans += - (-(H - attack_sum) // A_sorted[0])
print(ans)

"
"h, w = map(int, input().split())
a = ['#'*(w+2)] + ['#'+(input())+'#' for _ in range(h)] + ['#'*(w+2)]
for i in a:
    print(i)"
"import numpy as np
from functools import reduce
from operator import add,sub,mul,truediv
from fractions import gcd


n = int(input())

a = list(map(int,input().split()))

a = np.array(a)

a = np.insert(a,0,0)
a = np.append(a,0)

org = 0
dis = []
for i in range(1,n+2):
    org += abs(a[i]-a[i-1])
    dis.append(abs(a[i]-a[i-1]))

#print(org)
#print(dis)


for i in range(1,n+1):
    print(org - dis[i-1]-dis[i]+abs(a[i+1]- a[i-1]))
"
"#! /usr/bin/env python3
import bisect
import sys
sys.setrecursionlimit(10**9)



# Ref: https://qiita.com/takayg1/items/b7b3f7d458915bcc7a4e
class LazySegTree:
    def __init__(self, init_val, segfunc, ide_ele = 2**31 - 1):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.data = [ide_ele] * 2 * self.num
        self.lazy = [None] * 2 * self.num
        # 配列の値を葉にセット
        for i in range(n):
            self.data[self.num + i] = init_val[i]
        # 構築していく
        for i in range(self.num - 1, 0, -1):
            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])



    def propagates(self, *ids):
        for i in reversed(ids):
            v = self.lazy[i]
            if v is None:
                continue
            self.lazy[2 * i] = v
            self.lazy[2 * i + 1] = v
            self.data[2 * i] = v
            self.data[2 * i + 1] = v
            self.lazy[i] = None

    def update(self, l, r, x): # [l, r)
        *ids, = self.gindex(l, r)
        self.propagates(*ids)
        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                self.lazy[l] = x
                self.data[l] = x
                l += 1
            if r & 1:
                self.lazy[r - 1] = x
                self.data[r - 1] = x
            r >>= 1
            l >>= 1
        for i in ids:
            self.data[i] = self.segfunc(self.data[2 * i], self.data[2 * i + 1])


    def query(self, l, r): # [l, r)
        *ids, = self.gindex(l, r)
        self.propagates(*ids)

        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.data[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.data[r - 1])
            l >>= 1
            r >>= 1
        return res

    def gindex(self, l, r):
        l += self.num
        r += self.num
        lm = l >> (l & -l).bit_length()
        rm = r >> (r & -r).bit_length()

        while r > l:
            if l <= lm:
                yield l
            if r <= rm:
                yield r
            r >>= 1
            l >>= 1
        while l:
            yield l
            l >>= 1

def zarts(D,x): # 座標圧縮
    return bisect.bisect_left(D,x)
    

INF=10**20
def solve(N: int, Q: int, S: ""List[int]"", T: ""List[int]"", X: ""List[int]"", D: ""List[int]""):

    def segfunc(x,y):
        return min(x,y)

    v = [INF] * (Q+1)

    seg = LazySegTree(v,segfunc,ide_ele=INF)

    _X = list(enumerate(X))
    _X.sort(key=lambda x:x[1],reverse=True)
    for i,x in _X:
        l = zarts(D,S[i]-X[i])
        r = zarts(D,T[i]-X[i])
        
        if l == r: continue
        seg.update(l,r,X[i])
    

    for q in range(Q):
        d = q
        # print(""d"",d)
        x = seg.query(d,d+1)
        if x == INF:
            x = -1

        print(x)
    
    return

def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    S = [int()] * (N)  # type: ""List[int]""
    T = [int()] * (N)  # type: ""List[int]""
    X = [int()] * (N)  # type: ""List[int]""
    # X = [(int(),int())] * (N)  # type: ""List[int]""
    for i in range(N):
        S[i] = int(next(tokens))
        T[i] = int(next(tokens))
        X[i] = int(next(tokens))
        # X[i] = (-1 * int(next(tokens)),i)
    D = [int(next(tokens)) for _ in range(Q)]  # type: ""List[int]""
    solve(N, Q, S, T, X, D)



if __name__ == ""__main__"":
    main()
"
"N,K,S = map(int, open(0).read().split())
if S < 1000000000:
    ans = ([S]*K) + ([S+1]*(N-K))
    print(*ans)
else:
    ans = ([S]*K) + ([1]*(N-K))
    print(*ans)"
"def solve():
    N, A, B = map(int, input().split())
    print(min(A * N, B))


if __name__ == ""__main__"":
    solve()"
"import sys
sys.setrecursionlimit(10**9)
H, W = map(int, input().split())
S = [list(input()) for _ in range(H)]

cntblack, cntwhite = 0, 0
visited = [[False] * W for _ in range(H)]

def count(h, w):
    global cntblack, cntwhite
    if visited[h][w]: return
    visited[h][w] = True
    if S[h][w] == ""."": cntwhite += 1
    else: cntblack += 1
    for ny, nx in ((1,0),(0,1),(-1,0),(0,-1)):
        ny += h
        nx += w
        if not (0 <= ny < H and 0 <= nx < W): continue
        if S[ny][nx] == S[h][w]: continue
        count(ny, nx)


ans = 0
for h in range(H):
    for w in range(W):
        cntblack, cntwhite = 0, 0
        count(h, w)
        ans += cntblack * cntwhite

print(ans)
"
"import sys
import math
import bisect

def main():
    s = ''.join(sorted(list(input())))
    if s == 'abc':
        print('Yes')
    else:
        print('No')

if __name__ == ""__main__"":
    main()
"
"a, b = map(int, input().split())
print(""{} {} {:.5f}"".format(a // b, a % b, float(a / b)))
"
"W, H, x, y = map(int, input().split())

if (x==W/2) and (y==H/2):
    print((W*H)/2, 1)
else:
    print((W*H)/2, 0)"
"N, K = list(map(int, input().split()))
P = list(map(lambda x: int(x) - 1, input().split()))
C = list(map(int, input().split()))

ans = -10**9-1
for i in range(N):
    seen = [-1]*N
    cumsum = [0]*(N+1)
    now = i
    j = 0
    while seen[now] == -1:
        seen[now] = 1
        now = P[now]
        cumsum[j+1] = cumsum[j] + C[now]
        j += 1
    loop_size = j
    if K <= loop_size:
        ans = max([ans] + cumsum[1:K+1])
    else:
        if cumsum[loop_size] > 0:
            loop_n = K//loop_size - 1
            cumsum2 = cumsum[0:loop_size+1] + [x + cumsum[loop_size] for x in cumsum[1:loop_size+1]]
            score = cumsum[loop_size]*loop_n + max(cumsum2[0:loop_size+K%loop_size+1])
            ans = max(ans, score)
        else:
            ans = max([ans] + cumsum[1:loop_size+1])
print(ans)"
"from collections import Counter

N = int(input())
a = list(map(int, input().split()))

if len(set(a)) == 1 and a[0] == 0:
    print('Yes')
elif N % 3 == 0:
    l = [*Counter(a).values()]
    res = 0
    for s in set(a):
        res ^= s
    if len(l) == 3 and res == 0 and len(set(l)) == 1:
        print('Yes')
    elif len(l) == 2 and a.count(0) == N//3:
        print('Yes')
    else:
        print('No')
else:
    print('No')"
"from itertools import combinations_with_replacement as comb_rplc
n, m, q = list(map(int, input().split()))
req = [list(map(int, input().split())) for _ in range(q)]

ans = 0

for seq in comb_rplc(range(1,m+1),n):
    now = 0
    for a, b, c, d in req:
        if seq[b-1] - seq[a-1] == c:
            now += d
    ans = max(ans, now)

print(ans)"
"a = int(input())
s = ''
for i in range(a):
  s = s+""ACL""
print(s)"
"import math

def divisors(n):
    div = [n]
    for i in xrange(2,int(math.sqrt(n))+1):
        if n%i == 0:
            div.append(i)
            div.append(n/i)
    return div

n = int(raw_input())
ndiv = set(divisors(n))
mdiv = set(divisors(n-1))
count = 0
for x in ndiv:
    for k in xrange(1,41):
        if x**k > n:
            break
        if (n%x**k)==0 and (n/x**k)%x == 1:
            count += 1
            #print x
            break
count += len(mdiv)
if n==2:
    count = 1
print count"
"from itertools import product
N,M=map(int,input().split())
x,y,z = [0]*N, [0]*N, [0]*N
for i in range(N):
  x[i],y[i],z[i] = map(int,input().split())

prod= product([1,-1],repeat=3)
ans=0
for p in prod:
  s=[(p[0]*x[i]+p[1]*y[i]+p[2]*z[i]) for i in range(N)]
  s.sort(reverse=True)
  tmp=sum(s[:M])
  ans=max(ans,tmp)
print(ans)"
"N=int(input())
a=[list(map(int,input().split())) for i in range(N)]
a.sort()
print(sum(a[-1]))
"
"#!/usr/bin/env python3
import collections as cl
import sys


def II():
    return int(sys.stdin.readline())


def MI():
    return map(int, sys.stdin.readline().split())


def LI():
    return list(map(int, sys.stdin.readline().split()))


def main():
    N, K = MI()
    targets = LI()
    if N == 1:
        print(abs(targets[0]))
        return
    length = targets[K - 1] - targets[0]
    ans = length + min(abs(targets[K-1]), abs(targets[0]))
    for i in range(N-K + 1):
        length = targets[i + K - 1] - targets[i]
        cost = length + min(abs(targets[i+K-1]), abs(targets[i]))
        ans = min(ans, cost)

    print(ans)


main()
"
"a, b, c = input().split()

if a == b and a == c:
    print(""Yes"")

else:
    print(""No"")
"
"def div2_count(n):
  if n % 2 != 0: return 0
  else: return 1 + div2_count(n / 2)
 
N = int(input())
ans = 1
count = 0
 
for i in range(N, 1, -1):
  tmp = div2_count(i) 
  if tmp > count: 
    ans = i
    count = tmp
    
print(ans)"
"# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
# from decorator import stop_watch
# 
# 
# @stop_watch
def solve(N, K, Q, As):
    rev_point = [0] * (N + 1)
    for A in As:
        rev_point[A] += 1
    for rp in rev_point[1:]:
        if K - (Q - rp) > 0:
            print('Yes')
        else:
            print('No')


if __name__ == '__main__':
    # S = input()
    # N = int(input())
    N, K, Q = map(int, input().split())
    As = [int(input()) for _ in range(Q)]
    # Bs = [int(i) for i in input().split()]
    solve(N, K, Q, As)
"
"n = int(input())
list_A = list(map(int, input().split()))
list_B = list(map(int, input().split()))
ans = 0
for i in range(n):
  if list_A[i] >= list_B[i]:
    list_A[i] -= list_B[i]
    ans += list_B[i]
    list_B[i] = 0
  else:
    ans += list_A[i]
    list_B[i] -= list_A[i]
    list_A[i] = 0
    if list_B[i] > list_A[i+1]:
      ans += list_A[i+1]
      list_A[i+1] = 0
    else:
      ans += list_B[i]
      list_A[i+1] -= list_B[i]
print(ans)"
"import sys
import math
import itertools
import collections
import heapq
import re
import numpy as np

rr = lambda: sys.stdin.readline().rstrip()
rs = lambda: sys.stdin.readline().split()
ri = lambda: int(sys.stdin.readline())
rm = lambda: map(int, sys.stdin.readline().split())
rl = lambda: list(map(int, sys.stdin.readline().split()))
inf = float('inf')
mod = 10**9 + 7

n, m = rm()
print((m*1900 + (n-m)*100) * 2**m)













"
"n=int(input())
lst=[2]
lst.append(1)
for i in range (2,n+1):
  lst.append(lst[-1]+lst[-2])
print(lst[n])
"
"#!/usr/bin/env python3
n, l = map(int, input().split())
ans = 10**9
for i in range(n):
    c, t = map(int, input().split())
    if t <= l:
        ans = min(ans, c)
if ans == 10**9:
    print('TLE')
else:
    print(ans)
"
"s = list(input())
m = len(s)
for i in range(m):
  print(""x"",end="""")"
"l = [int(x) for x in input().split(' ')]
if l[0] <= l[2] and l[0] + l[1] >= l[2]:
  print(""YES"")
else:
  print(""NO"")"
"import numpy as np
import math

N = int(input())

a = list(map(int, input().split()))

avr = np.average(a)

av1 = math.floor(avr)
av2 = math.ceil(avr)

res1 = 0
res2 = 0

for num in a:
    res1 += (num - av1) ** 2
    res2 += (num - av2) ** 2

print(min(res1, res2))"
"n = int(input())
x = [int (z) for z in input().split(' ')]
tn = n - 1
for c in range(0,n):
    print(""%d"" % x[tn], end='')
    if c != n-1:
        print(' ', end='')
    tn -= 1
print('')"
"s = input()
found = 0
ans = 0
if s[0] == 'R':
    ans+=1
    if s[1] == 'R':
        ans += 1
        if s[2] == 'R':
            ans += 1
elif s[1] == 'R':
    ans +=1
    if s[2] == 'R':
        ans+=1
elif s[2] == 'R':
    ans+=1
print(ans)"
"n=int(input())
from collections import Counter as co
l=co(list(map(int,input().split()))).values()
ans=0
p=0

for i in l:
  if (i-1)%2==0:ans+=1
  else:p+=1
print(ans+p//2*2)"
"from collections import Counter
from functools import reduce
from operator import and_

n = int(input())

cs = [Counter(input()) for _ in range(n)]
enable_chars = reduce(and_, (set(c.keys()) for c in cs))

for enable_char in sorted(enable_chars):
    enable_counts = min(c[enable_char] for c in cs)
    print(enable_char * enable_counts, end="""")
print()
"
"import math as m
a,b,c=map(int,input().split())
sinc=m.sin(m.radians(c))
cosc=m.cos(m.radians(c))
h=b*sinc
d=(h**2+(a-b*cosc)**2)**(1/2)
print('{:.10f}'.format((1/2)*a*b*sinc))
print('{:.10f}'.format(b+a+d))
print('{:.10f}'.format(h))
"
"n,m = map(int, input().split())
ka = [list(map(int, input().split())) for _ in range(n)]

nums = [0]*m
for i in ka:
  for j in range(1,i[0]+1):
    nums[i[j]-1] += 1
print(nums.count(n))"
"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())
    
n, m = map(int, input().split())
graph_list = []
for _ in range(m):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    graph_list.append([a, b])

ans = n * (n - 1) // 2
ans_list = []
union = UnionFind(n)
for i, j in reversed(graph_list):
    ans_list.append(ans)
    if not union.same(i, j):
        ans -= union.size(i) * union.size(j)
    union.union(i, j)
for i in reversed(ans_list):
    print(i)"
"import sys
import math
import itertools
import collections
import heapq
import re
import numpy as np
from functools import reduce

rr = lambda: sys.stdin.readline().rstrip()
rs = lambda: sys.stdin.readline().split()
ri = lambda: int(sys.stdin.readline())
rm = lambda: map(int, sys.stdin.readline().split())
rl = lambda: list(map(int, sys.stdin.readline().split()))
inf = float('inf')
mod = 10**9 + 7

n, a, b = rm()
ans = 0
for i in range(1, n+1):
    s = sum(map(int, str(i)))
    if a <= s <= b:
        ans += i
print(ans)










"
"from scipy.special import comb
n, p = map(int, input().split())
A = list(map(int, input().split()))
cnt_o = len([a for a in A if a%2 == 1])
cnt_e = n - cnt_o
sum_comb_o = 0  # 奇数からとる組み合わせの和
for i in range(n+1):
    if p == 0 and i%2 == 0:
        sum_comb_o += comb(cnt_o, i, exact=True)
    elif p == 1 and i%2 == 1:
        sum_comb_o += comb(cnt_o, i, exact=True)
print(2**cnt_e * sum_comb_o)"
"n = int(input())

r0 = int(input())
r1 = int(input())
max = r1-r0
min = min(r0,r1)
for i in range(n-2):
    r = int(input())
    if max < r-min:
        max = r-min
    if min > r:
        min = r
print(max)"
"n, k = list(map(int, input().split()))

s = set()
for _ in range(k):
  kk = input()
  a = list(map(int, input().split()))
  for x in a:
    s.add(x)
print(n - len(s))"
"import sys
sys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python
import math
from copy import copy, deepcopy
from copy import deepcopy as dcp
from operator import itemgetter
from bisect import bisect_left, bisect, bisect_right#2分探索
#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下
from collections import deque
#deque(l), pop(), append(x), popleft(), appendleft(x)
##listでqueの代用をするとO(N)の計算量がかかってしまうので注意
from collections import Counter#文字列を個数カウント辞書に、
#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()
from itertools import accumulate,combinations,permutations#累積和
#list(accumulate(l))
from heapq import heapify,heappop,heappush
#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone
#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする
from functools import lru_cache#pypyでもうごく
#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率
from decimal import Decimal

def input(): 
    x=sys.stdin.readline()
    return x[:-1] if x[-1]==""\n"" else x
def printl(li): _=print(*li, sep=""\n"") if li else None
def argsort(s, return_sorted=False): 
    inds=sorted(range(len(s)), key=lambda k: s[k])
    if return_sorted: return inds, [s[i] for i in inds]
    return inds
def alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65
def num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)
def matmat(A,B):
    K,N,M=len(B),len(A),len(B[0])
    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]
def matvec(M,v):
    N,size=len(v),len(M)
    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]
def T(M):
    n,m=len(M),len(M[0])
    return [[M[j][i] for j in range(n)] for i in range(m)]
def main():
    mod = 1000000007
    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え

    #N = int(input())
    N, D, A = map(int, input().split())
    #A = tuple(map(int, input().split())) #1行ベクトル
    #L = tuple(int(input()) for i in range(N)) #改行ベクトル
    S = list(tuple(map(int, input().split())) for i in range(N)) #改行行列
    S.sort()
    xs=[0]*N
    hs=[0]*N
    
    for i,s in enumerate(S):
        x,h=s
        xs[i]=x
        hs[i]=h
    tot=[0]*N
    accu=0
    count=0
    for i,x in enumerate(xs):
        accu+=tot[i]
        h=hs[i]-accu*A
        num=max(0,math.ceil(h/A))
        accu+=num
        count+=num
        ei=bisect_right(xs,x+2*D)
        if ei<N:
            tot[ei]-=num
    print(count)

if __name__ == ""__main__"":
    main()"
"n, m = map(int, input().split())
s = []
c = []
for i in range(n):
  s.append(list(map(int, input().split())))
for i in range(m):
  c.append(list(map(int, input().split())))

ans = []
for i in range(n):
  d = {}
  for j in range(m):  
    d[j + 1] = abs(s[i][0] - c[j][0]) + abs(s[i][1] - c[j][1])
  d = sorted(d.items(), key=lambda x:x[1])
  ans.append(d[0][0])
for e in ans:
  print(e)"
"N = int(input())
numA = 0
numB = 0
cnt = 0
sm = 0

for i in range(N):
    mm = input()
    if mm[0]==""B"":
        numB += 1
    if mm[-1]==""A"":
        numA += 1
    if mm[0]==""B"" and mm[-1]==""A"":
        sm += 1

    for i in range(len(mm)):
        if mm[i:i+2]==""AB"":
            cnt += 1

if sm == numA and sm==numB and sm>0:
    numA -= 1
    numB -= 1
mm2 = min(numA,numB,N-1)
print(cnt+mm2)"
"N=int(input())
A=list(map(int,input().split()))

to = [0]*N

for i in range(N-1):
  if i == 0:
    SUM = A[i]
  else:
    SUM -= A[i-1]
  for j in range(min(to[i-1]+1,N-1),N):
    if SUM+A[j] != SUM^A[j]:
      to[i]=j-1
      break
    if j == N-1:
      to[i] = j
      break
    SUM += A[j]
  
print(sum([max(0,to[i]-i) for i in range(N)])+N)"
"import sys
input = sys.stdin.buffer.readline

n = int(input())
A = list(map(int, input().split()))
S = sum(A)

D = [0]*(10**5+1)
for a in A:
    D[a] += 1

q = int(input())
for i in range(q):
    b, c = map(int, input().split())
    S -= D[b]*b
    S += D[b]*c
    D[c] += D[b]
    D[b] = 0
    print(S)
"
"#-------------------------------------------------------------------------------
# coding: utf-8
# Created:     16/12/2015

import sys
io = sys.stdin

n = io.readline()

a0, a1 = [1, 1]
a2 = 1
for i in xrange(int(n)-1):
    a2 = a0 + a1
    a0, a1 = a1, a2

print a2"
"S = list(input())
l = len(S)

def judge(arr):
  l = len(arr)
  if len(arr) % 2 != 0:
    l = len(arr)
  for i in range(int(l/2)):
    if arr[i] != arr[l-1-i]:
      print(""No"")
      exit()
      
judge(S)
center = int((l-1)/2)
judge(S[0:center])
judge(S[center+1:])
print(""Yes"")"
"#!/usr/bin/env python3

X, Y = list(map(int, input().split()))
is_ok = False
for i in range(0, X + 1):
    if (i * 2 + (X - i) * 4) == Y:
        is_ok = True
        break
ans = ""Yes"" if is_ok else ""No""
print(ans)
"
"n, x, m = map(int, input().split())
ans = x
L = [0 for i in range(m+1)]
L[x] = 1

A = [x]
t = True
count = 2
while t:
    x = (x*x)%m
    if L[x] != 0:
        start = L[x]
        t = False
    else:
        L[x] = count
        count += 1
        A.append(x)

if A[-1] == 0:
    if len(A) - 1 > n:
        ans = sum(A[:n])
    else:
        ans = sum(A)

elif len(A) >= n:
    ans = sum(A[:n])
else:
    length = len(A)-start+1
    ans = sum(A[:(start-1)])
    t = (n-start+1) // length 
    s = (n-start+1) % length
    ans += sum(A[(start-1):])*t 
    ans += sum(A[start-1:(start-1+s)])
print(ans)"
"S = input()
YYMM = 0
MMYY = 0
start = S[0:2]
end = S[2:4]
tmp1 = int(start)
tmp2 = int(end)
if(tmp2 <= 12 and tmp2 != 0):
    YYMM = 1
if(tmp1 <= 12 and tmp1 != 0):
    MMYY = 1
if(YYMM == 1 and MMYY == 1):
    print(""AMBIGUOUS"")
elif(YYMM == 1):
    print(""YYMM"")
elif(MMYY == 1):
    print(""MMYY"")
else:
    print(""NA"")"
"n,m=map(int,input().split())
a=list(map(int,input().split()))
x=0
w=sum(a)
for i in range(n):
    if a[i]*4*m >= w:
        x += 1
print(""Yes"" if x>=m else ""No"")"
"N = int(input())
count = 0
for n in range(N):
  l, r = map(int,input().split())
  count += r-l+1
print(count)"
"# n=int(input())
n, k = map(int, input().split())
xl = list(map(int, input().split()))
#l=[list(input()) for i in range(h)]

if 0 in xl:
    k -= 1
else:
    xl.append(0)
    xl.sort()
if k == 0:
    ans = 0
else:
    ans = 10**9
    zeropoint = xl.index(0)
    endpoint = len(xl)-1
    startpoint = max(0, zeropoint-k)
    cur = startpoint
    while cur+k <= endpoint and cur <= zeropoint:
        # print(cur)
        # もし折り返すなら
        if cur < zeropoint < cur+k:
            tempdis = abs(xl[cur]-xl[cur+k])
            tempdis += min(abs(xl[cur]), xl[cur+k])
            ans = min(ans, tempdis)
        else:
            ans = min(ans, abs(xl[cur]-xl[cur+k]))
        cur += 1
print(ans)
"
"L = list(map(int, input().split()))
for i in range(5):
    if L[i] == 0:
        print(i+1)
        exit()"
"x = int(input())

mod = x%11
shou = x//11

if mod == 0:
    print(shou*2)
elif mod > 0 and 6 >= mod:
    print(shou*2+1)
else:
    print(shou*2+2)"
"N=input()
def alpha2num(alpha):
    num=0
    for index, item in enumerate(list(alpha)):
        num += pow(26,len(alpha)-index-1)*(ord(item)-ord('A')+1)
    return num
S=alpha2num(N)+1
num2alpha = lambda c: chr(c+64)

print(num2alpha(S))"
"import sys

input = lambda: sys.stdin.readline().rstrip()


def solve():
    N = int(input())
    if N == 1:
        print(0)
        exit()

    ans = (N) * (N - 1) // 2
    print(ans)


if __name__ == '__main__':
    solve()
"
"def main():
    MOD = 10**9 + 7
    N = int(input())
    T = [int(i) for i in input().split()]
    A = [int(i) for i in input().split()]
    if T[-1] != A[0]:
        return print(0)
    ma_idx_T = T.index(max(T))
    # print(ma_idx_T)
    if A[ma_idx_T] != T[ma_idx_T]:
        return print(0)
    non_fix = [True] * N
    non_fix[0] = False
    non_fix[-1] = False
    for i in range(1, N):
        if T[i-1] < T[i]:
            non_fix[i] = False
            ma_idx_T = i
        else:
            continue

    for i in range(N-1)[::-1]:
        if A[i] > A[i+1]:
            non_fix[i] = False
        else:
            continue
    ans = 1
    # print(non_fix)
    for i, f in enumerate(non_fix):
        if f:
            ans *= min(T[i], A[i])
            ans %= MOD
    print(ans % MOD)


if __name__ == '__main__':
    main()
"
"num = 0
x = int(input())
while num != 1:
    num = 0
    for i in range(2,x+1):
        if x%i == 0:
            num += 1
    j = x
    x += 1
print(j)"
"N,A,B,C = map(int,input().split())
l = [int(input()) for _ in range(N)]
ans = float('inf')
for i in range(2**N):
    da = [True]*N
    for j in range(N):
        if (i>>j) & 1:
            da[j] = False
    a = []
    lb = []
    for j in range(N):
        if da[j] == True:
            a.append(l[j])
        else:
            lb.append(l[j])
    #print(a,lb)
    if len(lb) >= 2:
        for j in range(2**len(lb)):
            db = [True] * len(lb)
            for k in range(len(lb)):
                if (j>>k) & 1:
                    db[k] = False
            b = []
            lc = []
            for k in range(len(lb)):
                if db[k] == True:
                    b.append(lb[k])
                else:
                    lc.append(lb[k])
            #print(db)
            if len(lc) >= 1:
                for k in range(2**len(lc)):
                    dc = [True] * len(lc)
                    for m in range(len(lc)):
                        if (k>>m) & 1:
                            dc[m] = False
                    c = []
                    for m in range(len(lc)):
                        if dc[m] == True:
                            c.append(lc[m])
                    if len(a) > 0 and len(b) > 0 and len(c) > 0:
                        #print(a,b,c)
                        ans = min(ans, 10*(len(a)-1)+abs(A-sum(a)) + 10*(len(b)-1)+abs(B-sum(b)) + 10*(len(c)-1)+abs(C-sum(c))          )
print(ans)


    
"
"def main():
  r = int(input())
    
  a = r * 2
  
  print(a * 3.14)
  
main()"
"import re
A, B = map(int, input().split())
S = input()
pattern = re.compile('[0-9]'*A + '-' +'[0-9]'*B)
print('Yes' if pattern.fullmatch(S) != None else 'No')"
"def main():
    n,k = map(int,input().split())
    a = []
    for _ in range(n):
        a.append(int(input()))

    def check(P):
        s = 0
        res = 1
        for b in a:
            if P<b:return False
            if P<s+b:
                s = b
                res+=1
            else :s+=b
        return k>=res

    l,r = 0,1000000007
    m = 0
    while l<r-1:
        m = (l+r)//2
        if check(m):r = m
        else       :l = m
    print(r)



if __name__ == '__main__':
    main()


"
"N = int(input())

ans = set()

for i in range(N):
    S = input()
    if S in ans:
        continue
    else:
        ans.add(S)

print(len(ans))"
"""""""
# 標準入力取得
## 文字列
 = sys.stdin.readline().rstrip()
 = list(sys.stdin.readline().rstrip())

## 数値
 = int(sys.stdin.readline())
 = map(int, sys.stdin.readline().split())
 = list(map(int, sys.stdin.readline().split()))
 = [list(map(int,list(sys.stdin.readline().split()))) for i in range(h)]  # 二次元配列入力　二次元マップみたいな入力のとき

# 0埋め, 小数点出力桁指定時のときの出力
a = 100
b = 0.987654321
print(""{0:06d}-{1:6f}"".format(a,b))
000100-0.987654

# 文字列をリストに格納
char_list = list(""abcd"") # [""a"",""b"",""c"",""d""]
""""""

import math
import sys
import itertools
import queue
from fractions import gcd

def lcm(a, b):
    return a * b // gcd(a, b)

mod = 1000000007

if __name__ == ""__main__"":
    t,x = map(int, sys.stdin.readline().split())
    print(float(t/x))"
"import sys
sys.setrecursionlimit(10**9)

def dfs(x): #グラフでの再帰DFS
    if dp[x] != -1:
        return dp[x] #すでに値が決まっていたらそれをかえす
    ans = 0
    for e in graph[x]: #すべての枝について
        ans = max(ans,1 + dfs(e))
    dp[x] = ans
    return ans # 最も長い距離を返す　

n,m = list(map(int, input().split()))

graph = [[] for i in range(n+1)]
dp = [-1]
for i in range(1,n+1):
    dp.append(-1) # dpは初期値-1

for _ in range(m): # グラフの作成
    a,b = map(int, input().split())
    graph[a].append(b)
    #graph[b].append(a) #無向グラフの時
    
ans=0

for i in range(1,n+1):
    ans=max(ans,dfs(i))
print(ans)"
"R, G, B, N = map(int, input().split())
def solve():
    ans = 0
    for i in range(N//R+1):
        b1 = N - i*R
        for j in range(b1//G+1):
            b2 = b1 - j*G
            if b2%B==0:
                ans += 1
    return ans
print(solve())"
"import sys
import itertools
# import numpy as np
import time
import math
import heapq
from collections import defaultdict
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())

N = int(input())
A = list(map(int, input().split()))

X = [0] * N
for i, a in enumerate(A):
    j = (N - 1 - a) // 2
    X[j] += 1

for i, x in enumerate(X):
    if x == 1 and not (i == (N + 1) // 2 - 1):
        print(0)
        exit()
    if x > 2:
        print(0)
        exit()

ans = 1
for x in X:
    if x == 0:
        break
    ans *= x
    ans %= MOD
print(ans)

"
"N = int(input())
kotae = 0
for i in range(0,N+1):
    if i%3 == 0 or  i%5 == 0:
        kotae = kotae
    else:
        kotae = kotae + i
print(kotae)"
"s = input()
if s.count(""C"")>=1 and s.count(""F"")>=1:
    if s.index(""C"")<s.index(""F"") or s.index(""C"")<len(s)-(1+s[::-1].index(""F"")):
        print(""Yes"")
    else:
        print(""No"")
else:
    print(""No"")"
"# import sys
# sys.setrecursionlimit(10 ** 6)
# import bisect
# from collections import deque
# from decorator import stop_watch
# 
# 
# @stop_watch
def solve(N, As):
    students = [(As[i], i) for i in range(N)]
    students.sort()
    ans = ''
    for n, s in students:
        ans += ' ' + str(s + 1)
    print(ans.strip())


if __name__ == '__main__':
    # S = input()
    N = int(input())
    # N, M = map(int, input().split())
    As = [int(i) for i in input().split()]
    # Bs = [int(i) for i in input().split()]
    solve(N, As)
"
"import heapq

N = int(input())
A = [list(map(int, input().split())) for _ in range(N)]

ans = 0
for i in range(N):
    for j in range(N):
        via_k = float('inf')
        for k in range(N):
            if A[i][j] > A[i][k] + A[k][j]:
                print(-1)
                exit()
            if k == i or k == j:
                continue
            via_k = min(via_k, A[i][k] + A[k][j])
        if i <= j:
            continue
        if A[i][j] < via_k:
            ans += A[i][j]
print(ans)
"
"N, K = map(int, input().split())

L = []



for i in range(10**5):
    M = N // K
    if i == 0:
        N = abs(N - K)
        L.append(N)
    else:
        if N > K:
            N = N - (K * M)
            L.append(N)
        else:
            N = abs(L[i-1] - K)
            L.append(N)


print(min(L))"
"from collections import deque

N = int(input())
A = sorted(list(map(int, input().split())), reverse=True)
s,d = 0,deque()

d.append(A[0])
for i in range(1,N):
	s += d.popleft()
	d.append(A[i])
	d.append(A[i])
print(s)"
"import numpy as np
N = int(input())
xy = [list(map(int, input().split("" ""))) for i in range(N)]

L = 0
for i in range( N ):
 for j in range( N ):
  a = xy[i][0]-xy[j][0]
  b = xy[i][1]-xy[j][1]
  l = np.sqrt( a**2 +b**2)
  L += l

print(L/N)
"
"import math
x1, y1, x2, y2 = map(float, input().split())
print(""{0:f}"".format(math.sqrt((x1-x2)**2.0 + (y1-y2)**2.0)))
"
"a, b, c = map(int,input().split())
n=3
if a==b or b==c or c==a:
  n=2
  if a==b and b==c:
    n=1

print(n)  "
"x=input().split()
a,b=int(x[0]),int(x[1])
if a<b:
    print(""a < b"")
elif a>b:
    print(""a > b"")
else:
    print(""a == b"")
"
"import sys, string

lines = []
for line in sys.stdin:
    lines.append(line)

text = ''.join(lines).lower()
    
for char in string.ascii_lowercase:
    print(""{} : {}"".format(char, text.count(char)))"
"_ =  input()

_ ,  d2 = [int(i) for i in input().split()]

if d2 == 1:
  print(1)
else:
  print(0)"
"N = int(input())
a = list(map(int,input().split()))
s = 0
for i in a:
    if i % 2 == 1:
        s += 1
if s % 2 == 0:
    print(""YES"")
else:
    print(""NO"")"
"k, x=map(int, input().split())
s=x+1-k
print(*range(s, s+(2*k-1)))"
"a,b,c,x,y=map(int,input().split())
e=max(x,y)*c*2
if x>=y:
  f=y*2*c+(x-y)*a
else:
  f=x*2*c+(y-x)*b
g=x*a+y*b
print(min(e,f,g))"
"import sys


stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


def main():
    n = ni()
    S = ns()
    ans = 0
    for i in range(1, n - 1):
        X = S[:i]
        Y = S[i:]
        tmp = len(set(X) & set(Y))
        ans = max(ans, tmp)
    print(ans)


if __name__ == '__main__':
    main()
"
"import sys
import math
def I():return int(sys.stdin.readline().replace(""\n"",""""))
def I2():return map(int,sys.stdin.readline().replace(""\n"","""").split())
def S():return str(sys.stdin.readline().replace(""\n"",""""))
def L():return list(sys.stdin.readline().replace(""\n"",""""))
def Intl():return [int(k) for k in sys.stdin.readline().replace(""\n"","""").split()]
def Lx(k):return list(map(lambda x:int(x)*-k,sys.stdin.readline().replace(""\n"","""").split()))

if __name__ == ""__main__"":
    s = S()
    s = s[::-1]
    ans = 0
    cnt = 0
    for i in range(len(s)):
        if s[i] == ""W"":
            cnt += 1
        else:
            ans += cnt
    print(ans)"
"N=int(input())
L=list(map(int,input().split()))
count=0
for i in range(N):
	x=L[i]
#	print(L[i],L[L[i]-1])
	if L[x-1]==i+1:
		count+=1
print(count//2)"
"# Vicfred
# https://atcoder.jp/contests/abc071/tasks/arc081_a
# greedy, sorting
class Counter(dict):
    def __missing__(self, i):
        return 0

n = int(input())
a = list(map(int, input().split()))

a.sort()
a.reverse()

counter = Counter()
for i in a:
    counter[i] += 1

first = -1
second = -1
for item in a:
    if second != -1:
        break;
    if counter[item] >= 2:
        if first == -1:
            first = item
            counter[item] -= 2
        elif second == -1:
            second = item

if first != -1 and second != -1:
    print(first*second)
else:
    print(0)
"
"import sys
input = sys.stdin.readline


def main():
    H, W, K = map(int, input().split())
    cake = [[0]*W for _ in range(H)]
    sb = []
    for y in range(H):
        s = input().strip()
        for x, c in enumerate(s):
            if c == ""#"":
                sb.append((y, x))
    for i, (y, x) in enumerate(sb):
        cake[y][x] = i + 1

    for i, s in enumerate(sb):
        i += 1
        y = s[0]
        x0 = x1 = s[1]
        for x in range(s[1]-1, -1, -1):
            if cake[y][x] != 0:
                break
            cake[y][x] = i
            x0 = x
        for x in range(s[1]+1, W):
            if cake[y][x] != 0:
                break
            cake[y][x] = i
            x1 = x
        for y in range(s[0]-1, -1, -1):
            if cake[y][x0:x1+1].count(0) != x1-x0+1:
                break
            for x in range(x0, x1+1):
                cake[y][x] = i
        for y in range(s[0]+1, H):
            if cake[y][x0:x1+1].count(0) != x1-x0+1:
                break
            for x in range(x0, x1+1):
                cake[y][x] = i
    for c in cake:
        print(*c)


if __name__ == '__main__':
    main()
"
"N, P = map(int, input().split())
S = list(map(int, list(input())))

l = len(S)
if P == 2:
    ans = 0
    for i in range(l):
        if S[i]%2 == 0:
            ans += i+1
elif P == 5:
    ans = 0
    for i in range(l):
        if S[i]%5 == 0:
            ans += i+1
else:
    data = [0]*P
    temp = 0
    ans = 0
    for i in range(l-1, -1, -1):
        temp += S[i]*pow(10, l-i-1, P)
        temp %= P
        ans += data[temp]
        data[temp] += 1
    ans += data[0]

print(ans)"
"lengthArray = list(map(int,input().split()))

a = lengthArray[0]*lengthArray[1]
b = lengthArray[2]*lengthArray[3]

if a<b:
  print(b)
else:
  print(a)
"
"#coding:utf-8

import sys
sys.setrecursionlimit(10**6)
write = sys.stdout.write
dbg = lambda *something : print(*something) if DEBUG else 0
DEBUG = False
def main(given = sys.stdin.readline):
    from collections import defaultdict
    input = lambda : given().rstrip()
    LMIIS = lambda : list(map(int,input().split()))
    II = lambda : int(input())
    XLMIIS = lambda x : [LMIIS() for _ in range(x)]


    P1 = 2**127-1
    P2 = 2**31-1
    P1 = 10**9*7
    P2 = 10**7-9
    base = 26
    N = II()
    S = list(map(ord,list(input())))
    pow1 = [1]*N
    pow2 = [1]*N
    for i in range(N-1):
        pow1[i+1] = pow1[i]*base%P1
        pow2[i+1] = pow2[i]*base%P2
    hash1 = [0]*(N+1)
    hash2 = [0]*(N+1)
    hash1[1] = hash2[1] = S[0]
    for i in range(2,N+1):
        hash1[i] = (hash1[i-1]*base + S[i-1]) % P1
        hash2[i] = (hash2[i-1]*base + S[i-1]) % P2
    
    def f(x):
        hashes = defaultdict(lambda : -1)
        for i in range(N-x+1):
            #S[i:i+x]
            h1 = (hash1[i+x] - hash1[i] * pow1[x]) % P1
            h2 = (hash2[i+x] - hash2[i] * pow2[x]) % P2
            if hashes[(h1,h2)] == -1:
                hashes[(h1,h2)] = i
            elif hashes[(h1,h2)] + x <= i:
                return True
        # print(hashes)
        return False
    
    ok = -1
    ng = N//2+1
    while ng-ok > 1:
        
        m = (ok+ng)//2
        # print(m)
        if f(m):
            ok = m
        else:
            ng = m
    print(ok)

if __name__ == '__main__':
    main()"
"r = float(input())
g = float(input())
print(int(r + (g - r)*2))
"
"#!/usr/bin/env python3
import sys, math, itertools, collections, bisect
input = lambda: sys.stdin.buffer.readline().rstrip().decode('utf-8')
inf = float('inf') ;mod = 10**9+7
mans = inf ;ans = 0 ;count = 0 ;pro = 1

s,w = map(int,input().split())
print(""unsafe"" if s <= w else ""safe"")"
"x=str(input())
if x == ""Sunny"":print(""Cloudy"")
elif x== ""Rainy"":print(""Sunny"")
else:
    print(""Rainy"")"
"# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


# MOD = int(1e09) + 7
MOD = 2019
INF = int(1e15)


def solve():
    S = Scanner.string()
    N = len(S)
    S = S[::-1]
    p = 1
    total = 0
    cnt = [0 for _ in range(MOD)]
    ans = 0
    for i in range(N):
        cnt[total] += 1
        total += int(S[i]) * p
        total %= MOD
        ans += cnt[total]
        p = p * 10 % MOD
    print(ans)


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


if __name__ == ""__main__"":
    main()
"
"A,B,C = map(int,input().split())
num_list = []
for i in range(A,B+1):
  if i % C == 0:
    num_list.append(i)

print(len(num_list))"
"N=int(input())
C=list(map(int,input().split()))
ans=[0]*(N+1)
for i in range(N):
  ans[C[i]]=i+1
ans.remove(0)
ans=' '.join([str(n) for n in ans])
print(ans)"
"N, T = map(int, input().split())
c = [0] * N
t = [0] * N
for i in range(N):
    c[i], t[i] = map(int, input().split())

z = zip(c, t)
z = sorted(z)
c, t = zip(*z)

for i in range(N):
    if t[i] <= T:
        print(c[i])
        exit()
print('TLE')
"
"import sys
input = sys.stdin.readline
def main():
  n=int(input())
  #a=list(map(lambda x:list(map(int,list(bin(int(x))[2:]))),input().split()))
  a=list(map(int,input().split()))
  mod=pow(10,9)+7
  bit=[0]*61
  for ai in a:
    for j in range(61):
      if ((ai>>j)&1):
        bit[j]+=1
  ans=0
  for i in range(61):# 2^iの位
    ans+=(pow(2,i,mod)*bit[i]*(n-bit[i]))%mod
    ans%=mod
  print(ans)
if __name__=='__main__':
  main()"
"o = str(input())
s = str(input())
n = """"

if not len(o) == len(s):
	for i in range(min(len(o),len(s))):
		n += o[i]
		n += s[i]

	if len(o) > len(s):
		n += o[len(o)-1]

else:
	for i in range(len(o)):
		n += o[i]
		n += s[i]
		
print(n)
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

S = str(input())
if len(S)<4:
    print('No')
elif S[:4]=='YAKI':
    print(""Yes"")
else:
    print('No')"
"import math
N,D=map(int, input().split())

if N%((2*D)+1)==0:
    print(N//((2*D)+1))
else:
    print((N//((2*D)+1))+1)"
"a,b=map(int,input().split())
print(""Impossible"" if a*b*(a+b)%3 else ""Possible"")
"
"s = input()
w = 0
for item in s:
    if item == 'o':
        w += 1

w += 15 - len(s)
if 8 <= w:
    print('YES')
else:
    print('NO')
"
"import sys
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

c = [[int(x) for x in input().split()] for _ in range(3)]

flag = 1

for a1 in range(101):
    for a2 in range(101):
        for a3 in range(101):
            if c[0][0] - a1 == c[1][0] - a2 and c[1][0] - a2 == c[2][0] - a3:
                if c[0][1] - a1 == c[1][1] - a2 and c[1][1] - a2 == c[2][1] - a3:
                    if c[0][2] - a1 == c[1][2] - a2 and c[1][2] - a2 == c[2][2] - a3:
                        flag = 0

if flag:
    print('No')
else:
    print('Yes')

"
"x = int(input())

k = 1
while True:
    if x*k % 360 == 0:
        print(k)
        exit()
    k += 1"
"a = 0

x = int(input())
y = x+1
for i in range(y):
    a = a+i
 

print(a)"
"import math
k,m=list(map(int,input().split()))
res=m*pow(m-1,k-1)
print(res)"
"n = int(input())
lst = list(map(int, input().split()))
print(max(lst) - min(lst))"
"a,b,c=map(int,input().split())
print([""No"",""Yes""][a>c>b or a<c<b])"
"l = list(input())
n = len(l)
mod = pow(10, 9) + 7
m = pow(10, 5) + 5
p2 = [1] * m
p3 = [1] * m
for i in range(1, m):
    p2[i] = (p2[i - 1] * 2) % mod
    p3[i] = (p3[i - 1] * 3) % mod
cnt = 0
ans = 0
for i in range(n):
    if l[i] == ""1"":
        ans += ((p3[n - i - 1] * p2[cnt]) % mod)
        ans %= mod
        cnt += 1
ans += p2[cnt]
ans %= mod
print(ans)"
"N = int(input())
A = list(map(int,input().split()))

def two_divisor(x):
  cnt = 0
  while x % 2 == 0:
    x //= 2
    cnt += 1
  return cnt

ans = 0
for i in range(N):
  if A[i] % 2 == 0:
    ans += two_divisor(A[i])
    
print(ans)"
"# Author: cr4zjh0bp
# Created: Sat Mar 14 09:09:09 UTC 2020
import sys
 
stdin = sys.stdin
inf = 1 << 60
mod = 1000000007
 
ni = lambda: int(ns())
nin = lambda y: [ni() for _ in range(y)]
na = lambda: list(map(int, stdin.readline().split()))
nan = lambda y: [na() for _ in range(y)]
nf = lambda: float(ns())
nfn = lambda y: [nf() for _ in range(y)]
nfa = lambda: list(map(float, stdin.readline().split()))
nfan = lambda y: [nfa() for _ in range(y)]
ns = lambda: stdin.readline().rstrip()
nsn = lambda y: [ns() for _ in range(y)]
ncl = lambda y: [list(ns()) for _ in range(y)]
nas = lambda: stdin.readline().split()

class UnionFind:
    def __init__(self, n):
        self.n = n
        self.par = [i for i in range(n)]
        self.rank = [0 for _ in range(n)]
        self._size = [1 for _ in range(n)]
        self._edges = 0

    def find(self, x):
        if self.par[x] == x:
            return x
        else:
            self.par[x] = self.find(self.par[x])
            return self.par[x]
        
    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.rank[x] < self.rank[y]:
            self.par[x] = y
            self._size[y] += self._size[x]
            self._edges += 1
        else:
            self.par[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1
            self._size[x] += self._size[y]
            self._edges += 1
    
    def size(self, x):
        x = self.find(x)
        return self._size[x]
    
    def trees(self):
        return self.n - self._edges

    def same(self, x, y):
        return self.find(x) == self.find(y)

n, m = na()
p = na()
uf = UnionFind(n)
for i in range(m):
    x, y = na()
    x -= 1
    y -= 1
    uf.unite(x, y)

d = dict()
for i in range(n):
    d[p[i] - 1] = i

ans = 0
for i in range(n):
    if uf.same(i, d[i]):
        ans += 1

print(ans)"
"a,b=map(int,input().split())

if a%2==0:
  if b%2==0:
    c=((b-1)//2-a//2+1)%2
    if c==0:
      print(b)
    else:
      if b%2==0:
        print(b+1)
      else:
        print(b-1)
  else:
    print((b//2-a//2+1)%2)
else:
  if b%2==0:
    c=(b//2-a//2-1)%2
    ans=list(format(b,""b"")[::-1])
    ans[0]=str((int(ans[0])+c)%2)
    for i,x in enumerate(format(a,""b"")[::-1]):
      ans[i]=str((int(ans[i])+int(x))%2)

    ans=str(""0b""+"""".join(ans[::-1]))
    print(int(ans,0))
    
  else:
    c=(b//2-(a+1)//2+1)%2
    if c==0:
      print(a)
    else:
      if a%2==0:
        print(a+1)
      else:
        print(a-1)"
"N,A,B,C=map(int,input().split())
X=[0,A,B,C]
L=[int(input()) for i in range(N)]
d=4**N
ans=float('inf')

for i in range(d):
  F=[0 for i in range(4)]
  cnt=[0 for i in range(4)]
  for j in range(N):
    F[i%4]+=L[j]
    cnt[i%4]+=1
    i //= 4
  p=True
  for k in range(1,4):
    if F[k]==0:
      p=False
      break
  tmp=0
  if p:
    for k in range(1,4):
      tmp+=cnt[k]*10+abs(X[k]-F[k])-10
    ans=min(ans,tmp)
print(ans)"
"import math
score = int(input())
answer = 0
gcd2 = 0
for i in range(score):
    for j in range(score):
        gcd2 = math.gcd(i+1,j+1)
        for k in range(score):
            answer += math.gcd(gcd2,k+1)
print(answer)"
"H,N = map(int,input().split())
A = sum(map(int,input().split()))

if H<=A:
  print(""Yes"")
else:
  print(""No"")"
"import sys
from collections import Counter

sys.setrecursionlimit(10**7)
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))

c = Counter(a)
c2 = [i[1] for i in c.items() if i[1] >= 2]
sum = 0
for i in c2:
    sum += i * (i - 1) // 2

for i in a:
    if c[i] - 1 >= 2:
        tmp = sum - c[i] * (c[i] - 1) // 2
        tmp += (c[i] - 1) * (c[i] - 2) // 2
        print(tmp)
    else:
        tmp = sum - c[i] * (c[i] - 1) // 2
        print(tmp)
"
"from itertools import product

N = int(input())
testimony_by = []   # i番目の人の発言を格納する(3次元リスト)
for i in range(N):
    a = int(input())
    li = []   # 発言一つ分のリスト
    for j in range(a):
        li.append(list(map(int, input().split())))
    testimony_by.append(li)
ans = 0
for bit_li in product([0, 1], repeat=N):
    is_ok = True    # 矛盾がないか
    for i in range(N):
        if bit_li[i] == 1:
            for li in testimony_by[i]:
                x, y = li
                x -= 1
                if bit_li[x] != y:
                    is_ok = False
                    break

        if not is_ok:
            break
    if is_ok:
        ans = max(ans, sum(bit_li))
print(ans)
"
"import sys
from collections import deque
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
n = int(input())
edges = [[]for _ in range(n)]
for _ in range(n-1):
    u, v, w = map(int, input().split())
    edges[u-1].append((w, v-1))
    edges[v-1].append((w, u-1))

next_v = deque([(0, 0)])
color = [-1]*n
while next_v:
    d, v = next_v.popleft()
    color[v] = d & 1
    for d2, v2 in edges[v]:
        if color[v2] != -1:
            continue
        next_v.append((d+d2, v2))
print(*color, sep='\n')
"
"n = int(input())
sum = 0
skip = -1
for i in range(1,n+1):
    sum += i
    if sum >= n:
        skip = sum - n # 超過分 skip <= n
        last = i
        break
for i in range(1,last+1):
    if i == skip:
        continue
    else:
        print(i)
"
"s = input()
if len(s) != 26:
    x = sorted(set(map(chr, range(97, 123)))-set(s))
    print(s+x[0])
else:
    num = list(map(lambda x: ord(x)-ord('a'), s))
    for i in reversed(range(25)):
        L, R = i, i+1
        if num[L] < num[R]:
            tmp = 26
            for r in num[R:]:
                if num[L] < r:
                    tmp = min(tmp, r)
            ans = num[:L]+[tmp]
            print(''.join(map(lambda x: chr(x+ord('a')), ans)))
            break
    else:
        print(-1)
"
"def resolve():
    X = int(input())
    res = (X // 11) * 2
    rem = X % 11
    if rem != 0:
        if rem <= 6:
            res += 1
        else:
            res += 2
    print(res)

if '__main__' == __name__:
    resolve()"
"import math

N,K,*AF = map(int, open(0).read().split())
A = sorted(AF[:N])
F = sorted(AF[N:],reverse=True)
left = 0
right = max(A) * max(F)
while left != right:
    mid = (left+right) // 2
    temp = 0
    for i in range(N):
        temp += max(A[i]-math.floor(mid/F[i]),0)
        if temp > K:
            left = mid + 1
            break
    else:
        right = mid
print(left)"
"import sys
sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline

n, a, b, c = map(int, input().split())
l = list(int(input()) for i in range(n))

ans = 0
mpa = mpb = mpc = 0
mp = [0,0,0]
INF = 10**4

groups = [[]*n for _ in range(3)]

def dfs(groups, parent=-1):
    groupa = groups[0]
    groupb = groups[1]
    groupc = groups[2]

    if parent == n-1:
        if len(groupa) > 0:mpa = 10 * (len(groupa)-1) + abs(sum(groupa)-a)
        else: mpa = INF

        if len(groupb) > 0:mpb = 10 * (len(groupb)-1) + abs(sum(groupb)-b)
        else: mpb = INF

        if len(groupc) > 0:mpc = 10 * (len(groupc)-1) + abs(sum(groupc)-c)
        else: mpc = INF

        return mpa+mpb+mpc

    else:
        parent+=1

        addl = [l[parent]]

        adda = dfs([groupa+addl ,groupb, groupc], parent)
        addb = dfs([groupa, groupb+addl, groupc], parent)
        addc = dfs([groupa, groupb, groupc+addl], parent)
        noadd = dfs([groupa,groupb,groupc],parent)

        return min(adda, addb, addc, noadd)

print(dfs(groups))
"
"import sys
import itertools
# import numpy as np
import time
import math
import heapq
from collections import defaultdict
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())

N = int(input())
S = input()

es = [0] * (N + 1)
ws = [0] * (N + 1)

for i, c in enumerate(S):
    if c == 'E':
        es[i + 1] = es[i] + 1
        ws[i + 1] = ws[i]
    elif c == 'W':
        ws[i + 1] = ws[i] + 1
        es[i + 1] = es[i]
    
ans = INF
for i in range(N):
    cnt = ws[i] + (es[N] - es[i + 1])
    ans = min(ans, cnt)
print(ans)
"
"n,k=map(int,input().split())
h=[int(input()) for _ in range(n)]
h.sort()
INF=2*10**9
ans=INF
for i in range(n-k+1):
	diff=h[i+k-1]-h[i]
	if ans>diff:
		ans=diff
		if ans==0:
			print(0)
			exit()
print(ans)"
"from collections import deque


def do_code():
    num = int(input())
    matrix = [[2] * (num + 1) for _ in range(num + 1)]
    honests = [set() for _ in range(num + 1)]
    unkinds = [set() for _ in range(num + 1)]
    # 人iは1〜Nのためインデックス0は使わずに1~Nで使うようにする
    for n in range(1, num + 1):
        u = set()
        h = set()
        ans = int(input())
        for a in range(ans):
            x, y = map(int, input().split("" ""))
            if y == 1:
                h.add(x)
            else:
                u.add(x)
        honests[n] = h
        unkinds[n] = u
    count = 0
    for n in range(1, 2 ** num):
        honest_set = set()
        for j in range(num):
            t = 2 ** j
            if n & t == t:
                honest_set.add(j + 1)
        th = set()
        tu = set()
        queue = deque(honest_set)
        visited = set()
        while len(queue) > 0:
            t = queue.popleft()
            if t in visited:
                continue
            visited.add(t)
            queue.extend(honests[t])
            th |= honests[t]
            tu |= unkinds[t]
        if not th.isdisjoint(tu):
            # 正直者と仮定した人の証言を集めた場合にhonest && unkindな人がいる＝矛盾
            continue
        if not honest_set.isdisjoint(tu):
            continue
        honest = max(len(th), len(honest_set))
        count = max(count, honest)
    print(count)


if __name__ == '__main__':
    do_code()
"
"a1, a2, a3 = list(map(int, input().split()))

if a1+a2+a3>21:
	print('bust')
else:
	print('win')"
"debug = False

if debug:import time
if debug:start = time.time()

n = int(input())
R = [0]*n
R_min = 10**9

for i in range(n):
    R[i] = int(input())

maximum_profit = -10**9
for i in range(1, n):
    R_min = R[i-1] if R[i-1] < R_min else R_min
    profit = R[i] - R_min
    maximum_profit = profit if profit > maximum_profit else maximum_profit
print(maximum_profit)

if debug:print(time.time() - start)"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
x,ans=0,0
for i in range(40,-1,-1):
    cnt1=0
    for j in a:
        if j>>i&1:
            cnt1+=1
    if n-cnt1>cnt1 and x+2**i<=k:
        x+=2**i
        ans+=(n-cnt1)*2**i
    else:
        ans+=cnt1*2**i
print(ans)"
"N, L = map(int, input().split())

A = list(map(int, input().split()))

ans_index = -1
for i in range(N-1):
    if A[i] + A[i+1] >= L:
        ans_index = i
        break

if ans_index == -1:
    print('Impossible')
    exit()
print('Possible')

ans_index += 1
for i in range(1, ans_index):
    print(i)
for i in range(N-1, ans_index, -1):
    print(i)

print(ans_index)
"
"n=0
t=1
def adjacent_matrix():
    global n
    n=int(input())
    v=[]
    array=[]
    for i in range(n):
        zero=[0 for i in range(n)]
        a=list(map(int,input().split()))
        a=a[2:]
        for j in a:
            zero[j-1]=1
        array.append(zero)
    return array
def dfs(array,i,d,f):
    global t
    if i == n:
        return
    else:
        if(d[i] == 0):
            d[i] = t
            t += 1
            for (j,x) in enumerate(array[i]):
                if x == 1:
                    dfs(array,j,d,f)
            f[i] = t
            t += 1
    return 


def main():
    array=adjacent_matrix()
    d=[0 for i in range(n)]
    f=[0 for i in range(n)]
    for i in range(n):
        dfs(array,i,d,f)
    for i in range(n):
        print(""{} {} {}"".format(i+1,d[i],f[i]))

if __name__ == ""__main__"":
    main()
"
"n = int(input())
ls = [(0, 0)] * n
for i in range(n):
    x, ln = map(int, input().split())
    l = x - ln
    r = x + ln
    ls[i] = (l, r)
#print(ls)

ls.sort(key=lambda x: x[1])
#print(ls)
last = -float('inf')
count = 0
for i in ls:
    if last <= i[0]:
        count += 1
        last = i[1]
print(count)"
"def main():
    from collections import deque
    N = int(input())
    A = sorted(int(input()) for _ in range(N))

    ans1 = 0
    ans2 = 0
    if N & 1:
        #W型
        a1 = sum(A[N//2+2:])*2+A[N//2+1]+A[N//2]-sum(A[:N//2])*2
        #M型
        a2 = sum(A[N//2+1:])*2-A[N//2]-A[N//2-1]-sum(A[:N//2-1])*2
        print(max(a1,a2))
    else:
        print(sum(A[N//2+1:])*2-sum(A[:N//2-1])*2-A[N//2-1]+A[N//2])










main()"
"n = int(input())
a = list(map(int, input().split()))
arr = [False] * n

for i in range(n, 0, -1):
    if sum(arr[i - 1::i]) % 2 != a[i - 1]:
        arr[i - 1] = True

if not any(arr):
    print(0)
else:
    print(sum(arr))
    ans = []
    for i, x in enumerate(arr):
        if x:
            ans.append(i + 1)
    print(*ans)"
"it = lambda: list(map(int, input().strip().split()))


def solve():
    N = int(input())
    A = it()
    cnt = 0
    for i in range(N):
        if i % 2 == 0 and A[i] % 2:
            cnt += 1
    print(cnt)

solve()"
"s = input()
n = len(s)

cnt =  0
cnt_W = 0
for i in range(n):
	if s[i] == 'W':
		cnt += i
		cnt_W += 1

res = cnt - (cnt_W - 1) * cnt_W // 2
print(res)
"
"""""""
import random
import functools
import copy
import bisect
import array
import re
import collections
import heapq
import fractions
import itertools
import string
import math
from operator import itemgetter as ig
from bisect import bisect_left, bisect_right, insort_left, insort_right
from itertools import permutations, combinations, product, accumulate, groupby
from heapq import heappush, heappop
from collections import deque, defaultdict, Counter
import sys
sys.setrecursionlimit(10 ** 7)
# import numpy as np

inf = 10 ** 20
INF = float(""INF"")
mod = 10 ** 9 + 7
dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]
ddn = dd + [(-1, 1), (1, 1), (1, -1), (-1, -1)]
ddn9 = ddn + [(0, 0)]
'''for dx, dy in dd:
        nx = j + dx; ny = i + dy
            if 0 <= nx < w and 0 <= ny < h:'''
""""""
from collections import Counter
import sys
sys.setrecursionlimit(10 ** 7)


def wi(): return list(map(int, sys.stdin.readline().split()))
# WideIntPoint


def wip(): return [int(x) - 1 for x in sys.stdin.readline().split()]


def ws(): return sys.stdin.readline().split()


def si(): return int(sys.stdin.readline())  # SingleInt


def ss(): return input()


def hi(n): return [si() for _ in range(n)]


def hs(n): return [ss() for _ in range(n)]  # HeightString


def s_list(): return list(input())


def mi(n): return [wi() for _ in range(n)]  # MatrixInt


def mip(n): return [wip() for _ in range(n)]


def ms(n): return [ws() for _ in range(n)]


def num_grid(n): return [[int(i) for i in sys.stdin.readline().split()[
    0]] for _ in range(n)]  # NumberGrid


def grid(n): return [s_list() for _ in range(n)]


def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


def lcm(a, b):
    """"""a,bの最小公倍数""""""
    return a * b // gcd(a, b)


def f(x):
    cnt = 0
    while x % 2 == 0:
        x //= 2
        cnt += 1
    return cnt


def main():
    N, M = wi()
    a = wi()

    for i in range(len(a)):
        if a[i] % 2 != 0:
            print('0')
            sys.exit()
        else:
            a[i] //= 2

    t = f(a[0])
    for i in range(N):
        if f(a[i]) != t:
            print(0)
            sys.exit()
        else:
            a[i] //= 2**t
    M //= 2**t

    l = 1
    for i in range(N):
        l = lcm(l, a[i])
        if l > M:
            print('0')
            sys.exit()

    M //= l
    ans = (M+1)//2
    print(int(ans))


if __name__ == '__main__':
    main()
"
"import sys

rl=lambda:next(sys.stdin)
rfs=lambda:rl().split()
ris=lambda:map(int,rfs())

N,M,K=ris()

adj=[{*()} for _ in range(N)]
for _ in range(M):
    A,B=ris()
    A,B=A-1,B-1
    adj[A].add(B)
    adj[B].add(A)

c=-1
cs=[c]*N
ct={}
for u in range(N):
    if cs[u]!=-1:
        continue
    c+=1
    cs[u]=c
    stk=[u]
    while stk:
        u=stk.pop()
        if c not in ct:
            ct[c]=0
        ct[c]+=1
        for v in adj[u]:
            if cs[v]!=-1:
                continue
            cs[v]=c
            stk.append(v)

ans=[0]*N
for u in range(N):
    g=ct[cs[u]]-1
    f=len(adj[u])
    ans[u]=g-f

for _ in range(K):
    A,B=ris()
    A,B=A-1,B-1
    if cs[A]==cs[B]:
        ans[A]-=1
        ans[B]-=1

print(*ans)
"
"from collections import deque
n,k=map(int,input().split())
a=list(map(int,input().split()))

asum=sum(a)


def divisor(n):
    divisors=[]
    for i in range(1,int(n**0.5+1)):
        if n%i==0:
            divisors.append(i)
            if i!=n//i:
                divisors.append(n//i)
    divisors.sort()
    return divisors
div=divisor(asum)
#print(div)
b=[0]*n

ans=0
for d in div:
    count=0
    #print(d)
    #print(a)
    for i in range(n):
        b[i]=a[i]%d
    b.sort()
    #print(b)
    que=deque(b)
    #print(que)
    while que:
        s=que.popleft()
        if s==0:
            continue
        if len(que)==0:
            count=0
            break
        g=que.pop()
        #print(s,g)
        if s==d-g:
            count+=s
        if s<d-g:
            que.append(s+g)
            count+=s
        if s>d-g:
            que.appendleft(s-d+g)
            count+=(d-g)
    #print(d,count)
    if count<=k:
        ans=d
print(ans)
"
"import sys

a, b, k = map(int, input().split())

for i in range(a, min(b, a + k)):
    print(i)

 # 左側の幅だけで全部網羅する場合
if b < a + k:
    print(b)
    sys.exit()

 # ベン図みたいにかぶってる時
for i in range(max( a + k, b + 1 - k ), b + 1):
    print(i)"
"# cording utf-8

num = int(input())
list = input().rstrip().split("" "")

num = num - 1
result = str(list[num])

for i in range(num):
    result = result + "" "" + str(list[num-1-i])

print(result)"
"n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

temp = 9999
ans = 0
for i in a:
  ans += b[i-1]
  if i - temp == 1:
    ans += c[i-2]
  temp = i
  
print(ans)"
"from collections import deque
n = int(input())
a = list(map(str, input().split()))
b = []

b = a[1::2][::-1]+a[::2]
if len(a)%2==0:
    print(' '.join(b))
else:
    print(' '.join(b[::-1]))"
"N=int(input())
C=[list(map(int,input().split()))for i in range(2)]
ans=0
for i in range(N):
	tmp=sum(C[0][:i+1])+sum(C[1][i:])
	if ans<tmp:
		ans=tmp
print(ans)"
"import math
import itertools
input_n = int(input())

def divisor(n): 
    i = 1
    table = []
    while i * i <= n:
        if n%i == 0:
            table.append(i)
            table.append(n//i)
        i += 1
    table = list(set(table))
    return table
yakusu_list = divisor(input_n)
yakusu_list.sort()

if (len(yakusu_list) % 2) == 1:
  tmp = yakusu_list[len(yakusu_list)//2 + 1 -1] + yakusu_list[-(len(yakusu_list)//2 + 1)]
  print(tmp -2)
else:
  tmp = yakusu_list[len(yakusu_list)//2 - 1] + yakusu_list[-(len(yakusu_list)//2)]
  print(tmp -2)

"
"n=input()[-1];print([['hon','bon'][n=='3'],'pon'][n in [*'0168']])"
"# B fLIP
n,m,k=map(int,input().split())

for h in range(n+1):
    for w in range(m+1):
        black=m*h+n*w-2*h*w
        if black==k:
            print('Yes')
            exit()
print('No')"
"class UnionFind():
    def __init__(self,n):
        self.n=n
        self.root=[-1]*n
        self.rank=[-1]*n

    def Find_Root(self,x):
        if self.root[x]<0:return x
        else:
            self.root[x]=self.Find_Root(self.root[x])
            return self.root[x]

    def Unite(self,x,y):
        x=self.Find_Root(x)
        y=self.Find_Root(y)

        if x==y:return
        elif self.rank[x]>self.rank[y]:
            self.root[x] +=self.root[y]
            self.root[y]=x
        else:
            self.root[y] +=self.root[x]
            self.root[x]=y
            if self.rank[x]==self.rank[y]:
                self.rank[y] +=1

    def isSameGroup(self,x,y):
        return self.Find_Root(x)==self.Find_Root(y)

    def size(self,x):
        return -self.root[self.Find_Root(x)]

    def members(self,x):
        root=self.Find_Root(x)
        return [i for i in range(self.n) if self.Find_Root(i)==root]

    def address(self):
        return[i for i,j in enumerate(self.root) if j<0]

    def group_members(self):
        return {i:self.members(i) for i in self.address()}


n,m=map(int,input().split())
P=list(map(int,input().split()))
XY=[list(map(lambda x: int(x)-1,input().split())) for _ in range(m)]

UnionFind=UnionFind(n)
for x,y in XY:
    UnionFind.Unite(x,y)

cnt=0
for num,p in enumerate(P):
    if UnionFind.isSameGroup(num,p-1):
        cnt +=1

print(cnt)"
"A=[list(map(int,input().split())) for _ in range(3)]
N=int(input())
b=[int(input()) for _ in range(N)]
G=[['*']*3,['*']*3,['*']*3]
for i in range(3):
  for j in range(3):
    if A[i][j] not in b:
      G[i][j]=A[i][j]

if G[0][0]==G[1][1]==G[2][2]=='*':
  print('Yes')
  exit()
elif G[0][2]==G[1][1]==G[2][0]=='*':
  print('Yes')
  exit()
else:
  for i in range(3):
    if G[i][0]==G[i][1]==G[i][2]=='*':
      print('Yes')
      exit()
    elif G[0][i]==G[1][i]==G[2][i]=='*':
      print('Yes')
      exit()

print('No')"
"A,B,C,X,Y = map(int, input().split())

l = []

#パターン１ AとBだけ作るとき
price1 = A * X + B * Y
l.append(price1)

#パターン2 AB分割とあまり調整
if X > Y:
    if A < 2*C:
        price2 = 2 * Y * C + A * abs(X-Y)
        l.append(price2)
    else:
        price3 = 2 * Y * C + C * abs(X-Y) * 2
        l.append(price3)
elif X < Y:
    if B < 2*C:
        price4 = 2 * X * C + B * abs(Y-X)
        l.append(price4)
    else:
        price5 = 2 * X * C + C * abs(Y-X) * 2
        l.append(price5)

else:
    price6 = 2 * X * C
    l.append(price6)


print(min(l))"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
f=list(map(int,input().split()))
a.sort()
f.sort()
f.reverse()

l,r=-1,10**12
while r-l!=1:
  t=(l+r)//2
  c=0
  for i in range(n):
    c+=max(a[i]-t//f[i],0)
  if c<=k:
    r=t
  else:
    l=t
print(r)"
"import sys

sys.setrecursionlimit(10**9)
input = sys.stdin.readline

def ii(): return int(input())
def mi(): return map(int, input().split())
def lmi(): return list(map(int, input().split()))
def lmif(n): return [list(map(int, input().split())) for _ in range(n)]
def ss(): return input().split()

def main():
    L, R = mi()

    mod = 2019
    min_mod = mod
    if R - L >= mod:
        print(0)
        return
    
    for i in range(L, R+1):
        for j in range(i+1, R+1):
            if i * j % mod < min_mod:
                min_mod = i * j % mod
        
    print(min_mod)

    return

main()
"
"a = int(input())

b = int(input())

c = (b-a) + b

print(c)
"
"#普通にソートしてから、配列のK個づつ区切ってパターンを調べればN - K + 1回の比較で行ける

N, K = map(int, input().split())
h = [int(input()) for _ in range(N)]
h.sort()

distances = [h[i + K -1] - h[i] for i in range(N -K + 1)]
ans = min(distances)
print(ans)"
"import itertools
import math
import fractions
import functools
import copy

p,q,r = map(int, input().split())
print(p+q+r-max(p,q,r))"
"S = str(input())

# バスが運行することになる駅の組み合わせが存在する場合は Yes を、存在しない場合は No を出力せよ。

if len(set(S)) == 1:
    print(""No"")
else:
    print(""Yes"")"
"import math
from math import gcd
INF = float(""inf"")

import sys
input=sys.stdin.readline
import itertools
from collections import Counter

def main():
    def isPrime(n):
        if n == 2:
            return True
        if n%2 == 0:
            return False
        m = math.floor(math.sqrt(n))+1
        for p in range(3,m,2):
            if n%p == 0:
                return False
        return True

    x = int(input())
    while True:
        if isPrime(x):
            print(x)
            exit()
        x += 1

if __name__==""__main__"":
    main()
"
"#!/usr/bin/python3
 
cmdvar_N=int(input())
tmp=cmdvar_N
for i in 2,3:
    tmp=tmp+cmdvar_N**i

print(tmp)"
"H = int(input())
count = 0
while H > 1:
  H = H // 2
  count += 1
print(2**(count+1)-1)"
"S = input()
l = len(S) - 1
ans=0
for i in range(2 ** l):
    op = [""-""] * l
    for j in range(l):
        if ((i >> j) & 1):
            op[l - 1 - j] = ""+""
    formula = """"
    for j in range(l):
        formula+=S[j]
        if op[j]==""+"":
            formula+=""+""
    formula+=S[l]
    ans+= eval(formula)
print(ans)"
"#!/usr/bin/env python3
import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
n = int(input())
a = list(map(int,input().split()))
a.sort()
print(a[-1]-a[0])
"
"h, w = map(int, input().split())
a = []
for _ in range(h):
    a.append(input())

pos = (0, 0)
pre = 1
nxt = 0
while pos!=(w-1, h-1):
    x, y = pos
    if x<w-1 and a[y][x+1]=='#':
        nxt += 1
        pos = (x+1, y)
    if y<h-1 and a[y+1][x]=='#':
        nxt += 1
        pos = (x, y+1)
    if x>0 and a[y][x-1]=='#':
        pre += 1
    if y>0 and a[y-1][x]=='#':
        pre += 1
    if nxt!=1 or pre!=1:
        print('Impossible')
        break
    pre = 0
    nxt = 0
else:
    tmp = 0
    for i in a:
        tmp += i.count('#')
    if tmp!=h+w-1:
        print('Impossible')
    else:
        print('Possible')"
"a, b, c, d = (int(x) for x in input().split())
dis1 = abs(a-b)
dis2 = abs(b-c)
dis3 = abs(a-c)
if dis3 <= d or (dis1 <= d and dis2 <= d):
    print('Yes')
else:
    print('No')"
"def main():
    from bisect import bisect_right

    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    A.sort()

    def calc(x):
        tmp = 0
        for a in A:
            tmp += N - bisect_right(A, x - a - 0.5)
        return tmp

    l = 0
    r = 3 * 10 ** 5
    while r - l > 1:
        mid = (l + r) // 2
        if calc(mid) >= M:
            l = mid
        else:
            r = mid

    B = [0] * (N + 1)
    for i in range(N):
        B[i + 1] = B[i] + A[i]

    ans = 0
    for a in A:
        tmp = bisect_right(A, r - a - 0.5)
        M -= (N - tmp)
        ans += a * (N - tmp) + (B[-1] - B[tmp])

    ans += M * l
    print (ans)

if __name__ == '__main__':
    main()"
"a,b,c = map(int,input().split())
arr = [a,b,c]
arr.sort()
list.sort(arr, reverse=True)
tmp = abs(arr[0] - arr[1])
tmp += abs(arr[1] - arr[2])
print(tmp)"
"while True:
    H, W = map(int, input().split())
    if H == 0 and W == 0:
        break
    print(""\n"".join(["""".join([""#"" for w in range(W)]) for h in range(H)])+""\n"")"
"# n, m, l = map(int, input().split())

# list_n = list(map(int, input().split()))

# n = input()
# list = [input() for i in range(N)

# list = [[i for i in range(N)] for _ in range(M)]

import sys
input = sys.stdin.readline

N, M = map(int, input().split())
LikeL = []
for i in range(N):
    temp = list(map(int, input().split()))
    temp.pop(0)
    LikeL.append(temp)

ans = 0
for Mi in range(M):
    all = True
    for i in range(N):
        if not(Mi+1 in LikeL[i]):
            all = False
            break
    if all:
        ans += 1
print(ans)
"
"import sys
input = sys.stdin.readline

N, K = map(int, input().split())
nums = [[] for i in range(N)]
for i in range(N):
    t, d = map(int, input().split())
    t -= 1
    nums[t].append(d)
maxs = []
rest = []
for i in range(N):
    nums[i].sort(reverse=True)
    if len(nums[i]) > 0:
        maxs.append(nums[i][0])
        for n in nums[i][1:]:
            rest.append(n)
        #rest = rest + nums[i][1:]
maxs.sort(reverse=True)
if len(maxs) > K:
    maxs = maxs[:K]
    for n in maxs[K:]:
        rest.append(n)
    #rest = rest + maxs[K:]
rest.sort(reverse=True)
other = []
idx = 0
while len(maxs)+len(other) < K:
    other.append(rest[idx])
    idx += 1
rest = rest[idx:]

types = len(maxs)
#print(maxs)
#print(rest)
for i,r in enumerate(rest):
    diff = types*types - pow(types-1, 2)
    if diff < r-maxs[len(maxs)-1-i]:
        maxs[len(maxs)-1-i] = r
        types -= 1
    else:
        break
ans = types*types
for num in maxs:
    ans += num
for num in other:
    ans += num
print(ans)
"
"a, b, c, d = map(int,input().split())

l=[1,9,7,4]
if a in l and b in l and c in l and d in l and len(set([a,b,c,d]))==4:
    print('YES')
else:
    print('NO')"
"k,s = map(int,input().split())
ans = 0
for i in range(k+1):
    for j in range(k+1):
        dum = (s - (i + j))
        if dum < 0:
            continue
        if dum <= k:
            ans += 1
print(ans)"
"N = int(input())
li = list(map(int,input().split()))
li.sort(reverse = True)
al = 0
bob = 0
for i in range(N):
  if i % 2 == 0:
    al = al + li[i]
  else:
    bob = bob + li[i]
an = al - bob
print(an)"
"S=list(input())

start=-1
last=-1

for i in range(len(S)):
  if S[i]==""A"":
    start=i
    break

for j in reversed(range(0,len(S))):
  if S[j]==""Z"":
    last=j
    break

print(last-start+1)
"
"def func(S, T):
    ans = T + S
    return ans


if __name__ == ""__main__"":
    S, T = input().split()
    print(func(S, T))
"
"import sys
input = sys.stdin.readline

n,k=map(int,input().split())
L=list(map(int,input().split()))

ans=[]
for i in range(k,n):
    if L[i]>L[i-k]:
        print('Yes')
    else:
        print('No')
            
"
"N, M, X = map(int, input().split())
A = list(map(int, input().split()))

left = 0
right = 0
for i in range(M):
  if A[i] > X:
    right += 1
  else:
    left += 1
    
print(min(left, right))"
"S = input()
now = S[0]
cnt = 0
for s in S:
    if now == s:
        continue
    cnt += 1
    now = s
print(cnt)"
"while True:
    n, x = map(int, input().split())
    count = 0
    if n == x == 0:
        break
    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            for k in range(j + 1, n + 1):
                if i + j + k == x:
                    count += 1
    print(count)

"
"w,h,n=map(int,input().split())

y_max,x_max=h,w
y_min,x_min=0,0

for i in range(n):
  x,y,a=map(int,input().split())
  if a==1:
    x_min=max(x_min,x)
  elif a==2:
    x_max=min(x_max,x)
  elif a==3:
    y_min=max(y_min,y)
  elif a==4:
    y_max=min(y_max,y)

width=max(x_max-x_min,0)
height=max(y_max-y_min,0)

print(int(width*height))



"
"import sys

N, X, M = map(int, sys.stdin.readline().split())

def f(x, m):
    return x**2 % m

a = []
a.append(X)

exists = set()
exists.add(X)
ans = a[0]
for i in range(1, N):
    tmp = f(a[i-1], M)
    if tmp in exists:
        start = a.index(tmp)
        # print(""start"", start)
        break
    ans += tmp
    a.append(tmp)
    exists.add(tmp)
else:
    # ループ未満で終了する場合
    print(ans)
    sys.exit()

# print(a)
# print(""ans"", ans) 
 
before_score = sum(a[:start])
# print(""before_score"", before_score)

loop = a[start:]
# print(loop)
loop_score = sum(loop)
# print(""loop_score"", loop_score)
loop_n = len(loop)
N -= start
res_n = N % loop_n
print(before_score + loop_score * (N // loop_n) + sum(loop[:res_n]))"
"a=int(input())
b,c=input().split()
d=""""
for i in range(a):
  d=d+b[i]+c[i]
print(d)"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
sys.setrecursionlimit(10**7)
from pprint import pprint as pp
from pprint import pformat as pf
# @pysnooper.snoop()
#import pysnooper # debug

import math
#from sortedcontainers import SortedList, SortedDict, SortedSet # no in atcoder
import bisect



class ModInt(int):

    MOD = None

    def __add__(self, other):
        self = ModInt(int.__add__(self, other) % ModInt.MOD)
        return self

    def __mul__(self, other):
        self = ModInt(int.__mul__(self, other) % ModInt.MOD)
        return self

def make_2d_arr(s1, s2, default=0):
    a = [None] * s1
    for i, _ in enumerate(a):
        a[i] = [default] * s2
    return a


if __name__ == '__main__':
    n, s = list(map(int, input().split()))
    data = list(map(int, input().split()))

    ModInt.MOD = 998244353
    dp = [ModInt(0)] * (s + 1)
    dp[0] = 1
    dp_arr = [dp, dp[:]]
    frm = 0
    to = 1

    for i in range(n):
        frm, to = to, frm
        for v in range(s + 1):
            dp_arr[to][v] = dp_arr[frm][v] * 2
            src = v - data[i]
            if src >= 0:
                dp_arr[to][v] += dp_arr[frm][src]
    #print('dp_arr') # debug
    #pp(dp_arr) # debug
    print(dp_arr[to][s])




    #print('\33[32m' + 'end' + '\033[0m') # debug
"
"import collections
N = int(input())
A = list(map(int,input().split()))
B = collections.Counter(A)
num = 0
for i in set(A):
    if B[i] > 1:
        num += B[i]*(B[i] - 1)//2
for i in A:
    print(num-B[i]+1)"
"N, K = map(int, input().split())
p = list(map(int, input().split()))
p = sorted(p, reverse=False)

sum = 0

for i in range(K):
    sum += int(p[i])
print(sum)"
"def main():
    n = int(input())
    ans = 0
    for i in range(1, n+1):
        x = len(str(i))
        if x % 2:
            ans += 1
    print(ans)

main()"
"weather = input()

seq = 0
prev = False
for i in range(3):
    if weather[i] == 'R':
        if prev:
            seq += 1
            prev = True
        else:
            seq = 1
            prev = True
    else:
        prev = False
            
print(seq)"
"# import time

N, K, C = list(map(int, input().split()))
S = list(input())

F = []
L = []

# t1 = time.time()
# for i in range(N):
#     if S[i] == 'o':
#         if len(F) == 0:
#             F.append(i)
#         elif F[-1] + C < i:
#             F.append(i)
#     if len(F) >= K:
#         break
# print(F)
# t2 = time.time()
i = 0
while len(F) <= K and i < N:
    if S[i] == 'o':
        if len(F) == 0:
            F.append(i)
        elif F[-1] + C < i:
            F.append(i)
    i += 1
# print(F)
# t3 = time.time()

# print(t2 - t1, t3 - t2)

i = N - 1
while len(L) <= K and i >= 0:
    if S[i] == 'o':
        if len(L) == 0:
            L.append(i)
        elif L[-1] - C > i:
            L.append(i)
    i -= 1

if len(F) == K and len(L) == K:
    ans = [i + 1 for i in set(F) & set(L)]
    if len(ans) != 0:
        ans.sort()
        [print(i) for i in ans]"
"n = int(input())
A = [0] + list(map(int, input().split())) + [0]
C = []
c = 0
for i in range(n+1):
  c += abs(A[i+1] - A[i])
for i in range(1, n+1):
  if A[i-1] <= A[i] <= A[i+1] or A[i+1] <= A[i] <= A[i-1]:
    print(c)
  elif A[i] <=A[i-1] <= A[i+1] or A[i] <= A[i+1] <= A[i-1]:
    print(c - abs(min(A[i-1], A[i+1]) - A[i])*2)
  elif A[i-1] <= A[i+1] <= A[i] or A[i+1] <= A[i-1] <= A[i]:
    print(c - abs(A[i] - max(A[i+1], A[i-1]))*2)"
"n = int(input())
s = input()
L = """"
R = """"
C = """"
tmp = 0
ans = []
for i in range(1, len(s)):
    L = s[:i]
    R = s[i:]
    C = len(set(L) & set(R))
    ans.append(C)
    L = """"
    R = """"
print(max(ans))"
"n, m = map(int, input().split())
a = []
b = []

for i in range(n):
    a.append([int(s) for s in input().split()])
for j in range(m):
    b.append([int(input())])

for x in range(n):
    sum = 0
    for y in range(m):
        sum += a[x][y] * b[y][0]
    print(sum)"
"n,l=map(int,input().split())
a=10*10
b=int(n*(n+2*l-1)/2)
for i in range(1,n+1):
    if abs(b-a)>abs(l+i-1):
        a=(b-l-i+1)
print(a)"
"from collections import deque

def main():
    n = int(input())
    adjacent = [[] for _ in range(n)]
    for _ in range(n - 1):
        a, b, c = map(int, input().split())
        adjacent[a - 1].append((b - 1, c))
        adjacent[b - 1].append((a - 1, c))
    q, k = map(int, input().split())
    next_search = deque([k - 1])
    searched = set()
    dist = [10**20] * n
    dist[k - 1] = 0
    while next_search:
        p = next_search.popleft()
        if p in searched:
            continue
        searched.add(p)
        for pp, d in adjacent[p]:
            dist[pp] = min(dist[p] + d, dist[pp])
            next_search.append(pp)
    for _ in range(q):
        x, y = map(int, input().split())
        print(dist[x - 1] + dist[y - 1])

if __name__ == '__main__':
    main()"
"(n,), *z = [[*map(int, o.split())] for o in open(0)]
if n == 1:
    print(1)
    exit()
from itertools import*
from collections import*
print(n - Counter((z[i][0] - z[j][0], z[i][1] - z[j][1]) for i, j in permutations(range(n), 2)).most_common()[0][1])"
"n = input()

powers10 = [10**i for i in range(1, 6)]
print(10 if int(n) in powers10 else sum(int(d) for d in n))
"
"nhw = input().split()
n = int(nhw[0])
h = int(nhw[1])
w = int(nhw[2])

ablist = []
for i in range(n):
    ab = input().split()
    a = int(ab[0])
    b = int(ab[1])
    ablist.append((a, b))


count = 0
for a, b in ablist:
    if a >= h and b >= w:
        count += 1

print(count)
"
"N = input()
N_list = []
for i in N:
    N_list.append(int(i))

if sum(N_list) % 9 == 0:
    print(""Yes"")
else: print(""No"")"
"if __name__ == ""__main__"":
    N = int(input())
    A = sorted(list(map(int, input().split())))
    ans = 1
    for i in range(N):
        ans *= A[i]
        if ans > 10**18:
            print(-1)
            break
    else:
        print(ans)
"
"x = int(input())

import math
primes=[2]
def isPrime(n):
  if n == 2:
    return True
  if n % 2 == 0:
    return False
  
  m = math.floor(math.sqrt(n))
  for p in primes:
      if n % p == 0:
        return False
      if p > m:
        break
  primes.append(n)
  return True

for i in range(2,x):
  isPrime(i)

n = x
while(True):
  if isPrime(n):
    print(n)
    exit(0)
  elif n > 10**6:
    exit(0)
  n += 1
"
"heightlist = list()
for i in range(10):
	heightlist.append(eval(input()))
heightlist.sort()
for i in range(-1, -4, -1):
	print(heightlist[i])"
"a,b,c,x,y = map(int,input().split())
ab = 2*c
if ab < a+b:
    if x <= y:
        print(min(c*2*(max(x,y)),ab*x+b*(y-x)))
    else:
        print(min(c*2*(max(x,y)),ab*y+a*(x-y)))
else:
    print(a*x+b*y)"
"import sys
sys.setrecursionlimit(10**9)
n=int(input())
l=[[] for i in range(n)]
C=[0]*n
for i in range(n-1):
    a,b,c=map(int,input().split())
    a-=1
    b-=1
    l[a].append([b,c])
    l[b].append([a,c])
def dfs(now,par,cost):
    C[now]=cost
    L=l[now]
    for i in range(len(L)):
        if L[i][0]==par:
            continue
        dfs(L[i][0],now,cost+L[i][1])
Q,K=map(int,input().split())
K-=1
dfs(K,K,0)
for i in range(Q):
    x,y=map(int,input().split())
    x-=1
    y-=1
    print(C[x]+C[y])"
"N = int(input())
A = list(map(int,input().split()))
A.sort()
ans = 0
for i in range(N):
    ans += A[3*N-(i+1)*2]
print(ans)"
"a,b,c,d=map(int,input().split())
e=a*b
o=c*d
if e<=o:
    print(o)
else:
    print(e)"
"import numpy as np

N = int(input())
xy = [list(map(int, input().split())) for _ in range(N)]

xy45 = [[xy[i][0] - xy[i][1], xy[i][0] + xy[i][1]] for i in range(N)]
xy45 = np.array(xy45)

print(max(max(xy45[:, 0]) - min(xy45[:, 0]), max(xy45[:, 1]) - min(xy45[:, 1])))
"
"a,b,c = map(int,input())
if a == 7:
    print(""Yes"")
elif b == 7:
    print(""Yes"")
elif c == 7:
    print(""Yes"")
else:
    print(""No"")"
"S = input()
k1 = k2 = 0
for i in S[::-1]:
  if i == 'W':
    k2 += 1
  else:
    k1 += k2
print(k1)"
"from itertools import product
n, a, b, c = map(int, input().split())
l = [int(input()) for _ in range(n)]
ans = 1001001001
for x in product(range(4), repeat=n):
    s = [0] * 4
    t = -3
    for i in range(n):
        t += x[i] < 3
        s[x[i]] += l[i]
    s.pop()
    if 0 in s:
        continue
    ans = min(ans, t * 10 + abs(s[0] - a) + abs(s[1] - b) + abs(s[2] - c))
print(ans)
"
"def modpow(a, n, m):
    r = 1
    while n > 0:
        if n & 1:
            r = r*a % m
        a = a*a % m
        n >>= 1
    return r

N = int(input())
X = input()
d = sum([y == '1' for y in X])
A,B = 0,0
f = list([0 for _ in range(N+1)])

for i in range(N):
	if X[i] == '1':
		if not d==1:
			A += modpow(2, N-i-1, d-1)
		B += modpow(2, N-i-1, d+1)
	t,c = i+1,0
	for j in range(18):
		if t & 1<<j:
			c += 1
	f[t] = f[t%c]+1

for i in range(N):
	c = 0
	if X[i]=='1' and not d==1:
		c = f[(A-modpow(2,N-i-1,d-1))%(d-1)]+1
	elif X[i] == '0':
		c = f[(B+modpow(2,N-i-1,d+1))%(d+1)]+1
	print(c)"
"def main():
    a, b, n = map(int, input().split())
    if b - 1<= n:
        print((a*(b-1))//b)
    else:
        print((a*n)//b)

if __name__ == '__main__':
    main()"
"
import numpy as np
from collections import deque

def parse():
  H, W = map(int, input().split("" ""))
  grid = [list(input()) for y in range(H)]
  return H, W, grid

def print_grid(grid):
  H = len(grid)
  print(""grid:"")
  for line in grid:
    for c in line:
      print(c, end="""")
    print("""")

def main():
  H, W, grid = parse()
  # print(H, W)
  # print_grid(grid)

  dark_points = [(x + 1, y + 1) for x in range(W) for y in range(H) if grid[y][x] == ""#""]

  visited = [[True] * (W + 2)]
  visited += [[True] + [False for x in range(W)] + [True] for y in range(H)]
  visited.append([True for x in range(W + 2)])
  # for y in range(H + 2):
  #   print(visited[y])
  # exit(0)
  for x, y in dark_points:
    visited[y][x] = True
  
  # visited = np.zeros((H, W), int)
  # for y in range(H):
  #   for x in range(W):
  #     if grid[y][x] == ""."":
  #       visited[y][x] = H * W

  # for y in range(1, H):  # ↓
  #   visited[y][:] = np.minimum(visited[y][:], visited[y - 1][:] + 1)

  # for y in range(H - 2, -1, -1):
  #   visited[y, :] = np.minimum(visited[y, :], visited[y + 1][:] + 1)

  # for x in range(1, W):
  #   visited[:, x] = np.minimum(visited[:, x], visited[:, x - 1] + 1)

  # for x in range(W - 2, -1, -1):
  #   visited[:, x] = np.minimum(visited[:, x], visited[:, x + 1] + 1)

  # print(dark_points)
  # exit(0)

  q = dark_points
  ans = 0
  while len(q) > 0:
    ans += 1
    next_q = []
    for x, y in q:
      if not visited[y - 1][x]: # 上
        visited[y - 1][x] = ans
        next_q.append((x, y - 1))
      if not visited[y + 1][x]: # 下
        visited[y + 1][x] = ans
        next_q.append((x, y + 1))
      if not visited[y][x - 1]: # 左
        visited[y][x - 1] = ans
        next_q.append((x - 1, y))
      if not visited[y][x + 1]: # 右
        visited[y][x + 1] = ans
        next_q.append((x + 1, y))
      
    # for y in range(H + 2):
    #   print(visited[y])
    # input()
    
    q = next_q

  print(ans - 1)

if __name__ == ""__main__"":
  main()"
"n, m=map(int, input().split())
l=[]
for i in range(n):
  l.append(list(map(int, input().split())))
l = sorted(l, reverse=False)  
#print(l)
drinks=0
ttl=0
add=0
for i in range(n):
  add=min(m-drinks, l[i][1])
  ttl=ttl+add*l[i][0]
  drinks+=add
  if drinks==m:
    print(ttl)
    exit()
"
"n = int(input())
b = list(map(int, input().split()))
a = [b[0],b[n-2]]
for i in range(n-2):
    a.append(min(b[i],b[i+1]))
print(sum(a))"
"N, A, B = map(int, input().split())

ans_min = B + A * (N - 1)
ans_max = B * (N - 1) + A

ans = max(0, ans_max - ans_min + 1)

print(ans)"
"while True:
    ( x, y) = [ int(i) for i in input().split()]
    if x == 0 and y == 0:
        break
    else:
        if x > y:
            tmp = x
            x = y
            y = tmp
        print( '{0} {1}'.format( x, y))"
"def resolve():
  d, n = map(int, input().split())
  if d == 0:
    if n == 100:
      print(101)
    else:
      print(n)
    return
  
  if d == 1:
    if n == 100:
      print(10100)
    else:
      print(100 * n)
    return

  if d == 2:
    if n == 100:
      print(1010000)
    else:
      print(10000 * n)
    return

  return

if __name__ == ""__main__"":
  resolve()
"
"from sys import stdin
nii=lambda:map(int,stdin.readline().split())
lnii=lambda:list(map(int,stdin.readline().split()))

a,b=nii()
ans=0
for i in range(a,b+1):
  s=str(i)
  if s==s[::-1]:
    ans+=1

print(ans)"
"h, w = map(int, input().split())
arr = [''] * h
for i in range(h):
  arr[i] = input()
for e in arr:
  print(e)
  print(e)"
"h, w, k = map(int, input().split())
c = []
for i in range(h):
  c.append(list(input()))

ans = 0

for row in range((1 << h) - 1): #2^h - 1
  for col in range((1 << w) - 1): #2^w -1
    black = 0
    for i in range(h):
      for j in range(w):
        if (row >> i) & 1 == 0 and (col >> j) & 1 == 0 and c[i][j] =='#':
           black += 1
    if black == k:
      ans += 1

print(ans)
"
"import bisect
import collections
import functools
import heapq
import math
import sys
from collections import deque
from collections import defaultdict
input = sys.stdin.readline
MOD = 10**9+7

N = int(input())
S1 = list(input())
S2 = list(input())
a = []
now = 0
while now < N:
    if S1[now] == S2[now]:
        a.append(""s"")
        now += 1
    else:
        a.append(""d"")
        now += 2

for i in range(len(a)):
    if i == 0:
        if a[i] == ""s"":
            ans = 3
        else:
            ans = 6
    else:
        if a[i-1] == ""s"":
            ans *= 2
        else:
            if a[i] == ""d"":
                ans *= 3

print(ans%MOD)"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7 
#mod = 998244353
from decimal import *
#import numpy as np
#decimal.getcontext().prec = 10

H, W = MAP()
s = [input() for _ in range(H)]

cnt = [[-1]*W for _ in range(H)]

if s[0][0] == ""."":
	cnt[0][0] = 0
else:
	cnt[0][0] = 1

dy = [0, 1]
dx = [1, 0]

q = deque([(0, 0)])
while q:
	y, x = q.popleft()
	for i in range(2):
		ny = y + dy[i]
		nx = x + dx[i]
		if ny < H and nx < W and cnt[ny][nx] == -1:
			if s[ny][nx] == s[y][x]:
				cnt[ny][nx] = cnt[y][x]
				q.appendleft((ny, nx))
			else:
				cnt[ny][nx] = cnt[y][x] + 1
				q.append((ny, nx))

if s[H-1][W-1] == ""#"":
	ans = (cnt[H-1][W-1]+1)//2
else:
	ans = (cnt[H-1][W-1])//2
print(ans)
"
"def factorize(n):
    lst = []
    tmp = n

    for i in range(2, int(n ** 0.5) + 1):
        if tmp % i == 0:
            cnt = 0
            while tmp % i == 0:
                tmp //= i
                cnt += 1
            lst.append([i, cnt])

    if tmp != 1:
        lst.append([tmp, 1])

    return lst


def main():
    n = int(input())

    lst = factorize(n)
    ans = 0

    for l in lst:
        for i in range(1, 10 ** 6 + 1):
            if i * (i + 1) // 2 > l[1]:
                ans += i - 1
                break

    print(ans)


if __name__ == ""__main__"":
    main()
"
"s = raw_input()
p = raw_input()
print 'Yes' if p in 2 * s else 'No'"
"n,k=map(int,input().split())
x=list(map(int,input().split()))

ans=float('inf')
for i in range(n-k+1):
    nowx=(x[i],x[i+k-1])
    if nowx[0]>=0 and nowx[-1]>=0:
        ans=min(ans, nowx[-1])
    elif nowx[0]<=0 and nowx[-1]<=0:
        ans=min(ans, abs(nowx[0]))
    elif nowx[0]<0 and nowx[-1]>=0:
        ans=min(ans, 2*abs(nowx[0])+nowx[-1], abs(nowx[0])+2*nowx[-1])
print(ans)"
"N = list(input())
s = 0
for i in range(len(N)):
    s += int(N[i])
if int("""".join(N)) % s == 0:
    print(""Yes"")
else:
    print(""No"")
"
"A, B, C, D, E, F = map(int, input().split())
max_a = int(3000 / (100 * A))
max_b = int(3000 / (100 * B))
max_c = int(3000 / C)
max_d = int(3000 / D)
max_dens = 0
max_sugar = 0
max_sugar_water = 0
for i in range(max_a + 1):
  water_A = 100 * A * i
  if water_A > F:
    break
  for j in range(max_b + 1):
    water = 100 * B * j + water_A
    if water > F:
      break
    max_solvable_sugar = E * water
    for s in range(max_c + 1):
      sugar_C = C * s
      if sugar_C * 100 > max_solvable_sugar:
        break
      for t in range(max_d + 1):
        sugar = D * t + sugar_C
        if sugar * 100 > max_solvable_sugar:
          break
        sugar_water = water + sugar
        if sugar_water > F or sugar_water == 0:
          break
        dens = 100 * sugar / sugar_water
        if dens >= max_dens:
          max_dens = dens
          max_sugar = sugar
          max_sugar_water = sugar_water
print(""{} {}"".format(max_sugar_water, max_sugar))"
"def main():
  n,m = list(map(int,input().split()))
  a = list(map(int,input().split()))
  ans=0
  num=sum(a)
  
  for i in range(0,n):
    if a[i] >= num/(4*m):
      ans+=1
      if ans==m:
        break
  if ans >= m:
    print(""Yes"")
  else:
    print(""No"")
  
main()"
"a, b = map(int, input().split())
diff = b - a
towers = [0] * diff
for i in range(1, diff):
    towers[i] = towers[i - 1] + i
print(towers[-1] - a)"
"s = input()
a = int(s[0])*1000+int(s[1])*100+int(s[2])*10+int(s[3])+1
b = s[4]+s[5]+s[6]+s[7]+s[8]+s[9] 
print(str(a)+b)

"
"import sys
A, B = map(int, input().split())
 
for i in range(10 ** 5):
  if int(i * 0.08) == A and int(i * 0.1) == B:
    print(i)
    sys.exit()
  else:
    continue
else:
  print(-1)"
"K = int(input())
S = len(input())
P = 10**9+7
nn = 2*10**6+1
fa = [1] * (nn+1)
fainv = [1] * (nn+1)
for i in range(nn):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(nn)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P
 
C = lambda a, b: fa[a] * fainv[b] % P * fainv[a-b] % P if 0 <= b <= a else 0

inv = [1]*27
for i in range(2,27):
  inv[i]=(-(P//i)*inv[P%i])%P
ans = 0
a = 1
b = pow(26,K,P)
for i in range(K+1):
  ans = (ans + (C(i+S-1,S-1)*a%P*b%P))%P
  a = a*25%P
  b = b*inv[26]%P
print(ans)"
"al = ""abcdefghijklmnopqrstuvwxyz""
d = {}
dn = {}
for a in al:
    d[a] = []
    dn[a] = 0
s = input()
for i in range(len(s)):
    d[s[i]].append(i)
    dn[s[i]] += 1

t = input()
import bisect
ans = 0
n = -1
for a in t:
    l = d[a]
    if l:
        res = bisect.bisect(l, n)
        if res == dn[a]:
            ans += 1
            n = l[0]
        else:
            n = l[res]
    else:
        ans = 0
        n = -2
        break
print(ans * len(s) + n + 1)"
"Input = input()

v_lakes =[]  #個々の湖の面積管理用のstack
idx_stack = [] #地形のindex管理用のstack

for i, c in enumerate(Input):
    if c == ""\\"":
        idx_stack.append(i)
    elif c == ""/"" and idx_stack:
        j = idx_stack.pop()
        v = i - j

        while v_lakes and j < v_lakes[-1][0]:
            v += v_lakes.pop()[1]

        v_lakes.append((j,v))

ans = [len(v_lakes)]
v = [v[1] for v in v_lakes]
ans.extend(v)

print(sum(v))
print(*ans)
"
"s = int(input())

L_MAX = 10**9

x1, y1 = 0, 0
x2, y2 = L_MAX, 1
x3 = ((s + L_MAX - 1) // L_MAX) * L_MAX - s
y3 = (s + L_MAX - 1) // L_MAX

print(x1, y1, x2, y2, x3, y3)
"
"from fractions import gcd
n,m=map(int,input().split())
s = input()
t = input()
g = gcd(n,m)
ng = n//g
mg = m//g
for i in range(g):
    if s[ng*i]!=t[mg*i]:
        print(""-1"")
        break
else:
    print(n*m//g)"
"n=int(input())
from collections import defaultdict
d=defaultdict(int)
def find(n,i):
    if d[n]!=0:
        return i
    d[n]=i
    if n%2==0:
        return find(n//2,i+1)
    else:
        return find(3*n +1 ,i+1)

print(find(n,1))
"
"N, K = map(eval, input().split())
candy = []

for i in range(K):
    input()
    candy.append(list(map(eval, input().split())))

result = 0

for i in range(1, N+1):
    for j in range(K):
        if i in candy[j]:
            break
    else:
        result += 1

print(result)"
"MOD = 10 ** 9 + 7

n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if a[i - 1] == b[j - 1]:
            dp[i][j] = (1 + dp[i - 1][j] + dp[i][j - 1]) % MOD
        else:
            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD

print((dp[n][m] + 1) % MOD)"
"n = int(input())
s = input()
r = 0
b = 0

for i in s:
    if i == ""R"":
        r += 1
    elif i== ""B"":
        b += 1
    else:
        pass
    pass

if r > b:
  	print('Yes')
else:
	print('No')
"
"S=input()
SS=S.replace('2017','2018')
print(SS)"
"N = input()
print(2*N.count(""+"") -4)"
"lis=[]
for i in range(10):
  lis.append(int(input()))
 
for i in sorted(lis,reverse=True)[:3]:
  print(i)"
"data = input().split()
data.reverse()
stk = []

for i in range(len(data)):
    tmp = data.pop()
    if tmp == '+':
        tmp1 = stk.pop()
        tmp2 = stk.pop()
        stk.append(int(tmp2)+int(tmp1))
    elif tmp == '-':
        tmp1 = stk.pop()
        tmp2 = stk.pop()
        stk.append(int(tmp2)-int(tmp1))
    elif tmp == '*':
        tmp1 = stk.pop()
        tmp2 = stk.pop()
        stk.append(int(tmp2) * int(tmp1))
    else:
        stk.append(tmp)

print(stk.pop())"
"s = input()

n = len(s)


for i in range(n-1):
    if s[i] == ""A"" and s[i+1] == ""C"":
        print(""Yes"")
        import sys
        sys.exit()
print(""No"")
"
"w,h,x,y=map(int,input().split())
#面積が大きくない方の最大値
s=0.5*w*h
#複数存在するかの判定
i=0
if 2*x==w and 2*y==h:
    i+=1
print(s,i)"
"from collections import Counter

n = int(input())
v = list(map(int, input().split()))

if len(set(v)) == 1:
    print(n // 2)
    exit()

kisu = Counter(v[::2]).most_common(2)
gusu = Counter(v[1::2]).most_common(2)

if kisu[0][0] == gusu[0][0]:
    keep = max(kisu[1][1] + gusu[0][1],
               kisu[0][1] + gusu[1][1])
else:
    keep = kisu[0][1] + gusu[0][1]

print(n - keep)
"
"# from decimal import Decimal
a, b, c = map(int, input().split())
print(b//c - a//c if a%c != 0 else b//c - a//c +1)"
"# H - Grid 1
H,W = map(int,input().split())
maze = []
for _ in range(H):
    a = list(input())
    maze.append(a)

# dp[i][j]: 座標 (i, j) に到達できる経路の数
dp = [[0]*(W) for _ in range(H)]

# 初期条件 
# 座標 (0, 0) への経路は 1 通り
dp[0][0] = 1

for h in range(H):
    for w in range(W):
        # スタート位置のときはスルー
        if (h,w) == (0,0):
            continue
        # 壁があるときはスルー
        if maze[h][w] == '#':
            continue
        # 左にマスがあるとき 
        if w > 0:
            dp[h][w] = (dp[h][w] + dp[h][w-1])%(10**9+7)
        # 上にマスがあるとき
        if h > 0:
            dp[h][w] = (dp[h][w] + dp[h-1][w])%(10**9+7)
print(dp[H-1][W-1])"
"# coding: utf-8
# Here your code !
import functools
N = input().split()
stack=[]

for i in N:
    if i.isdigit():
        stack.append(int(i))
        
    else:
        key=0
        if i==""+"":
            p2=stack.pop()
            p1=stack.pop()
            stack.append(p1+p2)
        elif i==""-"":
            p2=stack.pop()
            p1=stack.pop()
            stack.append(p1-p2)
        elif i==""*"":
            p2=stack.pop()
            p1=stack.pop()
            stack.append(p1*p2)
print(stack[0])"
"N = int(input())
A = list(map(int, input().split()))

ans = 0

for i in range(N-1):
    if A[i] < A[i+1]:
        pass
    else:
        ans = ans + (A[i] - A[i+1])
        A[i+1] = A[i+1] + (A[i] - A[i+1])

print(ans)
"
"from itertools import product
n = int(input())
F = [tuple(map(int, input().split()))for _ in range(n)]
P = [tuple(map(int, input().split()))for _ in range(n)]
INF = 10**18
ans = -INF
for schedule in product([0, 1], repeat=10):
    if 1 not in schedule:
        continue
    p_sum = 0
    for i, f in enumerate(F):
        cnt = 0
        for x, y in zip(schedule, f):
            if x == y == 1:
                cnt += 1
        p_sum += P[i][cnt]
    if ans < p_sum:
        ans = p_sum
print(ans)
"
"def YN(P):
    if P:
        print(""YES"")
    else:
        print(""NO"")

def yn(P):
    if P:
        print(""Yes"")
    else:
        print(""No"")
        
x=int(input())
YN(x==3 or x==5 or x==7)"
"n = int(input())
x = list(map(int,input().split()))
x.reverse()
ans =[]
c=1
for i in range(n):
    c=0
    for j in range(n-i):
        if x[j]==n-i-j:
            ans.append(x.pop(j))
            c=1
            break
    if c==0:
        print('-1')
        exit()    
ans.reverse()
for i in ans:
        print(i)
"
"a, b, c = input().split()
print(""NYOE S""[a[-1]+b[-1]==b[0]+c[0]::2])"
"#!/usr/bin/env python3
# encoding:utf-8
import copy
import random
import bisect #bisect_left　これで二部探索の大小検索が行える
import fractions #最小公倍数などはこっち
import math
import sys
import collections
from decimal import Decimal # 10進数で考慮できる

mod = 10**9+7
sys.setrecursionlimit(mod) # 再帰回数上限はでdefault1000

d = collections.deque()
def LI(): return list(map(int, sys.stdin.readline().split()))

A, B = LI()
print(A * B // math.gcd(A, B))"
"def actual(N):
    f = lambda x: sum(map(int, str(N)))

    if N % f(N) == 0:
        return 'Yes'

    return 'No'


N = int(input())
print(actual(N))"
"S = [int(i) for i in input()]
K = int(input())

if sum(S)==len(S):
    print(1)
else:
    for i in range(len(S)):
        if S[i]!=1:
            print(S[i])
            break
        elif S[i]==1 and K-1<=i:
            print(1)
            break"
"N, K = map(int, input().split())
H = map(int, input().split())

count = 0
for h in H:
    if(h >= K):
        count += 1
print(count)
"
"from collections import defaultdict, deque

N = int(input())
X = defaultdict(list)
for i in range(N - 1):
    ai, bi = map(lambda s: int(s) - 1, input().split())
    X[ai].append(bi)
    X[bi].append(ai)
c = list(map(int, input().split()))

c.sort(reverse=True)
print(sum(c[1:]))
d = [0] * N
q = deque([0])
i = 0
while len(q) > 0:
    v = q.popleft()
    d[v] = c[i]
    i += 1
    for x in X[v]:
        if d[x] != 0:
            continue
        q.append(x)
print(' '.join(list(map(str, d))))
"
"import sys
def input(): return sys.stdin.readline().strip()

def resolve():
    from itertools import accumulate

    N = int(input())  # len(A)
    A = list(map(int, input().split()))

    B = [0] + A
    B = list(accumulate(B))  # 累積和を格納したリスト作成

    ans=10**18
    for i in range(1, N):
        snuke=B[i]
        araiguma=B[N]-B[i]
        ans=min(ans,abs(snuke-araiguma))
    print(ans)
resolve()"
"a,b = [int(_) for _ in input().split()]
a_str = str(b)*a
b_str = str(a)*b
list_str = [a_str,b_str]
list_str.sort()
print(list_str[0])
"
"n = int(input())

dp = [1]*45

for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[n])

"
"import sys
n = int(input())
k = int(input())

keta = len(str(n))
# dp[i桁まで検査済み][coincidence][0以外の個数]
dp = [[[0] * (k + 1) for i in range(2)] for j in range(keta + 1)]

dp[0][1][0] = 1
for a in range(1, keta + 1):
    digit = int(str(n)[a - 1])
    for b in range(2):
        for c in range(k + 1):
            if b == 0 and c == k:
                # 最大値と不一致で0以外の個数がk個になる
                dp[a][b][c] += dp[a-1][0][k] * 1
                dp[a][b][c] += dp[a-1][0][k-1] * 9
                # d != 0(仮に3) -> 0
                # d == 0 -> 0にすると最大値と一致するのでだめ
                dp[a][b][c] += dp[a-1][1][k] * (1 if digit != 0 else 0)
                # d != 0(仮に3) -> 1, 2(0はkにならないのでだめ、3はb == 1になるのでだめ)
                # d == 0 -> 0にするとkが増えないのでだめ
                dp[a][b][c] += dp[a-1][1][k-1] * (digit - 1 if digit != 0 else 0)
            elif b == 0 and c != k:
                # 最大値と不一致で0以外の個数がc個になる
                dp[a][b][c] += dp[a-1][0][c] * 1
                dp[a][b][c] += 0 if c == 0 else dp[a-1][0][c-1] * 9
                dp[a][b][c] += dp[a-1][1][c] * (1 if digit != 0 else 0)
                dp[a][b][c] += 0 if c == 0 else dp[a-1][1][c-1] * (digit - 1 if digit != 0 else 0)
            elif b == 1 and c == k:
                # 最大値と一致で0以外の個数がk個になる
                dp[a][b][c] += dp[a-1][1][k] * (1 if digit == 0 else 0)
                dp[a][b][c] += dp[a-1][1][k-1] * (1 if digit != 0 else 0)
            elif b == 1 and c != k:
                dp[a][b][c] += dp[a-1][1][c] * (1 if digit == 0 else 0)
                dp[a][b][c] += 0 if c == 0 else dp[a-1][1][c-1] * (1 if digit != 0 else 0)
            else:
                None
#     print(""--"", a)
#     for i in range(k + 1):
#         print(dp[a][0][i])
#     for i in range(k + 1):
#         print(dp[a][1][i])

print(dp[keta][0][k] + dp[keta][1][k])


"
"import sys, math
from itertools import accumulate
sys.setrecursionlimit(10**9)

def input():
    return sys.stdin.readline()[:-1]

def mi():
    return map(int, input().split())

def ii():
    return int(input())

def i2(n):
    tmp = [list(mi()) for i in range(n)]
    return [list(i) for i in zip(*tmp)]


def main():
    s, K = input(), ii()
    l = list(map(lambda c: (ord('z')-ord(c)+1)%26, s))

    acc = 0
    t = ['']*len(s)
    for i in range(len(s)):
        if acc + l[i] <= K:
            acc += l[i]
            t[i] = 'a'
        else:
            t[i] = s[i]

    if i == len(s)-1 and K-acc > 0:
        t[i] = chr((ord(t[i])-ord('a')+K-acc)%26+ord('a'))

    print(''.join(t))

if __name__ == ""__main__"":
    main()"
"n = int(input())
a = list(map(int,input().split()))
lst = [0]+[0]*(10**5 + 1)
for i in a:
  lst[i] += 1
  
ans = 0
for i in range(1,10**5):
  ans = max(ans,lst[i-1]+lst[i]+lst[i+1])
print(ans)"
"R = int(input())
ans = 2 * R * 3.14159
print(ans)"
"W=input()

Ti=[]
count=0

while True:
  T=input()
  s=T.lower()
  if T==""END_OF_TEXT"":
    break
  Ti += list(s.split())

  
for i in range(len(Ti)):
  if Ti[i]==W:
    count +=1

print(count)
"
"H,W = list(map(int,input().split()))
V = 10
cost = []
for i in range(V):
    cost.append(list(map(int,input().split())))

INF = float('inf')
for k in range(V):
    for i in range(V):
        for j in range(V):
            if cost[i][k]!=INF and cost[k][j]!=INF:
                cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])

out = 0
for i in range(H):
    A = list(map(int,input().split()))
    for j in range(W):
        if A[j]==-1:
            continue
        else:
            out += cost[A[j]][1]
print(out)"
"n,m,*L=map(int,open(0).read().split())
dp=list(range(n+1))
for c in L:
	for j in range(c,n+1):
		dp[j]=min(dp[j],dp[j-c]+1)
print(dp[n])
"
"a = []
d = {}

def decode():
    global a

    n = int(input())
    a = [int(x) for x in input().split()]

    q = int(input())
    ms = [int(x) for x in input().split()]

    return n, a, q, ms


def solve(i, m):
    global a, d

    if (i, m) in d:
        return d[(i, m)]

    if a[i] == m:
        d[(i, m)] = True
        return True
    else:
        if i < len(a) - 1:

            if solve(i+1, m) or (m - a[i] > 0 and solve(i+1, m-a[i])):
                d[(i, m)] = True
                return True
            else:
                d[(i, m)] = False
                return False

        else:
            d[(i, m)] = False
            return False


if __name__ == '__main__':

    n, a, q, ms = decode()
    for m in ms:
        if solve(0, m):
            print(""yes"")
        else:
            print(""no"")

"
"h,w,k=map(int,input().split())
mod=10**9+7
F=[1,1,2,3,5,8,13,21,34]
if w==1:
  print(1)
else:
  DP=[[0]*w for _ in range(h+1)]
  DP[0][0]=1
  for i in range(h):
    DP[i+1][0]=(DP[i][0]*F[w-1]+DP[i][1]*F[w-2])%mod
    for j in range(1,w-1):
      DP[i+1][j]=(DP[i][j-1]*F[w-j-1]*F[j-1]+DP[i][j]*F[w-j-1]*F[j]+DP[i][j+1]*F[w-j-2]*F[j])%mod
    DP[i+1][w-1]=(DP[i][w-1]*F[w-1]+DP[i][w-2]*F[w-2])%mod
  print(DP[h][k-1])"
"N = int(input())
ls = [-1]
for i in range(N):
  ls += [int(input())]

ans = 0
p = 0
for i in range(1,N+1):
  if ls[i-1]+1<ls[i]:
    print(-1)
    break
  if ls[i-1]+1==ls[i]:
    if i==N:
      ans += (ls[i])
    p = ls[i]
    continue
  else:
    if i==N:
      ans += ls[i]
    ans += p
    p = ls[i]
else:
  print(ans)"
"import numpy as np
n,m,*xyz = map(int,open(0).read().split())
xyz = np.array(xyz).reshape(n,3)
abs_pattern = np.array(np.meshgrid((1,-1),(1,-1),(1,-1))).reshape(-1,3)
if m==0:
    ans = 0
else:
    ans = np.sort(np.dot(abs_pattern,xyz.T))[:,-m:].sum(axis=1).max()
print(ans)"
"n = int(input())
s = input()

cnt = 0
for i in range(1000):
    x = str(i).zfill(3)
    a = s.find(x[0])
    b = s[a+1:].find(x[1])
    c = s[a+b+2:].find(x[2])
    if -1 not in (a,b,c):
        cnt += 1
print(cnt)"
"s = list(input())
t = s.copy()
t.reverse()
print(len(s)-t.index(""Z"")-s.index(""A""))"
"n = int(input())
ans = 0

while n > ans:
    ans += 111
print(ans)"
"x=int(input())
i=0
u=0
while 500<=x:
    x-=500
    i+=1
while x>=5:
    x-=5
    u+=1
print(1000*i+5*u)"
"h,n=map(int,input().split())
ab = [list(map(int,input().split())) for i in range(n)]

dp=[float('inf')]*(h+1)
dp[0]=0
for i in range(h):
    for j in range(n):
        if dp[i] == float('inf'):continue
        next=i+ab[j][0] if i+ab[j][0]<=h else h
        dp[next]=min(dp[next],dp[i]+ab[j][1])
print(dp[-1])
"
"n, m = map(int, input().split())
LR = [list(map(int, input().split())) for _ in range(m)]

L = []
R = []
L_append = L.append
R_append = R.append
for l, r in LR:
    L.append(l)
    R.append(r)

min_R = min(R)
max_L = max(L)
if min_R >= max_L:
  ans = min_R +1 - max_L
else:
  ans = 0
  
print(ans)"
"from collections import Counter,defaultdict,deque
from heapq import heappop,heappush
from bisect import bisect_left,bisect_right 
import sys,math,itertools,fractions,pprint
sys.setrecursionlimit(10**8)
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

t = inpl()
a = inpl()
b = inpl()
if (a[0] > b[0] and a[1] > b[1]) or (a[0] < b[0] and a[1] < b[1]):
    print(0)
    quit()
c = [0,0]
for i in range(2):
    c[i] = abs(a[i]-b[i]) * t[i]
if c[0] == c[1]:
    print('infinity')
    quit()
if c[0] > c[1]:
    print(0)
else:
    sa = c[1]-c[0]
    tmp = 0
    if c[1]%sa:
        tmp = 1
    print((c[1]-1)//(c[1]-c[0])*2 - tmp)
"
"from collections import Counter

def resolve():
	n = int(input())
	s = input()
	sum_e = [0]*(n+1)
	sum_w = [0]*(n+1)
	for i in range(n):
		ev = 1 if s[i] == 'E' else 0
		wv = 1 if s[i] == 'W' else 0
		sum_e[i+1] = sum_e[i] + ev
		sum_w[i+1] = sum_w[i] + wv
	ans = float('inf')
	if n == 2:
		print(1 if len(Counter(list(s)).keys()) == 2 else 0)
		return
	e_w = sum_e[-1] - sum_e[1]
	e_e = sum_w[n-1]
	ans = min(e_w, e_e)
	for i in range(n):
		v = sum_w[i-1] + (sum_e[-1] - sum_e[i])
		ans = min(ans, v)
	print(ans)
resolve()"
"N,M=map(int,input().split())
p=list(map(int,input().split()))
par=[i for i in range(N)]
 
def find(x):
  if par[x]==x:
    return par[x]
  else:
    par[x]=find(par[x])
    return par[x]

def union(x,y):
  fx=find(x)
  fy=find(y)
  if fx!=fy:
    par[fx]=fy

f=lambda x:int(x)-1
for _ in range(M):
  x,y=map(f,input().split())
  union(x,y)

ans=0
for i in range(N):
  if find(p[i]-1)==find(i):
    ans+=1
print(ans)"
"# get line input split by space
def getLnInput():
    return input().split()


# ceil(a / b) for a > b
def ceilDivision(a, b):
    return (a - 1) // b + 1


def main():
    while True:
        H, W = list(map(int, getLnInput()))
        printFromSharp = True
        if H == 0 and W == 0:
            break
        if H != 0 or W != 0:
            for i in range(H):
                isCurrentSharp = printFromSharp
                for j in range(W):
                    print(""#"" if isCurrentSharp else ""."", end="""")
                    isCurrentSharp = not isCurrentSharp
                print()
                printFromSharp = not printFromSharp
        print()
    return


main()"
"def main():
    n = int(input())
    s = input()
    rcount = s.count('R')
    diff = s[0:rcount].count(""W"")

    print(diff)




if __name__ == ""__main__"":
    main()"
"N, K = map(int, input().split())
warp = list(map(int, input().split()))
warp = [i - 1 for i in warp]

visit = [0]

current_loc = 0
while warp[current_loc] != -1:
  visit.append(warp[current_loc])
  warp[current_loc] = -1
  current_loc = visit[-1]

res = visit.index(visit[-1])
cycle = visit[res + 1:]
if K <= res:
  print(visit[K] + 1)
else:
  answer = cycle[(K - res - 1) % (len(visit) - 1 - res)] + 1
  print(answer)"
"# 連続するK本のろうそくに火をつけるので、最小となる組を全探索する
N, K = map(int, input().split())
X = list(map(int, input().split()))

ans = float(""INF"")
for i in range(N - K + 1):
    lr = abs(X[i]) + abs(X[i] - X[i + K - 1])
    rl = abs(X[i + K - 1]) + abs(X[i + K - 1] - X[i])
    ans = min(ans, min([lr, rl]))

print(ans)"
"D, P = map(int, input().split())    
ans = 0.0
def func(i):
    t = 0
    while(i < P):
        i *= 2
        t += 1
    return t

for i in range(1, D + 1):
    ans += float((1/D)) * float(((1 / 2) ** func(i)))

print(ans)"
"X = list(input())

st = []
for x in X:
    if x == 'S':
        st.append(x)
    else:
        if len(st) > 0 and st[-1] == 'S':
            st.pop()
        else:
            st.append(x)
print(len(st))
"
"import math
lst=input().split()
lst=list(map(lambda i:int(i),lst))
a,b,C=lst[0],lst[1],lst[2]
S=(1/2)*a*b*math.sin(math.radians(C))
h=(2/a)*S
c=(a**2+b**2-2*a*b*math.cos(math.radians(C)))**(1/2)
L=a+b+c
print(S)
print(L)
print(h)

"
"n = int(raw_input())
for i in xrange(n):
    a = map(int, raw_input().split())
    a.sort()
    if a[0]**2 + a[1]**2 == a[2]**2:
        print 'YES'
    else:
        print 'NO'"
"n = int(input())
a = list(map(int,input().split()))
s = sum(a)
l1 = 0

for i in range(n):
    l1 += a[i] 
    if l1> s//2:break
r1 = s - l1
l2 = l1 -a[i]
r2 = s - l2
ans = min(abs(r1-l1),abs(r2-l2))
print(ans)"
"O = input()
E = input()
ans = """"
for i in range(len(O+E)) :
    if i % 2 == 0:
        ans += O[i//2]
    else :
        ans += E[(i+1)//2-1]
print(ans)"
"N, A=map(int, input().split())
x=list(map(int, input().split()))

dp=[[[0]*2501 for j in range(N+1)] for i in range(N)]

dp[0][0][0]=1
dp[0][1][x[0]]=1
for i in range(1, N):
  dp[i][0][0]=1
  for j in range(1, i+2):
    for k in range(2501):
      if k-x[i]>=0:
        dp[i][j][k]=dp[i-1][j-1][k-x[i]]+dp[i-1][j][k]
      else:
        dp[i][j][k]=dp[i-1][j][k]
        
print(sum([dp[-1][j][A*j] for j in range(1, N+1)]))"
"import sys
import math
import itertools
import bisect
from copy import copy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def k(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def X(): return list(input())
def L(): return list(input().split())
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
def gcd(*numbers): reduce(math.gcd, numbers)
sys.setrecursionlimit(10 ** 9)
mod = 10**9+7
count = 0
ans = 0

A, B, Q = I()
inf = float(""inf"")
s = [-inf]+sorted([k() for _ in range(A)])+[inf]
t = [-inf]+sorted([k() for _ in range(B)])+[inf]
aa = []

for i in range(Q):
    q = k()
    S = bisect.bisect(s,q)
    T = bisect.bisect(t,q)
    ans = inf
    for j in [s[S-1],s[S]]:
        for z in [t[T-1],t[T]]:
            x = abs(j-q)+abs(j-z)
            y = abs(z-q)+abs(j-z)
            ans = min(ans,x,y)
    aa.append(ans)

for i in aa:
    print(i)
"
"# C - X: Yet Another Die Game
def main():
    x = int(input())

    if x%11==0:
        print((x//11)*2)
    elif x%11<=6:
        print((x//11)*2+1)
    else:
        print((x//11)*2+2)
  
        
if __name__ == '__main__':
    main()
"
"N = int(input())
D, X = map(int, input().split())
A = []
for _ in range(N):
    A.append(int(input()))

ans = 0
for a in A:
    if D%a == 0:
        ans += D // a
    else:
        ans += D//a + 1

print(ans+X)"
"from collections import defaultdict

n = int(input())
S = [input() for i in range(n)]
m = int(input())
T = [input() for i in range(m)]

dictS = defaultdict(int)
dictT = defaultdict(int)

for s in S:
    dictS[s] += 1
for t in T:
    dictT[t] += 1

res = 0
for key in dictS:
    res = max(res, dictS[key] - dictT[key])
print(res)
"
"sd = input()
t = input()

n = len(sd)
m = len(t)
s = []

# sd を後ろから見ていき、 t の入りそうな場所を探す
for i in range(n - m, -1, -1):
    t_kamo = sd[i:i + m]
    for j in range(m + 1):
        # 1文字ずつ順に入りうるか調べ、最後まで入るなら ""?"" を ""a"" に置き換えて出力
        if j == m:
            print((sd[:i] + t + sd[i + len(t):]).replace(""?"", ""a""))
            exit()
        if t_kamo[j] == ""?"":
            continue
        elif t_kamo[j] != t[j]:
            break

print(""UNRESTORABLE"")"
"def solve():
  n = int(input())
  a = list(map(int, input().split()))
  g, z = 0, 0
  cut = 1
  for i in range(n-1):
    if a[i+1] > a[i]:
      g += 1
    elif a[i+1] < a[i]:
      z += 1
    if g != 0 and z != 0:
      cut += 1
      g, z = 0, 0
  print(cut)
  return 0
 
if __name__ == ""__main__"":
  solve()
"
"A=int(input())
B=int(input())
C=int(input())
D=int(input())

if A>=B:
    A=B
else:
    A=A

if C>=D:
    C=D
else:
    C=C

print(A+C)
"
"x,a,b=map(int,input().split())
t=a-b
if t>=0:
    print('delicious')
else:
    if abs(t)<=x:
        print('safe')
    else:
        print('dangerous')
"
"n,l = map(int,input().split())
line = []
for i in range(n):
    line.append(input())
line.sort()
for i in range(n):
    print(line[i],end="""")
print("""")"
"s = input()
a, b = s.count(""o""), s.count(""x"")
print(""YES"" if a+15-a-b>=8 else ""NO"")"
"def gcd(a, b):
    while b != 0:
        # gcd(a, b) == gcd(b, a%b)
        rem = a % b
        a = b
        b = rem
    return a

a, b = map(int, input().split())
print(gcd(a, b))"
"a, b, c, d = map(int, input().split())

while c or a >= 0:
    c -= b
    a -= d
    if c <= 0:
        print(""Yes"")
        break
    if a <= 0:
        print(""No"")
        break"
"N = int(input())
A = [int(input()) for i in range(N)]

def insertion_sort(A, N, diff, cnt):
    for i in range(diff, N):
        tmp_num = A[i]
        j = i - diff
        while j >= 0 and A[j] > tmp_num:
            A[j+diff] = A[j]
            j = j - diff
            cnt += 1
        A[j+diff] = tmp_num
    return cnt

if __name__ == ""__main__"":
    cnt = 0
    diffs = []
    h = 1
    while h <= N:
        diffs.append(h)
        h = h*3 + 1
    diffs.reverse()
    diffs_cnt = len(diffs)
    for diff in diffs:
        cnt = insertion_sort(A, N, diff, cnt)
    print(diffs_cnt)
    print("" "".join(map(str, diffs)))
    print(cnt)
    for num in A:
        print(num)

"
"n = int(input())

lt = []
for _ in range(n):
    lt.append(tuple(map(int, input().split())))

for i in range(n-2):
    if len(set(lt[i])) == 1 and len(set(lt[i+1])) == 1 and len(set(lt[i+2])) == 1:
        print(""Yes"")
        exit(0)
print(""No"")
"
"s=input()
res = s.count('+') - s.count('-')
print(res)"
"from sys import stdin
import sys
import math
from functools import reduce
import functools
import itertools
from collections import deque,Counter,defaultdict
from operator import mul
import copy
# ! /usr/bin/env python
# -*- coding: utf-8 -*-
import heapq
sys.setrecursionlimit(10**6)
# INF =  float(""inf"")
INF = 10**18
import bisect
import statistics
mod = 10**9+7
# mod = 998244353

N = int(input())

# 約数全列挙
def divisors(n):
    i = 1
    ans = []
    while i*i <= n:
        if n % i == 0:
            ans.append(i)
            if i*i != n: ans.append(n // i)
        i += 1
    ans.sort()
    return ans

a = divisors(N)
m = len(a)

if m % 2 == 1:
    print(2*a[m//2] - 2)
else:
    print(a[m//2-1] + a[m//2] - 2)"
"from sys import stdin

a = int(stdin.readline().rstrip())
print(a//3)"
"def func(x):
    ans = 0
    for a in range(1, n):
        for b in range(1, n):
            c = n - a * b
            if c <= 0:
                break
            ans += 1
    return ans

n = int(input())
print(func(n))"
"s=input()
length=len(s)
now_length=length-2
ans=0
while True:
    if s[0:int(now_length/2)]==s[int(now_length/2):now_length]:
        ans=now_length
        break
    else:
        now_length=now_length-2
print(ans)"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
dp=[False]*(k+1)
for i in range(1,k+1):
  for j in range(n):
    if  i-a[j]<0:
      break
    if dp[i-a[j]]==False:
      dp[i]=True
if dp[k]==True:
  print('First')
else:
  print('Second')

          
"
"N, M = map(int,input().split())
if N%2 == 1:
    for i in range(1,M+1):
        print(i,N+1-i)
else:
    for i in range(1,M+1):
        if i == N//4+1:
            break
        print(i,N+1-i)
        if i == M:
            quit()
    for j in range(i,M+1):
        print(j+1,N+1-j)"
"N,K,C= map(int, input().split())
S=input()
A=[]
for i in range(N):
  if S[i]=='o':
    A.append(i)
M=[]
d=0
cnt=0
for i in A:
  if d<=i:
    M.append(i)
    d=i+C+1
    cnt+=1
  if cnt==K+1:
    print()
    exit()
    
U=[]
d=N-1
cnt=0
for i in A[::-1]:
  if i<=d:
    U.append(i)
    d=i-C-1
    cnt+=1
  if cnt==K+1:
    print()
    exit()
D=set(M)&set(U)
D=sorted(D)
for i in D:
  print(i+1)"
"# https://atcoder.jp/contests/abc171/tasks/abc171_d


N = int(input())

A_list = list(map(int, input().split()))    #整数列
Q = int(input())                            #操作の回数

B_list = []                                 #値がBである要素を
C_list = []                                 #全てCに置き換える

for i in range(Q):
    B, C = map(int, input().split())
    B_list.append(B)
    C_list.append(C)


curr_sum = 0
elements_num_dict = {}

for A in A_list:
    curr_sum += A

    if A in elements_num_dict:
        elements_num_dict[A] += 1
    else:
        elements_num_dict[A] = 1


for i, (B, C) in enumerate(zip(B_list, C_list)):

    if B in elements_num_dict:
        
        count = elements_num_dict[B]
        diff = C*count - B*count
        curr_sum += diff


        # 辞書配列を修正
        elements_num_dict[B] -= count

        if C in elements_num_dict:
            elements_num_dict[C] += count
        else:
            elements_num_dict[C] = count

    
    print(curr_sum)"
"n,m = map(int,input().split("" ""))
ar = [[0,1] for i in range(n)]
ar[0] = [1,1]
r = 0
for i in range(m):
    a,b = map(int,input().split("" ""))
    a -= 1
    b -= 1
    if ar[a][0] == 1 and ar[a][1] >= 1:
        ar[b][0] = 1
    ar[b][1] += 1
    ar[a][1] -= 1
    if ar[a][1] == 0:
        ar[a][0] = 0
count = 0
for r in ar:
    if r[0] == 1:
        count += 1
print(count)"
"n,m = map(int,input().split())
L = [list(map(int,input().split())) for _ in range(n)]
L = sorted(L, key=lambda x: x[0])
limit = m
ans = 0
for i in range(n):
  if limit <= 0: break
  ans += min(limit, L[i][1]) * L[i][0]
  limit -= L[i][1]
print(ans)"
"import math
n = int(input())
d,x = map(int, input().split())
lis = []
for i in range(n):
    lis.append(int(input()))
    
cnt = 0
for i in lis:
    cnt += math.ceil(d/i)

print(cnt+x)"
"class Queue:
    def __init__(self,l):
        self.values = []
        self.l = l
        for _ in range(l):
            self.values.append(None)
        self.head = 0
        self.tail = 0
    def inc(self,n):
        if n+1 >= self.l:
            return 0
        else:
            return n+1
    def enqueue(self,v):
        if self.inc(self.head) == self.tail:
            print 'overflow'
            exit()
        self.values[self.head] = v
        self.head = self.inc(self.head)
    def dequeue(self):
        if self.head == self.tail:
            print 'underflow'
            exit()
        v = self.values[self.tail]
        self.tail = self.inc(self.tail)
        return v
    def size(self):
        if self.head >= self.tail:
            return self.head-self.tail
        else:
            self.head + (self.l-self.tail)

n,q = map(int,raw_input().split(' '))
queue = Queue(200000)
for _ in range(n):
    n,t = raw_input().split(' ')
    t = int(t)
    queue.enqueue((n,t))

c = 0
while queue.size()>0:
    n,t = queue.dequeue()
    if t <= q:
        c += t
        print n,c
    else:
        queue.enqueue((n,t-q))
        c += q"
"from collections import Counter
n=int(input())
c=Counter(list(map(int, input().split())))
l=list()
for k,v in c.items():
    for _ in range(v//2):
        l.append(k)

l.sort()
l.reverse()
if len(l)>=2:
    print(l[0]*l[1])
else:
    print(0)"
"def solve(S, T):
    L1 = len(S)
    L2 = len(T)
    dp = [[0]*(L2+1) for i in range(L1+1)]

    for i in range(L1-1, -1, -1):
        for j in range(L2-1, -1, -1):
            r = max(dp[i+1][j], dp[i][j+1])
            if S[i] == T[j]:
                r = max(r, dp[i+1][j+1] + 1)
            dp[i][j] = r

    # dp[0][0] が長さの解

    # ここからは復元処理
    res = []
    i = 0; j = 0
    while i < L1 and j < L2:
        if S[i] == T[j]:
            res.append(S[i])
            i += 1; j += 1
        elif dp[i][j] == dp[i+1][j]:
            i += 1
        elif dp[i][j] == dp[i][j+1]:
            j += 1
    return """".join(res)

S = input()
T = input()
print(solve(S,T))"
"def Rot(vec):
    new=[]
    new+=[vec[0]/2-vec[1]*3**(1/2)/2]
    new+=[vec[0]*3**(1/2)/2+vec[1]/2]
    return(new)

def Add(L):
    dist=[(L[1][0]-L[0][0])/3,(L[1][1]-L[0][1])/3]
    vec1=Rot(dist)
    p1=[2/3*L[0][0]+1/3*L[1][0],2/3*L[0][1]+1/3*L[1][1]]
    p2=[p1[0]+vec1[0],p1[1]+vec1[1]]
    p3=[2/3*L[1][0]+1/3*L[0][0],2/3*L[1][1]+1/3*L[0][1]]
    return([L[0],p1,p2,p3,L[1]])

def Koch(L,n):
    l=len(L)
    if n==0:
        Out=L
    elif n==1:
        if l==2:
            Out=Add(L)
        else:
            L1=L[0:l//2+1]
            L2=L[l//2:l]

            Out=Koch(L1,n)[:-1]+Koch(L2,n)
    else:
        Out=(Koch(Koch(L,n-1),1))

    return(Out)

n=int(input())
L=Koch([[0,0],[100,0]],n)
l=len(L)
for i in range(l):
    print(L[i][0],L[i][1])

"
"def mi():
    return map(int, input().split())

def main():
    S = input()
    N = len(S)+1
    l = [0]*N
    r = [0]*N
    ans = 0

    for i in range(N-1):
        if S[i] == '<':
            l[i+1] = l[i]+1
    for i in range(N-2, -1, -1):
        if S[i] == '>':
            r[i] = r[i+1]+1

    for i in range(N):
        ans += max(l[i], r[i])

    print(ans)

if __name__ == '__main__':
    main()
"
"import bisect
s = input()
t = input()
d = {}
if set(t) <= set(s):
    for c in set(s):
        d[c] = []
    for i,c in enumerate(s):
        d[c].append(i)
    ret = 0
    for i,c in enumerate(t):
        if i==0:
            loc = d[t[0]][0]
        else:
            nx_idx = bisect.bisect_right(d[c], loc)
            if nx_idx == len(d[c]):
                ret += 1
                nx_idx = 0
            nx_loc = d[c][nx_idx]
            loc = nx_loc
    print(ret*len(s) + loc + 1)
else:
    print(-1)
"
"N = int(input())
lower = []
upper = []
for i in range(N):
    a, b = map(int, input().split())
    lower.append(a)
    upper.append(b)
lower.sort()
upper.sort()
if N % 2 == 1:
    print(upper[(N-1)//2]-lower[(N-1)//2]+1)
else:
    print(upper[N//2]+upper[N//2 - 1]-lower[N//2]-lower[N//2 - 1]+1)"
"q,h,s,d = map(int, input().split())
n = int(input())

q = 4*q
h = 2*h

min_1 = min(q,h,s)
if n == 1:
    print(min_1)
else:
    if min_1*2 < d:
        print(n*min_1)
    else:
        double = n//2
        v = double*d
        if n%2 == 1:
            v += min_1
        print(v)"
"import bisect
n = int(input())
a = [int(i) for i in input().split()]
a.sort()
point = bisect.bisect_right(a, 0)
a_minus = a[:point]
a_plus = a[point:]
len_plus = len(a_plus)
if (len(a_minus) > 0) & (len(a_plus) > 0):
    ans = sum(a_plus) - sum(a_minus)
    print(ans)
    for i in range(len(a_plus)):
        if len_plus == 1:
            x = a_plus.pop(0)
            y = a_minus.pop(0)
            print(str(x) + "" "" + str(y))
        elif (i == 0):
            x = a_minus.pop(0)
            y = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
        elif i == len_plus - 1:
            y = x - y
            x = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
        else:
            x = x - y
            y = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
    for j in range(len(a_minus)):
        x = x - y
        y = a_minus.pop(0)
        print(str(x) + ' ' + str(y))
elif len(a_plus) > 0:
    ans = sum(a_plus) - ((a[0]) * 2)
    print(ans)
    for i in range(len(a_plus) - 1):
        if i == 0:
            x = a_plus.pop(0)
            y = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
        elif i == len_plus - 2:
            y = x - y
            x = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
        else:
            x = x - y
            y = a_plus.pop(0)
            print(str(x) + "" "" + str(y))
elif len(a_minus) > 0:
    ans = (a_minus[-1] * 2) - sum(a_minus)
    print(ans)
    for i in range(len(a_minus) - 1):
        if i == 0:
            x = a_minus[-1]
            y = a_minus.pop(0)
            print(str(x) + "" "" + str(y))
        elif i == len_plus - 2:
            x = x - y
            y = a_minus.pop(0)
            print(str(x) + "" "" + str(y))
        else:
            x = x - y
            y = a_minus.pop(0)
            print(str(x) + "" "" + str(y))"
"n,k = map(int,input().split())
n1 = n + 1
ans = 0
for i in range(1,n1):
    if n >= k:
        ans += 1
        n -= 1
    else:
        break
print(ans)"
"N=input()
N=int(N)
S=input()
count=0
for i in range(N-2):
  if S[i]==""A"" and S[i+1]==""B"" and S[i+2]==""C"":
    count=count+1
print(count)"
"n = int(input())
a = list(map(int,input().split()))
ave = sum(a)//n
b = c = 0
for i in range(n):
    b += (a[i]-ave)**2
    c += (a[i] - ave - 1)**2
print(min(b,c))
"
"n = int(input())
s = set()
for i in range(1, 32):
    s.add(i ** 2)

for i in range(1, 11):
    s.add(i ** 3)

for i in range(1, 7):
    s.add(i ** 4)

for i in range(1, 5):
    s.add(i ** 5)
    s.add(i ** 6)
    s.add(i ** 7)
    s.add(i ** 8)
    s.add(i ** 9)
    s.add(i ** 10)

t = list(s)
t.sort()
t = [x for x in t if x <= 1000]

res = 0
for tt in t:
    res = tt if tt <= n else res
print(res)"
"def main():
    A = map(int, input().split())
    A = map(lambda x: x % 3, A)

    r = 0
    for x in A:
        r = (r + x) % 3
        if x == 0 or r == 0:
            print('Possible')
            return

    print('Impossible')


if __name__ == '__main__':
    main()
"
"from copy import copy
from time import time
import random
t0 = time()
import math
import sys
input = sys.stdin.readline
D = int(input())
c = list(map(int,input().split()))
s = [list(map(int,input().split())) for _ in range(D)]
last = [0]*26
ans = [0]*D
score = 0
for i in range(D):
    ps = [0]*26
    for j in range(26):
        pl = copy(last)
        pl[j] = i+1
        ps[j] += s[i][j]
        for k in range(26):
            ps[j] -= c[k]*(i+1-pl[k])
    idx = ps.index(max(ps))
    last[idx] = i+1
    ans[i] = idx+1
    score += max(ps)
now = time()
lim = 1.85
T = 1000
while now-t0<lim:
    na = copy(ans)
    x = random.randint(1,365)
    y = random.randint(1,365)
    na[x-1] = na[y-1]
    last = [0]*26
    ns = 0
    for i in range(D):
        last[na[i]-1] = i+1
        ns += s[i][na[i]-1]
        for j in range(26):
            ns -= c[j]*(i+1-last[j])
    now = time()
    T = 1000+(-998)*(now-t0)/lim
    p = pow(math.e,-abs(ns-score)/T)
    if ns > score or random.random() < p:
        ans = na
        score = ns
for a in ans:
    print(a)"
"N, M ,C = map(int, input().split())
B = list(map(int, input().split()))
n = 0
for i in range(N):
    a = list(map(int, input().split()))
    AB = [x * y for (x, y) in zip(a,B)]

    if sum(AB) > -C:
        n += 1

print(n)
"
"n = int(input())
x = list(map(int, input().split()))

m = (n-1)//2
l = sorted(x)
for i in x:
  if i > l[m]: print(l[m])
  else: print(l[m+1])"
"import sys
import numpy as np
input = sys.stdin.readline

def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    divisors.sort(reverse=True)
    return divisors

def main():
    n, k = map(int, input().split())
    a = np.array([int(x) for x in input().split()])
    key = make_divisors(np.sum(a))
    
    for v in key:
        mod = np.sort(a%v)
        c1, c2 = 0, np.sum(mod)
        judge = c2
        for i in range(n-1, -1, -1):
            c1 += v-mod[i]
            c2 -= mod[i]
            judge = min(judge, max(c1, c2))
        if judge <= k:
            print(v)
            sys.exit()
    
    
if __name__ == ""__main__"":
    main()"
"#C
# 7,77,777･･･=7*(1,11,111･･･)
# 7*(10^i)=7*(10^i-1)/10-1 = 7*(10^i-1)/9 がkで割れる
# 10^iを(9k,7の倍数だったら9k/7)で割ってあまりが１だったら良い
import sys
k=int(input())
if k%7==0:
    k//=7
k*=9
a=10%k
for i in range(k):
    a=a%k
    if a==1:
        print(i+1)
        sys.exit()
    a*=10
print(-1)
"
"N = int(input())
A = [i for i in range(1, N)]
ans = 0
for i in range(N//2):
  a, b = A[i], A[N-2-i]
  if N == (a+b) and a != b:
    ans += 1
print(ans)    "
"import sys,collections,math
input = sys.stdin.readline

n,a,b = list(map(int,input().split()))
m = 10**9+7
ans = pow(2,n,m)


la  = 1
laa = 1
for i in range(n,n-a,-1):
    la = (la*i)%m
for i in range(1,a+1):
    laa = (laa*i)%m

lb  = 1
lbb = 1
for i in range(n,n-b,-1):
    lb = (lb*i)%m
for i in range(1,b+1):
    lbb = (lbb*i)%m

la = (la*pow(laa,10**9+5,m))%m
lb = (lb*pow(lbb,10**9+5,m))%m

print((ans-la-lb-1)%m)
"
"import math

X = int(input())

kane = 100
n = 0
while kane < X:
    n += 1
    kane = kane * 101
    kane = kane // 100

    #print(kane)
print(n)"
"N = int(input())
t_x_y = [list(map(int, input().split())) for _ in range(N)]
t_x_y.insert(0, [0, 0, 0])
 
ans = 'Yes'
for i in range(N):
  dt = t_x_y[i+1][0] - t_x_y[i][0]
  dist = abs(t_x_y[i+1][1] - t_x_y[i][1]) + abs(t_x_y[i+1][2] - t_x_y[i][2])
  
  # dt < dist が必要
  if dt < dist:
    ans = 'No'
    break
  else:
    # dt >= dist の上で、dtとdistの偶奇が一致すればよい
    if (dt - dist) % 2 != 0:
      ans = 'No'
      break
  
print(ans)"
"n = int(input())
A = []

for i in range(n):
    a = int(input())
    A.append(a)
A.sort()
i = 0
ans = 0
while True:
    cnt = 0
    while A[i + cnt] == A[i]:
        cnt += 1
        if i + cnt == n:
            break
    if cnt%2 == 1:
        ans += 1
    i += cnt
    if i == n:
        break
print(ans)"
"for i in range(365):
  print(i % 26 + 1)"
"# ？？？？？？？？？？？？？？？？？？？？？？？？？？
# ケース12と13、完全にバグとしか思えないのですが?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

# もしかして：頂点1は必ず0？

n = int(input())
a = list(map(int, input().split()))
if a[0] != 0:
    print(0)
    exit()
a = sorted(a)
d = {}
for av in a:
    if av not in d:
        d[av] = 1
    else:
        d[av] += 1

if a[0] != 0 or d[0] != 1 or len(set(d.keys())) != a[-1] + 1:
    print(0)
    exit()
MOD = 998244353
ans = 1
for i in range(2, a[-1] + 1):
    ans *= pow(d[i - 1], d[i], MOD)
print(ans % MOD)"
"import bisect, collections, copy, heapq, itertools, math, string, sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = float('inf')
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def sieve(n):
    is_prime = [True for _ in range(n+1)]
    is_prime[0] = False
    is_prime[1] = False
    for i in range(2, int(n**0.5)+1):
        if is_prime[i]:
            for j in range(i*2, n+1, i):
                is_prime[j] = False
    return [i for i in range(n+1) if is_prime[i]]

def resolve():
    N = I()

    primes = sieve(55555)
    # 1の位が同じ数字を5つ集めれば5の倍数になる
    ans = [i for i in primes if i % 10 == 3]
    print(*ans[:N])

if __name__ == '__main__':
    resolve()
"
"import math

N = int(input())
x = int(math.ceil(N / 1.08))
if int(x * 1.08) == N:
    print(x)
else:
    print(':(')
"
"import sys
input = lambda: sys.stdin.readline().rstrip()

def main():
    ab = [int(input()) for _ in range(2)]
    for i in range(1,4):
        if i not in ab:
            print(i)
            return

if __name__ == '__main__':
    main()"
"from functools import reduce
from fractions import gcd

POSSIBLE = ""POSSIBLE""
IMPOSSIBLE = ""IMPOSSIBLE""
n, k = map(int, input().split())
a = list(map(int, input().split()))

# max(a) < k → だめ
# N == 1 ぴったじゃなきゃだめ
# N > 1
## 互いに素な数が含まれている → ○
## 含まれてないが、kがその倍数 → ○
if max(a) < k:
    print(IMPOSSIBLE)
    exit()
if n == 1:
    if k == a[0]:
        print(POSSIBLE)
    else:
        print(IMPOSSIBLE)
else:
    g = reduce(lambda a, b: gcd(a, b), a)
    if g == 1:
        print(POSSIBLE)
    else:
        if k % g == 0:
            print(POSSIBLE)
        else:
            print(IMPOSSIBLE)

"
"N = int(input())
boss = [0] * N
A = map(lambda x:int(x) - 1, input().split())

for i in A:
    boss[i] += 1

print(*boss, sep='\n')"
"line = input()
a, b = [int(n) for n in line.split()]

largest = 0

x = [a+b, a-b, a*b]
x.sort()

print(x[-1])

"
"N = int(input())
S = set([])
for n in range(N):
  S.add(input())
print(len(S))"
"from bisect import bisect_right
import sys
def main():
    input = sys.stdin.readline
    N = int(input())
    *L, = map(int, input().split())
    L.sort()
    ans = 0
    for i in range(2, N):
        for j in range(i):
            k = bisect_right(L, L[i] - L[j], j + 1, i)
            ans += i - k
    print(ans)

if __name__ == '__main__':
    main()
"
"N = int(input())
S = [input() for _ in range(N)]

print(len(set(S)))
"
"N = int(input())
i = 1
ans = 0
while N:
  ans += i
  N //= 2
  i *= 2
print(ans)"
"N, K = list(map(int, input().split()))
X = [0]*N
Y = [0]*N
for i in range(N):
    X[i], Y[i] = list(map(int, input().split()))
YS = [[Y[i], i] for i in range(N)]
YS.sort()
# print(YS)

ans = 10**20
for i in range(N):
    for j in range(i+1, N):
        l, r = X[i], X[j]
        if l > r:
            l, r = r, l
        u = 0
        d = 0
        A = [(l <= X[k] <= r) for k in range(N)]
        # print(A)
        ct = A[YS[0][1]]
        for d in range(N):
            while ct < K:
                u += 1
                if u >= N:
                    break
                ct += A[YS[u][1]]
                # print(ct)
            else:
                S = (r-l)*(YS[u][0]-YS[d][0])
                ans = min(ans, S)
                ct -= A[YS[d][1]]
print(ans)
"
"input()
A=list(map(int,input().split()))
r=1
if 0 not in A:
  for a in A:
    r*=a
    if r>10e17:
      print(-1)
      break
  else:
    print(r)
else:
  print(0)"
"def dfs(li):
    if int("""".join(li)) > N:
        return 0
    cnt = 1 if all(i in li for i in ""357"") else 0
    for i in ""357"":
        cnt += dfs(li + [i])
    return cnt


N = int(input())
print(dfs([""0""]))
"
"H1,M1,H2,M2,K = map(int,input().split())
start = H1*60 + M1
finish = H2*60 + M2 - K

if finish - start >= 0:
  print(finish - start)
else:
  print(0)"
"N, K = input().split(sep=' ')
p = list(input().split(sep=' '))
p = list(map(int, p))
p.sort()
buy = 0
for item in range(int(K)):
  buy += p[item]
print(buy)"
"N = int(input())
n = N // 10
cnt = 0
if N % 2 == 0:
    while n != 0:
        cnt += n
        n //= 5
print(cnt)"
"import sys

input = sys.stdin.readline
N, M = map(int, input().split())
LR = [list(map(int, input().split())) for _ in range(M)]
common_l, common_r = 0, N
for l, r in LR:
    common_l = max(l, common_l)
    common_r = min(r, common_r)
print(max(0, common_r-common_l+1))
"
"MOD=1000000007
n,k=map(int,input().split())
a=[int(i) for i in input().split()]
pos=[]
neg=[]
nzero=0
for i in a:
    if i>0:
        pos.append(i)
    elif i<0:
        neg.append(-i)
    else:
        nzero+=1
if nzero+k>n:
    print(0)
elif nzero+k==n and len(pos)>0 and len(neg)>0:
    if nzero==0:
        res=1
        for i in pos+neg:
            res*=i
            res%=MOD
        if len(neg)%2:
            res*=-1
            res+=MOD
        print(res)
    elif len(neg)%2:
        print(0)
    else:
        res=1
        for i in pos+neg:
            res*=i
            res%=MOD
        print(res)
elif len(pos)==0:
    res=1
    if k%2 and nzero>0:
        print(0)
    elif k%2:
        neg.sort()
        for i in range(k):
            res*=MOD-neg[i]
            res%=MOD
        print(res)
    else:
        neg.sort(reverse=True)
        for i in range(k):
            res*=MOD-neg[i]
            res%=MOD
        print(res)
elif len(neg)==0:
    res=1
    pos.sort(reverse=True)
    for i in range(k):
        res*=pos[i]
        res%=MOD
    print(res)
else:
    pos.sort(reverse=True)
    neg.sort(reverse=True)
    ruip=[1 for i in range(len(pos)+1)]
    ruin=[1 for i in range(len(neg)+1)]
    for i in range(len(pos)):
        ruip[i+1]=ruip[i]*pos[i]
        ruip[i+1]%=MOD
    for i in range(len(neg)):
        ruin[i+1]=ruin[i]*neg[i]
        ruin[i+1]%=MOD
    np=0
    if len(pos)>=k:
        np=k
    elif (k-len(pos))%2:
        np=len(pos)-1
    else:
        np=len(pos)
    while np>=2 and (pos[np-1]*pos[np-2]<neg[k-np+1]*neg[k-np]):
        np-=2
        if len(neg)-1<k-np+1:
            break
    print((ruip[np]*ruin[k-np])%MOD)
"
"from functools import reduce
from fractions import gcd
from collections import defaultdict
import math
import bisect
import itertools
import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline
INF = float(""inf"")


# 処理内容
def main():
    N = int(input())
    S = input()[:-1]

    l = 0
    r = 0
    for i in range(N):
        if S[i] == ""."":
            r += 1
    
    ans = l + r
    for i in range(N):
        if S[i] == ""#"":
            l += 1
        else:
            r -= 1
        ans = min(ans, l + r)
    
    print(ans)
    


if __name__ == '__main__':
    main()"
"#!/usr/bin/env python3

import sys
import math
from bisect import bisect_right as br
from bisect import bisect_left as bl
sys.setrecursionlimit(2147483647)
from heapq import heappush, heappop,heappushpop
from collections import defaultdict
from itertools import accumulate
from collections import Counter
from collections import deque
from operator import itemgetter
from itertools import permutations
mod = 10**9 + 7
inf = float('inf')
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))

b = input()
if b == 'A':
    print('T')
elif b == 'T':
    print('A')
elif b == 'G':
    print('C')
else:
    print('G')"
"from collections import defaultdict
import sys


def input(): return sys.stdin.readline().strip()
def I(): return int(input())
def LI(): return list(map(int, input().split()))
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def S(): return input()
def LS(): return input().split()


INF = float('inf')


n, k = LI()
d = defaultdict(int)
for _ in range(n):
    a, b = LI()
    d[a] += b

d = sorted(d.items(), key=lambda x: x[0])
# print(d)
i = 0
ans = 1
cnt = 0
while cnt < k:
    ans = d[i][0]
    cnt += d[i][1]
    i += 1
print(ans)
"
"W,H,x,y = map(int,input().split())
if x == W/2 and y == H/2:
    a = 1
else:
    a = 0
print(W*H/2,a)"
"n,m=map(int,input().split())
s=n-((n//m)*m)
c=abs(s-m)
print(min(s,c))
"
"import collections
def solve(n, k, a_list):

    counter = collections.Counter()

    for i in a_list:
        counter[i] += 1

    key_num = len(counter.keys())
    if key_num > k:
        tmp = sorted(counter.items(), key=lambda x: x[1])
        ans = sum([v for k, v in tmp[: key_num - k]])
    else:
        ans = 0

    return ans

if __name__ == ""__main__"":
    n, k = [int(i) for i in input().split()]
    a_list = [int(i) for i in input().split()]
    print(solve(n, k, a_list))
"
"H, W, K = map(int, input().split())

c = []
for i in range(H):
    c.append(list(input()))

ans = 0

for i in range(1<<H):
    for j in range(1<<W):
        v = 0
        for k in range(H):
            for l in range(W):
                if c[k][l] == '#' and i >> k & 1 == 0 and j >> l & 1 == 0:
                    v += 1
        if v == K:
            ans += 1

print(ans)"
"n, m = map(int, input().split())
c = list(map(int, input().split()))

INF = 10**12

T = [i for i in range(n+1)]

for i in range(m):
    for j in range(1, n+1):
        if j - c[i] >= 0:
            T[j] = min(T[j], T[j - c[i]] + 1)

print(T[n])"
"import math
x1,y1,x2,y2=map(float,input().split())
print(f'{math.sqrt((x2-x1)**2+(y2-y1)**2):.5f}')
"
"S = input()

if S[0] == ""A"":
    if S[2:-1].count(""C"") == 1:
        if S[1:].replace(""C"", ""c"").islower():
            print(""AC"")
            exit()

print(""WA"")

"
"#!/usr/bin/env python3

def main():
    n = int(input())
    n_prev = [[2 for j in range(n)] for i in range(n)]
    post_matches = [[[] for j in range(n)] for i in range(n)]
    q = []
    for i in range(n):
        ai = list(map(int, input().split()))
        ai = [x - 1 for x in ai]
        for j in range(n - 1):
            x = min(i, ai[j])
            y = max(i, ai[j])
            if j == 0:
                n_prev[x][y] -= 1
                if n_prev[x][y] == 0:
                    q.append((x, y))
            else:
                xp = min(i, ai[j - 1])
                yp = max(i, ai[j - 1])
                post_matches[xp][yp].append((x, y))

    time = 0
    while q:
        time += 1
        qn = []
        while q:
            i, j = q.pop()
            for i2, j2 in post_matches[i][j]:
                n_prev[i2][j2] -= 1
                if n_prev[i2][j2] == 0:
                    qn.append((i2, j2))
        q = qn

    for i in range(n):
        for j in range(i + 1, n):
            if n_prev[i][j] > 0:
                print(-1)
                return
    print(time)

if __name__ == ""__main__"":
    main()
"
"from sys import exit
from math import gcd

def eratosthenes(n):
    '''
    n以下の整数の素数判定/列挙 (n > 1)
    O(NloglogN)
    '''
    is_prime = [True] * (n+1)
    is_prime[0] = False
    is_prime[1] = False
    judge = [i for i in range(n+1)]
    
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*2, n+1, i):
                is_prime[j] = False
                judge[j] = i

    return judge


n = int(input())
a = list(map(int, input().split()))

l = eratosthenes(10**6+1)

flag = True
used = [False] * (10**6+1)
for v in a:
    while v > 1:
        d = l[v]

        if used[d]:
            flag = False
        else:
            used[d] = True
        
        while v % d == 0:
            v //= d

if flag:
    print('pairwise coprime')
    exit()

g = a[0]
for v in a:
    g = gcd(g, v)

print('setwise coprime' if g == 1 else 'not coprime')"
print(input()[0:1]+ input()[1:2]+ input()[2:3])
"def selectionSort(A):
    N = len(A)
    cnt = 0
    for i in range(N):
        min_i = i
        for j in range(i,N):
            if A[j] < A[min_i]:
                min_i = j
        if min_i != i:
            A[i], A[min_i] = A[min_i], A[i]
            cnt += 1
    print(*A)
    print(cnt)

N=int(input())
A=list(map(int, input().split()))
selectionSort(A)"
"# F - Select Half
N = int(input())
A = list(map(int,input().split()))

if N%2==0:
    rec = [[0]*N for _ in range(2)]
    rec[0][0] = A[0]
    rec[1][1] = A[1]
    for i in range(2,N):
        rec[0][i] = rec[0][i-2]+A[i]
        rec[1][i] = max(rec[0][i-3],rec[1][i-2])+A[i]
    ans = max(rec[0][N-2],rec[1][N-1])
else:
    rec = [[0]*N for _ in range(3)]
    rec[0][0] = A[0]
    rec[1][1] = A[1]
    rec[0][2] = A[0]+A[2]
    rec[2][2] = A[2]
    for i in range(3,N):
        rec[0][i] = rec[0][i-2]+A[i]
        rec[1][i] = max(rec[0][i-3],rec[1][i-2])+A[i]
        rec[2][i] = max(rec[0][i-4],rec[1][i-3],rec[2][i-2])+A[i]
    ans = max(rec[0][N-3],rec[1][N-2],rec[2][N-1])
    
print(ans)"
"x,y = map(int,input().split())


if y%2 != 0 or y > 4*x or y < 2*x:
  print('No')
else:
  print('Yes')"
"x, n = map(int, input().split())
p = list(map(int,input().split()))
s = x
d = 1
while s in p:
    s = s - d
    d = int((abs(d)+1)*d/abs(d)*(-1))
print(s)"
"s = input()
k = int(input())
n = len(s)

def f(S):
    res = 0
    count = 1
    length = len(S)
    for i in range(1,length):
        if S[i] == S[i-1]:
            count += 1
        else:
            res += count // 2
            count = 1
    res += count // 2
    return res

res1 = f(s)
res2 = f(s+s)
res3 = f(s+s+s)

if res2 - res1 == res3 - res2:
    print(res1 + (res2-res1) * (k-1))
else:
    print(n * k // 2)
"
"from sys import stdin
A, B, C = [int(_) for _ in stdin.readline().rstrip().split()]
if A == B == C:
  print('Yes')
else:
  print('No')"
"import sys
input = sys.stdin.readline
from collections import *

N, M = map(int, input().split())
ab = [tuple(map(int, input().split())) for _ in range(M)]
ab.sort(key=lambda t: t[1])
ans = 0
prev_b = -1

for a, b in ab:
    if a>=prev_b:
        ans += 1
        prev_b = b

print(ans)"
"(N,) = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]

numLeafs = A
minNonLeafs = [None for i in range(N + 1)]
maxNonLeafs = [None for i in range(N + 1)]

maxNonLeafs[0] = 1
for i in range(1, N + 1):
    maxNonLeafs[i] = 2 * maxNonLeafs[i - 1] - numLeafs[i]

minNonLeafs[N] = 0
maxNonLeafs[N] = 0
if minNonLeafs[N] + numLeafs[N] > 2 ** N:
    print(-1)
    exit()

for i in range(N - 1, -1, -1):
    minNonLeafs[i] = (minNonLeafs[i + 1] + numLeafs[i + 1] + 1) // 2
    if minNonLeafs[i] + numLeafs[i] > 2 ** i:
        print(-1)
        exit()
    maxNonLeafs[i] = min(maxNonLeafs[i], maxNonLeafs[i + 1] + numLeafs[i + 1])
    if minNonLeafs[i] > maxNonLeafs[i]:
        print(-1)
        exit()

count = 0
for i in range(N + 1):
    count += maxNonLeafs[i] + numLeafs[i]
print(count)
"
"N = int(input())
A = list(map(int, input().split()))

cumulative = [0]
for i in range(N):
    cumulative.append(cumulative[i] + A[i])
lst = []
for i in range(1, N):
    a = abs(cumulative[i] - (cumulative[-1] - cumulative[i]))
    lst.append(a)
#print(lst)
print(min(lst))"
"N,M,X,Y = map(int,input().split())
x = list(map(int,input().split()))
y = list(map(int,input().split()))

for Z in range(-100,102):
    if X<Z<=Y and max(x)<Z and min(y)>=Z:
        print('No War')
        break
else:
    print('War')"
"import bisect
import copy
import heapq
import math
import sys
from collections import *
from itertools import accumulate, combinations, permutations, product
def main():
    # from math import gcd
    def input():
        return sys.stdin.readline()[:-1]
    def ruiseki(lst):
        return [0]+list(accumulate(lst))
    mod=pow(10,9)+7
    al=[chr(ord('a') + i) for i in range(26)]
    direction=[[1,0],[0,1],[-1,0],[0,-1]]

    h,w=map(int,input().split())
    a=[input() for i in range(h)]

    cnt=0

    itta=[[10**9]*w for i in range(h)]

    d=deque()
    # aaa=d.append
    for i in range(h):
        for j in range(w):
            if a[i][j]==""#"":
                d.append((i,j))
                itta[i][j]=0

    # print(d)
    # print(itta)

    while d:
        cnt+=1
        for l in range(len(d)):
            nh,nw=d.popleft()
            for i in range(4):
                d1,d2=direction[i]
                if 0<=nh+d1<h and 0<=nw+d2<w:
                    if itta[nh+d1][nw+d2]==10**9:
                        itta[nh+d1][nw+d2]=cnt
                        d.append((nh+d1,nw+d2))
        # print(d)

    # print(itta)
    print(cnt-1)

if __name__ == '__main__':
    main()"
"n = int(input())
t, a = list(map(int, input().split()))
h_list = list(map(int, input().split()))

def temp(x):
    y = abs(t - x*0.006 - a)
    return y
t_dif = list(map(temp, h_list))
t_min = min(t_dif)
t_index = int(t_dif.index(t_min))
print(t_index+1)"
"a, b, k = map(int, input().split())
for i in range(k):
    if i % 2 == 0:
        if a % 2 == 1:
            a -= 1
        a, b = a // 2, b+a//2
    else:
        if b % 2 == 1:
            b -= 1
        a, b = a+b//2, b//2
print(a, b)"
"S = input()
num = len(S)//2
if num % 2 == 0:
    for i in range(num):
        if S[i] == S[-i-1]:
            num -= 1
else:
    for i in range(num):
        if S[i] == S[-i-1]:
            num -= 1
print(num)"
"a = []
while True:
    n = int(input())
    if n == 0:
        break
    a.append(n)

for i in range(len(a)):
    b = list(str(a[i]))
    sum = 0
    for j in b:
        sum += int(j)
    print(sum)"
"S = list(map(str, input().split()))
I = list(map(int, input().split()))
U = input()
print(I[0] - (U == S[0]), I[1] - (U == S[1]))"
"N = int(input())
K = int(input())
X = [int(a) for a in input().split()]

ans = 0
for i in range(N):
    a = X[i] * 2
    b = abs(X[i]-K) * 2
    ans += min(a, b)
print(ans)"
"date = input()

new_date = ""2018/01/"" + date[-2:]

print(new_date)"
"N = int( input() )
A = input()
B = input()
C = input()


ans = 0
for i in range(N):
    if A[i] == B[i] and B[i] != C[i]: ans += 1
    if A[i] != B[i] and B[i] == C[i]: ans += 1
    if A[i] != B[i] and A[i] == C[i]: ans += 1
    if A[i] != B[i] and B[i] != C[i] and C[i] != A[i]: ans += 2

print( ans )"
"n=int(input())
l=list(map(int,input().split()))
print('YNeos'[max(l)*2>=sum(l)::2])"
"import sys

input = sys.stdin.readline


def main():
    N = int(input())
    A = tuple(map(int, input().split()))

    ans = 0
    b = -1
    cnt = 0
    for a in A:
        if b == a:
            cnt += 1
        else:
            ans += cnt // 2
            cnt = 1
            b = a
    ans += cnt // 2

    print(ans)


if __name__ == ""__main__"":
    main()
"
"n, k = map(int, input().split())
s = input()
print(s[:k-1]+s[k-1].lower()+s[k:])"
"X, Y, Z = map(int, input().split())
b = Y + 2 * Z
ans = 1
while True:
  b += Y + Z
  if b > X:
    break
  else:
    ans += 1
print(ans)"
print('Hello World' if input() == '1' else int(input()) + int(input()))
"o = input()
e = input()
for i in range(len(o+e)):
    if i % 2 == 0:
        print(o[i//2],end="""")
    else:
        print(e[(i-1)//2],end="""")"
"n = int(input())
As = list(map(int, input().split()))

a = max(As)

# 一番a/2に近い数を選ぶ
b = None
dist = float('inf')
for i in range(n):
    if As[i] != a and abs(As[i] - a/2) < dist:
        dist = abs(As[i] - a/2)
        b = As[i]

print(a, b)
"
"K=int(input())
A,B=map(int,input().split())
AB_list = [i for i in range(A,B+1) if i % K == 0]
if len(AB_list) != 0:
    print('OK')
else:
    print('NG')
"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits

def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7

n = INT()
a = LIST()

l = [1]*n
l1 = [l[i]*(-1)**i for i in range(n)]
l2 = [l[i]*(-1)**(i+1) for i in range(n)]

ans1 = 0
tmp1 = 0
for i, r in enumerate(a):
	tmp1 += r
	if tmp1*l1[i] <= 0:
		ans1 += abs(tmp1) + 1
		tmp1 = l1[i]

ans2 = 0
tmp2 = 0
for i, r in enumerate(a):
	tmp2 += r
	if tmp2*l2[i] <= 0:
		ans2 += abs(tmp2) + 1
		tmp2 = l2[i]

print(min(ans1, ans2))"
"import sys

sys.setrecursionlimit(10 ** 7)

read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(input())
S = list(input())

ans = 0

for l2 in range(1, N):
    same_len = 0
    for i in range(N):
        if N - 1 < l2 + i:
            continue

        if S[i] == S[l2 + i]:
            same_len += 1
        else:
            same_len = min(l2, same_len)
            ans = max(ans, same_len)
            same_len = 0
    same_len = min(l2, same_len)
    ans = max(same_len, ans)

print(ans)
"
"n,m=int(input()),10**9+7
print((pow(10,n,m)-2*pow(9,n,m)+pow(8,n,m))%m)"
"def actual(s):
    return s.replace(',', ' ')

s = input()
print(actual(s))"
"from collections import defaultdict
from itertools import accumulate


def solve():
    N, K, *A = map(int, open(0).read().split())
    
    Acumsum = [0] + list(accumulate(A))
    si = [(Acumsum[i] - i) % K for i in range(N + 1)]
    counter = defaultdict(int)
    
    ans = 0
    for j in range(N):
        counter[si[j]] += 1
        if 0 <= j - K + 1:
            counter[si[j - K + 1]] -= 1
        ans += counter[si[j + 1]]
    print(ans)


if __name__ == '__main__':
    solve()
"
"N = int(input())
slimes = input()

count = 1
current = None

for s in slimes:
  if current is None:
    current = s
    next
  if current != s:
    count +=1
  current = s
    
print(count)

"
"import sys
from collections import deque
#import numpy as np
import math
#sys.setrecursionlimit(10**6)
def S(): return sys.stdin.readline().rstrip()
def SL(): return map(str,sys.stdin.readline().rstrip().split())
def I(): return int(sys.stdin.readline().rstrip())
def IL(): return map(int,sys.stdin.readline().rstrip().split())

def solve(val):
    if val<=1:
        return 1
    else:
        return 2*solve(val//2)+1

if __name__=='__main__':
    h = I()
    print(solve(h))"
"def GSB(n):
	ans = -1
	for i in range(30):
		if n&(1<<i):
			ans = i
	return ans
def ans(a,b,c,d,M):
	other = [x for x in range(1<<M) if x not in [a,b,c,d]]
	print(*([a,b]+other+[c,d]+other[::-1]+[b,a,d,c]))

def solve(M,K):
	if K==0:
		arr = list(range(1<<M))
		print(*(arr+arr[::-1]))
	elif K==1:
		if M < 2:
			print(-1)
		else:
			ans(0,1,2,3,M)
	else:
		if M > GSB(K):
			a = 1<<GSB(K)
			b = K^a
			c = a+1
			d = K^c
			ans(a,b,c,d,M)
		else:
			print(-1)


solve(*map(int,input().split()))"
"a, b, t = [int(x) for x in input().split()]
print(b * (t // a))"
"n = list(str(input()))

ans = 0

for i in range(len(n)):
    if n[i] == '2':
        ans += 1
print(ans)
    
"
"#D
N = int(input())
S = input()

ans = S.count('R')*S.count('G')*S.count('B')

for start in range(0,N-2):
    for interval in range(1,N):
        try:
            if S[start] != S[start+interval] and S[start] != S[start+2*interval] and S[start+interval] != S[start+2*interval]:
                ans -= 1
        except IndexError:
            break
print(ans)"
"S, T=input(), input()
print(f'{""Yes"" if S==T[:-1] else ""No""}')"
"label = input().split()
rot = input()

dice = {
        ""top"":1,
        ""front"":2,
        ""right"":3,
        ""left"":4,
        ""back"":5,
        ""bottom"":6
        }

for r in rot:
    if r == 'E':
        t = dice[""top""]
        dice[""top""] = dice[""left""]
        dice[""left""] = dice[""bottom""]
        dice[""bottom""] = dice[""right""]
        dice[""right""] = t
    elif r == 'N':
        t = dice[""top""]
        dice[""top""] = dice[""front""]
        dice[""front""] = dice[""bottom""]
        dice[""bottom""] = dice[""back""]
        dice[""back""] = t
    elif r == 'S':
        t = dice[""top""]
        dice[""top""] = dice[""back""]
        dice[""back""] = dice[""bottom""]
        dice[""bottom""] = dice[""front""]
        dice[""front""] = t
    elif r == 'W':
        t = dice[""top""]
        dice[""top""] = dice[""right""]
        dice[""right""] = dice[""bottom""]
        dice[""bottom""] = dice[""left""]
        dice[""left""] = t
print(label[dice[""top""]-1])"
"import sys
sys.setrecursionlimit(2147483647)
INF = float(""inf"")
MOD = 10**9 + 7 # 998244353
input = lambda:sys.stdin.readline().rstrip()
def resolve():
    n = int(input())
    dp = [0] * (n + 1)
    dp[0] = 1
    for p in map(float, input().split()):
        ndp = [0] * (n + 1)
        for i in range(n):
            ndp[i + 1] += dp[i] * p
        for i in range(n):
            ndp[i] += dp[i] * (1 - p)
        dp = ndp

    res = 0
    for i in range(n + 1):
        if 2 * i > n:
            res += dp[i]
    print(res)
resolve()"
"def main():
    N = int(input())
    mod = 10**9 + 7
    v = {'TTTT': 1}
    for _ in range(N):
        u = {}
        for c, k in v.items():
            c = c[1:]
            for i in 'ACGT':
                t = c + i
                if 'AGC' in t or 'GAC' in t or 'ACG' in t or (t[0] == 'A' and t[2:] == 'GC') or (t[:2] == 'AG' and t[3] == 'C'):
                    continue
                u[t] = (u.get(t, 0) + k) % mod
        v = u
    print(sum(v.values()) % mod)

main()
"
"import sys
import numpy as np
from numba import jit
 
readline = sys.stdin.readline
 
@jit
def loop(n,k,a):
    for j in range(k):
        b = np.zeros(n+1, dtype=np.int64)
        for i in range(n):
            b[max(i-a[i], 0)] += 1
            b[min(i+a[i]+1, n)] -= 1
        a = np.cumsum(b)[:-1]
        if np.all(a==n):
            return(a)
            break
    else:
        return(a)
 
 
n, k = map(int, readline().split())
a = np.array(readline().split(), dtype=np.int64)
 
ans = loop(n,k,a)
print(*ans)"
"S = input()
N = int(input())
flg = 0
L = []
for i in range(N):
    e = input().split()
    if e[0] == '1':
        flg += 1
        flg = flg%2
    else:
        L.append(((flg+int(e[1]))%2, e[2]))

S = ''.join(list(reversed(S))) if flg else S
s1, s2 = '', ''
for f, v in L:
    if (flg+f)%2 == 1:
        s1 += v
    else:
        s2 += v

ans = ''.join(list(reversed(s1))) + S + s2
print(ans)"
"def com_div(x, y):
    dv = []
    m = min(x, y)
    for i in range(1, m + 1):
        if x % i == 0 and y % i == 0:
            dv.append(i)
    dv.sort()
    return dv[::-1]


a, b, k = list(map(int, input().split()))
print(com_div(a, b)[k - 1])"
"#17
n,T = map(int,input().split())
t = list(map(int,input().split()))
Sum = T

for i in range(n-1):
    if t[i+1]-t[i]<T:
        Sum += t[i+1]-t[i]
    else:
        Sum += T
        
print(Sum)"
"s = list(input())

if s[0] == s[2]:
  print(""H"")
else:
  print(""D"")"
"a,b=[int(input()) for i in range(2)]
print(""GREATER"" if a>b else ""LESS"" if a<b else ""EQUAL"")"
"import sys


def solve():
    readline = sys.stdin.buffer.readline
    mod = 10 ** 9 + 7
    n = int(readline())
    print((1000 - n % 1000) % 1000)


if __name__ == '__main__':
    solve()
"
"n = int(input())
a = list(map(int,input().split()))
ans = 0

from collections import defaultdict
dd = defaultdict(int)
for key in a:
    dd[key] += 1
for key in dd.keys():
    #print(key,dd[key])
    if dd[key]>=key:
        ans += dd[key]-key
    else:
        ans += dd[key]
print(ans)"
"a,b=map(int,input().split())
c=int(str(a)*b)
d=int(str(b)*a)
if c>d:
  print(str(a)*b)
else:
  print(str(b)*a)
"
"n,k=map(int,input().split())
print(n*k)"
""""""" AtCoder """"""

N = int(input())

print(N//3)
"
"n = int(input())
s = input()
ss = list(s)[::-1]

white = 0
black = 0
w = [0] * n
b = [0] * n

for i in range(n):
    if s[i] == '#':
        black += 1
    if ss[i] == '.':
        white += 1
    b[i] = black
    w[-i-1] = white

ans = 10**9

for i in range(n):
    if b[i] + w[i] < ans:
        ans = b[i] + w[i]

print(ans-1)"
"A,B,C = map(int,input().split())

water = ((B + C) - A)
if water < 0 :
    print(0)
else:
    print(water)"
"n,k = map(int,input().split())
d = {}
for _ in range(n):
    a,b = map(int,input().split())
    if not a in d:
        d[a] = b
    else:
        d[a] += b

c = 0
for v in sorted(d.items()):
    c += v[1]
    if k <= c:
        print (v[0])
        exit ()
"
"#33 2020/07/14
A, B = input().split(' ')
A = int(A)
B = int(B)
S = input()
if not '-' in S:
  print('No')
else:
  S = S.split('-')
  if '-' in S[0] or '-' in S[1]:
    print('No')
  elif len(S[0]) == A and len(S[1]) == B:
    print('Yes')
  else:
    print('No')
"
"import itertools

MOD = 10 ** 9 + 7

H, W = map(int, input().split())
A = [input() for _ in range(H)]

dp = [[0 for _ in range(W + 1)] for _ in range(H + 1)]
dp[1][1] = 1

it = itertools.product(range(H), range(W))
next(it)
for h, w in it:
    if A[h][w] == '.':
        dp[h + 1][w + 1] = (dp[h][w + 1] + dp[h + 1][w]) % MOD
print(dp[H][W])
"
"N,K = map(int,input().split())
mod = 10**9+7
ans = 0

data = [0]*(K+1)
for x in range(K,0,-1):
    p = pow(K//x,N,mod)
    for k in range(2,K//x+1):
        p -= data[k*x]
        p %= mod
    data[x] = p
    ans += x*p
    ans %= mod

###
#print(data)
###
    
print(ans)"
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# 問題：https://atcoder.jp/contests/abc127/tasks/abc127_d
# プライオリティキュー　解説を見ながら実装


import heapq

n, m = map(int, input().strip().split())

q = []
a = list(map(int, input().strip().split()))
for i in range(n):
    heapq.heappush(q,(a[i]*(-1), 1))
for i in range(m):
    b, c = map(int, input().strip().split())
    heapq.heappush(q,(c*(-1), b))

res = 0
for _ in range(n):
    c, b = heapq.heappop(q)
    res += c * (-1)
    if b > 1:
        b -= 1
        heapq.heappush(q, (c, b))

print(res)
"
"a,b,c,d,e,f = list(map(int, input().split()))
maxn = -1
ans = ()
for at in range(0,31):
    for bt in range(0,31-at):
        water = (at * a + bt * b) * 100
        if water > f:
            continue

        # 溶け残らないように砂糖を選ぶ
        maxsugar = water * e // 100
        for ct in range(0, maxsugar//c + 1):
            for dt in range(0, (maxsugar-ct*c)//d + 1):
                sugar = ct * c + dt * d

                if 0 < sugar + water <= f and sugar <= (at * a + bt * b) * e:
                    # 水１００に対して溶けている砂糖の量
                    n = 100 * sugar / water
                    if n == e:
                        print(water + sugar, sugar)
                        exit()
                    if n > maxn:
                        ans = water + sugar, sugar
                        maxn = n
print(*ans)"
"n = int(raw_input())
s = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
h = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
c = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
d = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]

for i in range(n):
    x = raw_input().split()
    x[1] = int(x[1])
    if x[0] == ""S"":
        s[x[1]] = 1
    elif x[0] == ""H"":
        h[x[1]] = 1
    elif x[0] == ""C"":
        c[x[1]] = 1
    elif x[0] == ""D"":
        d[x[1]] = 1

for i in range(1,14):
    if s[i] != 1:
        print ""S %d"" %i
for i in range(1,14):
    if h[i] != 1:
        print ""H %d"" %i
for i in range(1,14):
    if c[i] != 1:
        print ""C %d"" %i
for i in range(1,14):
    if d[i] != 1:
        print ""D %d"" %i"
"L = list(map(int,input().split()))
s = set(L)
print(len(s))"
"n, p = map(int, input().split())
s = input()[::-1]
if p == 2:
  ans = 0
  for num, i in enumerate(s):
    if int(i)%2 == 0:
      ans += n-num
elif p == 5:
  ans = 0
  for num, i in enumerate(s):
    if int(i)%5 == 0:
      ans += n-num
else:
  C = [0]*p
  now = 0
  for num, i in enumerate(s):
    a = int(i)
    now = (now+pow(10, num, p)*a)%p
    C[now] += 1
  ans = C[0]
  for c in C:
    ans += c*(c-1)//2
print(ans)"
"a,b = map(int,input().split())
c = a

for i in range(b):
    if c % b == 0:
        break
    c += a

print(c)"
"n = int(input())
g = [[-1 for _ in range(15)] for _ in range(15)]
for i in range(n):
  a = int(input())
  for j in range(a):
    x, y = map(int, input().split())
    g[i][x-1] = y
    
ans = 0
for bit in range(1<<n):
  honests = [0]*n
  for i in range(n):
    if bit & 1<<i: honests[i] = 1
  flg = True
  for i in range(n):
    if honests[i]:
      for j in range(n):
        if g[i][j] == -1: continue
        if g[i][j] != honests[j]: flg = False
  if flg:
    ans = max(ans, honests.count(1))
print(ans)"
"n= [int(s) for s in input().split()]
n.sort()
max_value = n[2] * 10 + n[1] + n[0]

print(max_value)"
"a, b = input().split()
c = a * int(b)
d = b * int(a)
print(min(c, d))"
"n, h0, w0 = map(int, input().split())
count = 0
for i in range(n):
    h, w = map(int, input().split())
    if h >= h0 and w >= w0:
        count += 1

print(count)

"
"score = [0, 0]

n = int(raw_input())
for i in range(n):
    t, h = raw_input().split()
    if t < h:
        score[1] += 3
    elif t > h:
        score[0] += 3
    else:
        score[0] += 1
        score[1] += 1
print score[0], score[1]"
"import bisect
from collections import Counter
import sys


def input(): return sys.stdin.readline().strip()
def I(): return int(input())
def LI(): return list(map(int, input().split()))
def IR(n): return [I() for i in range(n)]
def LIR(n): return [LI() for i in range(n)]
def SR(n): return [S() for i in range(n)]
def S(): return input()
def LS(): return input().split()


n, m = LI()
a = LI()
a = sorted(a)[::-1]
bc = LIR(m)
bc = sorted(bc, key=lambda x: x[1])[::-1]
all_c = []
for bi, ci in bc:
    all_c += [ci] * bi
    if len(all_c) >= n:
        break
if len(all_c) < n:
    all_c += [0] * (n - len(all_c))

ans = 0
a_i = 0
c_i = 0
for _ in range(n):
    if a[a_i] > all_c[c_i]:
        ans += a[a_i]
        a_i += 1
    else:
        ans += all_c[c_i]
        c_i += 1
print(ans)
"
"A, B = map(int, input().split())
k = A + B
print(int(k / 2) if k%2 == 0 else ""IMPOSSIBLE"")"
"import sys
def MI(): return map(int,sys.stdin.readline().rstrip().split())

N,M = MI()
xv = [(0,0)] + [tuple(MI()) for _ in range(N)]

A = [0]*(N+1)  # 時計回りにi貫目までいけるとき、差し引き得られる最大キロカロリー
a = 0
for i in range(1,N+1):
    x,v = xv[i]
    x0,v0 = xv[i-1]
    a += v-(x-x0)
    if a > A[i-1]:
        A[i] = a
    else:
        A[i] = A[i-1]

B = [0]*(N+1)  # 時計回りにi貫目までいけるとき、差し引き得られる最大キロカロリー(最後初期位置に戻る)
b = 0
for i in range(1,N+1):
    x,v = xv[i]
    x0,v0 = xv[i-1]
    b += v-2*(x-x0)
    if b > B[i-1]:
        B[i] = b
    else:
        B[i] = B[i-1]

for i in range(1,N+1):
    x,v = xv[i]
    xv[i] = (M-x,v)
xv.sort()

C = [0]*(N+1)  # 反時計回りにi貫目までいけるとき、差し引き得られる最大キロカロリー
c = 0
for i in range(1,N+1):
    x,v = xv[i]
    x0,v0 = xv[i-1]
    c += v-(x-x0)
    if c > C[i-1]:
        C[i] = c
    else:
        C[i] = C[i-1]

D = [0]*(N+1)  # 反時計回りにi貫目までいけるとき、差し引き得られる最大キロカロリー(最後初期位置に戻る)
d = 0
for i in range(1,N+1):
    x,v = xv[i]
    x0,v0 = xv[i-1]
    d += v-2*(x-x0)
    if d > D[i-1]:
        D[i] = d
    else:
        D[i] = D[i-1]

ans = 0
for i in range(N+1):
    ans = max(ans,A[i]+D[N-i])
    ans = max(ans,C[i]+B[N-i])
print(ans)
"
"def L():
    return list(map(int, input().split()))

[x,y]=L()

if x%y==0:
  print(-1)
else:
  print(x)
"
"n = int(input())

d2 = n % 100
u2 = n // 100

if 1 <= d2 <= 12 and 1 <= u2 <= 12:
    print(""AMBIGUOUS "")
elif 1 <= d2 <= 12:
    print(""YYMM"")
elif 1 <= u2 <= 12:
    print(""MMYY"")
else:
    print(""NA"")
"
"import itertools


def main():
    N = int(input())
    P = list(map(int, input().split()))
    Q = list(map(int, input().split()))
    lst = sorted(P)

    for i, j in enumerate(itertools.permutations(lst)):
        if list(j) == P:
            a = i
        if list(j) == Q:
            b = i

    print(abs(a - b))


if __name__ == ""__main__"":
    main()
"
"n = input()
a = map(int,raw_input().split())
a.sort()
print a[0],a[n-1],sum(a)"
"from collections import deque

N = int(input())
b = list(map(int, input().split()))

result = deque([])
while b:
    for i in range(len(b) - 1, -1, -1):
        if b[i] == i + 1:
            result.appendleft(b.pop(i))
            break
    else:
        break

if not b:
    print('\n'.join(str(i) for i in result))
    #print(*result, sep='\n')
else:
    print(-1)
"
"from collections import deque

def solve():
    H, W = map(int, input().split())
    A = [list(input()) for _ in range(H)]
    INF = 10 ** 9
    d = [[INF] * W for i in range(H)]
    d[0][0] = 1 if A[0][0] == '#' else 0

    prepare = 1 if A[0][0] == '#' else 0
    q = deque([(prepare, 0, 0)])
    while q:
        c, x, y = q.popleft()
        for a, b in [(1,0), (0,1)]:
            nx, ny = x+a, y+b
            if nx >= W or ny >= H: continue
            k = 1 if A[y][x] != A[ny][nx] else 0
            if c+k >= d[ny][nx]: continue
            d[ny][nx] = c+k
            q.append((c+k, nx, ny))

    return (d[H-1][W-1]+1)//2

print(solve())"
"import sys
sys.setrecursionlimit(10**6)

#a = int(input())
#b = list(map(int, input().split()))
a, b = map(int, input().split())
#s = input()
#s,t = input().split()
#a = [int(input()) for _ in range(n)]
#
#readline = sys.stdin.readline
#n,m = [int(i) for i in readline().split()]
#ab = [[int(i) for i in readline().split()] for _ in range(n)]

if a <= 5:
    print(0)
elif a >= 13:
    print(b)
else:
    print(b//2)"
"# -*- coding: utf-8 -*-
import bisect
import heapq
import math
import random
from collections import Counter, defaultdict, deque
from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal
from fractions import Fraction
from functools import lru_cache, reduce
from itertools import combinations, combinations_with_replacement, product, permutations, accumulate
from operator import add, mul, sub, itemgetter, attrgetter


import sys
# sys.setrecursionlimit(10**6)
# readline = sys.stdin.buffer.readline
readline = sys.stdin.readline

INF = 2**62-1


def read_int():
    return int(readline())


def read_int_n():
    return list(map(int, readline().split()))


def read_float():
    return float(readline())


def read_float_n():
    return list(map(float, readline().split()))


def read_str():
    return readline().strip()


def read_str_n():
    return readline().strip().split()


def error_print(*args):
    print(*args, file=sys.stderr)


def mt(f):
    import time

    def wrap(*args, **kwargs):
        s = time.perf_counter()
        ret = f(*args, **kwargs)
        e = time.perf_counter()

        error_print(e - s, 'sec')
        return ret

    return wrap


@mt
def slv(N, M, A):
    return reduce(lambda x, y: x + y*(y-1)//2, Counter(accumulate([0]+A, lambda x, y: (x+y) % M)).values(), 0)


def main():
    N, M = read_int_n()
    A = read_int_n()
    print(slv(N, M, A))


if __name__ == '__main__':
    main()
"
"import sys

read = sys.stdin.read
readline = sys.stdin.buffer.readline
sys.setrecursionlimit(10 ** 8)
INF = float('inf')
MOD = 10 ** 9 + 7


class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())


def main():
    N, M = map(int, readline().split())
    edge = list(list(map(int, readline().split())) for _ in range(M))
    bridge = 0
    for i in range(M):
        uf = UnionFind(N)
        for j in range(M):
            if i==j:
                continue
            else:
                uf.union(edge[j][0]-1, edge[j][1]-1)
        if uf.group_count()>1:
            bridge += 1
    print(bridge)



if __name__ == '__main__':
    main()
"
"

def read_int():
    return int(input().strip())


def read_ints():
    return list(map(int, input().strip().split(' ')))


def solve():
    W, a, b = read_ints()
    if a+W <= b:
        return abs(a+W-b)
    if b+W <= a:
        return abs(b+W-a)
    return 0


if __name__ == '__main__':
    print(solve())
"
"a, b = input().split()
c = int(a + b)

if (c**0.5).is_integer():
    print('Yes' , flush=True)
else:
    print('No' , flush=True)
"
"# -*- coding: utf-8 -*-


def main():
    s_length = raw_input()
    s = set(raw_input().strip().split(' '))
    t_length = raw_input()
    t = set(raw_input().strip().split(' '))

    print len(s.intersection(t))

if __name__ == '__main__':
    main()"
"if __name__ == '__main__':
    N, A, B = map(int, input().split())
    
    if A%2 == B%2:
        print(""Alice"")
    else:
        print('Borys')"
"N, M = [int(x) for x in input().split()]
A = [int(input()) for _ in range(M)]

aset = set(A)
MOD = 10 ** 9 + 7

dp = [0] * (N + 1)

if 1 not in aset:
    dp[1] = 1

if 2 not in aset and N >= 2:
    dp[2] += dp[1] + 1

for i in range(3, N + 1):
    if i in aset:
        continue

    dp[i] += dp[i - 1]
    dp[i] += dp[i - 2]

print(dp[N] % MOD)
"
"N=input()

num=list(N)
sum=0;
for i in range(1 << len(num)-1):
    l=[]
    for j in range(len(num)):
        l+=num[j]
        if (j != len(num)-1):
            if (i & (1<<j)):
                l+=['+']
        
    sum+=eval("""".join(l))
print(sum)
"
"import math

n = int(input())
aL = list(map(int, input().split("" "")))

d1 = {}
d2 = {}
for i in range(n):
    d1i = i - aL[i]
    d2i = i + aL[i]

    if d1i in d1:
        d1[d1i] += 1
    else:
        d1[d1i] = 1

    if d2i in d2:
        d2[d2i] += 1
    else:
        d2[d2i] = 1

ans = 0
for k, v in d2.items():
    if k in d1:
        ans += v * d1[k]

print(ans)"
"import math

pi = math.pi

n = int(input())
p1 = [0,0]
p2 = [100,0]

def koch(n, p1, p2):
    if n == 0:
        return
    s = [(2*p1[0]+p2[0])/3.0,(2*p1[1]+p2[1])/3.0]
    t = [(1*p1[0]+2*p2[0])/3.0,(p1[1]+2*p2[1])/3.0]
    u = [(t[0]-s[0])*math.cos(pi/3) - (t[1]-s[1])*math.sin(pi/3) + s[0], 
         (t[0]-s[0])*math.sin(pi/3) + (t[1]-s[1])*math.cos(pi/3) + s[1]]
         

    koch(n - 1, p1, s)
    print(*s)
    koch(n - 1, s, u)
    print(*u)
    koch(n - 1, u, t)
    print(*t)
    koch(n - 1, t, p2)

print(*p1)
koch(n, p1, p2)
print(*p2)"
"import queue

def bfs(maze,h,w,sy,sx):
    dist=[[-1 for _ in range(w)] for _ in range(h)]
    q=queue.deque([[sy,sx]])
    dist[sy][sx]=0
    while q:
        y,x=q.popleft()
        for dy,dx in d:
            ny,nx=y+dy,x+dx
            if 0<=ny<h and 0<=nx<w and dist[ny][nx]==-1 and maze[ny][nx]!='#':
                dist[ny][nx]=dist[y][x]+1
                q.append([ny,nx])
    return max([max(i) for i in dist])

h,w=map(int,input().split())
a=[input() for _ in range(h)]
d=[[1,0],[0,1],[-1,0],[0,-1]]
ans=0
for sy in range(h):
    for sx in range(w):
        if a[sy][sx]!='#':
            ans=max(ans,bfs(a,h,w,sy,sx))
print(ans)"
"st = input()
num = int(st)
print(num*num*num)"
"n , t = map(int,input().split())
a = list(map(int,input().split()))
k = [0 for i in range(n)]
nowmin = a[0]
for i in range(1,n):
    k[i] = a[i] - nowmin
    nowmin = min(nowmin,a[i])

maxri = max(k)
ans = 0
for i in range(n):
    if k[i] == maxri:
        ans += 1
print(ans)"
"S = input()
flag = True
count = 0
if not S[0] == ""A"":
  flag = False
for i in range(2,len(S)-1):
  if S[i] == ""C"":
    count += 1
  else:
    if not S[i].islower():
      flag = False
if not S[1].islower():
  flag = False
if not S[len(S)-1].islower():
  flag = False
if not count == 1:
  flag = False
if flag:
  print(""AC"")
else:
  print(""WA"")"
"def insersion_sort(a):
    print(*a)
    n = len(a)
    for i in range(1, n):
        v = a[i]
        j = i - 1
        while j >= 0 and a[j] > v:
            a[j+1] = a[j]
            j -= 1
        a[j+1] = v
        print(*a)

input()
insersion_sort([int(i) for i in input().split()])"
"n,m = (int(i) for i in input().split())
x = [int(i) for i in input().split()]
y = [int(i) for i in input().split()]
difx,dify,num,num2,mod = [],[],0,0,10**9+7
for i in range(1,n): difx.append(x[i]-x[i-1])
for i in range(1,m): dify.append(y[i]-y[i-1])
for i in range(n-1): num = (num+(i+1)*(n-i-1)*difx[i])%mod
for i in range(m-1): num2 = (num2+(i+1)*(m-i-1)*dify[i])%mod
print(num*num2%mod)"
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect
from operator import itemgetter
#from heapq import heappush, heappop
#import numpy as np
#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson
#from scipy.sparse import csr_matrix
#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN
sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
nf = lambda: float(ns())
na = lambda: list(map(int, stdin.readline().split()))
nb = lambda: list(map(float, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

L = ni()
print((L/3)**3)

        

"
"a,b,c=map(int,input().split())
k=int(input())

m=max(a,b,c)
for _ in range(k):
    m*=2

print(a+b+c+m-max(a,b,c))"
"# Python3 (3.4.3)
import sys
input = sys.stdin.readline

# -------------------------------------------------------------
# function
# -------------------------------------------------------------


# -------------------------------------------------------------
# main
# -------------------------------------------------------------
N,X = map(int,input().split())
M = [int(input()) for _ in range(N)]

r = X - sum(M)
print(N + r//min(M))"
"import sys


sys.setrecursionlimit(10 ** 6)
INF = float(""inf"")
MOD = 10 ** 9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    N, M = map(int, input().split())

    if N % 2 == 0:
        for i in range(M):
            x = i + 1
            y = N - i - 1
            if y - x > (N - y + x):
                print(x, y)
            else:
                print(x, y - 1)
    else:
        for i in range(M):
            print(i + 1, N - i)


if __name__ == ""__main__"":
    main()
"
"n=input()
for i in range(n):
    a,b,c = sorted(map(int, raw_input().split()))
    if c**2 == a**2+b**2:
        print ""YES""
    else:
        print ""NO"""
"N = int(input())
A = list(map(int, input().split()))

ans = 'APPROVED'

for i in range(N):
  if A[i] % 2 == 0 and A[i] % 6 != 0 and A[i] % 10 != 0:
    ans = 'DENIED'
    break

print(ans)"
"# AtCoder Beginner Contest 060
# A - Shiritori 
A, B, C = map(str, input().split())
if A[len(A)-1] == B[0] and B[len(B)-1] == C[0]:
    print('YES')
else:
    print('NO')"
"N = int(input())

ans_list = [1, 2, 4, 8, 16, 32, 64]

for n in ans_list:
    if (n <= N):
        ans = n

print(ans)"
"import sys

stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


a, b, t = nm()
print(int(((t + 0.5) // a) * b))
"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")

n = int(input())
a = list(map(int, input().split()))
M = 10**9+7

def factor(n, m=None):
    # mを与えると、高々その素因数まで見て、残りは分解せずにそのまま出力する
    arr = {}
    temp = n
    M = int(-(-n**0.5//1))+1
    if m is not None:
        M = min(m+1, M)
    for i in range(2, M):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr[i] = cnt

    if temp!=1:
        arr[temp] = 1

    if not arr:
        arr[n] = 1

    return arr

ds = [factor(num) for num in a]
D = {}
for d in ds:
    for k,v in d.items():
        if k in D:
            D[k] = max(D[k], v)
        else:
            D[k] = v
l = 1
for k,v in D.items():
    l *= pow(k,v,M)
    l %= M
ans = 0
for num in a:
    ans += (l*pow(num, M-2, M))
    ans %= M
print(ans)"
"def main():
    n=int(input())
    a,b=map(int,input().split())
    p=map(int,input().split())
    A,B,C = 0,0,0
    for pp in p:
        if pp <= a:
            A += 1
        elif pp <= b:
            B += 1
        else:
            C += 1
    print(min(A,B,C))

if __name__ == ""__main__"":
    main()"
"N = int(input())
a = list(map(int, input().split()))
ma = a.index(max(a))+1
mi = a.index(min(a))+1
print(2*N-1)

if (abs(max(a)) >= abs(min(a))):
    for i in range(1, N+1):
        print(str(ma) + "" "" + str(i))
    for i in range(1, N):
        print(str(i) + "" "" + str(i+1))
else:
    for i in range(1, N+1):
        print(str(mi) + "" "" + str(i))
    for i in reversed(range(2, N+1)):
        print(str(i) + "" "" + str(i-1))"
"list1 = list(map(int,input().split()))
list2 = sorted(list1)
print(list2[0]+list2[1]+10*list2[2])"
"
n, m = (int(x) for x in input().split())

# 0 = まだACなし, 1 = AC済み
ans_list = [0] * (n + 1)
# 誤った回数が記録され、ACのタイミングで加算
WA_list = [0] * (n + 1)

ans = 0
penalty = 0

for id in range(m):
    # listを紐付けて要素を抜き出すことができる
    query = list(map(str, input().split()))
    # ACだった場合
    if query[1] == 'AC':
        if ans_list[int(query[0])] == 0 :
            ans_list[int(query[0])] = 1
            ans += 1
            penalty = penalty + WA_list[int(query[0])]
    # WAだった場合 
    else:
        if ans_list[int(query[0])] == 0 :
            WA_list[int(query[0])] += 1

print(""{0} {1}"".format(ans, penalty))"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-


""""""
input:
11
7
8
9
10
11
12
13
14
15
16
17

output:
4
""""""

import sys
import math


def is_prime(x):
    if x == 2:
        return True
    elif x < 2 or not x % 2:
        return False

    i = 3
    x_sqrt = math.sqrt(x)
    while i <= x_sqrt:
        if not x % i:
            return False
        i += 2

    return True


def solve(_c_list):
    cnt = 0
    for ele in _c_list:
        if is_prime(ele):
            cnt += 1
    return cnt


if __name__ == '__main__':
    _input = sys.stdin.readlines()
    c_num = int(_input[0])
    c_list = list(map(int, _input[1:]))
    ans = solve(c_list)
    print(ans)"
"n = int(input())

if n == 2:
  count = 1
else:
  count = 2
divisor = []

d = 2
while d * d < n - 1:
  if (n - 1) % d == 0:
    count += 2
  d += 1
if d * d == n - 1:
  count += 1

d = 2
while d * d < n:
  if n % d == 0:
    divisor.append(d)
    divisor.append(n // d)
  d += 1
if d * d == n:
  divisor.append(d)

for d in divisor:
  tmp = n
  while tmp % d == 0:
    tmp //= d
  if tmp % d == 1:
    count += 1

print(count)"
"S, T = [input() for _ in range(2)]
count = 0
for i in range(3):
    if S[i] == T[i]:
        count += 1

print(count)"
"building = [[[0 for i in range(10)] for j in range(3)] for k in range(4)]
n = int(input())

for _ in range(n):
    b, f, r, v = input().split("" "")
    building[int(b)-1][int(f)-1][int(r)-1] += int(v)



for i, b in enumerate(building):
    for f in b:
        for r in f:
            print("" %d""%(r), end="""")
        print("""")
    if i != 3:
        print (""#"" * 20)"
"N = int(input())
a = list(map(int,(input().split())))
b = list(map(int,(input().split())))

nega = []
c = 0
gap = [0]*N
for i in range(N):
    gap[i] = a[i]-b[i]
    if gap[i] > 0:
        c += gap[i]
    elif gap[i] < 0:
        nega.append((-gap[i])//2)

nc = sum(nega)

if nc >= c:
    print(""Yes"")
else:
    print(""No"")"
"import sys
import math
import itertools
import bisect
from copy import copy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def i(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def L(): return list(input().split())
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
sys.setrecursionlimit(10 ** 9)
INF = 10**9
mod = 10**9+7

A,B = I()
ans = 0
for i in range(A,B+1):
    F = 1
    s = str(i)
    for i in range(2):
        if s[i] != s[4-i]:
            F = 0
    if F == 1:
        ans += 1
print(ans)"
"N, M, K = list(map(int, input().split()))
mod = 10**9 + 7

tn = 0
tm = 0

for n in range(N):
    tn = (tn + n*(n+1)//2) % mod
tn = tn*M*M % mod

for m in range(M):
    tm = (tm + m*(m+1)//2) % mod
tm = tm*N*N % mod

class combinationmod():
    def __init__(self, MAX, mod):
        self.mod = mod
        self.fac = [0]*(MAX+1)
        self.finv = [0]*(MAX+1)
        self.inv = [0]*(MAX+1)
        self.fac[0] = self.fac[1] = 1
        self.finv[0] = self.finv[1] = 1
        self.inv[1] = 1
        for i in range(2, MAX+1):
            self.fac[i] = self.fac[i-1]*i % mod
            self.inv[i] = (-self.inv[mod % i]*(mod//i)) % mod
            self.finv[i] = self.finv[i-1] * self.inv[i] % mod
    def nCk(self,n,k):
        if n<k or n<0 or k<0:
            return 0
        return self.fac[n]*(self.finv[k]*self.finv[n-k]%self.mod)%self.mod
 
c = combinationmod(200000,int(1e9+7))

ans = (tn + tm)*c.nCk(N*M-2, K-2) %mod
print(ans)"
"n=int(input())
l=list(map(int,input().split()))
c=0
for i in range(n):
    if(i%2==0 and l[i]%2==1):
        c=c+1
print(c)
"
"n, a, b = map(int, input().split())

ma = min(a, b)
if a + b - n < 0:
    mi = 0
else:
    mi = a + b - n

print(ma, mi)"
"s = list(input())
print(*s[:3],sep=(""""))"
"# ac_072_b
# 英小文字からなる文字列S
# 前から数えて奇数文字列目だけ抜き出して作った文字列を出力。
# 文字列の先頭の文字を１文字目とする。

s = input()

# [0::2]０番目はじめて2つ刻みの意味[0,1,2,3,4,5]の場合[0,2,4,]=奇数番目になる。
# [1::2]１番目めからはじめて２つ刻み[0,1,2,3,4,5]の場合[1,3,5]=偶数番目になる。
# 奇数番目のみ抽出したい場合。
print(s[0::2])
"
"print(-int(input())+sum(list(map(int,input().split()))))"
"import sys
readline = sys.stdin.readline

A = readline().rstrip()

from collections import Counter
counter = Counter(A)

ans = 1 + (len(A) * (len(A) - 1)) // 2

for val in counter.values():
  ans -= (val * (val - 1)) // 2
  
print(ans)"
"import collections
n=int(input())
a=[int(input()) for _ in range(n)]
b=collections.Counter(a)
ans=0
for i in b.keys():
  if b[i]%2:
    ans+=1
print(ans)"
"#-*-coding:utf-8-*-

def main():
    a,b,c = map(int,input().split())
    ans=b//a
    if c > ans:
        print(ans)
    else:
        print(c)

if __name__==""__main__"":
    main()"
"import sys

n,k0=map(int,input().split())
v=list(map(int,input().split()))

k=k0
if n<=k:
    v.sort()
    vsum=sum(v)
    kk=k-n
    vsum=0
    for i in range(n):
        if i>kk:
            vsum+=v[i]
        elif i<=kk and v[i]>0:
            vsum+=v[i]
    print(max(0,vsum))
    sys.exit()

vmax=-10**10

kk=k0
for k in range(kk):
    k2=kk-k-1
    
    vv=[[0]*(k+1) for i in range(k+1+1)]
    for i in range(k+1):
        vv[0][i]=v[n-k+i-1]
    vsum=sum(vv[0])
    vmax=max(vsum,vmax)
#    print(""k:"",k,""vsum:"",vsum,""vmax:"",vmax)
#    print(vv[0])
    vvv=vv[0].copy()
    vvv.sort()
    for i in range(min(k2,k+1)):
        if vvv[i]<0:
            vsum-=vvv[i]
    vmax=max(vsum,vmax)
#    print(""k:"",k,""vsum:"",vsum,""vmax:"",vmax)

    for i in range(k+1):
        vv[i+1]=vv[i].copy()
        vv[i+1].pop(0)
        vv[i+1].append(v[i])
        vsum=sum(vv[i+1])
        vmax=max(vsum,vmax)
#        print(""k:"",k,""vsum:"",vsum,""vmax:"",vmax)
#        print(vv[i+1])
        vvv=vv[i+1].copy()
        vvv.sort()
        for i in range(min(k2,k+1)):
            if vvv[i]<0:
                vsum-=vvv[i]
        vmax=max(vsum,vmax)
#        print(""k:"",k,""vsum:"",vsum,""vmax:"",vmax)
    
print(max(0,vmax))    

"
"n=int(input())
y=(1+8*n)**0.5
if not y.is_integer():
    print(""No"")
    exit()
x=int(y)
if x%2==0:
    print(""No"")
    exit()
print(""Yes"")

k=(1+x)//2
atama=set()
atama.add(1)
now=1
for i in range(1,1000):
    now+=i
    if now<=n:
        atama.add(now)
    else:
        break
haji=set()
d={}
now=0
for i in range(1,1000):
    now+=i
    if now<=n and now not in haji:
        haji.add(now)
        d[now]=i
    else:
        break
k=len(atama)

ans=[list(atama),list(haji)]
for s in atama:
    if s==1:
        continue
    l=[s]
    while s+1 not in haji:
        l.append(s+1)
        s+=1
    s+=1
    l.append(s)
    c=d[s]
    for i in range(c,1000):
        s+=i
        if s<=n:
            l.append(s)
        else:
            break
    ans.append(l)
print(k+1)
for i in range(k+1):
    print(k,*ans[i])
"
"s = input()
c = ""CODEFESTIVAL2016""
a = 0
for i in range(len(c)):
  if s[i] != c[i]:
    a = a + 1
print(a)"
"def insertionSort(A, n , g, in_cnt):
    lo_cnt = in_cnt
    for i in range(g, n):
        v = A[i]
        j = i - g
        while j>=0 and A[j]>v:
            A[j+g] = A[j]
            j = j - g
            lo_cnt = lo_cnt + 1
        A[j+g] = v
    return [A,lo_cnt]


A = []
G = []
data_num = int(input())
for i in range(data_num):
     A.append(int(input().rstrip()))

cnt = 0
gap = data_num
while True: 
    if gap > 1:
        gap = gap // 2

    G.append(gap)
    A, cnt = insertionSort(A, data_num, gap, cnt)
    if gap == 1:
        break
    
print(str(len(G)))
print("" "".join(map(str,G)))
print(str(cnt))
print(""\n"".join(map(str,A)))"
"h, w = map(int, input().split())
s = [list(input()) for _ in range(h)]

for i in range(h):
    count = 0
    start = 0
    end = 0
    for j in range(w):
        if s[i][j] != ""#"":  # 　#じゃなければおけ
            count += 1
        else:
            for z in range(start, end):
                s[i][z] = count
            start = end+1
            count = 0
        end += 1
    for z in range(start, end):
        s[i][z] = count
    # print(s[i])
ans = 0

for i in range(w):
    count = 0
    start = 0
    end = 0
    for j in range(h):
        if s[j][i] != ""#"":  # 　#じゃなければおけ
            count += 1
        else:
            for z in range(start, end):
                s[z][i] += count
            start = end+1
            count = 0
        end += 1
    for z in range(start, end):
        s[z][i] += count
# print()
for i in range(h):
    # print(s[i])
    for j in range(w):

        if s[i][j] != ""#"":
            ans = max(ans, s[i][j])
print(ans-1)
"
"target = int(input())
a, b = map(int, input().split())

b_largest = (b // target) * target

print('OK' if b_largest >= a else 'NG')

"
print ''.join([w[0] for w in raw_input().split()]).upper()
"import numpy as np
N=int(input())
A=[int(i) for i in input().split()]
A=[A[i]-i for i in range(N)]
#print(A)
b=np.median(A)
K=[abs(A[i]-b) for i in range(N)]
print(int(sum(K)))"
"s=input()
k=int(input())
l=len(s)
now=1
seq=[]
re=False
all=False
for i in range(l):
    if s[i%l]==s[(i+1)%l]:
        if i==l-1:
            re=True
            if len(seq)==0:
                all=True
            else:
                first=seq[0]//2
                end=now//2
                seq[0]=(seq[0]+now)
        now+=1
    else:
        seq.append(now)
        now=1
if all:
    ans=len(s)*k//2
else:
    seq=[i//2 for i in seq]
    if re:
        ans=sum(seq)*k-seq[0]+first+end
    else:
        ans=sum(seq)*k

print(ans)
"
"N=int(input())
for i in range(N,999+1):
  check=str(N)
  if check[0]==check[1]==check[2]:
    print(N)
    exit()
  N+=1
"
"N = int(input())

result = []

for c in input():
    r = ord(c) + N

    # Zを超えている
    if r > 90:
        r = 65 + r % 90 - 1

    result.append(chr(r))

print(''.join(result))
"
"s=input()
a=s.count('a')
b=s.count('b')
c=s.count('c')
if len(set(list(s)))==1 and len(s)>1:
  print('NO')
elif len(set(list(s)))==2 and len(s)>2:
  print('NO')
elif abs(a-b)<=1 and abs(b-c)<=1 and abs(c-a)<=1:
  print('YES')
else:
  print('NO')"
"x = int(input())

if x <= 6:
    print(1)
else:
    ans = (x//11)*2
    if x%11 == 0:
        print(int((x/11)*2))
    elif (x//11)*11 +6 >= x:
        print(ans+1)
    else:
        print(ans+2)"
"n = int(input())
ans = 1
elem_list = []

for i in range(7):
    elem_list.append(2**i)

for i in elem_list[::-1]:
    if i <= n:
        print(i)
        break"
"a=0
K=int(input())
A,B=map(int,input().split())
for i in range(1,1001):
    if A<=K*i<=B:
        a=1
        break
if a==0:
    print('NG')
else:
    print('OK')"
"import sys


#input = sys.stdin.buffer.readline

#sys.setrecursionlimit(10**9)
#from functools import lru_cache

def RD(): return sys.stdin.read()


def II(): return int(input())


def MI(): return map(int,input().split())


def MF(): return map(float,input().split())


def LI(): return list(map(int,input().split()))


def LF(): return list(map(float,input().split()))


def TI(): return tuple(map(int,input().split()))


# rstrip().decode('utf-8')


def main():
	n=II()
	s=input()
	ss=s
	for _ in range(100):
		s=s.replace(""()"","""")
	ans=""(""*s.count("")"")+ss+"")""*s.count(""("")
	print(ans)
	
	
	





	

if __name__==""__main__"":
	main()
"
"S = input()

ans = 1000
for i in range(len(S)-2):
    t = abs(int(S[i:i+3])- 753)
    if t < ans:
        ans = t
print(ans)"
"N,M=map(int,input().split())
A=sorted(map(int,input().split()))
B=[0]
for a in A:
    B.append(B[-1]+a)
def f(n):
    a,b=0,0
    r=N-1
    for l in range(N):
        while r>-1 and A[l]+A[r]>=n:
            r-=1
        a+=N-1-r
        b+=A[l]*(N-1-r)+B[N]-B[r+1]
    return a,b
l,r=0,10**6
x=0
while l+1<r:
    t=(l+r)//2
    a,b=f(t)
    if a<M:
        r=t
    else:
        x=max(x,t)
        l=t
a,b=f(x)
print(b-x*(a-M))"
"import bisect, collections, copy, heapq, itertools, math, string, sys
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = float('inf')
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    N, D = LI()
    X = [LI() for _ in range(N)]

    MAX_DIST = 16000
    square_num = set()
    i = 1
    while i ** 2 <= MAX_DIST:
        square_num.add(i ** 2)
        i += 1

    ans = 0
    for i, j in itertools.combinations(range(N), 2):
        if sum([(k - l) ** 2 for k, l in zip(X[i], X[j])]) in square_num:
            ans += 1

    print(ans)

if __name__ == '__main__':
    resolve()
"
"a, b, k = map(int, input().split())
ans = []
for i in range(1, a*b + 1):
    if a%i == 0 and b%i == 0:
        ans.append(i)
print(ans[-1*k])
"
"def main():
    n = input()

    res = ''

    for i in range(len(n)):
        if n[i] == '1':
            res += '9'
        elif n[i] == '9':
            res += '1'
        else:
            res += n[i]
    
    print(int(res))

if __name__ == '__main__':
    main()"
"_, *_XL = open(0).read().split()

XL = list(zip(*[map(int, iter(_XL))]*2))

ans = 0
t = -10**10 # 数直線のマイナス方向からスタートする

arms = [(X-L, X+L) for X, L in XL]
arms_sorted = sorted(arms, key=lambda k:k[1])

ans = 0

for s, e in arms_sorted:
    if t <= s:
        t = e
        ans += 1
        
print(ans)"
"def main():
    r, g, b = input().split()

    if int(r + g + b) % 4 == 0:
      print(""YES"")
    else:
      print(""NO"")

  
if __name__ == ""__main__"":
  main()"
"n, m, x = map(int, input().split())
inp=[]

# 入力をすべて受け取る
for i in range(n):
  tmp = list(map(int, input().split()))
  inp.append(tmp)

# bit全探索を行うための箱づくり
sum = 0
min = 10**10
for i in range(2**n):
  tmp = [0]*m
  flg = 0
  
  # ある買う買わないのケースに対して、フラグが立ってたらスキルポイントを増やす
  for j in range(n):
    if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
      sum += inp[j][0]
      for k in range(1,m+1):
        #print(n,j, k, tmp, inp)
        tmp[k-1] += inp[j][k]
  for ii, k in enumerate(tmp):
    if k < x: # x未満ならflgをたててNGとする
      flg = 1
      break
  #print(tmp, flg)
  if sum < min and flg == 0: min = sum
  sum = 0
  
if min == 10**10: min = -1
print(min)
"
"h,w,lim = map(int,input().split())
S = []
ans = 10**10
for i in range(h):
    S.append(input())
for i in range(2**(h-1)):
    bit = ''
    cur = 1
    for j in range(h-1):
        if i&cur != 0:
            bit = '1'+bit
        else:
            bit = '0'+bit
        cur *= 2
    group = []
    if i == 0:
        group = [[i for i in range(h)]]
    else:
        div = []
        for j in range(len(bit)):
            if bit[j] == '0':
                div.append(j)
            else:
                div.append(j)
                group.append(div)
                div = []
        div.append(j+1)
        if len(div) != 0:
            group.append(div)
    num = [0]*len(group)
    cur = len(group)-1
    flag1 = True
    for j in range(w):
        next = [0]*len(group)
        flag2 = True
        for k in range(len(group)):
            plus = 0
            for l in range(len(group[k])):
                if S[group[k][l]][j] == '1':
                    plus += 1
            if plus > lim:
                flag1 = False
                break
            elif plus+num[k] > lim:
                flag2 = False
                next[k] += plus
            else:
                next[k] += plus
        if flag1 == False:
            break
        else:
            if flag2 == False:
                cur += 1
                num = next
            else:
                for k in range(len(group)):
                    num[k] += next[k]
    if flag1:
        ans = min(ans, cur)
print(ans)
"
"X,K,D=map(int,input().split())
X=abs(X)
straight=min(K,X//D)
K-=straight
X-=straight*D
if K%2==0:
    print(X)
else:
    print(D-X)"
"#!/usr/bin/env python3
#coding: utf-8

# Volume0 - 0002 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0002)

while 1:
    try:
        i = input()
        l = i.split("" "")
        s = int(l[0]) + int(l[1])
        ans = len(str(s))
        print(ans)
    except:
        break"
"INF = 10**10

def chmax(a, b):
    if(a>b):
        return a
    else:
        return b

def chmin(a, b):
    if(a<b):
        return a
    else:
        return b


N, K = map(int,input().split())

h = list(map(int,input().split()))

dp = N*[INF]
dp[0]=0


for i in range(1,N):
    for j in range(1,K+1):
        dp[i] = chmin(dp[i],dp[i-j]+abs(h[i]-h[i-j]))
        if i < j:
            break

#print(dp)
print(dp[N-1])"
"from math import gcd
n = int(input())
P = [tuple(map(int, input().split())) for i in range(n)]
C = {}
for x, y in P:
    if x == 0 and y == 0:
        x0, y0 = 0, 0
    elif x != 0 and y == 0:
        x0, y0 = 1, 0
    elif x == 0 and y != 0:
        x0, y0 = 0, 1
    else:
        g = gcd(x, y)
        x0, y0 = x // g, y // g
    if y0 < 0:
        x0, y0 = -x0, -y0
    try:
        C[(x0, y0)] += 1
    except KeyError:
        C[(x0, y0)] = 1
D = []
for x, y in C.keys():
    if x <= 0:
        try:
            C[(y, -x)]
        except KeyError:
            D.append((y, -x))
for x, y in D:
    C[(x, y)] = 0
ans = 1
p = 10**9 + 7
for x, y in C.keys():
    if x > 0:
        a = C[(x, y)]
        try:
            b = C[(-y, x)]
        except KeyError:
            b = 0
        ans *= pow(2, a, p) + pow(2, b, p) - 1
        ans %= p
try:
    ans += C[(0, 0)] - 1
except KeyError:
    ans -= 1
print(ans % p)
"
"n = int(input())

C = [[1 for i in range(n)] for j in range(n)]
for i in range(n):
    C[i][i] = 0
if n%2 == 0:
    for i in range(n):
        C[i][n-1-i] = 0
else:
    for i in range(n):
        C[i][n-2-i] = 0

print(n*(n-1)//2-n//2)
for i in range(n):
    for j in range(n):
        if i<j and C[i][j] == 1:
            print(i+1,j+1)"
print(3.14159265359*2*int(input()))
"import sys
import numpy as np


stdin = sys.stdin
def ns(): return stdin.readline().rstrip()
def ni(): return int(stdin.readline().rstrip())
def nm(): return map(int, stdin.readline().split())
def nl(): return list(map(int, stdin.readline().split()))


def main():
    h, w = nm()
    A = np.array([list(ns()) for _ in range(h)])
    i = 0
    while i < len(A):
        if np.all(A[i] == '.'):
            A = np.delete(A, i, 0)
        else:
            i += 1

    j = 0
    while j < len(A[0]):
        if np.all(A[:, j] == '.'):
            A = np.delete(A, j, 1)
        else:
            j += 1
    for a in A:
        print(''.join(a))


if __name__ == '__main__':
    main()
"
"import sys, math
from collections import defaultdict, deque, Counter
from bisect import bisect_left, bisect_right
from itertools import combinations, permutations, product
from heapq import heappush, heappop
from functools import lru_cache
input = sys.stdin.readline
rs = lambda: input().strip()
ri = lambda: int(input())
rl = lambda: list(map(int, input().split()))
mat = lambda x, y, v: [[v]*y for _ in range(x)]
ten = lambda x, y, z, v: [mat(y, z, v) for _ in range(x)]
mod = 1000000007
sys.setrecursionlimit(1000000)

N, D = rl()
ps = []
for i in range(N):
	x, y = rl()
	ps.append((x,y))

ans = 0
for x, y in ps:
	if x**2+y**2 <= D**2:
		ans += 1
print(ans)
"
"from collections import deque

H, W = map(int, input().split())

G = []
G.append([""#"" for _ in range(W + 2)])
for i in range(H):
    G.append([""#""] + list(input()) + [""#""])
G.append([""#"" for _ in range(W + 2)])

# print(G)

dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

INF = 10 ** 18
d = [[INF for i in range(W + 2)] for j in range(H + 2)]


def bfs(i, j):
    q = deque()
    q.append((i, j))
    d[i][j] = 0
    while q:
        a, b = q.popleft()
        for k in range(4):
            if G[a + dx[k]][b + dy[k]] == ""#"":
                continue
            if d[a + dx[k]][b + dy[k]] != INF:
                continue
            d[a + dx[k]][b + dy[k]] = d[a][b] + 1
            q.append((a + dx[k], b + dy[k]))


bfs(1, 1)
# print(d)
# print(d[H][W])

# (H+2)*(W+2) から「経路+1」と、全ての'#'の数を引いたものが答え
if d[H][W] == INF: # 到達できないときは -1を出力
    print(-1)
else:
    ans = (H + 2) * (W + 2)
    ans -= d[H][W] + 1
    cnt = 0
    for h in range(H + 2):
        for w in range(W + 2):
            if G[h][w] == ""#"":
                cnt += 1
    ans -= cnt
    print(ans)
"
"n, k = map(int, input().split())
a = list(map(int, input().split()))

mod = 10 ** 9 + 7
a.sort()

def extGCD(a, b):
    if b == 0:
        return a, 1, 0
    g, y, x = extGCD(b, a%b)
    y -= a//b * x
    return g, x, y

def moddiv(a, b):
    _, inv, _ = extGCD(b, mod)
    return (a * inv) % mod

N = 10 ** 5 + 10
fact = [0] * (N)
fact[0] = 1
for i in range(1, N):
    fact[i] = (fact[i-1] * i) % mod

def comb(a, b):
    return moddiv(moddiv(fact[a], fact[a-b]), fact[b])

def minsum(a):
    ret = 0
    for i, x in enumerate(a[:n-k+1]):
        ret += x * comb(n-i-1, k-1)
        ret %= mod
    return ret

b = [-x for x in reversed(a)]
print((-minsum(b) - minsum(a))%mod)"
"x, y, a, b, c = map(int, input().split())
p = sorted(list(map(int, input().split())))[::-1]
q = sorted(list(map(int, input().split())))[::-1]
r = sorted(list(map(int, input().split())))[::-1]

u = sorted(p[:x] + q[:y] + r)[::-1]
print(sum(u[:x + y]))
"
"a,b,n = map(int,input().split())

num = min(b-1,n)

print(int((a*num)/b)-a*int(num/b))"
"Q,H,S,D=map(int,input().split())
N=int(input())
a=0
if N%2:
    a+=min(4*Q,2*H,S)
a+=N//2*min(8*Q,4*H,2*S,D)
print(a)"
"A, V = map(int, input().split())
B, W = map(int, input().split())
T = int(input())

lange = abs(B - A)
s = V - W

res = 0

if s != 0:
    tmp = lange / s
    if tmp <= T and tmp >= 0:
        res = 1

if (res == 0):
    print(""NO"")
else:
    print(""YES"")"
"import sys
input=sys.stdin.readline
n,a=map(int,input().split())
x=[0]+list(map(int,input().split()))
su=sum(x)
maxi=max(x)
dp=[[[0 for k in range(maxi*n+1)] for j in range(51)] for i in range(51)]
dp[0][0][0]=1
for i in range(1,n+1):
    for j in range(i+1):
        for k in range(maxi*j+1):
            if k<x[i]:
                dp[i][j][k]=dp[i-1][j][k]
            if k>=x[i] and j>=1:
                dp[i][j][k]=dp[i-1][j][k]+dp[i-1][j-1][k-x[i]]
ans=0
for t in range(1,n+1):
    if a*t<=su:
        ans+=dp[n][t][a*t]
    else:
        break
print(ans)
"
"N,X = list(map(int,input().split()))

f=[1]
p=[1]

for n in range(N):
    f.append(2*f[n]+3)
    p.append(2*p[n]+1)

def get_p(N,X):
    if N == 0:
        if X <= 0:
            return 0
        else:
            return 1
    if X == 1:
        return 0
    elif X > 1 and X <= f[N-1] + 1:
        return get_p(N-1,X-1)
    elif X == f[N-1] + 2:
        return p[N-1]+1
    elif X > f[N-1] + 2 and X <= 2*f[N-1] + 1: 
        return p[N-1] + 1 + get_p(N-1,X-(f[N-1]+2))
    else:
        return p[N]
    
print(get_p(N,X))"
"m,d = map(int,input().split())
k = 0
for i in range(1,m+1):
    for j in range(1,d+1):
        x = j // 10
        if x < 2:
            continue
        y = j % 10
        if y < 2:
            continue
        if x * y == i:
            k += 1

print(k)"
"import numpy as np
from scipy.sparse.csgraph import connected_components
from scipy.sparse import csr_matrix

import sys
sys.setrecursionlimit(10**9)
n,m,k=[int(i) for i in input().split()]
frends_num=[0 for i in range(n)]
def make_frends(m,n):
    data=[1 for i in range(m)]

    row=[]
    col=[]
    for k in range(m):
        i,j=[int(l) for l in input().split()]
        new_i=min(i,j)-1
        new_j=max(i,j)-1
        row.append(new_i)
        col.append(new_j)
        frends_num[new_i]+=1
        frends_num[new_j]+=1
    frend_sparce_matrix=csr_matrix((data, (row, col)),shape=(n,n))
    return frend_sparce_matrix


frends=make_frends(m,n)
l,labels=connected_components(frends)
labels
labels=list(labels)

class Group:
    def __init__(self,labels):
        self.labels=labels
        self.group_num=[0 for i in range(l)]
        for i in labels:
            self.group_num[i]+=1
    def get_group_num(self,i):
        return self.group_num[self.labels[i]]

group=Group(labels)


def get_frend_num(i):
    return frends_num[i]


def make_block(k,n):
    block_num=[0 for i in range(n)]
    for p in range(k):
        i,j =[int(l)-1 for l in input().split()]
        new_i=min(i,j)
        new_j=max(i,j)
        if labels[new_i]==labels[new_j]:
            block_num[i]+=1
            block_num[j]+=1
    return block_num

block=make_block(k,n)

def get_block_num(i):
    return block[i]

ans=[]
for i in range(n):
    ans.append(str(group.get_group_num(i)-1-get_frend_num(i)-get_block_num(i)))
print("" "".join(ans))
"
"num = list(map(int, input().split()))

ans = sorted(num)
if(ans[0]==5 and ans[1]==5 and ans[2] == 7):
    print(""YES"")
else:
    print(""NO"")"
"c=[list(map(int,input().split())) for _ in range(3)]

a0=0
b0=c[0][0]-a0
b1=c[0][1]-a0
b2=c[0][2]-a0

a1= c[1][0]-b0
a2= c[2][0]-b0
if a1 == c[1][1]-b1 == c[1][2]-b2\
and a2 == c[2][1]-b1 == c[2][2]-b2:
  print(""Yes"")
else:
  print(""No"")"
"N,M=map(int,input().split())
A=dict()
ans=0
A=[list(map(int,input().split()))for i in range(N)]
A.sort()
for i in range(N):
    if M>A[i][1]:
        M-=A[i][1]
        ans+=A[i][0]*A[i][1]
    else:
        ans+=A[i][0]*M
        break
print(ans)
"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

import numpy as np
n,k=map(int,readline().split())
a=np.array(readline().split(),np.int64)
f=np.array(readline().split(),np.int64)
a.sort()
f.sort()
f=f[::-1]

s=-1
e=10**12
while s+1<e:
    mid=(s+e)//2
    if a.sum()- np.minimum(a,mid//f).sum() <=k:
        e=mid
    else:
        s=mid
print(e)"
"sl = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT']
s = input().rstrip()
r = 7 - sl.index(s)
print(r)
"
"n,m,l = map(int,input().split())
a = [list(map(int,input().split())) for i in range(n)]
b = [list(map(int,input().split())) for i in range(m)]
for i in range(n):
    for j in range(l):
        sum = 0
        for k in range(m):
            sum += a[i][k]*b[k][j]
        if j==l-1:print(sum)
        else:print(sum,end="" "")

"
"s = input()
k = int(input())

for i in range(len(s)):
    n = int(s[i])
    if i+1==k:
        print(n)
        break
    elif n!=1:
        print(n)
        break "
"from operator import itemgetter

N,W = map(int, input().split())
List = [[int(l) for l in input().split()] for _ in range(N)]

num = [0]*4
w0 = List[0][0]
for i in range(N):
    num[List[i][0]-w0] += 1
    
List.sort(reverse=True, key=itemgetter(1))
L = []
for i in range(N):
    if List[i][0] == w0:
        L.append(List[i])
for i in range(N):
    if List[i][0] == w0+1:
        L.append(List[i])
for i in range(N):
    if List[i][0] == w0+2:
        L.append(List[i])
for i in range(N):
    if List[i][0] == w0+3:
        L.append(List[i])
        
prev = w0
for i in range(1, N):
    if L[i][0] == prev:
        L[i][1] += L[i-1][1]
    else:
        prev += 1
        
ans = 0
for i in range(-1, num[0]):
    wi = (i+1)*w0
    ci = 0
    if i >= 0:
        if wi > W:
            break
        ci += L[i][1]
    for j in range(-1, num[1]):
        wj = (j+1)*(w0+1)
        cj = 0
        if j >= 0:
            if wi+wj > W:
                break
            cj += L[j+num[0]][1]
        for k in range(-1, num[2]):
            wk = (k+1)*(w0+2)
            ck = 0
            if k >= 0:
                if wi+wj+wk > W:
                    break
                ck += L[k+num[0]+num[1]][1]
            for l in range(-1, num[3]):
                wl = (l+1)*(w0+3)
                cl = 0
                if l >= 0:
                    if wi+wj+wk+wl > W:
                        break
                    cl += L[l+num[0]+num[1]+num[2]][1]
                ans = max(ans, ci+cj+ck+cl)
            
print(ans)"
"#輸入字串並分隔，以list儲存
str_in = input()
num = [int(n) for n in str_in.split()]
num =list(map(int, str_in.strip().split()))  
#print(num) #D,T,S

#若T<(D/S)->遲到
if num[1] > (num[0]/num[2]):
    print(""Yes"")
elif num[1] == (num[0]/num[2]):
    print(""Yes"")
else:
    print(""No"")


"
"N, K = map(int, input().split())
S = input()
[print(S[i].lower(), end='') if i == K-1 else print(S[i], end='') for i in range(len(S))]"
"N = int(input())
A = list(map(int, input().split()))
from fractions import gcd
from math import ceil
from collections import Counter, deque, defaultdict
from heapq import heappush, heappop, heappushpop, heapify, heapreplace, merge
from bisect import bisect_left, bisect_right, bisect, insort_left, insort_right, insort
from itertools import accumulate, product, permutations, combinations
ans = 0
d = Counter(A)
if N%2==1:
    for i in range(0,N,2):
        # print(i)
        if i==0:
            if d[i]!=1:
                # print('A',A)
                break
        elif d[i]!=2:
            # print('B',i)
            break
    else:
        ans = pow(2,(N-1)//2,10**9+7)
else:
    for i in range(1,N,2):
        if d[i]!=2:
            # print(i)
            break
    else:
        ans = pow(2,N//2,10**9+7)
print(ans)"
"def resolve():
    a, b, c = map(int, input().split())
    print(""Yes"" if a <= c <= b else ""No"")


if __name__ == ""__main__"":
    resolve()
"
"import sys
from itertools import product

input = sys.stdin.readline


def main():
    N = int(input())
    X = [0] * N
    Y = [0] * N
    H = [0] * N
    for i in range(N):
        X[i], Y[i], H[i] = map(int, input().split())

    for Cx, Cy in product(range(101), repeat=2):
        Ch = set()
        Ch_upper = float(""inf"")
        for x, y, h in zip(X, Y, H):
            a = abs(x - Cx) + abs(y - Cy)
            if h == 0:
                Ch_upper = min(Ch_upper, a)
            else:
                Ch.add(h + a)
        if len(Ch) != 1:
            continue
        else:
            Ch = Ch.pop()
            if Ch <= Ch_upper:
                ans = f""{Cx} {Cy} {Ch}""
                break

    print(ans)


if __name__ == ""__main__"":
    main()
"
"MOD = 10 ** 9 + 7
INF = 10 ** 11
import sys
sys.setrecursionlimit(100000000)

def main():
    N,M = map(int,input().split())
    possible = [0] * N
    possible[0] = 1
    ball_cnt = [1] * N
    for _ in range(M):
        x,y = map(int,input().split())
        x -= 1
        y -= 1
        if possible[x]:
            possible[y] = 1
            if ball_cnt[x] == 1:
                possible[x] = 0
        ball_cnt[x] -= 1
        ball_cnt[y] += 1
    ans = sum((b > 0)*p for b,p in zip(ball_cnt,possible))
    print(ans)
if __name__ == '__main__':
    main()
"
"from bisect import*
r=lambda:sorted(map(int,input().split()))
N=r()[0]
A,B,C,w,i=r(),r(),r(),[0]*(N+1),N
while i:i-=1;w[i]=w[i+1]+N-bisect(C,B[i])
print(sum(w[bisect(B,A[i])]for i in range(N)))"
"import math
from math import gcd,pi,sqrt
INF = float(""inf"")

import sys
sys.setrecursionlimit(10**6)
import itertools
from collections import Counter,deque
def i_input(): return int(input())
def i_map(): return map(int, input().split())
def i_list(): return list(i_map())
def i_row(N): return [i_input() for _ in range(N)]
def i_row_list(N): return [i_list() for _ in range(N)]
def s_input(): return input()
def s_map(): return input().split()
def s_list(): return list(s_map())
def s_row(N): return [s_input for _ in range(N)]
def s_row_str(N): return [s_list() for _ in range(N)]
def s_row_list(N): return [list(s_input()) for _ in range(N)]

import string

def main():
    n = i_input()
    a = i_list()
    m = INF
    l = []
    cnt = 0
    for i in a:
        if i < 0:
            cnt += 1
        i = abs(i)
        l.append(i)
        m = min(m,i)

    if cnt %2==0:
        print(sum(l))
    else:
        print(sum(l)-m*2)



if __name__==""__main__"":
    main()
"
"n = int(input())
a = [int(input()) for _ in range(n)]

ans = -1
visited = set()
count = 0
btn = 0
for i in range(n):
  if btn in visited:
    break
  visited.add(btn)
  btn = a[btn]-1
  count += 1
  if btn == 1:
    ans = count
    break

print(ans)
"
"def main():
    k = int(input())
    ab = [int(_x) for _x in input().split()]
    a = ab[0]
    b = ab[1]
    for i in range(a, b+1):
        if i % k == 0:
            print(""OK"")
            return
    print(""NG"")


main()
"
"X = int(input())
money = 100
for i in range(1, 100000):
    money = money + (money // 100)
    if money >= X:
        print(i)
        break
"
"n=int(input())
if n>999:
    print(""ABD"")
else:
    print(""ABC"")"
"n = int(input())
cnt = 0
for i in range(n+1):
  s = len(str(i))
  if s % 2 == 1:
    cnt += 1

print(cnt-1)"
"import bisect
import heapq
import itertools
import math
import operator
import os
import re
import string
import sys
from collections import Counter, deque, defaultdict
from copy import deepcopy
from decimal import Decimal
from fractions import gcd
from functools import lru_cache, reduce
from operator import itemgetter, mul, add, xor

import numpy as np

if os.getenv(""LOCAL""):
    sys.stdin = open(""_in.txt"", ""r"")

sys.setrecursionlimit(2147483647)
INF = float(""inf"")
IINF = 10 ** 18
MOD = 10 ** 9 + 7

N = int(sys.stdin.readline())
P = [int(sys.stdin.readline()) for _ in range(N)]

# dp[i]: i より前に何個連続してるか
dp = np.zeros(N + 1, dtype=int)
for i in range(N):
    p = P[i]
    dp[p] = dp[p - 1] + 1
print(N - dp.max())
"
"n,m = map(int, input().split())

if m - 2*n <0:
    print(m//2)
else:
    ans = n
    m -= 2*n
    ans += m//4
    print(ans)"
"N=int(input())
d=[input() for i in range(N)]
def ans085(N:int, d:str):
    d=map(int,d)
    return(len(set(d)))
print(ans085(N,d))"
"# 入力
A, B, C = map(int, input().split())

# 出力
if -100 <= A and B and C <= 100:
    if C >= A and C <= B:
        print('Yes')
    else:
        print('No')"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# FileName: 	D_fix
# CreatedDate:  2020-08-08 01:53:55 +0900
# LastModified: 2020-08-08 01:56:11 +0900
#


import os
import sys
# import numpy as np
# import pandas as pd


def main():
    x = int(input())
    for a in range(-120, 120):
        for b in range(-120, a):
            if a**5-b**5 == x:
                print(""{} {}"".format(a, b))
                return


if __name__ == ""__main__"":
    main()
"
"N = int(input())
dp = [0, 0, 0]
for i in range(N):
    a, b, c = map(int, input().split())
    tmp_a = a + max(dp[1], dp[2])
    tmp_b = b + max(dp[0], dp[2])
    tmp_c = c + max(dp[0], dp[1])
    dp = [tmp_a, tmp_b, tmp_c]
print(max(dp))
"
"i = list(map(int, input().split()))
print([""No"", ""Yes""][(i[0] + i[1]) >= i[2]])"
"n,m = map(int,input().split())
drink = []
for _ in range(n):
    a,b = map(int,input().split())
    drink.append((a,b))
d = sorted(drink)

ans = 0
x = 0

for t in d:
    if x+t[1] < m:
        ans += t[0]*t[1]
        x += t[1]
    else:
        ans += t[0]*(m-x)
        break

print (ans)
"
"def solve(n, a, lst):
  m = max(max(lst), a)
  ans = [[[0]*(n*m+1) for i in range(n+1)] for j in range(n+1)]
  #ans[i][j][k] : lst[:i]までの中からj枚選んで合計kにする選び方
  for i in range(n+1):
    for j in range(n+1):
      for k in range(n*m+1):
        if i == 0 and j == 0 and k == 0:
          ans[i][j][k] = 1
        elif i >= 1 and k < lst[i-1]:
          ans[i][j][k] = ans[i-1][j][k]
        elif i >= 1 and lst[i-1] <= k and j >= 1:
          ans[i][j][k] = ans[i-1][j-1][k-lst[i-1]] + ans[i-1][j][k]
        else:
          ans[i][j][k] = 0
  ret = 0
  for i in range(1,n+1):
    ret += ans[-1][i][i*a]
  return int(ret)

if __name__ == ""__main__"":
  n, a = map(int,input().split())
  x_list = [int(i) for i in input().split()]
  ans = solve(n,a,x_list)
  print(ans)
"
"n = int(input())
m = max(2, n)
for i in range(m, 2*n+1, m):
    if i % 2 == 0:
        print(i)
        exit(0)
"
"import sys

readline = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)


def main():
    N = int(readline())
    S = input()

    if N % 2 == 0:
        first = S[:N // 2]
        second = S[N // 2:]
        if first == second:
            print(""Yes"")
        else:
            print(""No"")
    else:
        print(""No"")


if __name__ == '__main__':
    main()
"
"import sys
sys.setrecursionlimit(2147483647)
INF=float(""inf"")
MOD=10**9+7
input=lambda :sys.stdin.readline().rstrip()
def resolve():
    from collections import defaultdict
    n,m=map(int,input().split())
    A=list(map(int,input().split()))
    S=[0]*(n+1)
    for i in range(n):
        S[i+1]=S[i]+A[i]
    D=defaultdict(int)
    for s in S:
        D[s%m]+=1
    ans=0
    for val in D.values():
        ans+=val*(val-1)//2
    print(ans)
resolve()"
"N,M = input().split()

if N==M:
  print(""Yes"")
else:
  print(""No"")"
"import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy

A = input()

print(""Yes"" if A[0] == A[1] == A[2] or A[1] == A[2] == A[3] else ""No"")"
"N = int(input())


def keta_sum(N):
    if N < 10:
        return N
    else:
        return keta_sum(N // 10) + (N % 10)


if N % keta_sum(N) == 0:
    print('Yes')
else:
    print('No')
"
"def resolve():
    A,B,M = map(int,input().split())
    a = list(map(int,input().split()))
    b = list(map(int,input().split()))
    min_price = min(a) + min(b)
    for i in range (M):
        x,y,c = map(int,input().split())
        min_price = min(a[x-1] + b[y-1] - c, min_price)
    print(min_price)
resolve()"
"abc = input()
abc_ls = abc.split()
a = int(abc_ls[0])
b = int(abc_ls[1])
s = int(a * b / 2)
print( s )"
"h,w,k=map(int,input().split())
c=[input() for i in range(h)]
ans=0
for i in range(2**h):
  for j in range(2**w):
    cnt=0
    for p in range(h):
      for q in range(w):
        if i&(1<<p) and j&(1<<q):
          if c[p][q]=='#':
            cnt+=1
    if cnt==k:
      ans+=1
print(ans)"
"S = list(input())
A = list('abcdefghijklmnopqrstuvwxyz')
ans = 'None'
for a in A:
    if a not in S:
        ans = a
        break
print(ans)"
"moji = input()
if moji.isupper():
    print(""A"")
elif moji.islower():
    print(""a"")
"
"a,b=map(int,input().split())

x=a*b
y=2*(a+b)

print(x,y)
"
"n = int(input())
a = list(map(int,input().split()))
a.sort(reverse=True)
sum_a = sum(a)

ans = n
for i in range(1,n):
    sum_a -= a[i-1]
    if a[i-1] <= 2*sum_a:
        pass
    else:
        print(i)
        exit()

print(n)"
"H, W = map(int, input().split())
S = [input() for _ in range(H)]
yoko = [[0] * W for _ in range(H)]
tate = [[0] * W for _ in range(H)]

for h in range(H):
    d = []
    for w in range(W):
        if S[h][w] == ""."":
            d.append([h, w])
            if W != w+1: continue
        for h, w in d:
            yoko[h][w] = len(d)
        d = []

for w in range(W):
    d = []
    for h in range(H):
        if S[h][w] == ""."":
            d.append([h, w])
            if H != h+1: continue
        for h, w in d:
            tate[h][w] = len(d)
        d = []
        
ans = 0
for h in range(H):
    for w in range(W):
        if ans < yoko[h][w]+tate[h][w]-1:
            ans = yoko[h][w]+tate[h][w]-1
print(ans)"
"import sys
A = input()
B = input()
if len(A) > len(B):
    print('GREATER')
    sys.exit()
elif len(A) < len(B):
    print('LESS')
    sys.exit()
elif A == B:
    print('EQUAL')
    sys.exit()

for i in range(len(A)):
    if A[i] == B[i]:
        i += 1
        continue
    elif A[i] > B[i]:
        print('GREATER')
        sys.exit()
    elif A[i] < B[i]:
        print('LESS')
        sys.exit()
print('EQUAL')"
"n, m, k = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
a = 0
b = 0
a_time = 0
b_time = 0
max_read = 0

for i in range(m):
    if b_time + B[i] > k:
        break
    else:
        b_time += B[i]
else:
    i += 1
b = i
max_read = b

for i in range(n):
    if a_time + A[i] > k:
        break
    
    a_time += A[i]
    a += 1
    if a_time + b_time <= k:
        max_read = max(max_read, a + b)
        continue
    else:
        while(a_time + b_time > k):
            b -= 1
            if b < 0:
                break
            b_time -= B[b]
        max_read = max(max_read, a + b)

print(max_read)"
"N,M = map(int,input().split())
S = input()[::-1]
ans = []
cur = 0
while cur < N:
    for i in range(1,min(M+1,N-cur+1))[::-1]:
        if S[cur+i] == '0':
            ans.append(i)
            cur += i
            break
    else:
        print(-1)
        exit()
print(*ans[::-1])"
"""""""
スタックのデータ構造の定義
""""""

class Stack:
    def __init__(self):
        self.stack = []

    def push(self, num):
        self.stack.append(num)

    def individual_push(self, num):
        self.stack.append(num)

    def pop(self):
        if len(self.stack) > 0:
            return True, self.stack.pop(-1)
        else:
            return False, 0
    
    def push_individual(self, left_index, current_index):
        sum_a = 0
        for pair in reversed(self.stack):
            if pair[0] > left_index:
                _, a = self.pop()
                sum_a += a[1]
            else:
                break
        self.push((left_index, sum_a + (current_index - left_index)))

    def print_individual_volume(self):
        volume_list = [str(s[1]) for s in self.stack]
        if len(volume_list) == 0:
            print(0)
        else:
            print(""{} "".format(len(volume_list)) + "" "".join(volume_list))


if __name__==""__main__"":
    input_values = input()

    stack1 = Stack()
    stack2 = Stack()
    area_sum = 0

    for i, v in enumerate(input_values):
        # print(i)

        if v == ""\\"":
            stack1.push(i)
        elif v == ""/"":
            result, pop_value = stack1.pop()
            if result:
                area = i - pop_value
                stack2.push_individual(pop_value, i)
            else:
                area = 0
            area_sum += area

    print(area_sum)
    stack2.print_individual_volume()
"
"N = input()
ans_num = 0
# 重複を消して抽出する
set_N = list(set(N))
for i in set_N:
    if N.count(i) % 2 == 1:
        ans_num = 1
        break
    else:
        continue
if ans_num == 0:
    print('Yes')
else :
    print('No')"
"s = input()
alpha = s.count(""o"")

print(700 + 100 * alpha)"
"n = int(input())
monsters = list(map(int, input().split()))
braves = list(map(int, input().split()))
destroys = 0
for i in range(n):
    if braves[i] > monsters[i]:
        destroys += monsters[i]
        braves[i] -= monsters[i]

        if braves[i] > monsters[i + 1]:
            destroys += monsters[i + 1]
            monsters[i + 1] = 0
        
        else:
            destroys += braves[i]
            monsters[i + 1] -= braves[i]
    else:
        destroys += braves[i]
print(destroys)
"
"a = input()
ans = 10000
for i in range(len(a)-2):
  ans = min(abs(753-int(a[i:i+3])),ans)
print(ans)"
"import sys
import math
from collections import defaultdict

sys.setrecursionlimit(10**7)
def input():
    return sys.stdin.readline()[:-1]

mod = 10**9 + 7

def I(): return int(input())
def LI(): return list(map(int, input().split()))
def LIR(row,col):
    if row <= 0:
        return [[] for _ in range(col)]
    elif col == 1:
        return [I() for _ in range(row)]
    else:
        read_all = [LI() for _ in range(row)]
        return map(list, zip(*read_all))

#################

# 引かれる数の左からi桁目に+10 & 引く数のi-1桁目に+1 を適宜行う

def calc(x):
    if 0 <= x <= 5:
        return x
    else:
        return 10-x+1

S = list(input())
L = len(S)

dp0 = [0]*L
dp1 = [0]*L
dp0[0] = calc(int(S[0]))
dp1[0] = calc(int(S[0])+1)

for i in range(1,L):
    n = int(S[i])
    if n == 0:
        dp0[i] = dp0[i-1]
    else:
        dp0[i] = min(dp0[i-1]+n, dp1[i-1]+10-n)
    if n == 9:
        dp1[i] = dp1[i-1]
    else:
        dp1[i] = min(dp0[i-1]+n+1, dp1[i-1]+9-n)

print(dp0[-1])"
"n,k=map(int,input().split())
a=list(map(int,input().split()))
a=list(map(lambda x:x-1 ,a))

s=[0]
for i in range(n):
    s.append(s[-1]+a[i])
s=list(map(lambda x:x%k,s))
from collections import defaultdict
d=defaultdict(int)
d[0]=1
ans=0

for i in range(1,n+1):
    if i>=k:
        d[s[i-k]]-=1
    ans+=d[s[i]]
    d[s[i]]+=1
print(ans)
"
"N,K = map(int,input().split())
import numpy as np
H = np.array(input().split(), dtype = int)

INF = 10 ** 9 + 1
dp = np.full(N,INF,dtype = int)
dp[0] = 0

for i in range(1, N):
  dp[i] = min(dp[max(i - K,0):i] + np.abs(H[max(i - K,0):i] - H[i]))

print(dp[-1])"
"n=input()
a=[]
area=[]
x1=[]
x2=[]

x=1
for i in n:
	if i=='\\':
		a.append(x)
		
	elif i=='/' and len(a)>=1:
		area.append(x-a[len(a)-1])
		x1.append(a[len(a)-1])
		x2.append(x)
		a.pop()		
		
		for i in range(len(x1)-2,-1,-1):	
			if x1[len(x1)-1]<x1[i] and x2[len(x2)-1]>x2[i]:
				x1.pop(i)
				x2.pop(i)
				area[i]=area[i]+area[len(area)-1]
				area.pop()
	x+=1

print(sum(area))
print(len(area),*area)

	

"
"# import sys
# input = sys.stdin.readline
import itertools
import collections
from decimal import Decimal
from functools import reduce


# 持っているビスケットを叩き、1枚増やす
# ビスケット A枚を 1円に交換する
# 1円をビスケット B枚に交換する
def main():
    n = int(input())
    numbers = input_list()
    ans = []
    s = reduce(lambda a, b: a ^ b, numbers)
    for i in range(n):
        ans.append(s ^ numbers[i])
    print(*ans)


def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a


def bfs(H, W, black_cells, dist):
    d = 0
    while black_cells:
        h, w = black_cells.popleft()
        d = dist[h][w]
        for dy, dx in ((1, 0), (0, 1), (-1, 0), (0, -1)):
            new_h = h + dy
            new_w = w + dx
            if new_h < 0 or H <= new_h or new_w < 0 or W <= new_w:
                continue
            if dist[new_h][new_w] == -1:
                dist[new_h][new_w] = d + 1
                black_cells.append((new_h, new_w))
    return d


def input_list():
    return list(map(int, input().split()))


def input_list_str():
    return list(map(str, input().split()))


if __name__ == ""__main__"":
    main()
"
"N,K = map(int,input().split())
A = [list(map(int,input().split())) for _ in range(N)]
A = sorted(A,key=lambda x:x[0])
cnt = 0
i = 0
while K>cnt:
    cnt += A[i][1]
    i += 1
print(A[i-1][0])"
"n = int(input())
a = [0] * n
b = [0] * n
for i in range(n):
    A, B = map(int, input().split())
    a[i], b[i] = A, B

a.reverse()
b.reverse()

ans = 0
for i in range(n):
    if (ans+a[i]) % b[i] == 0:
        cnt = 0
    else:
        cnt = b[i] - ((ans+a[i]) % b[i])
    ans += cnt
print(ans)"
"l = [int(i) for i in input().split("" "")]
print(l[0]/l[1])
"
"N, M = map(int, input().split())

ans = []
neg = 0
for n in range(N):
  ans.append(-1)

for m in range(M):
  s, c = map(int, input().split())
  if ans[s-1] == -1:
    ans[s-1] = c
  elif ans[s-1] == c:
    pass
  else:
    neg = -1
    break

if ans[0] == 0 and N != 1:
  neg = -1

for j in range(len(ans)):
  if ans[j] == -1:
    ans[j] = 0

if N == 1:
  pass

elif ans[0] == 0:
  ans[0] = 1

if neg == -1:
  print(neg)
else:
  print("""".join([str(i) for i in ans]))"
"n,k = map(int,input().split())
w = [int(input()) for i in range(n)]

def binarySearch(left,right):
    mid = 0
    while right > left:
        mid = int(left + (right - left)//2)
        if check(mid,w,k):
            right = mid
        else:
            left = mid + 1
    return left

def check(p,w,k):
    k_tmp = 1
    w_tmp = 0
    for w_i in w:
        w_tmp += w_i
        if w_tmp > p:
            w_tmp = w_i
            k_tmp += 1
            if k_tmp > k:
                return False
    return True

print(binarySearch(max(w),sum(w)))"
"if input('') in ['a', 'e', 'i', 'o', 'u']:
    print('vowel')
else:
    print('consonant')"
"N = int(input())
A = [list(map(int,input().split())) for i in range(N)]

for k in range(N):
    for i in range(N):
        for j in range(N):
            if A[i][j] > A[i][k] + A[k][j]:
                print(-1)
                exit()

ans = 0
for i in range(N-1):
    for j in range(i+1,N):
        for k in range(N):
            if k==i or k==j: continue
            if A[i][j] == A[i][k] + A[k][j]:
                break
        else:
            ans += A[i][j]
print(ans)"
"s = list(input())
q = int(input())
r = 0
first = []
last = []

for i in range(q):
    query = list(input().split())

    if query[0] == ""1"":
        r = (r+1) % 2
        continue

    if r == 0:
        if query[1] == ""1"":
            first.append(query[2])
        else:
            last.append(query[2])
    else:
        if query[1] == ""1"":
            last.append(query[2])
        else:
            first.append(query[2])

first.reverse()
ans = first + s + last

if r == 1:
    ans.reverse()

print("""".join(ans))"
"import sys
def Ii():return int(sys.stdin.readline())
def Mi():return map(int,sys.stdin.buffer.readline().split())
def Li():return list(map(int,sys.stdin.buffer.readline().split()))

n = Ii()
i = 0;
s = [chr(ord('a') + i) for i in range(26)]
a = []
while n >= 1:
	a.append(s[n%26-1])
	n = (n-1) // 26
    
print(''.join(a)[::-1])
"
"(d,t,s) = map(int,input().split())

if (d<=t*s):
	print(""Yes"")
else:
	print(""No"")"
"n, k = map(int, input().split())
a = list(map(int, input().split()))

s = [0]
for i in range(len(a)):
    s.append(s[-1] + a[i])

ss = []
for i in range(len(s)):
    ss.append((s[i] - i) % k)

# print(ss)

ans = 0
from collections import Counter
c = Counter(ss[1: min(k, len(ss))])
for i in range(len(ss)):
    # print(i, c)
    ans += c[ss[i]]

    if i + 1 < len(ss):
        c[ss[i + 1]] -= 1
    if i + k < len(ss):
        c[ss[i + k]] += 1

print(ans)
"
"s=input()
l=['AKIHABARA','KIHABARA','AKIHBARA','AKIHABRA','AKIHABAR',
   'KIHBARA','AKIHBRA','AKIHABR','KIHABRA',
   'AKIHBAR','KIHABAR',
   'KIHBRA','AKIHBR','KIHABR','KIHBAR','KIHBR']

if s in l:
    print(""YES"")
else:
    print(""NO"")"
"n = int(raw_input())
ais = map(int,raw_input().split(' '))
res = [0] * n

c = 0
sign = 1
for ai in ais:
	c += ai * sign
	sign *= -1
res[0] = c/2
for i in range(1, len(ais)): res[i] = ais[i-1] - res[i-1]
print ' '.join(map(str,[e*2 for e in res]))"
"def main():
    S = input()
    T = input()
    slen = len(S)
    tlen = len(T)
    if tlen != slen + 1:
        print(""No"")
        return

    if T[:slen] == S:
        print(""Yes"")
    else:
        print(""No"")


main()
"
"import math
s = int(input())

x1 = 10**9
y2 = math.ceil(s/10**9)
x2 = 1
y1 = x1*y2 - s

print(0,0,x1,y1,x2,y2)"
"# https://atcoder.jp/contests/abc164/tasks/abc164_d

import sys
input = sys.stdin.readline


S = input().rstrip()

res = 0

x = 0
p = 1
MOD = 2019
reminder = [0]*2019
reminder[0] = 1
for s in reversed(S):
    """""" 累積和 """"""
    x = (int(s)*p + x)%MOD
    p = p*10%MOD
    res += reminder[x]
    reminder[x] += 1

print(res)"
"INF=float('inf')
mod=10**9+7

h,w=map(int,input().split())
G=[]
for _ in range(h):
  s=input()
  G.append(s)
  
dp=[[-INF for i in range(w+1)] for j in range(h+1)]
dp[1][1]=1

for i in range(1,h+1):
  for j in range(1,w+1):
    if G[i-1][j-1]=='#':
      continue
    if i==1 and j==1:
      continue
    dp[i][j]=max(0,dp[i-1][j])+max(0,dp[i][j-1])
    dp[i][j]%=mod
print(dp[h][w])"
"N,K = map (int, input ().split ())
l = [int (x) for x in input().split()]
list.sort (l)
x = 0
for i in range (K):
  x += l[-i-1]
print (x)"
"(a, b, c) = input().split(' ')
a = int(a)
b = int(b)
c = int(c)
 
if a < b < c:
    print(a, b, c)
elif a < c < b:
    print(a, c, b)
elif b <= a <= c:
    print(b, a, c)
elif b <= c <= a:
    print(b, c, a)
elif c <= a <= b:
    print(c, a, b)
else:
    print(c, b, a)"
"n, k = map(int, input().split())

ans = 1
while True:
    n = n // k
    if n == 0:
        break
    ans += 1
print(ans)"
"buf = input()
buf_len = len(buf)

str_array = []
for i in range(buf_len):
    str_array.append(buf[i])

for i in range(buf_len):
    if str_array[i].isupper():
        str_array[i] = str_array[i].lower()
    else:
        str_array[i] = str_array[i].upper()

for i in range(buf_len):
    print(""%s"" % str_array[i], end="""")

print()

"
"from collections import deque

n = int(input())
a = input().split()
d = deque([])
for i in range(n):
    if i % 2 == 0:
        d.append(a[i])  # 右に足す
    else:
        d.appendleft(a[i])  # 左に足す
if (n % 2) == 1:
    print(' '.join(list(d)[::-1]))
else:
    print(' '.join(list(d)))
"
"a,b = map(int,input().split())
if (a + b)%2 ==0:
    print(round((a + b) / 2))
else:
    print(round((a + b + 1) / 2))"
print(int(input())^int(input()))
"X,Y,A,B,C=map(int,input().split())
P=sorted(map(int,input().split()), reverse=True)[:X]
Q=sorted(map(int,input().split()), reverse=True)[:Y]
R=sorted(map(int,input().split()), reverse=True)[:X+Y]
i,j=X-1,Y-1
for r in R:
    if i==-1 and j==-1:
        break
    elif j==-1:
        if r>P[i]:
            P[i]=r
            i-=1
        else:
            break
    elif i==-1:
        if r>Q[j]:
            Q[j]=r
            j-=1
        else:
            break
    elif P[i]>Q[j]:
        if r>Q[j]:
            Q[j]=r
            j-=1
        else:
            break
    else:
        if r>P[i]:
            P[i]=r
            i-=1
        else:
            break
print(sum(P)+sum(Q))"
"import sys
from bisect import *
from heapq import *
from collections import *
from itertools import *
from functools import *
from math import *
from fractions import *

sys.setrecursionlimit(100000000)
input = lambda: sys.stdin.readline().rstrip()

def main():
    X, Y, Z, K = map(int, input().split())
    A = sorted(map(int, input().split()), reverse=True)
    B = sorted(map(int, input().split()), reverse=True)
    C = sorted(map(int, input().split()), reverse=True)
    h = []
    for i in A:
        for j in B:
            if len(h) < K:
                heappush(h, i + j)
            elif h[0] < i + j:
                heappush(h, i + j)
                heappop(h)
    AB = h[:]
    AB.sort(reverse=True)
    h = []
    for i in AB:
        for j in C:
            if len(h) < K:
                heappush(h, i + j)
            elif h[0] < i + j:
                heappush(h,i + j)
                heappop(h)
    ABC = h[:]
    ABC.sort(reverse=True)
    for i in range(K):
        print(ABC[i])

main()
"
"def ABC_66_A():
    a,b,c = map(int, input().split())
    
    if (a+b <= b+c) and (a+b <= a+c):
        print(a+b)
    elif (b+c <= a+b) and (b+c <= a+c):
        print(b+c)
    else:
        print(a+c)

if __name__ == '__main__':

    ABC_66_A()"
"n, m  =map(int, input().split())

mod = 10**9+7
ans = 1


if abs(n-m) >= 2:
    ans = 0
elif abs(n-m) == 1:
    for i in range(1, max(n, m)+1):
        ans *= i
        ans %= mod
    for j in range(1, min(n, m)+1):
        ans *= j
        ans %= mod
elif abs(n-m) == 0:
    for i in range(1, n+1):
        ans *= i
        ans %= mod
    ans **= 2
    ans*= 2
    ans %= mod


print(ans)
"
"h,w=map(int,input().split())
field=[list(input()) for i in range(h)]

l=[[0]*w for i in range(h)]
r=[[0]*w for i in range(h)]
u=[[0]*w for i in range(h)]
d=[[0]*w for i in range(h)]

for i in range(h):
    for j in range(w):
        if field[i][j]==""#"":
            l[i][j]=0
        elif j==0:
            l[i][j]=1
        else:
            l[i][j]=l[i][j-1]+1

for i in range(h):
    for j in reversed(range(w)):
        if field[i][j]==""#"":
            r[i][j]=0
        elif j==w-1:
            r[i][j]=1
        else:
            r[i][j]=r[i][j+1]+1

for i in range(h):
    for j in range(w):
        if field[i][j]==""#"":
            u[i][j]=0
        elif i==0:
            u[i][j]=1
        else:
            u[i][j]=u[i-1][j]+1

for i in reversed(range(h)):
    for j in range(w):
        if field[i][j]==""#"":
            d[i][j]=0
        elif i==h-1:
            d[i][j]=1
        else:
            d[i][j]=d[i+1][j]+1

ans=0
for i in range(h):
    for j in range(w):
        tmp=l[i][j]+r[i][j]+u[i][j]+d[i][j]-3
        ans=max(ans,tmp)
print(ans)
"
"import re
s = input()
print(re.sub(r'2017', r'2018', s))"
"K = int(input())
A = list(map(int,input().split()))
B = [2,2]
for i in range(K-1,-1,-1):
    a = A[i]
    bmin = B[0]
    bmax = B[1]
    if bmin%a==0:
        bmin = bmin
    else:
        bmin = (bmin//a+1)*a
    if bmin>bmax:
        B = []
        break
    else:
        if bmax%a==0:
            bmax = bmax+a-1
        else:
            bmax = (bmax//a)*a+a-1
        B = [bmin,bmax]
if len(B)==0:
    print(-1)
else:
    print(B[0],B[1])"
"n, m = map(int, input().split())
x = list(map(int, input().split()))

if n >= m:
  print(0)
  exit()

d = [0] * (m-1)
x.sort()

for i in range(m-1):
  d[i] = x[i+1] - x[i]
d.sort(reverse=True)
mx = x[-1] - x[0]
r = n - 1
dsum = sum(d[:r])
print(mx - dsum)"
"a=[]
i=0
while True:
  i+=1
  a=input()
  if a==0:
    break
  print ""Case {0}: {1}"".format(i, a)"
"def main():
    r,g,b = (input().split())
    print('YES' if int(g+b)%4==0 else 'NO')

if __name__ == '__main__':
    main()"
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
print((n-1) * (m-1))"
"n = int(input())
mod = n%1000
print(1000-mod if mod !=0 else 0)"
"# 約分してから計算するアルゴリズム

def combination(n, r):
    # n >= 0, r >= 0, r <= n を仮定
    if n < 0 or r < 0 or n < r:
        return 0

    # r <= n - r を仮定
    if n - r < r:
        r = n - r

    # r < 2 の場合
    if r == 0:
        return 1
    if r == 1:
        return n

    # nCr の分子
    # [n - r + 1, n - r + 2, ... , n - 1, n]
    numerator = [n - r + 1 + i for i in range(r)]


    # nCr の分母
    # [1, 2, ... , r - 1, r]
    denominator = [i + 1 for i in range(r)]

    # nCr を約分する
    for i in range(r):
        # i番目の分母で約分する
        # 0番目は1なので省略

        # 元の（今までの約分を行う前の）i番目の分母の値
        original_denominator = i + 1

        # 今までの約分を行った後の、i番目の分母の値
        # 今回の約分で割る数
        divisor = denominator[i]

        # divisorが1（全て約分済み）の場合は無視する
        if divisor == 1:
            continue

        # 約分する相手の分子を決める
        # 0～i番目の分子（約分前）の中で、
        # original_denominatorで割り切れる数
        # （一つしかない）を選ぶ
        # remainder = i番目の分子 % original_denominator
        # とするとき、
        # (i - remainder)番目の分子 = i番目の分子 - remainder
        # (i - remainder)番目の分子 % original_denominator
        #  = (i番目の分子 - remainder) % original_denominator
        #  = 0
        # なので、(i - remainder)番目の分子を選べばよい。

        # remainder = i番目の分子 % original_denominator
        #           = (n - r + i + 1) % (i + 1)
        #           = (n - r) % (i + 1)
        remainder = (n - r) % original_denominator

        # divisor で約分できるペアをすべて約分する
        for j in range(i, r, original_denominator):
            numerator[j - remainder] = numerator[j - remainder] // divisor
            denominator[j] = denominator[j] // divisor

    ans = 1
    for i in numerator:
        ans *= i
    return ans


N_string = input()
N = int(N_string)
K = int(input())

if N < 10:
    if K == 1:
        print(N)
    else:
        print(0)
# elif N < 100:
#     if K == 1:
#         print(9 + N // 10)
#     elif K == 2:
#         print(9 * (N // 10 - 1) + (N - (N // 10) * 10))
#     else:
#         print(0)
else:
    # 10 ** n <= N < 10 ** (n + 1) なる n
    # すなわち、N が n + 1 桁であるような n
    n = len(N_string) - 1

    # 10 ** n 未満で条件を満たす整数の数
    ans = combination(n, K) * (9 ** K)

    # Nの先頭の数字
    a = int(N_string[0])

    if K == 1:
        ans += a
    else:
        # a以外に0でない数字が出現するかどうか
        if N_string[1:] == ""0"" * n:
            # 出現しないとき
            ans += (a - 1) * combination(n, K - 1) * (9 ** (K - 1))
        else:
            # 出現するとき
            # Nの2番目の0以外の数字とその表れる桁数を計算
            m = n - 1
            while True:
                if N_string[n - m] != ""0"":
                    b = int(N_string[n - m])
                    break
                m -= 1

            if K == 2:
                # n + 1 桁かつ、先頭の数字が1以上a未満であるような、
                # 問題の条件を満たす整数の個数
                ans += (a - 1) * combination(n, K - 1) * 9

                # n + 1 桁かつ、先頭の数字が　a　であるような、
                # 問題の条件を満たす整数でN以下のもののの個数
                ans += combination(m, 1) * 9 + b
            else:
                # K == 3
                # a, b以外に0でない数字が出現するかどうか
                if N_string[n - m + 1:] == ""0"" * m:
                    # 出現しないとき

                    # n + 1 桁かつ、先頭の数字が1以上a未満であるような、
                    # 問題の条件を満たす整数の個数
                    ans += (a - 1) * combination(n, 2) * 9 * 9

                    # n + 1 桁で先頭の数字が　a　かつ、 m + 1 桁目が0であるような、
                    # 問題の条件を満たす整数でN以下のもののの個数
                    ans += combination(m, 2) * 9 * 9

                    # n + 1 桁で先頭の数字が a かつ、
                    # m + 1 桁目の数字が1以上b未満であるような、
                    # 問題の条件を満たす整数の個数
                    ans += (b - 1) * combination(m, 1) * 9
                else:
                    # Nの3番目の0以外の数字とその表れる桁数を計算
                    l = m - 1
                    while True:
                        if N_string[n - l] != ""0"":
                            c = int(N_string[n - l])
                            break
                        l -= 1

                    # n + 1 桁かつ、先頭の数字が1以上a未満であるような、
                    # 問題の条件を満たす整数の個数
                    ans += (a - 1) * combination(n, K - 1) * 9 * 9

                    # n + 1 桁で先頭の数字が　a　かつ、 m + 1 桁目が0であるような、
                    # 問題の条件を満たす整数でN以下のもののの個数
                    ans += combination(m, K - 1) * 9 * 9

                    # n + 1 桁で先頭の数字が a かつ、
                    # m + 1 桁目の数字が1以上b未満であるような、
                    # 問題の条件を満たす整数の個数
                    ans += (b - 1) * combination(m, K - 2) * 9

                    # n + 1 桁で先頭の数字が a かつ、
                    # m + 1 桁目の数字が　b　であるような、
                    # 問題の条件を満たす整数でN以下のもののの個数
                    ans += combination(l, 1) * 9 + c

    print(ans)
"
"N = int(input())
SI = list(input().split())
SB = SI.copy()

# bubble sort
for i in range(N):
	for j in range(N - 1, i, -1):
		if SB[j - 1][1] > SB[j][1]:
			x = SB[j - 1]
			SB[j - 1] = SB[j]
			SB[j] = x

# insertion sort
for i in range(N):
	ptr = i
	for j in range(i + 1, N):
		if SI[ptr][1] > SI[j][1]:
			ptr = j
	x = SI[i]
	SI[i] = SI[ptr]
	SI[ptr] = x

# print the answer!
for i in range(N):
	print(SB[i] + "" "" if i != N - 1 else str(SB[i]) + ""\n"", end='')
print(""Stable"")
for i in range(N):
	print(SI[i] + "" "" if i != N - 1 else str(SI[i]) + ""\n"", end='')
print(""Stable"" if SI == SB else ""Not stable"")

"
"N,K=map(int,input().split())
 
if N/2>K-1:
  print('YES')
else:
  print('NO')"
"M, D = map(int, input().split())
count = 0
if D >= 22:
  for i in range(22, D + 1):
    j = str(i)
    if int(j[1]) >= 2:
      m = int(j[0]) * int(j[1])
      if m <= M:
        count += 1
print(count)"
"N, X, Y = map(int, input().split())

ans = [0] * N

for i in range(1,N):
    for j in reversed(range(N+1)):
        if i >= j:
            break

        tmp = min(j-i,abs(X-i)+1+abs(Y-j))
        ans[tmp] += 1

for i in range(1,N):
    print(ans[i])"
"n=int(input())
x=[list(map(int,input().split())) for i in range(n-1)]
for i in range(n):
    ans=0
    for j in range(i,n-1):
        if ans%x[j][2]==0:
            a=0
        else:
            a=x[j][2]-(ans%x[j][2])
        ans=(max(ans+a,x[j][1]))
        ans+=x[j][0]
    print(ans)"
"n = int(input())
d_l = list(map(int, input().split()))
d_l = sorted(d_l)
if len(d_l) %2 != 0:
    print(0)
else:
    idx = int(len(d_l)/2)
    abc = d_l[idx-1]
    agc = d_l[idx]
    print(agc-abc)"
"# A - Prefix and Suffix

N = int(input())
s, t = [input() for i in range(2)]
delta = N

for i in range(N):
    if s[i:] == t[:N-i]:
        delta = i
        break

print(N+delta)"
"import math
a,b,x = list(map(int, input().split()))
volume = a*a*b
if 2 * x <= volume:
    print(90 - math.degrees(math.atan(2*(x/b/a)/b)))
else:
    print(math.degrees(math.atan(2*(volume-x)/a/a/a)))
"
"import itertools
A, B, C = map(int,input().split())

lst = []
for i in range(1,100):
    lst.append(A * i)


for i in range(1,3):
    for v in itertools.combinations(lst,i):
        if sum(v) % B == C:
            print('YES')
            exit()
print('NO')"
"A, B, C, D = map(int, open(0).read().split())
if A*B >= C*D:
  print(A*B)
else:
  print(C*D)"
"a = int(input())
a += int(input())
a *= int(input())
print(a//2)"
"s=input()
# アルファベット(a〜z)→数値(1〜26)小文字限定
a2n = lambda c: ord(c) - ord('a') + 1
# 数値(1〜26)→アルファベット(a〜z)
n2a = lambda c: chr(c+64).lower()

if len(s)<26:
  for i in range(1,27):
    if n2a(i) not in s:
      print(s+n2a(i))
      exit()
f=False
for i in range(1,26):
  if a2n(s[-i-1])>a2n(s[-i]):
    continue
  else:
    f=True
    break
if f==False:
  print(-1)
  exit()

ans=s[:-i-1]
mini=min([a2n(d) for d in s[-i:] if a2n(d)>a2n(s[-i-1])])
ans+=str(n2a(mini))
print(ans)
"
"N, P = list(map(int, input().split()))
S = input()

#累積和を求めるため後ろから処理したい。配列は逆転しておく。
revS = S[::-1] 


# 10が素数であまり0、つまり2か5の場合
# 区間の下1けた目の数によって、どれだけ左側に伸ばして行っても
# 必ず割り切れる
if(10 % P == 0):
  res = 0

  for index, num in enumerate(revS):
    if(int(num) % P == 0) :
      res += len(revS) - index

  print(res)

else:

  #累積和を入れておく
  cs = 0

  ## あまりの値のカウント
  counts = [0] * P

  ## 累積和の初項は0になる
  ## 余りの値をindexにして配列 counts に同じ余りの値の個数を記録するので
  ## 初項の分は先に処理しておく
  counts[cs] += 1

  ## 桁
  d = 1

  ## 2項目からはfor文を使って同じ余りの値のカウントを行う処理する
  for num in revS:
    m = (int(num) * d) % P
    cs = (cs + m) % P

    counts[cs] += 1

    # 次の桁へ移動
    d *= 10

    # 桁が巨大になりすぎるのであまりを撮っておく
    # 掛け算の最中にあまりを撮るのは問題ない
    d %= P

  res = 0

  for n in counts:
    # 同じ余りの値がn個あったとして、重複なく2つ取り出す方法はnC2個
    res += n * (n - 1) // 2

  print(res)"
"s = int(input())
n = 1000000000
x = (n-s%n)%n
y = (s+x)//n
print(*[1,n,y,x,0,0])"
"s=input()
t=input()

if s==t[::-1]:
    print('YES')
else:
    print('NO')"
"from itertools import product

A, B = map(int, input().split())
A -= 1
B -= 1

G = [[""#"" for _ in range(100)] for _ in range(50)]
for i, j in product(range(0, 50, 2), repeat=2):
    if A <= 0:
        break
    G[i][j] = "".""
    A -= 1

H = [[""."" for _ in range(100)] for _ in range(50)]
for i, j in product(range(1, 51, 2), repeat=2):
    if B <= 0:
        break
    H[i][j] = ""#""
    B -= 1

print(100, 100)
for g in G:
    print("""".join(g))

for h in H:
    print("""".join(h))
"
"
import sys, io, os, re
import bisect
from pprint import pprint
from math import sin, cos, pi, radians, sqrt, floor
from copy import copy, deepcopy
from collections import deque
from fractions import gcd
from functools import reduce

def array1(n): return [0] * n
def array2(n, m): return [[0] * m for x in range(n)]
def array3(n, m, l): return [[[0] * l for y in xrange(m)] for x in xrange(n)]

n, s = list(map(int, sys.stdin.readline().strip().split()))
a = [0 for x in range(n)]
a = list(map(int, sys.stdin.readline().strip().split()))

mod = 998244353

d = array2(n+1, s+1)
d[0][0] = 1

for i in range(n):
    #print(d)
    for j in range(s+1):
        d[i+1][j] += d[i][j] * 2
        d[i+1][j] %= mod
        if j + a[i] <= s:
            d[i+1][j+a[i]] += d[i][j]
            d[i+1][j+a[i]] %= mod

#print(d)
print(d[n][s])
"
"# input()
# int(input())
# map(int, input().split())
# list(map(int, input().split()))
# list(map(int, list(input()))) # スペースがない数字リストを読み込み
import math
import fractions
import sys
import bisect
import heapq  # 優先度付きキュー(最小値取り出し)
import collections
from collections import Counter
from collections import deque
import pprint
import itertools

sr = lambda: input()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

""""""nを素因数分解""""""
""""""2以上の整数n => [[素因数, 指数], ...]の2次元リスト""""""


def factorization(n):
    arr = []
    temp = n
    if n == 1:
        return arr

    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):
        if temp % i == 0:
            cnt = 0
            while temp % i == 0:
                cnt += 1
                temp //= i
            arr.append([i, cnt])

    if temp != 1:
        arr.append([temp, 1])

    if arr == []:
        arr.append([n, 1])

    return arr


# a^n
def power(a, n, mod):
    x = 1
    while n:
        if n & 1:
            x *= a % mod
        n >>= 1
        a *= a % mod
    return x % mod


# n*(n-1)*...*(l+1)*l
def kaijo(n, l, mod):
    if n == 0:
        return 1
    a = n
    tmp = n - 1
    while (tmp >= l):
        a = a * tmp % mod
        tmp -= 1
    return a

# Union Find
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

# 約数生成
def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)

    divisors.sort()
    return divisors


inf = 10 ** 18
mod = 10 ** 9 + 7

h,w,d = lr()
a = [lr() for i in range(h)]
dic = [[0,0] for i in range(h*w)]
dic1 = [[0] for i in range(d)]
for i in range(h):
    for j in range(w):
        dic[a[i][j]-1] = [i,j]
for j in range(d):
    pre = dic[j]
    for k in range(j,h*w,d):
        cost = abs(pre[0] - dic[k][0])+abs(pre[1] - dic[k][1])
        dic1[j].append(dic1[j][-1]+cost)
        pre = dic[k]
q = ir()
for t in range(q):
    l,r = lr()
    l-=1
    r-=1
    next = (r-l)//d
    start = l%d
    left = l//d+1
    print(dic1[start][left+next]-dic1[start][left])"
"n=int(input())
print((n//2)+int(n%2!=0))"
"m, k = map(int, input().split())
ret = []
if k >= 2 ** m or (m == 1 and k == 1):
    ret.append(-1)
elif m == 1:
    ret = [0, 0, 1, 1]
else:
    ret.append(k)
    for i in range(2 ** m):
        if i != k:
            ret.append(i)
    ret.append(k)
    for i in range(2 ** m - 1, -1, -1):
        if i != k:
            ret.append(i)
print(' '.join(map(str, ret)))"
"def main():
    N = int(input())
    A = list(map(int, input().split()))
    breakcount = 0
    cnt = 1
    for i in range(N):
        if A[i] != cnt:
            breakcount += 1
        else:
            cnt += 1
    if cnt == 1:
        print(-1)
        return
    print(breakcount)

if __name__ == ""__main__"":
    main()
"
"line = int(input())
if line < 1200:
    print(""ABC"")
else:
    print(""ARC"")
"
"import sys
sys.setrecursionlimit(10**9)

def mi(): return map(int,input().split())
def ii(): return int(input())
def isp(): return input().split()
def deb(text): print(""-------\n{}\n-------"".format(text))

INF=10**20
def main():
    N=ii()
    D=list(mi())

    ans = 0
    for i in range(N):
        for j in range(i+1,N):
            ans += D[i]*D[j]

    print(ans)




if __name__ == ""__main__"":
    main()"
"d, n = map(int, input().split())
if n == 100:
    n += 1
print(n if d==0 else 100*n if d==1 else (100**2)*n)
"
"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

N = I()
A = LI()
A_tup = [(0, 0)] * N
for i in range(N):
    A_tup[i] = (A[i], i)
A_tup.sort(reverse=True)

dp = [[0] * (N + 1) for i in range(N + 1)]
dp[0][0] = 0
for i in range(N):
    pi = A_tup[i][1]
    for j in range(i + 1):
        k = i - j
        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + (pi - j) * A_tup[i][0])
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + (N - k - 1 - pi) * A_tup[i][0])

ans = 0
for i in range(N):
    ans = max(ans, dp[N][i])
print(ans)"
"A=input()
cntg=0
cntp=0
cnt=0
for i in A:
  if i=='g':
    if cntg==cntp:
      cntg+=1
    else:
      cntp+=1
      cnt+=1
  else:
    if cntg==cntp:
      cntg+=1
      cnt-=1
    else:
      cntp+=1
print(cnt)"
"a, b = map(int, input().split())
ans = ""Odd"" if a * b % 2 == 1 else ""Even""
print(ans)
"
"N = int(input())
A = [int(x) for x in input().split()]

C = 0
for i in range(0,N,2):
  if A[i] % 2 == 1:
  	C += 1
    
print(C)"
"from collections import Counter

N = int(input())
A = [list(map(int, input().split())) for _ in range(N)]

pq = []

for x, y in A:
    for i, j in A:
        if x == i and y == j:
            continue
        pq.append(str(i-x)+str(j-y))

ans = Counter(pq).most_common()

if ans == []:
    print(1)
else:
    print(N - ans[0][1])"
"n = input()
print(""Yes"" if n[0] == ""9"" or n[1] == ""9"" else ""No"")"
"N = int(input())
A = [int(i) for i in input().split()]

def selectionSort(A):
    count = 0
    for i in range(len(A)):
        minj = i
        for j in range(i, len(A)):
            if A[j] < A[minj]:
                minj = j
        if i != minj:
            tmp = A[i]
            A[i] = A[minj]
            A[minj] = tmp
            count += 1
    return A, count

A ,count = selectionSort(A)
print(' '.join([str(i) for i in A]))
print(count)"
"import itertools
n = int(input())
p = list(map(int, input().split()))
q = list(map(int, input().split()))
l = []
for v in itertools.permutations(list(range(1, n+1))):
    l.append(v)
l = [0] + l
print(abs(l.index(tuple(p))-l.index(tuple(q))))"
"x, y = map(int, input().split())

ans = 10 ** 18
# 最初にB押す、最後にB押す
X, Y = -x, -y
if X <= Y:
    ans = min(ans, Y - X + 2)

# 最初にB押さない、最後にB押す
X, Y = x, -y
if X <= Y:
    ans = min(ans, Y - X + 1)

# 最初にB押す、最後にB押さない
X, Y = -x, y
if X <= Y:
    ans = min(ans, Y - X + 1)

# 最初にB押さない、最後にB押さない
X, Y = x, y
if X <= Y:
    ans = min(ans, Y - X)

print(ans)"
"c1 = input().strip()
c2 = input().strip()
if c1[0] == c2[2] and c1[1] == c2[1] and c1[2] == c2[0]:
    print(""YES"")
else:
    print(""NO"")
"
"n=input()
ans=""""
for x in n:
  if x==""1"":
    ans+=""9""
  elif x==""9"":
    ans+=""1""
  else:
    ans+=x
print(ans)"
"n = int(input())
a = list(map(int, input().split()))

avg = sum(a) / len(a)
diff = list(map(lambda x : abs(x - avg), a))
min_diff = min(diff)
for i in range(n):
    if abs(a[i] - avg) == min_diff:
        print(i)
        break"
"from sys import stdin
import math
import fractions
from collections import deque
from collections import Counter
import itertools
import heapq

readline = stdin.buffer.readline

INF = 10 ** 10

# M日後まで得られる報酬の合計の最大値
N, M = [int(x) for x in readline().split()]

#Ai日後にBiの金
#AB = [tuple(map(int, readline().split())) for _ in range(N)]

jobs = [[] for _ in range(M+1)]

for _ in range(N):
    A, B = [int(x) for x in readline().split()]
    if A <= M:
        jobs[A].append(B)

# priority queue
pq = [] 

ans = 0

# i = 1 to M
for i in range(1, M+1):
    for job in jobs[i]:
        heapq.heappush(pq, -job)
    
    if(pq):
        ans += -heapq.heappop(pq)

print(ans)   
"
"n, x = map(int, input().split())
m = [int(input()) for _ in range(n)]
m.sort()
ans = len(m)
x = x - sum(m)
ans += x//m[0]
print(ans)
"
"import bisect
n = int(input())
A = [int(input()) for i in range(n)]
m = 10**9
X = []
for a in A:
    i = bisect.bisect_right(X, -a)
    if i == len(X):
        X.append(-a)
    else:
        X[i] = -a
print(len(X))
"
"import itertools
n, k = (int(i) for i in input().split())
P = [int(i) for i in input().split()]

probs = list(itertools.accumulate([(1+p)/2 for p in P]))
probs.insert(0,0)

ans = 0

for i in range(n-k+1):
    ans = max(ans, -probs[i]+probs[i+k])

print(ans)
"
"# -*- coding: utf-8 -*-
import bisect
import heapq
import math
import random
from collections import Counter, defaultdict, deque
from decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal
from fractions import Fraction
from functools import lru_cache, reduce
from itertools import combinations, combinations_with_replacement, product, permutations, accumulate
from operator import add, mul, sub, itemgetter, attrgetter


import sys
# sys.setrecursionlimit(10**6)
# readline = sys.stdin.buffer.readline
readline = sys.stdin.readline

INF = 2**62-1


def read_int():
    return int(readline())


def read_int_n():
    return list(map(int, readline().split()))


def read_float():
    return float(readline())


def read_float_n():
    return list(map(float, readline().split()))


def read_str():
    return readline().strip()


def read_str_n():
    return readline().strip().split()


def error_print(*args):
    print(*args, file=sys.stderr)


def mt(f):
    import time

    def wrap(*args, **kwargs):
        s = time.perf_counter()
        ret = f(*args, **kwargs)
        e = time.perf_counter()

        error_print(e - s, 'sec')
        return ret

    return wrap


@mt
def slv(X, Y, Z, K, A, B, C):
    q = []
    A.sort(reverse=True)
    B.sort(reverse=True)
    C.sort(reverse=True)
    if len(A) > K:
        A = A[:K]
    if len(B) > K:
        B = B[:K]
    if len(C) > K:
        C = C[:K]

    for a in A:
        for b in B:
            heapq.heappush(q, a+b)
            if len(q) > K:
                heapq.heappop(q)

    qq = []
    for c in C:
        for d in q:
            heapq.heappush(qq, d+c)
            if len(qq) > K:
                heapq.heappop(qq)
    qq.sort(reverse=True)
    return qq

def main():
    X, Y, Z, K = read_int_n()
    A = read_int_n()
    B = read_int_n()
    C = read_int_n()
    print(*slv(X, Y, Z, K, A, B, C), sep='\n')


if __name__ == '__main__':
    main()
"
"#!/usr/bin/env python3


n, k = list(map(int, input().split()))
h = [int(input()) for _ in range(n)]

h.sort(reverse=True)

ans = 10**10
for i in range(0, n-k+1):
    max_ = h[i]
    min_ = h[i+k-1]
    ans = min(ans, max_-min_)
print(ans)
"
"N=int(input())
A=list(map(int,input().split()))

count=0
k=1
for i in range(len(A)):
    if A[i]==k:
        count+=1
        k+=1

if count==0:
    print(-1)
else:
    print(len(A)-count)"
"def actual(N, S):
    count = 0

    for i in range(1, N):
        left_chars = set(S[:i])
        right_chars = set(S[i:])

        and_chars = left_chars & right_chars
        unique_chars = len(and_chars)

        if unique_chars > count:
            count = unique_chars

    return count

N = int(input())
S = input()

print(actual(N, S))"
"from sys import stdin
import bisect

a,b = [int(x) for x in stdin.readline().rstrip().split()]

print(max(a+b,a-b,a*b))"
"M=10**9+7
n,k=map(int,input().split())
for i in range(k):
  if n-k<i: print(0)
  else:
    s=t=1
    for j in range(1,i+1): s=s*(n-k+2-j)*(k-j)%M; t=t*j*j%M
    print(s*(n-k+1-i)*pow(t*(i+1),M-2,M)%M)"
"X = int(input())

def Main(X):
    if X <= 2:
        return X
    ans = 0
    for i in range(1, X):
        ans += i
        if ans >= X:
            return i
    
print(Main(X))
"
"x=input()
print('ABC'+x)"
"def resolve():
    a, b = map(int, input().split())

    ans = a + b
    if ans >= 24:
        ans -= 24

    print(ans)
resolve()"
"n = int(input())
A = list(map(int, input().split()))

A.sort()

for i in range(len(A)):
    if i == 0:
        continue
    if A[i-1] == A[i]:
        print('NO')
        exit()
print('YES')
"
"S = input()
nick = str()
for n in range(3):
  nick = nick + S[n]    

print(nick)"
"import sys
import math
from itertools import accumulate as acc

input=sys.stdin.readline

N=int(input())
a=list(map(int,input().split()))
b=[abs(a[i]) for i in range(N)]
l=b.index(max(b))

if a[l]==0: print(0),sys.exit()
elif a[l]>0:
	print(N*2)
	for i in range(2):
		print(l+1,1)
	for i in range(1,N):
		for j in range(2):
			print(i,i+1)

else:
	print(N*2)
	for i in range(2):
		print(l+1,N)
	for i in range(N,1,-1):
		for j in range(2):
			print(i,i-1)"
"def cmb(n,r):
    if (n-r)<r: r=n-r
    if r==0: return 1
    if r==1: return n

    numerator = [n-r + k+1 for k in range(r)]
    denominator = [k+1 for k in range(r)]

    for p in range(2,r+1):
        pivot = denominator[p-1]
        if pivot>1:
            offset = (n-r)%p
            for k in range(p-1,r,p):
                numerator[k - offset] /= pivot
                denominator[k] /= pivot

    result = 1
    for k in range(r):
        if numerator[k] > 1:
            result *= int(numerator[k])

    return result

x,y = map(int,input().split())

MOD = 10**9+7
n = (x+y)//3
a = x-n
b = y-n

if (x+y)%3 != 0 or a < 0 or b < 0:
    print(0)
else:
    a = x-n
    b = y-n
    print(cmb(a+b,b)%MOD)"
"from itertools import combinations

n, k = map(int, input().split())

if k > (n - 1) * (n - 2) // 2:
  print(-1)
else:
  print(n - 1 + (n - 1) * (n - 2) // 2 - k)
  for i in range(2, n + 1):
    print(1, i)
  comb = list(combinations([i for i in range(2, n + 1)], 2))
  for i, j in comb[:(n - 1) * (n - 2) // 2 - k]:
    print(i, j)"
"s=input()
if ""C""not in s:print(""No"")
elif s.find(""C"",0)<s.find(""F"",s.find(""C"",0)+1):print(""Yes"")
else:print(""No"")"
"S = input()
T = input()

for i in range(len(S)):
    T = T[1:] + T[0]
    if T == S:
        print(""Yes"")
        break

else:
    print(""No"")
"
"A, B, C = [int(x) for x in input().split()]
ans = 0
while True:
    if A % 2 == 1 or B % 2 == 1 or C % 2 == 1:
        break
    elif A == B == C:
        ans = -1
        break
    ans += 1
    A, B, C = (B + C) // 2, (A + C) // 2, (A + B) // 2

print(ans)"
"from collections import deque

n, q = map(int,input().split())

edge = [[] for _ in range(n)]
for i in range(n-1):
    a, b = map(int,input().split())
    edge[a-1].append(b-1)
    edge[b-1].append(a-1)

score = [0]*n

for i in range(q):
    p, x = map(int,input().split())
    score[p-1] += x

visited = [0]*n
visited[0] = 1

s = deque([0])
while s:
    now = s.pop()
    for v in edge[now]:
        if visited[v]:
            continue
        score[v] += score[now]
        visited[v] = 1
        s.append(v)

print(*score)"
"W,H,x,y,r=[int(x) for x in input().split()]
print('Yes' if 0<=x-r<=x+r<=W and 0<=y-r<=y+r<=H else 'No')
"
"import sys
input=sys.stdin.buffer.readline
mod=10**9+7

n,m=map(int,input().split())
*x,=map(int,input().split())
*y,=map(int,input().split())
xd=[i-j for j,i in zip(x,x[1:])]
yd=[i-j for j,i in zip(y,y[1:])]
xs=ys=0
for i,d in enumerate(xd):
	xs+=d*(i+1)*(n-1-i)%mod
	xs%=mod
for i,d in enumerate(yd):
	ys+=d*(i+1)*(m-1-i)%mod
	ys%=mod
print(xs*ys%mod)"
"# coding: utf-8
import sys

sr = lambda: sys.stdin.readline().rstrip()
ir = lambda: int(sr())
lr = lambda: list(map(int, sr().split()))

A, B, T = lr()
answer = B * (T//A)
print(answer)
"
"def compare(a, b, c):
    if a < b and b < c:
        print('Yes')
    else:
        print('No')

a, b, c = [int(x) for x in input().split()]
compare(a, b, c)"
"A,B,C=map(int,input().split())
print([""No"",""Yes""][A==B==C])"
"N, *A = map(int, open(0).read().split())
ans = 0
for i in range(N):
    q, r = divmod(A[i], 2)
    ans += q
    if r == 0 or i == N - 1:
        continue
    elif A[i + 1] != 0:
        A[i + 1] += 1
print(ans)
"
"k,s = map(int,input().split())
ans = 0
for x in range(k+1):
  for y in range(k+1):
    z = s-x-y
    ans += (0 <= z <= k)
print(ans)"
"num = int(input())
a = []

for i in range(num):
    n = int(input())
    a.append(n)
    
myset = set(a)

len_list = len(frozenset(myset))

print(len_list)
"
"import sys
import collections

readline = sys.stdin.readline

class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1]*n
        self.rank = [0]*n
        self.size = [1]*n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
    
    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.rank[x] < self.rank[y]:
            self.size[y] += self.size[x]
            self.parents[x] = y
        else:
            self.size[x] += self.size[y]
            self.parents[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def msize(self, x):
        return -self.size[self.find(x)]

def main():
    N, M = map(int, readline().split())
    nodelist = []
    for _ in range(M):
        A, B = map(int, readline().split())
        A -= 1; B -= 1
        nodelist.append((A, B))
    
    uf = UnionFind(N)
    anstmp = (N*(N-1))//2
    anslist = [anstmp]
    for _ in range(M):
        node = nodelist.pop()
        n0 = uf.find(node[0])
        n1 = uf.find(node[1])
        if n0 != n1:
            n0size = uf.size[n0]
            n1size = uf.size[n1]
        else:
            n0size = 0; n1size = 0
        uf.union(node[0], node[1])
        anstmp = anslist[-1]
        ans = anstmp - n0size*n1size
        anslist.append(ans)
    anslist = anslist[:-1]
    for _ in range(len(anslist)):
        ans = anslist.pop()
        print(ans)

if __name__ == ""__main__"":
    main()
"
"divisors = []
divisorsc = []

a, b, c = input().split()
a = int(a)
b = int(b)
c = int(c)

for n in range(int(c)):
    if c%(n + 1) == 0:
        divisorsc.append(n+1)

#if a == b:
    #if a in divisorsc:
       # divisors.append(a)
        
for i in range(1 + b - a):
    if i + a in divisorsc:
        divisors.append(i+a)
        
print(len(divisors))"
"from sys import stdin, setrecursionlimit
from math import factorial

setrecursionlimit(10 ** 9)
INF = 1 << 60


def input():
    return stdin.readline().strip()


def main():
    N, M, K = map(int, input().split())
    MOD = 998244353
    COM_MAX = N

    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)
    fac[0] = fac[1] = 1
    finv[0] = finv[1] = 1
    inv[1] = 1

    for i in range(2, COM_MAX + 1):
        fac[i] = fac[i - 1] * i % MOD
        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD
        finv[i] = finv[i - 1] * inv[i] % MOD

    def mod_com(n, k):
        if n < k:
            return 0
        if n < 0 or k < 0:
            return 0
        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD

    ans = 0
    power = M % MOD
    for k in range(N - 1, -1, -1):
        if k <= K:
            ans += mod_com(N - 1, k) * power % MOD
        power = power * (M - 1) % MOD

    print(ans % MOD)

    return


if __name__ == '__main__':
    main()
"
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    plus = []
    minus = []
    for _ in range(n):
        x, y = map(int, input().split())
        plus.append(x + y)
        minus.append(x - y)
    plus.sort()
    minus.sort()
    ans = max(plus[-1] - plus[0], minus[-1] - minus[0])
    print(ans)

main()"
"sum = int(input())
h = sum // 60**2
m = (sum % 60**2) // 60
s = sum % 60
print(h, ':', m, ':', s, sep='')
"
"import sys
sys.setrecursionlimit(10**6)

b = input()

d = {'A':'T','C':'G','T':'A','G':'C'}

print(d[b])"
"n, m, q = map(int, input().split())
d = [[0] * n for _ in range(n)]
for _ in range(m):
    l, r = map(int, input().split())
    l -= 1
    r -= 1
    for i in range(l + 1):
        d[i][r] += 1
for i in range(n):
    for j in range(1, n):
        d[i][j] += d[i][j-1]
for _ in range(q):
    p, q = map(int, input().split())
    print(d[p-1][q-1])"
"import sys
w=input().upper()
print(sys.stdin.read().upper().split().count(w))"
"def my_print():
    print(""{}"".format("""".join(str[command[1]: command[2]])))

def replace():
    command[3] = list(command[3])
    str[command[1]: command[2]] = command[3]

def reverse():
    str[command[1]: command[2]] = reversed(str[command[1]: command[2]])

str = list(input())
q = int(input())
for i in range(q):
    command = input().split()
    command[1], command[2] = int(command[1]), int(command[2]) + 1
    if command[0] == ""print"":
        my_print()
    elif command[0] == ""replace"":
        replace()
    else:
        reverse()

"
"a, b, c = map(int, raw_input().split(' '))
print len([x for x in xrange(a, b+1) if not(c%x)])"
"import sys

n = int(input())

a = []

for _ in range(n):
    A = list(map(int, input().split( )))
    a.append(A)

b = [[a[i][j] for j in range(n)] for i in range(n)]

#三角不等式(等号可)を満たしてなかったら無理
#満たしてた場合、どの迂回路とも真の不等号ならば保持

for k in range(n):
    for i in range(n):
        for j in range(n):
            if a[i][k] + a[k][j] < a[i][j]:
                print(-1)
                sys.exit()
            if i!=k and j!=k and a[i][k] + a[k][j] == a[i][j]:

                b[i][j] = 0
ans = 0
for i in range(n):
    ans += sum(b[i])

print(ans//2)


"
"X, Y, Z = map(int,input().split())

print(Z, X, Y)"
"
def resolve():
    MOD = 10**9+7
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    P = []
    M = []
    for a in A:
        if a < 0:
            M.append(a)
        else:
            P.append(a)
    p_n = len(P)
    m_n = len(M)
    # 正の値にできるかを判定する
    ok = False
    if p_n > 0:
        if N == K:
            ok = (m_n%2==0) # 負の値が偶数あるとTrue
        else:
            ok = True
    # 負の値しか無い場合
    else:
        ok = (K % 2 == 0) # Kが偶数なら負の値を偶数個選べる

    ans = 1
    # 正の値にできない
    if not ok:
        # 絶対値が小さい順にソート
        A.sort(key=lambda x:abs(x))
        for i in range(K):
            ans *= A[i]
            ans %= MOD
    else:
        P.sort()
        M.sort(reverse=True)
        if K%2== 1:
            ans *= P.pop()
            ans %= MOD
        pair = []
        # 2個ずつ処理する
        while len(P) >= 2:
            x = P.pop()
            x *= P.pop()
            pair.append(x)
        while len(M) >= 2:
            x = M.pop()
            x *= M.pop()
            pair.append(x)
        pair.sort(reverse=True)
        for i in range(K//2):
            ans *= pair[i]
            ans %= MOD
    ans %= MOD
    print(ans)

if __name__ == ""__main__"":
    resolve()
"
"import math
s = int(input())
h = math.floor(s / 3600)
tmp = s % 3600
m = math.floor(tmp / 60)
s = tmp % 60
a = [h,m,s]
print("":"".join(list(map(str, a))))"
"d, n = map(int, input().split())
if n < 100: print(n * (100 ** d))
else: print((n + 1) * (100 ** d))"
"N, M, D = map(int, input().split())

if D==0:
    dnum = N
else:
    dnum = 2*(N-D)
    
ans = dnum*(M-1) / N**2

print(ans)"
"n = int(input())
p = list(map(int, input().split()))
num = 1
mini = p[0]
for i in range(1,n):
    if p[i] < mini:
        num += 1
        mini = p[i]
print(num)"
"K = int(input())

A = [0 for _ in range(K)]
for i in range(K):
    if i == 0:
        mod = 7 % K
    else:
        mod = (10 * A[i-1] + 7) % K
    A[i] = mod
    if mod == 0:
        print(i+1)
        exit()
print(-1)
"
"def readints():
    return list(map(int, input().split()))


a = int(input())
b = int(input())
c = int(input())
d = int(input())

print(min(a, b)+min(c, d))
"
"N=int(input())
A=[]
A=list(map(int,input().split()))
ans=[0 for i in range(N)]
for i in range(N-1):
    ans[A[i]-1]=ans[A[i]-1]+1

for i in ans:
    print(i)
"
"a,b,c,d=map(int,input().split())
e=list(map(int,input().split()))
f=list(map(int,input().split()))
for i in range(c+1,d+1):
    if max(e)<i and min(f)>=i:
        print('No War')
        exit()
print('War')"
"[n, m, l] = [int(x) for x in raw_input().split()]

A = []
B = []
counter = 0
while counter < n:
    A.append([int(x) for x in raw_input().split()])
    counter += 1

counter = 0
while counter < m:
    B.append([int(x) for x in raw_input().split()])
    counter += 1

B = list(zip(*B))

for i in range(n):
    data = []
    for j in range(l):
        data.append(sum([x[0] * x[1] for x in zip(A[i], B[j])]))
    print(' '.join([str(x) for x in data]))"
"N=int(input())
S=list(input())

M=0
for i in range(1,N):
    M=max(M,len(set(S[:i])&set(S[i:])))
print(M)
"
"n=int(input())
s=''
if n==0:
    print(0)
    exit()
while n!=0:
    m=n%2
    s+=str(m)
    n=(n-m)//-2
print(s[::-1])"
"data = raw_input().split()
n = int(data[0])
q = int(data[1])

queue = []
for i in range(n):
	process = raw_input().split()
	process[1] = int(process[1])
	queue.append(process)

time = 0
while len(queue) > 0:
	if queue[0][1] > q:
		queue[0][1] -= q
		time += q
		queue.append(queue[0])
	else:
		time += queue[0][1]
		print(""{:} {:}"".format(queue[0][0], time))
	del queue[0]"
"import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(max(1000, 10**9))
write = lambda x: sys.stdout.write(x+""\n"")


n,m = list(map(int, input().split()))
ab = [tuple(map(int, input().split())) for _ in range(n)]
ans = 0
c = 0
ab.sort(key = lambda x: (x[0], -x[1]))
from heapq import heappop as hpp, heappush as hp
class HST:
    def __init__(self, ascending=True):
        self._h = []
        self._q = []
        self.ascending = ascending
    def push(self, v):
        if not self.ascending:
            v *= -1
        hp(self._h, v)
    def remove(self, v):
        if not self.ascending:
            v *= -1
        hp(self._q, v)
    def top(self):
        while self._q and self._q[0]==self._h[0]:
            hpp(self._q)
            hpp(self._h)
        if not self._h:
            res = None
        else:
            res = self._h[0]
            if not self.ascending:
                res *= -1
        return res
h = HST(ascending=False)
ans = 0
ab = ab[::-1]
# print(ab)
for c in range(m, -1, -1):
    while ab and ab[-1][0]+c<=m:
        a,b = ab.pop()
        h.push(b)
    val = h.top()
    if val is not None:
        ans += val
        h.remove(val)
print(ans)"
"n,m=map(int,input().split())
g = [[] for _ in range(n)]

for _ in range(m):
    a, b = map(int,input().split())
    g[a-1].append(b-1)
    g[b-1].append(a-1)

from collections import deque

d = [None] * n
def bfs(u):
    queue = deque([u])
    d[u] = 0
    while queue:
        v = queue.popleft()
        for i in g[v]:
            if d[i] is None:
                d[i] = d[v] + 1
                queue.append(i)
cnt=0
for i in range(n):
    if d[i] is None:
        cnt+=1
        bfs(i)
print(cnt-1)"
"import sys
sys.setrecursionlimit(10**8)
def ii(): return int(sys.stdin.readline())
def mi(): return map(int, sys.stdin.readline().split())
def li(): return list(map(int, sys.stdin.readline().split()))
def li2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]
def dp2(ini, i, j): return [[ini]*i for i2 in range(j)]
def dp3(ini, i, j, k): return [[[ini]*i for i2 in range(j)] for i3 in range(k)]
#import bisect #bisect.bisect_left(B, a)
#from collections import defaultdict #d = defaultdict(int) d[key] += value
#from collections import Counter # a = Counter(A).most_common()
#from itertools import accumulate #list(accumulate(A))

N = ii()
A = li()

if N == 0:
    if A==[1]:
        print(1)
    else:
        print(-1)
    exit()

max_a = [0] * (N+1)
max_a[0] = 1 - A[0]

for i in range(1, N+1):
    max_a[i] = max_a[i-1] * 2 - A[i]
    if max_a[i] < 0:
        print(-1)
        exit()

cnt_list = [0]*(N)
cnt_list[-1] = min(A[-1], max_a[N-1])

for i in reversed(range(N-1)):
    if cnt_list[i+1] + A[i+1] <= max_a[i]:
        cnt_list[i] = cnt_list[i+1] + A[i+1]
    else:
        cnt_list[i] = max_a[i]

cnt = sum(cnt_list[:N+1]) + sum(A)

print(cnt)"
"N = int(input())
li = list(map(int, input().split()))
an = 0
ma = 0
for i in range(N):
    if i != N-1 and li[i] >= li[i+1] :
        an += 1
    else:
        an = 0
    ma = max(an,ma)
print(ma)"
"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

Asum_li = [0]
Asum = 0
Bsum_li = [0]
Bsum = 0

for A_ in A:
    Asum = Asum + A_
    Asum_li.append(Asum)

for B_ in B:
    Bsum = Bsum + B_
    Bsum_li.append(Bsum)

cnt_max = 0
cnt_b = M

for cnt_a in range(N+1):

    if Asum_li[cnt_a] > K : break

    while (Bsum_li[cnt_b] + Asum_li[cnt_a]) > K:
        cnt_b = cnt_b - 1
        if cnt_b < 0: break

    if (cnt_max < cnt_a + cnt_b): cnt_max = cnt_a + cnt_b


print(cnt_max)

"
"n = int(input())
if n%2!=0: n*=2
print(n)"
"import math
N = int(input())
lst = [int(input()) for _ in range(5)]

#print(lst)
#print(min(lst),N//min(lst))
'''
if min(lst) >= N:
    print(5)
else:
    print(N//min(lst)+5)
'''

print(math.ceil(N/min(lst))+4)"
"X=int(input())

count=1

while True:
  if X*count%360==0:
    break
  else:
    count=count+1

print(count)"
"import math
x1,y1,x2,y2=map(float,input().split())
X=x2-x1
Y=y2-y1
L=math.sqrt(X**2+Y**2)
print(f'{L:.8f}')

"
"print('\n'.join('{0}x{1}={2}'.format(i, j, i * j) for i in range(1, 10) for j in range(1, 10)))"
"S=list(input())
count=S.count(""R"")
if S==[""R"",""S"",""R""]:
  count=1
print(count)"
"N = int(input())
S = [input().strip() for _ in range(N)]
C = {""A"":0,""B"":0,""BA"":0}
cnt = 0
for i in range(N):
    s = S[i]
    for j in range(len(s)-2+1):
        if s[j:j+2]==""AB"":
            cnt += 1
    if s[0]==""B"" and s[-1]==""A"":
        C[""BA""] += 1
    elif s[0]==""B"":
        C[""B""] += 1
    elif s[-1]==""A"":
        C[""A""] += 1
if C[""BA""]>0:
    cnt += C[""BA""]-1
    if C[""B""]>0:
        cnt += 1
        C[""B""] -= 1
    if C[""A""]>0:
        cnt += 1
        C[""A""] -= 1
cnt += min(C[""B""],C[""A""])
print(cnt)"
"import sys
readline = sys.stdin.buffer.readline
def even(n): return 1 if n%2==0 else 0

n = int(readline())
lst1 = []
for i in range(n):
    lst1.append(int(readline()))

ans = 0
lst2 = []
for i in lst1:
    i -= 2
    if i >= 0:
        ans += (i+1)//2
    if i == -2:
        lst2.append(0)
    elif even(i):
        lst2.append(2)
    else:
        lst2.append(1)

now = 0
while now < n:
    if now == 0:
        if lst2[now] == 2:
            ans += 1
            lst2[now] = 0
        now += 1
        continue
    if lst2[now-1] == 1 and lst2[now] == 2:
        ans += 1
        lst2[now] = 1
        now += 1
        continue

    if lst2[now-1] == 1 and lst2[now] == 1:
        ans += 1
        lst2[now] = 0
        now += 1
        continue
    
    if lst2[now] == 2:
        ans += 1
        lst2[now] = 0
        now += 1
        continue
    now += 1

print(ans)"
"import sys
import math
from fractions import Fraction
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import defaultdict

MOD = 10**9+7
N = int(input())
dic = defaultdict(int)
gp = []
zero = 0
left_zero = 0
right_zero = 0
for i in range(N):
    a,b = map(int, input().split())
    if b < 0:
        a = -a
        b = -b
    if a == 0 and b != 0:
        left_zero += 1
    elif a != 0 and b == 0:
        right_zero += 1
    elif a == 0 and b == 0:
        zero += 1
    else:
        g = math.gcd(a, b)
        a //= g
        b //= g
        dic[str(Fraction(a, b))] += 1
        gp.append((a, b))
done = defaultdict(bool)
ans = 1
for a,b in gp:
    k = str(Fraction(a, b))
    if done[k]: continue
    rk = str(Fraction(-b, a))
    done[k] = True
    done[rk] = True
    cnt1 = pow(2, dic[k], MOD)-1
    cnt2 = pow(2, dic[rk], MOD)-1
    c = cnt1+cnt2+1
    ans *= c
    ans %= MOD
c1 = pow(2, left_zero, MOD)-1
c2 = pow(2, right_zero, MOD)-1
c = c1+c2+1
ans *= c
ans += zero
ans %= MOD
print((ans-1)%MOD)
"
"n,k=map(int,input().split())
l=list(map(int,input().split()))

for i in range(k,n):
  if l[i] > l[i-k]:
    print('Yes')
  else:
    print('No')
"
"def main():
    N, T = (int(i) for i in input().split())
    A = [int(i) for i in input().split()]
    ans = 0
    for i in range(N-1):
        ans += min(A[i+1] - A[i], T)
    ans += T
    print(ans)


if __name__ == '__main__':
    main()
"
"n=int(input())
a=sorted(list(map(int,input().split())))
now=a[0]
ans=1
for i in range(1,n):
    if now*2>=a[i]:
        ans+=1
    else:
        ans=1
    now+=a[i]
print(ans)"
"import sys

sys.setrecursionlimit(10 ** 6)
INF = float(""inf"")
MOD = 10 ** 9 + 7


def input():
    return sys.stdin.readline().strip()


def main():
    H, W, D = map(int, input().split())
    A = []
    for _ in range(H):
        a = list(map(int, input().split()))
        A.append(a)

    place = {}
    for h in range(H):
        for w in range(W):
            place[A[h][w]] = (h, w)

    diff = dict()
    for d in range(1, D + 1):
        cumsum = [0]
        ds = list(range(d, H * W + 1, D))
        N = len(ds)
        for i in range(N - 1):
            x, y = place[ds[i]]
            X, Y = place[ds[i + 1]]
            tmp = cumsum[-1] + abs(x - X) + abs(y - Y)
            cumsum.append(tmp)
        diff[d % D] = cumsum

    Q = int(input())
    ans = []
    for _ in range(Q):
        L, R = map(int, input().split())
        m = L % D
        if m == 0:
            L_idx = L // D - 1
            R_idx = R // D - 1
        else:
            L_idx = L // D
            R_idx = R // D
        a = diff[m][R_idx] - diff[m][L_idx]
        ans.append(a)

    for a in ans:
        print(a)


if __name__ == ""__main__"":
    main()
"
"#


def main():
    array = [1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51]
    k = int(input())
    print(array[k - 1])


if __name__ == '__main__':
    main()
"
"#ABC043C
n=int(input())
a = list(map(int, input().split()))
h=round(sum(a)/len(a))
sum_a=0
for i in range(len(a)):
    sum_a=sum_a+(a[i]-h)**2
print(int(sum_a))"
"N,K=map(int,input().split())

ans=[K]

for i in range(1,N):
    ans.append(K-i)
    ans.append(K+i)

ans.sort()


print(*ans)
"
"def bubbleSort():
    l = int(input())
    A = list(map(int, input().split("" "")))
    count = 0
    for i in range(l-1):
        for j in range(l-1-i):
            if (A[j]>A[j+1]):
                temp = A[j]
                A[j] = A[j+1]
                A[j+1] = temp
                count += 1
    print("" "".join(map(str, A)))
    print(count)

bubbleSort()"
"s = input()
s = s.replace(""BC"", ""X"")
cnt, ans = 0, 0
for i in s:
    if i == ""A"":
        cnt += 1
    elif i == ""X"":
        ans += cnt
    else:
        cnt = 0
print(ans)"
"S=input()
K=int(input())
N=len(S)
s=set()
for i in range(N):
    for j in range(i+1,min(i+K+1,N+1)):
        s|={S[i:j]}
A=list(s)
A.sort()
print(A[K-1])
"
"n=int(input())

t=0
h=0

for i in range(n):
    T,H=map(str,input().split())
    
    if T>H:
        t+=3
    elif T<H:
        h+=3
    else:
        t+=1
        h+=1
        
print(t,h)
"
"def actual(A, op, B):
    if op == '+':
        return A + B

    return A - B

A, op, B = input().split()
A, B = int(A), int(B)

print(actual(A, op, B))"
"n = input().split()
a = n[0]
b = n[1]
c = n[2]
if a[-1] == b[0] and b[-1] == c[0]:
  print('YES')
else:
  print('NO')"
"s = input()
t = input()
u = 0

if s == t:
  print(0)
else:
  for i in range(len(s)):
    if s[i] != t[i]:
      u += 1
  print(u)
"
"a, b = map(int, input().split())
af = 1
cnt = 0
while af < b:
    af += (a-1)
    cnt += 1
    if af >= b:
        break
print(cnt)
"
"s = input().split()

a = int(s[0])
b = int(s[2])

if s[1] == '+':
    print(a + b)
else:
    print(a - b)"
"#!/usr/bin/env python3
s = list(str(input()))

n = len(s)+1


from_left = [0 for _ in range(n)]
from_right = [0 for _ in range(n)]

for i, sym in enumerate(s, 1):
    if sym == "">"":
        from_left[i] = 0
    else:
        from_left[i] = from_left[i-1]+1

for i, sym in enumerate(s[::-1]):
    i = n-2-i
    if sym == ""<"":
        from_right[i] = 0
    else:
        from_right[i] = from_right[i+1]+1

seq = [max(x, y) for x, y in zip(from_left, from_right)]

print(sum(seq))
"
"def main():
    k, a, b = map(int, input().split())
    x = k+1
    y = 0
    if b > a:
        c = b-a
        k -= a-1
        y = c*(k//2-1) + b + (k%2)
    print(max(x, y))

if __name__ == ""__main__"":
    main()"
"def main():
    n, m = map(int, input().split())
    ans = []
    t = [True]*(n+1)
    l = n//2 - 1
    for i in range(1, n//2):
        if l <= 0:
            break
        if not t[i] or not t[i+l]:
            continue
        ans.append([i, i+l])
        t[i] = False
        t[i+l] = False
        l -= 2
    if n % 2 == 1:
        l = n//2
        for i in range(n//2, n):
            if l <= 0:
                break
            if not t[i] or not t[i+l]:
                continue
            ans.append([i, i+l])
            t[i] = False
            t[i+l] = False
            l -= 2
    else:
        l = n//2 - 2
        for i in range(n//2, n):
            if l <= 0:
                break
            if not t[i] or not t[i+l]:
                continue
            ans.append([i, i+l])
            t[i] = False
            t[i+l] = False
            l -= 2
    for i in range(m):
        print(ans[i][0], ans[i][1])

if __name__ == ""__main__"":
    main()
"
"import sys

N, A, B = map(int, sys.stdin.readline().strip().split())

H = []
for _ in range(N):
    H.append(int(sys.stdin.readline().strip()))
H.sort()

# 二分探索でmid回の攻撃で魔物を消し去れるか
left = 1
right = 10**9

# うまくいかないのでansを保持しておく
ans = right
while left < right:
    mid = (left + right) // 2
    # print(mid)
    n = mid
    for h_i in H:
        if h_i <= B * mid:
            continue

        # Bの攻撃のみで消し去れない場合はAの攻撃を消費する
        h_i -= B * mid
        n -= (h_i - 1) // (A-B) + 1

    if n >= 0:
        ans = min(ans, mid)
    if n == 0:
        break
    elif n > 0:
        right = mid
    else:
        left = mid + 1

print(ans)"
"n, a, b = map(int, input().split())

# A B -> A
# AB -> B
# AB -> B
# B A -> A
# A  B -> B
# A B  -> A
# A B -> A
#  AB -> B
# A   B -> A
# A  B -> B
# A  B  ->

diff = b - a
if diff % 2 == 0:
    print(""Alice"")
else:
    print(""Borys"")
"
"n = int(input())
k = int(input())
X = [int(i) for i in input().split()]

ans = 0
for x in X:
    dis_a = x
    dis_b = abs(k - x)
    ans += min(dis_a, dis_b) * 2
print(ans)"
"import heapq

N,M=map(int,input().split())

L=[[]    for i in range(3*N)]

for i in range(M):
  u,v=map(int,input().split())
  u,v=u-1,v-1
  L[u].append(N+v)
  L[N+u].append(2*N+v)
  L[2*N+u].append(v)

S,T=map(int,input().split())

D=[10**6 for i in range(3*N)]
D[~-S]=0
A=[(0,~-S)]
heapq.heapify(A)

while len(A)>0:
  d,v=heapq.heappop(A)
  if D[v]<d:
    continue
  for i in L[v]:
    if D[i]>D[v]+1:
      D[i]=D[v]+1
      heapq.heappush(A,(D[v]+1, i))

print(D[~-T]//3 if D[~-T]!=10**6 else -1)
"
"import sys
from collections import deque
input = sys.stdin.readline
def RD(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]

def main():
    N, Q = MI()
    #木
    tree = [[] for i in range(N)]
    for i in range(N-1):
        a,b = MI()
        tree[a-1].append(b-1)
        tree[b-1].append(a-1)
    #カウンター保存用、初期化
    counter = [0]* N
    score = [0]* N
    dq = deque()
    dq.append([0,-1])
    for i in range(Q):
        p, x = MI()
        counter[p-1] += x
    score[0] = counter[0]
    #score[tree[0][0]] = counter[tree[0][0]]
    while dq:
        temp, past = dq.pop()
        for num in tree[temp]:
            if num != past:
                score[num] = score[temp]+counter[num]
                dq.append([num,temp])
    score = [str(i) for i in score]
    print("" "".join(score))
    return None

if __name__ == ""__main__"":
    main()"
"n = int(input())
sum = 1
flag = 1
limit = 1000000000000000000
nums = list(map(int, input().split()))
for num in nums:
  if num == 0:
    sum = 0
    break;
  if flag == 1:
    sum *= num
  if sum > limit or sum == -1:
    flag = 2
    sum = -1
print(sum)"
"h, w, k = map(int, input().split())
for r in range(h + 1):
    for c in range(w + 1):
        s = (h - r) * c + r * (w - c)
        if s == k:
            print('Yes')
            exit()
print('No')
"
"n = int(input())
al = list(map(int, input().split()))
al.sort()

if n==2:
    print(al[1]-al[0])
    print(al[1],al[0])
    exit()

res = []
neg = []
pos = []
for a in al:
    if a>=0:
        pos.append(a)
    else:
        neg.append(a)

if len(pos)==0:
    res.append((neg[-1],neg[-2]))
    pos.append(neg[-1]-neg[-2])
    neg = neg[:-2]
if len(neg)==0:
    res.append((pos[0],pos[1]))
    neg.append(pos[0]-pos[1])
    pos = pos[2:]


# len(pos)>0 and len(neg)>0
n = neg[0]
for i in range(1,len(pos)):
    res.append((n,pos[i]))
    n = n - pos[i]
p = pos[0]
for i in range(1,len(neg)):
    res.append((p,neg[i]))
    p = p - neg[i]
res.append((p,n))
print(p-n)
for x,y in res:
    print(x,y)"
"N = int(input())
P = [int(input()) for _ in range(N)]

V = [-1] * (N+1)
for i in range(N):
    V[P[i]] = i+1
# print(V)

c = 0
ans = 0
for i in range(1, N+1):
    if V[i-1] > V[i]:
        c = 1
    else:
        c += 1
    ans = max(c, ans)

print(N-ans)
"
"import sys
import math
import bisect

def main():
    n, m = map(int, input().split())
    if m == n:
        print('Yes')
    else:
        print('No')

if __name__ == ""__main__"":
    main()
"
"from collections import Counter
w = input()
c = Counter(w)
li = set(list(w))
for i in li:
    if int(c[i]) % 2 != 0:
        print(""No"")
        exit()
print(""Yes"")"
"S = input()
X, Y = map(int, input().split())

SIZE = 10 ** 4

M = [0] if S[0] == ""T"" else []
for i in range(1, len(S)):
  if S[i] != S[i-1]:
    M.append(i)
M.append(len(S))
M = [0] + M
#print(""M:"", M)

L = []
for i in range(1, len(M)):
  L.append(M[i] - M[i - 1])
#print(""L:"", L)

for i in range(3, len(L), 2):
  L[i] += L[i - 2]
L = [0] + L
#print(""L:"", L)

x = 1 << SIZE
y = 1 << SIZE
#print(""x:"", bin(x)[2::])
#print(""y:"", bin(y)[2::])

for i in range(1, len(L), 2):
  dist = L[i]
  dirc = L[i - 1]
  #print(""dist, dirc:"", dist, dirc)
  if i == 1:
    x = x << dist
  else:
    if dirc % 2 == 0:
      x = (x << dist) | (x >> dist)
    else:
      y = (y << dist) | (y >> dist)
      
if (x >> SIZE + X) & 1 == 1 and (y >> SIZE + Y) & 1 == 1:
  print(""Yes"")
else:
  print(""No"")"
"import sys

x, a, b = map(int, sys.stdin.readline().split())

def main():
    d = -a + b
    if d <= 0: ans = 'delicious'
    elif d <= x: ans = 'safe'
    else: ans = 'dangerous'
    print(ans)

if __name__ ==  '__main__':
    main()"
"X, Y = map(int, input().split())

cnt = 0
i = X
while i <= Y:
  cnt += 1
  i *= 2
  
print(cnt)"
"import bisect,collections,copy,heapq,itertools,math,numpy,string
import sys
sys.setrecursionlimit(10**7)

def S(): return sys.stdin.readline().rstrip()
def I(): return int(sys.stdin.readline().rstrip())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LS(): return list(sys.stdin.readline().rstrip().split())

def main():
    A = I()
    B = I()
    print(6-(A+B))

main()

"
"op=[""+"",""-""]
a,b,c,d=map(str,input())

for o1 in op:
  for o2 in op:
    for o3 in op:
      form= a+o1+b+o2+c+o3+d
      if eval(form)==7:
        print(form+""=7"")
        exit()"
"[N,M] = list(map(int,input().split()))
S = list(map(int,input().split()))
T = list(map(int,input().split()))

ta = [[0] * (M+1) for i in range(N+1)]
ta[0][0]=1
wa = [[0] * (M+1) for i in range(N+1)]
wa[0][:]=[1]*(M+1)
for i in range(N+1):
    wa[i][0]=1
output = 1
for i in range(1,N+1):
    for j in range(1,M+1):
        if S[i-1]==T[j-1]:
            ta[i][j]=wa[i-1][j-1]
            wa[i][j]=(wa[i-1][j]+wa[i][j-1])%(10**9+7)
        else:
            wa[i][j]=(wa[i-1][j]+wa[i][j-1]-wa[i-1][j-1]+(10**9+7))%(10**9+7)
output = wa[N][M]
print(int(output))"
"import itertools

n,c=map(int,input().split())
dp=[[0]*100002 for i in range(c)]

for i in range(n):
    s,t,x=map(int,input().split())
    dp[x-1][s-1]+=1
    dp[x-1][t]-=1

for i in range(c):
    dp[i]=list(itertools.accumulate(dp[i]))


ans=0

for i in range(100001):
    cnt=0
    for j in range(c):
        if dp[j][i]!=0:
            cnt+=1
    
    ans=max(ans,cnt)


print(ans)"
"import math
while True:
  try:
    a,b=map(int,input().split())
    def lcm(x,y):
      return (x*y)//math.gcd(x,y)
    print(math.gcd(a,b),lcm(a,b))
  except:
    break
"
"H,W=map(int, input().split())
M=[list(input()) for _ in range(H)]

used=[[False for _ in range(W)] for __ in range(H)]
def dfs(sx,sy):
    global used
    if used[sy][sx]: return (0,0)
    black=white=0
    stack=[(sx,sy)]
    used[sy][sx]=True
    while stack:
        x,y=stack.pop()
        if M[y][x]=='#':
            black+=1
        else:
            white+=1
        for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            nx,ny=x+dx,y+dy
            if 0<=nx<W and 0<=ny<H and not used[ny][nx]:
                if M[y][x]!=M[ny][nx]:
                    stack.append((nx,ny))
                    used[ny][nx]=True
    return (black,white)

ans=0
for y in range(H):
    for x in range(W):
        black,white=dfs(x,y)
        ans+=black*white
print(ans)
"
"n, m = map(int, input().split())
ab = [[] for _ in range(m+1)]
for i in range(n):
  t = [int(inp) for inp in input().split()]
  if t[0] <= m:
    ab[t[0]].append(-t[1])
ans = 0
import heapq
h = ab[1]
heapq.heapify(h)
for i in range(1, m+1):
  if len(h) > 0:
    ans += heapq.heappop(h)
  if i != m:
    for t in ab[i+1]:
      heapq.heappush(h, t)
print(-ans)"
"N = int(input())
A = list(map(int, input().split()))

A.sort(reverse=True)
ans = 0
tmp = 0
j = 0
for i in range(len(A)-1):
    if i == 0:
        ans += A[0]
        j += 1
    elif i % 2 == 0:
        ans += tmp
    else:
        tmp = A[j]
        ans+=tmp
        j += 1
print(ans)"
"import sys
from collections import defaultdict
input = sys.stdin.readline
H, W, N = map(int, input().split())

board = defaultdict(int)
black = []
for _ in range(N):
    a, b = map(int, input().split())
    black.append((a - 1, b - 1))
    board[(a-1) * W + (b - 1)] = 1

num = [0] * 10
for p in black:
    for ch in range(max(p[0] - 1, 1), min(p[0] + 2, H - 1)):
        for cw in range(max(p[1] - 1, 1), min(p[1] + 2, W - 1)):
            count = 0
            for h in range(ch - 1, ch + 2):
                for w in range(cw - 1, cw + 2):
                    if board[h * W + w] == 1:
                        count += 1
            num[count] += 1
for i in range(1, 10):
    num[i] //= i
print((H - 2) * (W - 2) - sum(num))
for i in range(1, 10):
    print(num[i])
"
"MOD = 10**9+7

N, M=map(int,input().split())
S=list(map(int,input().split()))
T=list(map(int,input().split()))

dp=[[1]*(M+1) for i in range(N+1)]
S_index=[[] for i in range(10**5+1)]

for i in range(N):
  S_index[S[i]].append(i)
  if len(S_index[S[i]])>=2:
    ikkomae=S_index[S[i]][-2]
    for j in range(M+1):
    	dp[i-1][j]=(dp[i-1][j]+dp[ikkomae-1][j])%MOD
  for j in range(M):
    dp[i][j]=dp[i][j-1]
    if len(S_index[T[j]])>=1:
    	dp[i][j]=(dp[i][j]+dp[S_index[T[j]][-1]-1][j-1])%MOD
      
print(dp[N-1][M-1])
"
"import sys,queue,math,copy,itertools,bisect,collections,heapq
MOD = 10**9 + 7
LI = lambda : [int(x) for x in sys.stdin.readline().split()]

H,W,K = LI()

if W == 1:
    print(1)
    exit(0)

dp = [[0] * W for _ in range(H+1)]
dp[0][0] = 1

good = []
for ami in range(2**(W-1)-1):
    b = 1
    m = -2
    for i in range(W-1):
        if b & ami:
            if i <= m + 1:
                break
            m = i
        b <<= 1
    else:
        s = []
        b = 1
        for i in range(W):
            s.append(ami & b > 0)
            b <<= 1
        good.append([0] + s + [0])

for i in range(H):
    for ami in good:
        for j in range(W):
            if ami[j] == 0 and ami[j+1] == 0:
                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD
            elif ami[j] == 1:
                dp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j]) % MOD
            else:
                dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD

print(dp[-1][K-1])"
"N, M = map(int, input().split())
a = [0] * M
b = [0] * M
list = []
for i in range(M):
  a[i], b[i] = map(int, input().split())
for i in range(M):
  if a[i] == 1:
    list.append(b[i])
  elif b[i] == N:
    list.append(a[i])
list = sorted(list)
ans = 'IMPOSSIBLE'
for i in range(len(list)-1):
  if list[i] == list[i+1]:
    ans = 'POSSIBLE'
    break
print(ans)"
"N = int(input())
S = list(map(int,input().split()))

sp = [400,800,1200,1600,2000,2400,2800,3200]
rank = [""gray"",""brown"",""green"",""cyan"",""blue"",""yellow"",""orange"",""red"",""highest""]
cnt = [0]*len(rank)

import bisect as b

for score in S:
  cnt[b.bisect(sp,score)] += 1
  
mid = sum([1 for n in cnt[:-1] if n > 0])
t = cnt[-1]
max_amt = mid + t
min_amt = mid
if t > 0:
  min_amt = max(mid,1)
print(min_amt,max_amt)
#print(cnt)"
"H = int(input())
 
# 体力がHのモンスター1体に勝つために必要な攻撃回数をf(H)とする
# すると、f(H)は以下の漸化式に従って求まる
# f(H)=2*f(floor(H/2)+1) (H>1)
# f(H)=1 (H=1)

# 漸化式の実装はAtCoderで珍しい。パターンとして覚えよ！
def attack_num(x):
  if x == 1: return 1
  else: return 2*attack_num(x // 2) + 1
  
print(attack_num(H))"
"import sys
H,W=map(int,input().split())
L = [[0 for j in range(W)] for i in range(H)]
c=0
for i in range(H):
  a=list(input())
  c+=a.count(""."")
  L[i]=a
#幅優先探索？
subete=[[0,0]]
ans = [[] for i in range(H*W+1)]
ans[0].append([0,0])
for i in range(H*W+1):
  for j in range(len(ans[i-1])):
    a,b=ans[i-1][j][0],ans[i-1][j][1]
    if a+1!=H:
      if [a+1,b] not in subete and L[a+1][b]==""."":
        ans[i].append([a+1,b])
        subete.append([a+1,b])
    if a!=0:
      if [a-1,b] not in subete and L[a-1][b]==""."":
        ans[i].append([a-1,b])
        subete.append([a-1,b])
    if b+1!=W:
      if [a,b+1] not in subete and L[a][b+1]==""."":
        ans[i].append([a,b+1])
        subete.append([a,b+1])
    if b!=0:
      if [a,b-1] not in subete and L[a][b-1]==""."":
        ans[i].append([a,b-1])
        subete.append([a,b-1])
  if [H-1,W-1] in subete:
    print(c-i-1)
    sys.exit()
print(-1)"
"import bisect
n = int(input())
ans = [-1*int(input())]
for i in range(n-1):
  a=int(input())
  a=-1*a
  if ans[-1]<=a:
    ans.append(a)
  else:
    b = bisect.bisect_right(ans,a)
    ans[b]=a
print(len(ans))"
"import sys
from math import gcd
sys.setrecursionlimit(10**7)
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #空白あり
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #空白なし
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())  #空白あり
def LS2(): return list(sys.stdin.readline().rstrip())  #空白なし


N,M = MI()
A = LI()

x = sum(a % 2 == 0 for a in A)
if x != N:
    print(0)
    exit()

r = 0
while A[0] % 2 == 0:
    r += 1
    A[0] //= 2
for i in range(1,N):
    if A[i] % (2**r) != 0 or (A[i]//(2**r)) % 2 == 0:
        print(0)
        exit()
    else:
        A[i] //= 2**r

lcm = A[0]
for i in range(1,N):
    lcm = (lcm*A[i])//gcd(lcm,A[i])

a = (lcm*2**r)//2
print(((M//a)+1)//2)
"
"from itertools import accumulate
import bisect

n, c = [int(item) for item in input().split()]

xs, vs, xrs = [], [], []
for i in range(n):
  x, v = [int(item) for item in input().split()]
  xs.append(x)
  xrs.append(c-x)
  vs.append(v)
xrs = xrs[::-1]

lft_v = list(accumulate(vs))
rgt_v = list(accumulate(vs[::-1]))

lft_c = []
rgt_c = []
for i in range(n):
  lft_c.append(lft_v[i]-xs[i])
  rgt_c.append(rgt_v[i]-xrs[i])
  
lft_max = [0] * n
rgt_max = [0] * n
lm, rm = 0,0
for i in range(n):
  if lm < lft_c[i]:
    lm = lft_c[i]
  lft_max[i] = lm
  if rm < rgt_c[i]:
    rm = rgt_c[i]
  rgt_max[i] = rm

ans = 0
# No return
for i in range(n):
  ans = max(ans, lft_c[i], rgt_c[i])
  
# Includes return
for i in range(n-1):
  ans = max(ans, lft_c[i] - xs[i] + rgt_max[n-2-i])
  ans = max(ans, rgt_c[i] - xrs[i] + lft_max[n-2-i])
    
print(ans)"
"n = int(input())
a = 0
ans = 0
for i in range(n):
    k = int(input())
    a = max(a, k)
    ans += k

ans -= a // 2

print(ans)"
"#ABC047A https://atcoder.jp/contests/abc047/tasks/abc047_a

a,b,c=(int(x) for x in input().split())

max=a
o1=b
o2=c

if b>max:
    max=b
    o1=a

if c>max:
    max=c
    o2=b

if max==(o1+o2):
    print(""Yes"")
else:
    print(""No"")

"
"def abc158d_string_formation():
    from collections import deque
    s = deque(list(input()))
    q = int(input())
    flip = 0
    for _ in range(q):
        query = list(input().split())
        if query[0] == '1':
            flip = 1-flip
        elif query[1] == '1':
            if flip == 0:
                s.appendleft(query[2])
            else:
                s.append(query[2])
        else:
            if flip == 0:
                s.append(query[2])
            else:
                s.appendleft(query[2])
    if flip == 1:
        s = ''.join(reversed(s))
    else:
        s = ''.join(s)
    print(s)
abc158d_string_formation()"
"N,M = map(int,input().split())
H = list(map(int, input().split()))
AB = [list(map(int,input().split()))for i in range(M)]
good = [True]*N
for i in range(M):
        a,b = AB[i]
        if H[a-1] > H[b-1]:
            good[b-1] = False
        elif H[a - 1] < H[b - 1]:
            good[a - 1] = False
        else:
            good[a - 1] = False
            good[b - 1] = False
#print(good)
print(good.count(True))"
"import sys , math

N,K=list(map(int, input().split()))
Ws=list(map(int, input().split()))
Ws.sort(reverse=True)

l=0
r=10**9

def check (m):
    now=0
    for i in range(N):
        now += (Ws[i] - 1) // m
    return now <= K

while r - l > 1:
    m = ( l + r ) // 2

    if check(m):
        r = m
    else:
        l = m
print(r) "
"n,m,k=map(int,input().split())
for i in range(n+1):
    for j in range(m+1):
        if i*(m-j)+(n-i)*j==k:
            break
    else:
        continue
    break
else:
    print('No')
    exit()
print('Yes')"
"from fractions import gcd
from datetime import date, timedelta
from heapq import*
import math
from collections import defaultdict, Counter, deque
import sys
from bisect import *
import itertools
import copy
sys.setrecursionlimit(10 ** 7)
MOD = 10 ** 9 + 7


def main():
    n = int(input())
    xy = [list(map(int, input().split())) for i in range(n)]
    
    d = defaultdict(int)
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            aaa = xy[i][0] - xy[j][0]
            bbb = xy[i][1] - xy[j][1]
            d[(aaa,bbb)]+=1
            
    t = 0
    for v in d.values():
        t = max(v , t)
    print(n - t)

    






    


if __name__ == '__main__':
    main()
"
"# Problem:https://atcoder.jp/contests/agc012/tasks/agc012_a
# Python 2nd Try

import sys
# from collections import defaultdict
# import heapq,copy
# from collections import deque


def II(): return int(sys.stdin.readline())


def MI(): return map(int, sys.stdin.readline().split())


def LI(): return list(map(int, sys.stdin.readline().split()))


def LLI(rows_number): return [LI() for _ in range(rows_number)]


def solver(groupNumber, scoreList):
    allMenbar = 3 * groupNumber
    scoreList.sort()
#    print(scoreList)
    secondPositioner = scoreList[groupNumber:allMenbar:+2]
#    print(secondPositioner)
    result = sum(secondPositioner)
    # algorithm
    return result


if __name__ == ""__main__"":
    N = II()
    AI = LI()
    print(""{}"".format(solver(N, AI)))
"
"S, W = [int(v) for v in input().split()]

print(""unsafe"" if W >= S else ""safe"")"
"# -*- coding: utf-8 -*-
while True:
    try:
        list = [int(x) for x in raw_input().split("" "")]
        list.sort(lambda x, y: y - x)
        gcd = lcm = 0
        m = list[0]
        n = list[1]
        while True:
            r = m%n
            if r == 0:
                gcd = n
                break
            m = n
            n = r
        lcm = list[0] * list[1] / gcd
        print(str(gcd) + "" "" + str(lcm))
    except EOFError:
        break"
"a,b,c = map (int, input ().split ())
x = round (a*b/2)
print (x)"
"A,B = map(int,input().split())
if B == 1:
    print(0)
elif B <= A:
    print(1)
else:
    ans = 1+int((B-A)/(A-1))
    if (B-A)%(A-1):
        ans += 1
    print(ans)"
"import math


c=input()

if c in ""aiueo"":
    print(""vowel"")
else:
    print(""consonant"")
"
"import sys
from heapq import heappush, heappop


N, Q = map(int, input().split())
P = []
for i in range(1, N + 1):
    s, t, x = map(int, sys.stdin.readline().split())
    P.append((s - x, t - 1 - x, x))
P.sort()


q = []
cur = 0
ans = [-1] * Q
for i, d in enumerate(map(int, sys.stdin)):
    while cur < N and P[cur][0] <= d:
        s, t, x = P[cur]
        heappush(q, (x, t))
        cur += 1
    while q and q[0][1] < d:
        heappop(q)
    if q:
        ans[i] = q[0][0]

print(*ans, sep='\n')"
"# input
N = int(input())
A = [list(map(int, input().split())) for i in range(2)]

# check
element = set(A[0] + A[1])
if len(element) == 1:
    print(list(element)[0] * (N + 1))
else:
    res = 0
    for d in range(N):
        if d == 0:
            sum_num = A[0][0] + sum(A[1])
        elif d == N - 1:
            sum_num = sum(A[0]) + A[1][N - 1]
        else:
            sum_num = sum(A[0][:d + 1]) + sum(A[1][d:])
        if res < sum_num:
            res = sum_num
    print(res)"
"N,*A = map(int,open(0).read().split())

m =1
ans = 0
#for a in A:
#  m *=a
#m-=1
#
#for a in A:
#  ans+=m%a
#  pass
#print(ans)

for a in A:
  ans += a-1
print(ans)"
"H, W = map(int, input().split())
A = [list(input()) for _ in range(H)]

# 一段目
print(""#""*(W+2))
for a in A:
    print(""#"" + """".join(a) + ""#"")
# 最終段
print(""#""*(W+2))
"
"#!/usr/bin/env python3

N, A, B = list(map(int, input().split()))
a_idx = A
b_idx = B
turn = ""A""
while True:
    # 判定
    if turn == ""A"":
        if a_idx == 1 and b_idx == a_idx + 1:
            winner = ""Borys""
            break
    else:
        if b_idx == N and a_idx == b_idx - 1:
            winner = ""Alice""
            break

    if turn == ""A"":
        if b_idx == a_idx + 1:
            a_idx -= 1
        else:
            a_idx += 1
        turn = ""B""
    else:
        if a_idx == b_idx - 1:
            b_idx += 1
        else:
            b_idx -= 1
        turn = ""A""

ans = winner
print(ans)
"
"def cum2D(a, H, W):
    cum = [[0]*(W+1) for _ in range(H+1)]
    for i in range(H):
        for j in range(W):
            cum[i+1][j+1] = cum[i][j+1] + cum[i+1][j] - cum[i][j] + a[i+1][j+1]
    return cum
    
n, m, q = map(int, input().split())
trains = [tuple(map(int, input().split())) for _ in range(m)]  #;print(trains)
a = [[0]*(n+1) for j in range(n+1)]
for k in range(m):
    start, stop = trains[k]
    a[start][stop] += 1
cum = cum2D(a, n, n)          #;print2D(a, n+1) ;print() ;print2D(cum, n+1)

for _ in range(q):
    p, q = map(int, input().split())
    print(cum[n][q] - cum[p-1][q])
   "
"from math import *
N,M = map(int,input().split())
print(max(0,2-abs(N-M))*factorial(N)*factorial(M)%(10**9+7))"
"n = int(input())
arr = list(map(int, input().split()))

c = 0
h = set([])

for i in range(n):
  for j in range(i+1,n):
    for k in range(j+1,n):
      t = [arr[i], arr[j],arr[k]]
      t.sort()
      if t[0] + t[1] > t[2]:
        if t[0]!=t[1]!=t[2]:#if (i,j,k) not in h:
          h.add((i,j,k))
          c+=1
        
print(c)"
"import numpy as np
 
def main():
    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')
    A = stdin[1:]
    A = np.mod(A, 2)
    print(""first"") if np.count_nonzero(A) else print(""second"")
if __name__ == ""__main__"":
    main()
"
"INF = 10**9 + 7


def main():
    import sys
    input = sys.stdin.buffer.readline
    N, M = (int(i) for i in input().split())
    A = []
    B = []
    C = []
    for _ in range(M):
        a, b = (int(i) for i in input().split())
        A.append(a)
        B.append(b)
        bit = 0
        for s in input().split():
            c = int(s)
            bit |= (1 << (c-1))
        C.append(bit)

    dp = [[INF]*(1 << N) for _ in range(M+1)]
    dp[0][0] = 0
    for i in range(M):
        for j in range(1 << N):
            dp[i+1][j] = min(dp[i+1][j], dp[i][j])
            if dp[i][j] != INF:
                next_bit = j | C[i]
                dp[i][next_bit] = min(dp[i][next_bit], dp[i][j] + A[i])
    ans = dp[M][(1 << N) - 1]
    if ans == INF:
        print(-1)
    else:
        print(ans)


if __name__ == '__main__':
    main()
"
"N = int(input())
prefs = []
for i in range(N):
    a, b = map(int, input().split())
    prefs.append((a + b, a, b))
prefs.sort(reverse=True)
ans = 0
for i, (p, a, b) in enumerate(prefs):
    if i % 2:
        ans -= b
    else:
        ans += a
print(ans)
"
"H, W = map(int, input().split())
if H == 1 or W == 1:
    ans = 1
elif (H * W) % 2 == 0:
    ans = (H * W) // 2
else:
    ans = (H * W) // 2 + 1
print (ans)"
"#左右それぞれで一番近い神社
#その神社それぞれの左右それぞれで一番近い寺
#はい２ぶたん

INF = 10**12

from bisect import bisect_right
 
A,B,Q = map(int,input().split())
s = [int(input()) for i in range(A)]
t = [int(input()) for i in range(B)]
ans =[]
for i in range(0,Q,1):
    tmpans = INF

    q = int(input())
    sr = bisect_right(s,q)
    sl = sr-1
    sr = min(sr,A-1)
    sl = max(0,sl)
    for j in (sr,sl):
        tr = bisect_right(t,s[j])
        tl = tr-1
        tr = min(tr,B-1)
        tl = max(0,tl)
        ansR=abs(s[j]-q)+abs(s[j]-t[tr])
        ansL=abs(s[j]-q)+abs(s[j]-t[tl])
        tmpans = min(tmpans,ansR,ansL)

    
    tr = bisect_right(t,q)
    tl = tr-1
    tr = min(tr,B-1)
    tl = max(0,tl)
    for j in (tr,tl):
        sr = bisect_right(s,t[j])
        sl = sr-1
        sr = min(sr,A-1)
        sl = max(0,sl)
        ansR=abs(t[j]-q)+abs(t[j]-s[sr])
        ansL=abs(t[j]-q)+abs(t[j]-s[sl])
        tmpans = min(tmpans,ansR,ansL)
    
    ans.append(tmpans)

for i in range(0,Q,1):
    print(ans[i])"
"l=[]
l.append(int(input()))
l.append(int(input()))
for i in range(1, 4):
  if i not in l: print(i)"
"H, W = map(int, input().split())
h, w = map(int, input().split())
result = (H - h) * (W - w)
print(result)
"
"a, b, c = map(int, input().split())
if a < c < b or a > c > b:
  print(""Yes"")
else:
  print(""No"")"
"n = int(input())
l = str(n)
print(l.count(""2""))"
"# -*- coding=utf-8 -*-
import itertools

count = int(input())
_list = list(map(int, input().split("" "")))

count2 = int(input())
_answers = list(map(int, input().split("" "")))

desc = []
checked = False

# answersの数だけloopして取ってくる
for answer in _answers:
    checked = False
    tmp = [i for i in _list if answer >= i]

    # そもそもtmpの中身をsumしてanswer未満ならば強制的にno
    if answer > sum(tmp):
        desc.append(""no"")

    # itertoolsのコンビネーションを使用して解く
    else:
        for i in range(len(tmp) + 1):
            if checked == True:
                break

            tmp2 = list(itertools.combinations(tmp, i))
            for tmp3 in tmp2:
                if sum(tmp3) == answer:
                    desc.append(""yes"")
                    checked = True
                    break

        if checked != True:
            desc.append(""no"")

for i in desc:
    print(i)

"
"n=int(input())

bp = [0] * (n+10)
for i in range(2, n+10):
    if bp[i] == 0:
        bp[i] = i
        for j in range(i*i, n+1, i):
            bp[j] = i


def fact(n):
    ret=1
    while n>1:
        now=n
        cnt=0
        p=bp[now]
        while now % p == 0:
            now//=p
            cnt+=1
        ret*=cnt+1
        n=now
    return ret
ans=0
for i in range(1,n+1):
    ans += i*fact(i)

print(ans)"
"import sys
import math
from collections import deque
from collections import Counter

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()


def main():
    H, W, N = NMI()
    grid = {}
    for i in range(N):
        a, b = NMI()
        for t in range(-2, 1):
            for k in range(-2, 1):
                if a + t < 1 or b + k < 1:
                    continue
                if a + t >= H - 1 or b + k >= W - 1:
                    continue
                point = (a+t) * 10**10 + b+k
                grid[point] = grid.get(point, 0) + 1
    c = Counter(grid.values())
    for i in range(10):
        if i == 0:
            print((H-2)*(W-2) - sum(c.values()))
        else:
            print(c.get(i, 0))


if __name__ == ""__main__"":
    main()"
"# coding: utf-8
import sys
#from operator import itemgetter
sysread = sys.stdin.buffer.readline
read = sys.stdin.buffer.read
from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
#from itertools import product, accumulate, combinations, product
#import bisect# lower_bound etc
#import numpy as np
#from copy import deepcopy
#from collections import deque

def run():
    N = int(input())
    if N % 2:
        print(0)
    else:
        ans = 0
        div = 10
        while True:
            val = N // div
            ans += val
            if not val:break
            div *= 5
        print(ans)

if __name__ == ""__main__"":
    run()"
"tmp = input().split()
ans = int(tmp[0]) * int(tmp[1])
print(ans)"
"n = int(input())
ans = []
for i in range(1, n):
    for j in range(i+1, n+1):
        if i+j==n//2*2+1:
            continue
        ans.append((i, j))
print(len(ans))
for i in ans:
    print(*i)"
"n,m=map(int,input().split())
abc=[list(map(int,input().split())) for i in range(m)]

inf=float(""inf"")
data=[-inf]*(n+1)
data[1]=0
for i in range(n):
    for a,b,c in abc:
        if data[a]!=inf:
            data[b]=max(data[b],data[a]+c)

lst=data[:]
for i in range(n):
    for a,b,c in abc:
        if data[a]!=inf:
            data[b]=max(data[b],data[a]+c)

que=[]
for i in range(1,n+1):
    if lst[i]!=data[i]:
        que.append(i)
        
flag=[0]*(n+1)
for u in que:
    flag[u]=1

li=[[] for i in range(n+1)]
for a,b,c in abc:
    li[a].append(b)

while que:
    h=que.pop()
    for u in li[h]:
        if flag[u]==0:
            flag[u]=1
            que.append(u)

if flag[n]==1:
    print(""inf"")
else:
    print(data[n])"
"#!/usr/bin/env python3
s = input()
t = input()
n = len(t)
m = len(s)
c = ""z"" * m
for i in range(m - n + 1):
    if all(j in (t[k], ""?"") for k, j in enumerate(s[i:n + i])):
        c = min(c, s[:i] + t + s[i + n:])
print(""UNRESTORABLE"" if c == ""z"" * m else c.replace(""?"", ""a""))
"
"q, h, s, d = map(int, input().split())
n = int(input())
l = [4 * q, 2 * h, s, d / 2]
ans = 0
if n >= 2:
  a = l.index(min(l))
  if a == 0:
    ans = 4 * q * n
  elif a == 1:
    ans = 2 * h * n
  elif a == 2:
    ans = s * n
  elif a == 3:
    if n % 2 == 0:
      ans = n // 2 * d
    elif n % 2 == 1:
      ans = n // 2 * d
      b = l.index(min(l[:3]))
      if b == 0:
        ans += 4 * q
      elif b == 1:
        ans += 2 * h
      elif b == 2:
        ans += s
else:
  b = l.index(min(l[:3]))
  if b == 0:
    ans = 4 * q * n
  elif b == 1:
    ans = 2 * h * n
  elif b == 2:
    ans = s * n
print(ans)
"
"import sys
def input(): return sys.stdin.readline().strip()


def main():
    A, B = map(int, input().split())
    if B % A == 0:
        print(A + B)
    else:
        print(B - A)

if __name__ == ""__main__"":
    main()
"
"H, W, A, B = map(int, input().split())
MAX = 200000
MOD = 1000000007
fac = [0]*MAX
finv = [0]*MAX
inv = [0]*MAX
fac[0] = 1
fac[1] = 1
finv[0] = 1
finv[1] = 1
inv[1] = 1
for i in range(2, MAX):
  fac[i] = fac[i-1]*i%MOD
  inv[i] = MOD - inv[MOD%i]*(MOD//i)%MOD
  finv[i] = finv[i-1]*inv[i]%MOD  
# sum_{i=B}^{W-1} C_{H-A-1+i}_{i}C_{A+W-i-2}_{A-1}
r = 0
for i in range(B, W):
  r += fac[H-A-1+i]*(finv[H-A-1]*finv[i]%MOD)%MOD * fac[A+W-i-2]*(finv[A-1]*finv[W-1-i]%MOD)%MOD
  r = r%MOD
print(r)
"
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools
from collections import deque

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

DR = [1, -1, 0, 0]
DC = [0, 0, 1, -1]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
     
def main():
    x = S()
    s_cnt = 0
    removed = 0
    for c in x:
        if c == 'S':
            s_cnt += 1
        if c == 'T':
            if s_cnt > 0:
                s_cnt -= 1
                removed += 2
    print(len(x) - removed)
main()

"
"a = 'CODEFESTIVAL2016'
b = input()
lista = list(a)
listb = list(b)
count = 0
for i in range(len(lista)):
  if lista[i]!=listb[i]:
    count+=1
print(count)"
"from collections import Counter
c = {""a"":0,""b"":0,""c"":0}
for si in input():
    c[si] += 1
if max(c.values()) - min(c.values()) <= 1:
    print(""YES"")
else:
    print(""NO"")"
"a,b,k=map(int,input().split())
i=0

aa=a
bb=b
if a>=1:
  a-=k
  k-=aa
if b>=1 and k>0:
  b-=k
  k-=bb

if a<0:
  a=0
if b<0:
  b=0
print(a,b)
"
"#!/usr/bin/env python
# -*- coding: utf-8 -*-
""""""
????????°?????????????´¢
""""""
s = input().strip()
p = input().strip()
ret = ""No""
for i in range(len(s)):
    if p in s:
        ret = ""Yes""
        break
    # ?????????????????????????????????????????????push pop??????????????£??????
    s = s[1:] + s[0] # ????????????????????°????????????????????????

print(ret)"
"# -*- coding: utf-8 -*-
import sys
import math
from bisect import bisect_left
from bisect import bisect_right
from collections import defaultdict
from heapq import heappop, heappush
import itertools
import random
from decimal import *

input = sys.stdin.readline

def inputInt(): return int(input())
def inputMap(): return map(int, input().split())
def inputList(): return list(map(int, input().split()))
def inputStr(): return input()[:-1]

inf = float('inf')
mod = 1000000007

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

def main():
	D = inputInt()
	C = inputList()
	S = []
	ans = []
	for i in range(D):
		s = inputList()
		S.append(s)

	for i in range(D):
		tmp = inputInt()
		ans.append(tmp)

	scezhu = [inf for i in range(26)]
	sco = 0
	for i,val in enumerate(ans):
		tmp = S[i][val-1]
		scezhu[val-1] = i
		mins = 0
		for j,vol in enumerate(C):
			if scezhu[j] == inf:
				mins = mins + (vol * (i+1))
				#if i == 1:
					#print(vol * (i+1))
			else:
				mins = mins + (vol * ((i+1)-(scezhu[j]+1)))
				#if i == 1:
					#print(scezhu[i]+1)
		#print(mins)
		tmp -= mins
		sco += tmp
		print(sco)

#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
if __name__ == ""__main__"":
	main()
"
"#k = int(input())
#s = input()
#a, b = map(int, input().split())
#s, t = map(str, input().split())
#l = list(map(int, input().split()))
#l = [list(map(int,input().split())) for i in range(n)]
#a = [list(input()) for _ in range(n)]
#a = [int(input()) for _ in range(n)]

n = int(input())
a = list(map(int, input().split()))

def func(a):
    rtn = 0
    while a % 2 == 0:
        a //= 2
        rtn+=1
    return rtn

for i in range(n):
    a[i] = func(a[i])
print(min(a))

"
"import math
def main():
	A, B = map(int,input().split())
	K = 50
	ans = [[""#"" if i < K else ""."" for _ in range(2*K)] for i in range(2*K)]
	num_w = 0
	num_b = 0
	for i in range(A-1):
		k = (i*2//(2*K))*2
		l = (i*2)%(2*K)
		ans[k][l] = "".""

	for i in range(B-1):
		k = (i*2//(2*K))*2
		l = (i*2)%(2*K)
		ans[K+1+k][l] = ""#""

	l1 = str(2*K) + "" "" + str(2*K)
	print(l1)
	for i in range(2*K):
		this_ans = """"
		for j in range(2*K):
			this_ans += ans[i][j]
		print(this_ans)


if __name__ == '__main__':
    main()"
"import math
def main():
    K = int(input())
    if K % 2 == 0:
        print(K**2//4)
    else:
        print(math.floor(K//2)*(math.floor(K//2)+1))
if __name__ == ""__main__"":
    main()"
"a=sorted(map(int,input().split()))
print(a[2]-a[0])"
"N,M = map(int,input().split())
AB = [tuple(map(int,input().split())) for i in range(N)]
CD = [tuple(map(int,input().split())) for i in range(M)]
for a,b in AB:
    best_i = -1
    best_d = 10**9
    for i,(c,d) in enumerate(CD):
        dist = abs(a-c) + abs(b-d)
        if dist < best_d:
            best_d = dist
            best_i = i
    print(best_i + 1)"
"a,b,c,d=map(int,input().split())
if a==c:
    print(min(b,d))
elif a<c:
    if b>d:
        print(d-c)
    else:
        print(max(0,b-c))
else:
    if b<d:
        print(b-a)
    else:
        print(max(0,d-a))"
"s=input()
n=len(s)
for i in reversed(range(n-1)):
    if i%2:
        l=s[:i//2+1]
        r=s[i//2+1:i+1]
        ok=True
        for j in range(i//2+1):
            if l[j]!=r[j]:
                ok=False
        if ok:
            print(i+1)
            exit()"
"H1,M1,H2,M2,K = map(int, input().split())

TIME = (H2-H1)*60
TIME = TIME+(M2-M1)

print(TIME-K)"
"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    R, C, K, *RCV = map(int, read().split())

    item = [[0] * C for _ in range(R)]
    for r, c, v in zip(*[iter(RCV)] * 3):
        item[r - 1][c - 1] = v

    dp = [0] * (C + 1)
    for i in range(R):
        value = [0] * 4
        for j in range(C):
            if value[0] < dp[j + 1]:
                value[0] = dp[j + 1]
            if item[i][j] > 0:
                for k in range(2, -1, -1):
                    if value[k + 1] < value[k] + item[i][j]:
                        value[k + 1] = value[k] + item[i][j]
            dp[j + 1] = max(value)

    print(dp[C])

    return


if __name__ == '__main__':
    main()
"
"#!/usr/bin/env python3
#AGC30 A

import sys
import math
from bisect import bisect_right as br
from bisect import bisect_left as bl
sys.setrecursionlimit(1000000000)
from heapq import heappush, heappop,heappushpop
from collections import defaultdict
from itertools import accumulate
from collections import Counter
from collections import deque
from operator import itemgetter
from itertools import permutations
mod = 10**9 + 7
inf = float('inf')
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))

a,b,c = LI()
print(min(b+c,b + min(c,(a+b))+1))
"
"S = input()

for i in range(1,6) :
    hita = ""hi"" * i
    if hita == S :
        print(""Yes"")
        exit()

print(""No"")
"
"x=[int(input()) for i in range(5)]
k=int(input())

if x[-1]-x[0]<=k:
  print(""Yay!"")
else:
  print("":("")"
"import sys
import math


def input():
    return sys.stdin.readline().rstrip()


def main():
    S = list(input())

    count1 = 0
    count2 =0
    b =""1""
    w =""0""
    for i in range(len(S)):
        if int(S[i]) != i%2:
            count1 +=1
        if int(S[i]) != (i+1)%2:
            count2 +=1
    print(min(count1,count2))





if __name__ == ""__main__"":
    main()
"
"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from heapq import heappop, heappush

def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7

N = INT()
ab = [LIST() for _ in range(N-1)]

def dijkstra(E, start):
   N_d = len(E)
   dist = [INF] * N_d
   dist[start] = 0
   q = [(0, start)]
   while q:
       dist_v, v = heappop(q)
       if dist[v] != dist_v:
           continue
       for u, dist_vu in E[v]:
           dist_u = dist_v + dist_vu
           if dist_u < dist[u]:
               dist[u] = dist_u
               heappush(q, (dist_u, u))
   return dist

E = [[] for _ in range(N)]

for a, b in ab:
	E[a-1].append((b-1, 1))
	E[b-1].append((a-1, 1))

d_f = dijkstra(E, 0)
d_s = dijkstra(E, N-1)

f = 0
s = 0
for i in range(N):
	if d_f[i] <= d_s[i]:
		f += 1
	else:
		s += 1

if f > s:
	print(""Fennec"")
else:
	print(""Snuke"")
"
"n=input()
S=input().split()
q=input()
T=input().split()
c=0
for t in T:
    if(t in S):c+=1
print(c)"
"x, y = map(int, input().split())

if x == y:
	res = 0
elif x < y:
	if (0 <= x and 0 <= y) or (x <= 0 and y <= 0):
		res = y - x
	else:
		if abs(x) >= y:
			res = abs(x) - y + 1
		else:
			res = y - abs(x) + 1
else:
	if 0 < x and 0 < y:
		res = x - y + 2
	elif x < 0 and y < 0:
		res = abs(y) - abs(x) + 2
	else:
		if x >= abs(y):
			res = x - abs(y) + 1
		else:
			res = abs(y) - x + 1
		
print(res)"
"string = input()
for i in string:
    if i.isupper():
        print(i.lower(), end = """")
    elif i.islower():
        print(i.upper(), end = """")
    else:
        print(i, end = """")
print()"
"import numpy as np
import sys
input = sys.stdin.readline


def main():
    n, s = map(int, input().split())
    A = np.array([int(i) for i in input().split()])

    MOD = 998244353

    dp = np.zeros(s + 1, dtype=""int32"")
    dp[0] = 1

    for a in A:
        p = (dp * 2) % MOD
        p %= MOD
        p[a:] += dp[:-a]
        dp = p % MOD

    print(dp[s])


if __name__ == '__main__':
    main()"
"N = int(input())
a = list(map(int,input().split()))

m = 0
manu = []

for i in range(1,N):
    if abs(a[m]) < abs(a[i]):
        m = i

for i in range(N):
    if a[m]*a[i] < 0:
        a[i] += a[m]
        manu.append([m,i])

if a[m] >= 0:
    for i in range(N-1):
        if a[i] > a[i+1]:
            a[i+1] += a[i]
            manu.append([i,i+1])

else:
    for i in range(N-1):
        if a[N-i-2] > a[N-i-1]:
            a[N-i-2] += a[N-i-1]
            manu.append([N-i-1,N-i-2])
    
print(len(manu))
for i in range(len(manu)):
    manu[i][0] += 1
    manu[i][1] += 1
    print("" "".join(list(map(str,manu[i]))))"
"line = int(input())
for i in range(line):
	a,b,c = sorted([int(i) for i in input().split(' ')])

	if a**2 + b**2 == c**2:
		print('YES')
	else:
		print('NO')"
"import sys
S, T = next(sys.stdin).strip().split()
A, B = map(int, next(sys.stdin).split())
U = next(sys.stdin).strip()

if U == S:
  A -= 1
elif U == T:
  B -= 1
else:
  raise ValueError

print(A, B)"
"cnt = 0
def insertion_sort(A, n, g):
    global cnt
    for i in range(g, n):
        v = A[i]
        j = i - g
        while j >= 0 and A[j] > v:
            A[j+g] = A[j]
            j -= g
            cnt += 1
        A[j+g] = v
def shell_sort(A, n):
    G = [1]
    for i in range(25):
        g = G[-1]*2+1
        if g > len(A)-1:
            break
        G.append(g)
    G.reverse()
    m = len(G)
    for g in G:
        insertion_sort(A, n, g)
    return m, G, A
n = int(input())
A = [int(input()) for _ in range(n)]
m, G, A = shell_sort(A, n)
print(m)
print("" "".join(map(str, G)))
print(cnt)
for a in A:
    print(a)
"
"x,y = map(int,input().split())

mod = 10**9+7

division = (x+y)//3

if [x%3,y%3] in [[1,1],[2,2]]:
    print(0)
    exit()

def cmb(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    r = min(r, n-r)
    return g1[n] * g2[r] * g2[n-r] % mod

mod = 10**9+7 #出力の制限
N = 10**6
g1 = [1, 1] # 元テーブル
g2 = [1, 1] #逆元テーブル
inverse = [0, 1] #逆元テーブル計算用テーブル

for i in range( 2, N + 1 ):
    g1.append( ( g1[-1] * i ) % mod )
    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2.append( (g2[-1] * inverse[-1]) % mod )



r = min(x,y)-division
ans = cmb(division,r,mod)

print(ans)
"
"def actual(s):
    if (s[0] != s[1]) and (s[1] != s[2]) and (s[2] != s[0]):
        return 'Yes'

    return 'No'

s = input()
print(actual(s))"
"#!/usr/bin/env python3
n,k=map(int,input().split())
odd = 0
for i in range(1,n+1):
    a=0
    while k > i*2**a:
        a+=1
    odd += 2**-a
print(odd/n)
"
"lines = []
colums = []

while True:
  H,W = map(int,input().split())
  if H == 0 and W == 0:
    break
  lines.append(H)
  colums.append(W)

for H,W in zip(lines,colums):
  for i in range(H):
    if i == 0 or i == H-1:
      for j in range(W):
        print(""#"",end="""")
    else:
      for j in range(W):
        if 0 < j and j < W-1:
          print(""."",end="""")
        else:
          print(""#"",end="""")
    print(""\n"",end="""")
  print(""\n"",end="""")
"
"import itertools
from collections import Counter

n = int(input())
al = list(map(int, input().split()))

arr = [0]
arr += list(itertools.accumulate(al))
c = Counter(arr)
ans = 0

for v in c.values():
    ans += v * (v - 1) // 2  # vC2

print(ans)
"
"A, B, C = tuple(map(int, input().split()))
if (A + B) < C:
    print(A + 2 * B + 1)
else:
    print(B + C)"
"N,M=map(int,input().split())
A=list(map(int,input().split()))
k=0
l=0
for i in range(N):
    k+=A[i]
for i in range(N):
    if ((A[i]/k)>=(1/(4*M))):
        l+=1
if l>=M:
    print('Yes')
else:
    print('No')"
"import sys
from collections import deque
input = sys.stdin.readline
sys.setrecursionlimit(10**8)

n = int(input())
edge = [[] for _ in range(n)]
for i in range(n-1):
    a, b = map(int, input().split())
    a, b = a-1, b-1
    edge[a].append(b)
    edge[b].append(a)

d1 = [-1] * n
d2 = [-1] * n
def dfs(v, d):
    for v_next in edge[v]:
        if d[v_next] == -1:
            d[v_next] = d[v] + 1
            dfs(v_next, d)

d1[0] = 0
dfs(0, d1)
d2[-1] = 0
dfs(n-1, d2)

n_f = 0
for i in range(n):
    if d1[i] <= d2[i]:
        n_f += 1

if n_f > n // 2:
    ans = ""Fennec""
else:
    ans = ""Snuke""
print(ans)
"
"import math
n = int(input())
ans = len(str(n))
for i in range(1,int(math.sqrt(n))+1):
    if n%i == 0:
        ans = min(ans,max(len(str(i)),len(str(n//i))))
print(ans)"
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
read = sys.stdin.buffer.read
sys.setrecursionlimit(10 ** 7)
INF = float('inf')

O = input()
E = input()

ans = """"
for i in range(len(O)):
    if i < len(E):
        ans += O[i] + E[i]
    else:
        ans += O[i]
print(ans)
"
"n,k=[int(x) for x in input().split()]
p=[int(x)-1 for x in input().split()]
c=[int(x) for x in input().split()]

ans=max(c)
if ans<0:
    print(ans)
    exit()

for i in range(n):
    #最後に自分という順番
    nxt=i
    lp=[]
    while 1:
        nxt=p[nxt]
        lp.append(nxt)
        if nxt==i:
            break
    lpc=max(0,sum(c[x] for x in lp))
    nxt=i
    lpl=len(lp)
    wks=0
    #ループ内の最大値を見る
    for j in range(lpl):
        nxt=p[nxt]
        wks+=c[nxt]
        #ループ内の距離をkから引いた数でループ長を割ることによって
        #剰余部分を加算するパータンと、剰余に突入する1つ前のループの途中でやめた
        #パターンの両方を確認できる
        #ループが負になる場合も考えて,この部分のみ加算するパターンも考える
        #このループはkを超えないので安全
        ans=max(ans,(k-j-1)//lpl*lpc+wks,wks)
        #ループの長さがkを超える場合打ち切る
        if j==k-1:
            break
print(ans)
"
"def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10**7)
    from collections import Counter, deque
    #from collections import defaultdict
    from itertools import combinations, permutations, accumulate, groupby, product
    from bisect import bisect_left,bisect_right
    from heapq import heapify, heappop, heappush
    from math import floor, ceil
    #from operator import itemgetter

    #inf = 10**17
    #mod = 10**9 + 7

    a,b = map(int, input().split())
    if a >=13:
        print(b)
    elif a<=5:
        print(0)
    else:
        print(b//2)

if __name__ == '__main__':
    main()
"
"N = int(input())
dp = [i for i in range(N + 1)]

for i in range(N + 1):
    index = 1
    while 6 ** index <= i:
        dp[i] = min(dp[i], dp[i - (6 ** index)] + 1)
        index += 1

    index = 1
    while 9 ** index <= i:
        dp[i] = min(dp[i], dp[i - (9 ** index)] + 1)
        index += 1

print(dp[N])"
"station=input()

flg=""No""
for i in range(2):
    if station[i]!=station[i+1]:
        flg=""Yes""

print(flg)"
"import sys

sys.setrecursionlimit(500000)
def input():
    return sys.stdin.readline()[:-1]

def main():
    N,M = list(map(int,input().split()))

    e_list = [[] for i in range(3*N)]

    def z(i,j):
        return i + j*N

    for i in range(M):
        u,v = list(map(int,input().split()))
        u,v = u-1,v-1
        e_list[z(u,0)].append(z(v,1)) 
        e_list[z(u,1)].append(z(v,2)) 
        e_list[z(u,2)].append(z(v,0))

    S,T = list(map(int,input().split()))
    S,T = S-1,T-1
    from collections import deque

    vi = z(S,0)  #change
    INF = float('inf')

    Q = deque([vi])

    checked_list = [False]*3*N
    checked_list[vi]=True

    min_path_list = [INF]*3*N #change
    min_path_list[vi] = 0

    while len(Q)>0:
        v = Q.pop()
        for v1 in e_list[v]:
            if not checked_list[v1]:
                checked_list[v1]=True
                Q.appendleft(v1)
                min_path_list[v1]=min(min_path_list[v1],min_path_list[v]+1) #change

    if min_path_list[z(T,0)]<10**9:
        print(min_path_list[z(T,0)]//3)
    else:
        print(-1)

if __name__ == '__main__':
    main()

"
"def resolve():
  n = int(input())
  a = list(map(int, input().split()))
  b = list(map(int, input().split()))
  c = list(map(int, input().split()))

  ans = 0
  prev = -2
  for x in a:
    x -= 1
    ans += b[x]
    if prev + 1 == x:
      ans += c[prev]
    prev = x
  print(ans)
  return

if __name__ == ""__main__"":
  resolve()
"
"n=int(input())
x=list(map(int,input().split()))

ans=float('inf')

for i in range(1, 100):
  res=0
  for j in range(n):
    res+=(x[j]-i)**2
  ans=min(res,ans)
print(ans)"
"n, x, t = map(int, input().split())

if n % x != 0:
    print((n // x + 1) * t)
else:
    print(n // x * t)
"
"import bisect
n, d, a = map(int, input().split())
xh = [list(map(int, input().split())) for _ in range(n)]

xh.sort()
xs = [x for x, h in xh]

memo = [0 for _ in range(n)]

ans = 0

for j, (x, h) in enumerate(xh):
    memo[j] +=  memo[j-1]
    b = h - memo[j]
    if b > 0:
        c = (b + a - 1) // a
        memo[j] += c * a
        ans += c
        i = bisect.bisect_right(xs, x + 2 * d)
        if i < n:
            memo[i] -= c * a

print(ans)
"
"n=int(input())
a=[int(x) for x in input().split()]
b=[y for y in a if y%2 == 0]
c=0
for i in b:
    if i%3 == 0 or i%5 == 0:
        pass
    else:
        print(""DENIED"")
        c=1
        break
        
if c==0:
    print(""APPROVED"")"
"import sys

l = []
for i in sys.stdin:
    l.append(i.split())

for i in range(0,len(l)-1):
    if int(l[i][0]) == -1 or int(l[i][1]) == -1:
        print('F')
    elif int(l[i][0]) + int(l[i][1]) >= 80:
        print('A')
    elif int(l[i][0]) + int(l[i][1]) < 80 and int(l[i][0]) + int(l[i][1]) >= 65:
        print('B')
    elif (int(l[i][0]) + int(l[i][1]) < 65 and int(l[i][0]) + int(l[i][1]) >= 50) or int(l[i][2]) >= 50:
        print('C')
    elif int(l[i][0]) + int(l[i][1]) < 50 and int(l[i][0]) + int(l[i][1]) >= 30:
        print('D')
    else:
        print('F')
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

S = list(input())+['END']
lis = []
now = S[0]
for s in S[1:]:
    if s!=now:
        lis.append(now)
        now = s

print(len(lis)-1)"
"n=int(input())
l=[None]*n
for i in range(n):
  a,b=map(int,input().split())
  l[i]=[a,b]
l.sort(key=lambda x:x[0]+x[1], reverse=True)
#print(l)
ans=0
for i in range(n):
  if i%2:
    ans-=l[i][1]
  else:
    ans+=l[i][0]
print(ans)"
"S = input()

num = len(S)//2
ans = []

if len(S) % 2!=0:
    num += 1
    for i in range(num):
        nn = 2*i
        ans.append(S[nn])
else:
    for i in range(num):
        nn = 2*i
        ans.append(S[nn])
        
        
print("""".join(ans))"
"import heapq
import sys
input = sys.stdin.readline
n,m = map(int,input().split())
INF = 10**18
edge = [[] for i in range(n)]
for i in range(m):
    x,y = map(int,input().split())
    edge[x-1].append(y-1)
s,t = map(int,input().split())

def dijkstra_heap(s,g,p):
    d = [[INF] * p for i in range(n)] 
    used = [[True] * p for i in range(n)] 
    used[s][0] = False
    ed_list = []
    for es in edge[s]:
        heapq.heappush(ed_list,[1,es,1]) # 回数、向かう頂点、あまり
    while len(ed_list):
        ken,v,md = heapq.heappop(ed_list)
        if not used[v][md]:
            continue
        d[v][md] = ken
        used[v][md] = False
        if not used[g][0]:
            break
        for e in edge[v]:
            if used[e][(md+1)%p]:
              if (md+1)%p == 1:
                heapq.heappush(ed_list,[ken+1,e,1])
              else:
                heapq.heappush(ed_list,[ken,e,(md+1)%p])
    return d[g][0]

ans = dijkstra_heap(s-1,t-1,3)
if ans == INF:
  print(-1)
else:
  print(ans)"
"import copy
import sys

array_data = map(int, raw_input().split())
r = array_data[0]
c = array_data[1]

array = []
for i in range(r):
	partial_array = map(int, raw_input().split())
	array.append(partial_array)

ans = copy.deepcopy(array)
for i in range(r):
	ans[i].append(sum(array[i]))
ans.append([])
for j in range(c+1):
	wa = 0
	for i in range(r):
		wa += ans[i][j]
	ans[r].append(wa)

for i in range(len(ans)):
	for j in range(len(ans[i])):
		if j != len(ans[i])-1:
			sys.stdout.write(""{:} "".format(ans[i][j]))
		else:
			print(ans[i][j])"
"a,b=[int(s) for s in input().split()]
print(a-b+1)"
"def dist(x,y):
    return abs(x[0]-y[0])+abs(x[1]-y[1])
N = int(input())
X = [list(map(int,input().split())) for _ in range(N)]
flag = 0
t1 = 0
x1,y1 = 0,0
for i in range(N):
    t2,x2,y2 = X[i]
    dt = t2-t1
    d = dist((x1,y1),(x2,y2))
    if dt>=d and (dt-d)%2==0:
        t1,x1,y1 = t2,x2,y2
        continue
    flag = 1
    break
if flag==0:
    print(""Yes"")
else:
    print(""No"")"
"k=int(input());n=50;print(n);print(*[n+k//n if i<k%n else n+(k//n-1)-k%n for i in range(n)])
"
"# https://atcoder.jp/contests/abc120/tasks/abc120_d

######### Union Find ########
class UnionFind(object):
    def __init__(self, n):
        self.n = n
        self.root = [-1]*(n+1)
        self.rnk = [0]*(n+1)

    def find(self, x):
        if self.root[x] < 0:
            return x
        else:
            self.root[x] = self.find(self.root[x])
            return self.root[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return 
        elif self.rnk[x] > self.rnk[y]:
            self.root[x] += self.root[y]
            self.root[y] = x
        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            if self.rnk[x] == self.rnk[y]:
                self.rnk[y] += 1

    def is_same(self, x, y):
        return self.find(x) == self.find(y)

    def count(self, x):
        return -self.root[self.find(x)]


if __name__ == '__main__':
    n, m = map(int, input().split())
    ab = []
    for _ in range(m):
        ai, bi = map(int, input().split())
        ab.append((ai - 1, bi - 1))
    all_n = n * (n - 1) // 2
    ans = [all_n]
    uf = UnionFind(n)

    # 後ろから
    for i in range(m - 1):
        ai, bi = ab[-1 - i]
        # print(ai, bi)

        if not uf.is_same(ai, bi):
            all_n -= uf.count(ai) * uf.count(bi)
        uf.unite(ai, bi)
        ans.append(all_n)

    for v in ans[::-1]:
        print(v)
"
"n = int(raw_input())
a = [0,0,0]
 
for i in range(n):
    a[0],a[1],a[2] = map(int,raw_input().split())
    a.sort()
    if a[0]**2 + a[1]**2 == a[2]**2:
        print(""YES"")
    else:
        print(""NO"")"
"n = input()
if len(set(n))==3:
  print(""Yes"")
else:
  print(""No"")"
"from itertools import accumulate
n = 10**5 + 1
primes = set(range(3, n+1, 2))

for i in range(3, int(n**0.5+1)):
    primes.difference_update(range(i*2, n+1, i))
primes.add(2)


def like_2017(n):
    return n in primes and (n + 1) // 2 in primes


result = [0] * 10**5
for i in range(1, 10**5 + 1, 2):
    result[i] = like_2017(i)


cumsum = list(accumulate(result))

q = int(input())

for _ in range(q):
    l, r = map(int, input().split())
    print(cumsum[r] - cumsum[l - 1])"
"from decimal import Decimal
a,b = map(int,raw_input().split())

d=a/b
r=a%b

print ""%d %d %f"" %(d,r,float(a)/b)"
"N, K = map(int, input().split())
P = list(map(int, input().split()))

ans = 0
P_sum = 0

for i in range(N):
  P[i] = (P[i] + 1) / 2

for j in range(K):
  P_sum += P[j]

ans = P_sum
for t in range(K, N):
  P_sum -= P[t - K]
  P_sum += P[t]
  ans = max(ans, P_sum)

print(ans)"
"N,Y = map(int,input().split())
x = y = z = 0
while  Y >= 10000:
    x += 1
    N -= 1
    Y -= 10000
while Y >= 5000:
    y += 1
    N -= 1
    Y -= 5000
while Y >= 1000:
    z += 1
    N -= 1
    Y -= 1000
if Y != 0 or N < 0:
    x = y = z = -1
else:
    while N >= 9 and x > 0:
        x -= 1
        z += 10
        N -= 9
    while N >= 4 and y > 0:
        y -= 1
        z += 5
        N -= 4
    while N > 0 and x > 0:
        x -= 1
        y += 2
        N -= 1
    if N != 0:
        x = y = z = -1
print(x,y,z)"
"k =int(input())
s =input()
ans = ''
if k>len(s):
  k = len(s)
for i in range (k):
  ans = ans+s[i]

if k<len(s):
  print(ans+'...')
else:
  print(ans)"
"def main():
    import sys
    from collections import defaultdict
    sys.setrecursionlimit(10**6)
    input = sys.stdin.readline

    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a % b)
    
    N, M = [int(x) for x in input().strip().split()]
    S = input().strip()
    T = input().strip()
    L = (N * M) // gcd(N, M)
    d = defaultdict(int)
    for n in range(N):
        d[L//N*n] = S[n]
    for m in range(M):
        if d[L//M*m] == 0 or d[L//M*m] == T[m]:
            continue
        else:
            print(-1)
            return
    print(L)

if __name__ == '__main__':
    main()"
"import math
X = int(input())
A, B = 1, 1


def is_ok(i, x):
    return pow(i, 5) >= x


def bisect(ng, ok, x):
    while (abs(ok - ng) > 1):
        mid = (ok + ng) // 2
        if is_ok(mid, x):
            ok = mid
        else:
            ng = mid
    return ok


ss = math.ceil(X ** (1 / 4)) + 10
for a in range(1, math.ceil(X ** (1 / 4)) + 10):
    tmp = abs(pow(a, 5) - X)
    b = bisect(-1, ss, tmp)
    if tmp == pow(b, 5):
        A = a
        if a ** 5 - X > 0:
            B = b
        else:
            B = -1 * b
        break
print(A, B)
"
"# 084_a
M=int(input())
if 1<=M and M<=23:
    result=48-M
    if result>=0:
        print(result)"
"def readints():
    return list(map(int, input().split()))


# n, d = map(int, input().split())
# x = [input().split() for i in range(n)]
# print(x)

a = input()
b = input()
c = input()

print(a[0], end="""")
print(b[1], end="""")
print(c[2], end="""")
"
"import copy

n = int(input())
if n == 1:
    print(1)
    exit()

l_2 = 0
l_1 = 2
l_0 = 1
for i in range(2, n+1):
    l_2 = copy.deepcopy(l_1)
    l_1 = copy.deepcopy(l_0)
    l_0 = l_1 + l_2
print(l_0)"
"# N = int(input())
N, A, B = [int(_) for _ in input().split()]
if (B - A) % 2 == 0:
    print((B-A) // 2)
else:
    print(min(N - B + 1 + (N - (A + N-B+1)) // 2, A + (B - A - 1)//2))
"
"def main():
    N, M, K = map(int, input().split())
    ok = False
    for i in range(N+1):
        for j in range(M+1):
            if K == i*(M-j) + j*(N-i):
                ok = True
                break
    print(""Yes"" if ok else ""No"")
         


if __name__ == ""__main__"":
    main()"
"import sys

input = sys.stdin.readline


def main():
    A, B, C, D = map(int, input().split())

    if B <= C or D <= A:
        ans = 0
    else:
        ans = min(B, D) - max(A, C)

    print(ans)


if __name__ == ""__main__"":
    main()
"
"a,b,c=map(int,input().split())
if b>=c:
	print(b+c)
else:
	if a+b>=c:
		print(c+b)
	else:
		print(b+a+b+1)"
"def main():
    A, B, C = (int(x) for x in input().split())
    if A - B >= C:
        ans = 0
    else:
        ans = C - (A - B)
    print(ans)


if __name__ == ""__main__"":
    main()
"
"c = ['Sunny', 'Cloudy', 'Rainy', 'Sunny']
s = input()
print(c[c.index(s) + 1])"
"k, n = map(int, input().split())
l = list(map(int, input().split()))
d = [0] * n
for i in range(n):
    if i == n - 1:
        d[i] = k - l[-1] + l[0]
    else:
        d[i] = l[i + 1] - l[i]
print(k - max(d))"
"n,k=map(int,input().split());print(sum((n+1-i)*i+1for i in range(k,n+2))%(10**9+7))"
"n = int(input())
b = [10**6] + list(map(int, input().split()))
a = [0] * n
a[0] = b[1]
a[n-1] = b[n-1]

for i in range(1, n-1):
    a[i] = min(b[i], b[i+1])

print(sum(a))
"
"H, W = map(int,input().split())

S = []
for i in range(H):
    S.append(input())

ans = [["" "" for i in range(W)] for j in range(H)]

for i in range(H):
    for j in range(W):
        if S[i][j] == ""#"":
            ans[i][j] = ""#""

        else:
            a = 0
            if i > 0:
                if S[i-1][j] == ""#"":
                    a += 1
                    
                if j > 0:
                    if S[i-1][j-1] == ""#"":
                        a += 1

                if j < W-1:
                    if S[i-1][j+1] == ""#"":
                        a += 1

            if j > 0:
                if S[i][j-1] == ""#"":
                    a += 1

            if j < W-1:
                if S[i][j+1] == ""#"":
                    a += 1

            if i < H-1:
                if S[i+1][j] == ""#"":
                    a += 1
                    
                if j > 0:
                    if S[i+1][j-1] == ""#"":
                        a += 1

                if j < W-1:
                    if S[i+1][j+1] == ""#"":
                        a += 1

            ans[i][j] = str(a)

for i in range(H):
  print("""".join(ans[i]))"
"import math
A,B,C,D = map(int,input().split())
count1 = 0
count2 = 0
ans1 = B-B//C-B//D+B//((C*D)//math.gcd(C,D))
A = A-1
ans2 = A-A//C-A//D+A//((C*D)//math.gcd(C,D))
print(ans1-ans2)"
"import sys

input=sys.stdin.buffer.readline


#sys.setrecursionlimit(10**9)
#from functools import lru_cache

def RD(): return sys.stdin.read()


def II(): return int(input())


def MI(): return map(int,input().split())


def MF(): return map(float,input().split())


def LI(): return list(map(int,input().split()))


def LF(): return list(map(float,input().split()))


def TI(): return tuple(map(int,input().split()))


# rstrip().decode('utf-8')


def main():
	a,b,c,d=MI()
	print(max(a*c,a*d,b*c,b*d))
	

	

if __name__==""__main__"":
	main()
"
"import sys
def ii(): return int(sys.stdin.readline())
def mi(): return map(int, sys.stdin.readline().split())
def li(): return list(map(int, sys.stdin.readline().split()))
def li2(N): return [list(map(int, sys.stdin.readline().split())) for i in range(N)]
def dp2(ini, i, j): return [[ini]*i for i2 in range(j)]
def dp3(ini, i, j, k): return [[[ini]*i for i2 in range(j)] for i3 in range(k)]
#import bisect #bisect.bisect_left(B, a)
#from collections import defaultdict #d = defaultdict(int) d[key] += value

N = ii()
A = sorted([ii() for _ in range(N)])
'''
if N > 2:
    ans += A[-1] * 2 - A[0] - A[1]
    l_ind = 2
    r_ind = N-2
    while True:
        if r_ind - 2 >= l_ind:
'''
if N==2:
    print(A[1]-A[0])
elif N%2:
    '''
    ans_1 = A[N-1]*2 - A[0] - A[1]
    ans_1 += sum(A[N//2:N-1])*2 - sum(A[:N//2])*2 - A[N//2] - A[N//2-1]
    ans_2 = A[N-1] + A[N-2] - A[0]*2
    ans_2 += sum(A[N//2+1:])*2 - sum(A[1:N//2+1])*2 - A[N//2] - A[N//2+1]
    print(ans_1, ans_2)
    '''
    ans_1 = A[N-1]*2 - A[0] - A[1]
    tmp = A[0] + A[1]
    l_ind = 1
    r_ind = N-1
    while True:
        r_ind -= 2
        if r_ind < l_ind:
            break
        ans_1 += A[r_ind] + A[r_ind+1] - tmp
        tmp = A[r_ind] + A[r_ind+1]
        l_ind += 2
        if l_ind > r_ind:
            break
        ans_1 += tmp - (A[l_ind] + A[l_ind-1])
        tmp = A[l_ind] + A[l_ind-1]
    #print(ans_1)

    ans_2 = A[N-1] + A[N-2] - A[0]*2
    tmp = A[N-1] + A[N-2]
    l_ind = 0
    r_ind = N-2
    while True:
        l_ind += 2
        if l_ind > r_ind:
            break
        ans_2 += tmp - (A[l_ind] + A[l_ind-1])
        tmp = A[l_ind] + A[l_ind-1]
        r_ind -= 2
        if r_ind < l_ind:
            break
        ans_2 += A[r_ind] + A[r_ind+1] - tmp
        tmp = A[r_ind] + A[r_ind+1]

    print(max(ans_1, ans_2))

else:
    ans_1 = A[N-1]*2 - A[0] - A[1]
    tmp = A[0] + A[1]
    l_ind = 1
    r_ind = N-1
    while True:
        r_ind -= 2
        if r_ind == l_ind:
            ans_1 += A[r_ind+1] - A[r_ind-1]
            break
        ans_1 += A[r_ind] + A[r_ind+1] - tmp
        tmp = A[r_ind] + A[r_ind+1]
        l_ind += 2
        if l_ind == r_ind:
            ans_1 += A[r_ind+1] - A[r_ind-1]
            break
        ans_1 += tmp - (A[l_ind] + A[l_ind-1])
        tmp = A[l_ind] + A[l_ind-1]

    ans_2 = A[N-1] + A[N-2] - A[0]*2
    tmp = A[N-1] + A[N-2]
    l_ind = 0
    r_ind = N-2
    while True:
        l_ind += 2
        if l_ind == r_ind:
            ans_2 += A[r_ind+1] - A[r_ind-1]
            break
        ans_2 += tmp - (A[l_ind] + A[l_ind-1])
        tmp = A[l_ind] + A[l_ind-1]
        r_ind -= 2
        if r_ind == l_ind:
            ans_2 += A[r_ind+1] - A[r_ind-1]
            break
        ans_2 += A[r_ind] + A[r_ind+1] - tmp
        tmp = A[r_ind] + A[r_ind+1]

    print(max(ans_1, ans_2))"
"def main():
    n = int(input())
    a = list(map(int, input().split()))

    min_two_count = 2 ** 30

    for i in range(len(a)):
        temp_two_count = 0
        while a[i] % 2 == 0:
            temp_two_count += 1
            a[i] = a[i] // 2

        if min_two_count > temp_two_count:
            min_two_count = temp_two_count

    print(min_two_count)


if __name__ == ""__main__"":
    main()
"
"import sys
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import floyd_warshall

N,M,L = map(int,readline().split())
ABC = [list(map(int,readline().split())) for _ in range(M)]
Q = int(readline())
ST = [list(map(int,readline().split())) for _ in range(Q)]
    
def warshall_floyd(d):
    for k in range(N):
        for i in range(N):
            for j in range(N):
                d[i][j] = min(d[i][j],d[i][k] + d[k][j])
    return d

INF = 10**11
d = [[INF]*N for i in range(N)] 
a =  [[INF]*N for i in range(N)] 
for x,y,z in ABC:
    if z <= L:
      d[x-1][y-1] = z
      d[y-1][x-1] = z
for i in range(N):
    d[i][i] = 0
    a[i][i] = 1
d = csr_matrix(d)
d = floyd_warshall(csgraph=d)

for i in range(N-1):
  for j in range(i+1,N):
    if d[i][j] <= L:
      a[i][j] = 1
      a[j][i] = 1
a = csr_matrix(a)
a = floyd_warshall(csgraph=a)

for s,t in ST:
  ans = a[s-1][t-1]
  if ans == INF:
      print(-1)
  else:
      print(int(ans)-1)"
"import queue
n=int(input())
e=[[] for _ in range(n)]
INF=10**18
d=[INF]*n
for _ in range(n-1):
  v,u,w=map(int,input().split())
  e[v-1]+=[(u-1,w)]
  e[u-1]+=[(v-1,w)]
q=queue.Queue()
q.put(0)
d[0]=0
while not q.empty():
  now=q.get()
  for to,dis in e[now]:
    if d[to]==INF:
      d[to]=d[now]+dis
      q.put(to)
for i in d:
  print(i%2)"
"a, b, c = map(int, input().split())
res = 'No'
if a == b and a != c: res = 'Yes'
if a == c and a != b: res = 'Yes'
if c == b and a != c: res = 'Yes'
print(res)"
"N, A, B = map(int, input().split())
S = input()

a = 0
b = 0
for s in S:
    if s == 'a':
        if a+b < A+B:
            print('Yes')
            a += 1
        else:
            print('No')
    elif s == 'b':
        if a+b < A+B and b < B:
            print('Yes')
            b += 1
        else:
            print('No')
    else:
        print('No')"
"r,d,x = map(int, input().split())

for _ in range(10):
  x *= r
  x -= d
  print(x)"
"#ABC 173 C - H and V
import numpy as np

h,w,k = map(int,input().split())
c = np.zeros((h,w)).astype('str')
for i in range(h):
    s = input()
    for j,a in enumerate(s):
        c[i,j] = a
        
cnt = 0
for o in range(2**h):
    for l in range(2**w):
        black = 0
        for m in range(h):
            for n in range(w):
                if ((o>>m)&1==0) and ((l>>n)&1==0) and (c[m,n]=='#'):
                    black += 1
        if black == k:
            cnt += 1
print(cnt)"
"h,w=map(int,input().split())
g=[input() for _ in range(h)]
for x in range(h):
  for y in range(w):
    if g[x][y]=='.': continue
    ng=1
    for dx,dy in [(1,0),(0,1),(-1,0),(0,-1)]:
      nx,ny=x+dx,y+dy
      if 0<=nx<h and 0<=ny<w:
        if g[nx][ny]=='#': ng=0
    if ng:
      print('No')
      exit()
print('Yes')"
"n,m = map(int,input().split())
if n>12:
    print(m)
elif n>5:
    print(m//2)
else:
    print(0)"
"a,b=map(int,input().split())
pfa={}
m=a
for i in range(2,int(m**0.5)+1):
    while m%i==0:
        pfa[i]=pfa.get(i,0)+1
        m//=i
if m>1:pfa[m]=1
pfb={}
m=b
for i in range(2,int(m**0.5)+1):
    while m%i==0:
        pfb[i]=pfb.get(i,0)+1
        m//=i
if m>1:pfb[m]=1
aa=set()
bb=set()
for i in pfa.keys():
    aa.add(i)
for i in pfb.keys():
    bb.add(i)
print(len(aa&bb)+1)"
"import sys
input = sys.stdin.readline
import math
from fractions import gcd
import operator
from functools import reduce
from itertools import accumulate

def read():
    N = int(input().strip())
    A = list(map(int, input().strip().split()))
    return N, A


def prime_factorization_preprocess(n):
    """"""
    エラトステネスの篩を用いて、sqrt(n)以下の素数を列挙する
    """"""
    m = math.floor(math.sqrt(n)) + 1
    primes = []
    is_prime = [True for i in range(m)]
    for i in range(2, m):
        if is_prime[i]:
            primes.append(i)
            for j in range(i+i, m, i):
                is_prime[j] = False
    return primes


def prime_factorization(x, primes):
    """"""
    試し割り法により、数値の素因数分解を求める
    """"""
    factors = defaultdict(int)
    for p in primes:
        if x % p == 0:
            n = 0
            while x % p == 0:
                x //= p
                n += 1
            factors[p] = n
    return factors


def solve(N, A, AMAX = 10**9, INF=10**9):
    sl = list(accumulate(A, gcd))
    sr = list(reversed(list(accumulate(reversed(A), gcd))))
    max_gcd = sl[-1]
    for i in range(N):
        # gcdの単位元は0
        v = 0
        if i > 0:
            v = gcd(v, sl[i-1])
        if i < N-1:
            v = gcd(v, sr[i+1])
        max_gcd = max(max_gcd, v)
    return max_gcd


if __name__ == '__main__':
    inputs = read()
    print(solve(*inputs))
"
"import sys
import fractions
sys.setrecursionlimit(10**9)

n,m=map(int,input().split())
alist=list(map(int,input().split()))
alist=list(set(alist))

n=len(alist)


def sks(n):
	global alist
	if n == 1:
		return alist[0]
	else:
		tmp=sks(n-1)
		return tmp*alist[n-1]//fractions.gcd(tmp,alist[n-1])

sk = sks(n)
gomi=sk//2

for a in alist:
	if (gomi-a//2)%a != 0:
		print(0)
		sys.exit()

print(int((m+gomi)//sk))

"
"def gcd(a, b):
    if a == b: return a
    while b > 0: a, b = b, a % b
    return a

n,x=(int(i) for i in input().strip().split("" ""))
from functools import reduce
ar=[int(i) for i in input().strip().split("" "")]
ar.sort()
from bisect import insort
insort(ar,x)
temp=[]
for i in range(1,len(ar)):
    temp.append(abs(ar[i]-ar[i-1]))

k=reduce(gcd,temp)
print(k)"
"a,b,c,d=map(int,input().split())
a_b=set(range(a,b+1))
c_d=set(range(c,d+1))
print(len(a_b&c_d)-1 if len(a_b&c_d)!=0  else 0)"
"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**9)

def solve():
    N = int(input())
    adjL = [[] for _ in range(N)]
    for i in range(N-1):
        a, b = map(int, input().split())
        a, b = a-1, b-1
        adjL[a].append((b, i))
        adjL[b].append((a, i))

    def dfs(vNow, vPar, clrPar):
        clr = 1
        for v2, i in adjL[vNow]:
            if v2 == vPar: continue
            if clr == clrPar:
                clr += 1
            anss[i] = clr
            dfs(v2, vNow, clr)
            clr += 1

    anss = [0] * (N-1)
    dfs(0, -1, 0)

    print(max(anss))
    print('\n'.join(map(str, anss)))


solve()
"
"#!/usr/bin python3
# -*- coding: utf-8 -*-

def main():
    S = input()
    S = S.replace('BC','Z')
    S = S.replace('B',' ')
    S = S.replace('C',' ')
    S = S[::-1]
    S = S.split()
    ret = 0
    for s in S:
        zcn = 0
        for si in s:
            zcn += (si == 'Z')
            ret += zcn * (si == 'A')
    print(ret)

if __name__ == '__main__':
    main()"
"N=int(input())
list1 = list(map(int, input().split()))

list1.sort()
x=list1[0]
y=list1[-1]

s=0
list2=[]
while x+s<=y:
    list2.append(x+s)
    s=s+1

list3=[]
for j in list2:
    w=0
    for i in list1:
        w=w+(i-j)*(i-j)
    list3.append(w)

list3.sort()
print(list3[0])
"
"n=int(input())
M=list(map(int,input().split()))
M.sort()
dic={}
dic[M[0]]=1
for i in range(1,n):
	if(M[i]!=M[i-1]):
		dic[M[i]]=1
	else:
		dic[M[i-1]]+=1

L=list(dic.keys())
l=len(L)
L.sort()
count=0
for i in range(0,l):
	for j in range(0,i):
		for k in range(0,j):
			if(L[i]<L[j]+L[k]):
				count+=dic[L[i]]*dic[L[j]]*dic[L[k]]
print(count)"
"N, K = map(int, input().split())
R, S, P = map(int, input().split())
T = input()
keys = [i for i in range(N)]
hands = {key: 0 for key in keys}  # n回目の手を記録

for i in range(N):
    if i < K:
        if T[i] == 'r':
            hands[i] = P
        elif T[i] == 's':
            hands[i] = R
        else:
            hands[i] = S
    elif i >= K:
        if T[i] == T[i-K] == 'r':
            if hands[i-K] == 0:
                hands[i] = P
        elif T[i] == T[i-K] == 's':
            if hands[i-K] == 0:
                hands[i] = R
        elif T[i] == T[i-K] == 'p':
            if hands[i-K] == 0:
                hands[i] = S
        else:
            if T[i] == 'r':
                hands[i] = P
            elif T[i] == 's':
                hands[i] = R
            else:
                hands[i] = S

total = sum(hands.values())
print(total)
"
"#!/usr/bin/env python3
def main():
    A, B = map(int, input().split())

    for price in [str(x) for x in range(10, 1001)]:
        a = str(int(price) * 8)
        a = int(a[:-2]) if len(a) >= 3 else 0
        b = int(price[:-1]) if len(price) >= 2 else 0
        if a == A and b == B and a <= 100 and b <= 100:
            print(price)
            return
    print(-1)


if __name__ == '__main__':
    main()
"
"N, M = map(int, input().split())
H = list(map(int, input().split()))

ap = [False]*(N+1)

for m in range(M):
    a, b = map(int, input().split())
    if H[a-1] > H[b-1]: 
        ap[b] = True
    elif H[a-1] < H[b-1]:
        ap[a] = True
    elif H[a-1] == H[b-1]:
        ap[a] = True
        ap[b] = True

count = 0
for a in range(1, N+1):
    if ap[a] == False:
        count += 1

print(count)"
"# coding: utf-8
# Your code here!

a,b =list(map(int,input().split()))
if(a-2*b>0):
    print(a-2*b)
else:print(""0"")"
"n = int(input())
s = list(input())
ans = """"

l = 0
for i in range(n):
    ans += s[i]
    if s[i] == "")"":
        if l == 0:
            ans = ""("" + ans
        else:
            l -= 1
    else:
        l += 1

ans += ("")""*l)

print(ans)
"
"# ???????????????????????¢??°
def eval(m, f, r):
    if m == -1 or f == -1:
        return ""F""
    elif m + f >= 80:
        return ""A""
    elif 65 <= m + f < 80:
        return ""B""
    elif 50 <= m + f < 65:
        return ""C""
    elif 30 <= m + f < 50:
        if r >= 50:
            return ""C""
        else:
            return ""D""
    elif m + f < 30:
        return ""F""


while 1:
    mfr = input().split()
    m = int(mfr[0])
    f = int(mfr[1])
    r = int(mfr[2])

    if m == -1 and f == -1 and r == -1:
        break
    else:
        print(eval(m, f, r))"
"import sys

line = sys.stdin.readline()
inp = []
for i in line.split("" ""):
    inp.append(int(i))

inp.sort()

print(""%d %d %d"" % (inp[0],inp[1],inp[2]))"
"from collections import Counter
N=int(input())
C=list(input())

# RRRRWWWW ok
count=Counter(C)
ws=count[""W""]
rs=count[""R""]

outws=0
outrs=0
for i in range(N):
    c=C[i]
    if c==""R"":
        if not 0<=i<rs:
            outrs+=1
    else:
        if 0<=i<rs:
            outws+=1

ans=max(outrs, outws)
print(ans)"
"def main():
    a, b = map(int, input().split())
    n = (b - a) - 1
    a_ = n*(n+1)/2
    print(int(a_ - a))
main()"
"N, K = map(int, input().split())

""""""
2(a+b+c) = nK <= 6N
n=1,2,......,6N//K

a+b=iK-c<=2
2N>=iK-c

a+c=iK
a+b=jK
b-c=XK Xは整数
b+c=kK kは自然数
2b=(X+k)K 
b=X'K/2
→K=2a：bはa刻み
→K=2a-1：bはK刻み
""""""


# max_n = (2*N)//K
# count = 0
# anslist = []
# for sum_ab in range(K, 2*N + 1, K):
#     print((""a+b"", sum_ab))
#     min_a = sum_ab - N if sum_ab - N >= 1 else 1

#     for a in range(min_a, min(sum_ab, N+1)):
#         b = sum_ab - a
#         if (a - b) % K != 0:
#             continue
#         if b < 1 or b > N:
#             break
#         lower = min(a, b)
#         for c in range(1, N+1):
#             if (lower + c) % K == 0:
#                 # print((a, b, c))
#                 anslist.append([a, b, c])
#                 count += 1
# anslist.sort(key=lambda x: x[0])
# print(anslist)
# print(count)

if K % 2 == 0:
    kizami = K // 2
    max_kizami = N // kizami
    pa1 = max_kizami // 2
    pa2 = max_kizami - pa1
    print(pa1**3+pa2**3)
else:
    kizami = K
    max_kizami = N // kizami
    print(max_kizami**3)

""""""偶数の場合
a+b=K max_kizami通り
    kizami kizami [kizami,kizami+K,...]
a+b=2K 2max_kizami　+　N//K通り
    1kizami 3kizami [kizami,kizami+K,...]
    2kizami 2kizami [2kizami,4kizami,...]
    3kizami 1kizami [kizami,kizami+K,...]


a+b=2(N//K)K
    max_kizami*kizami max_kizami*kizami [kizami,...]
""""""
""""""奇数の場合
K K [K,2K,...]

2K K []
K 2K []

3K K []
2K 2K []
K 3K []



max_kizami
""""""
"
"while True:
    (x, y) = (int(i) for i in input().split())
    if x == 0 and y == 0:
        break
    elif x <= y:
        print(x, y)
    else:
        print(y, x)"
"import sys
print(int(sys.stdin.readline())^1)"
"import math
x1,y1,x2,y2 = map(float,input().split())

x_d = x2 - x1
y_d = y2 - y1
print(""%0.5f"" % math.sqrt(x_d**2 + y_d**2))"
"n,a,b=map(int,input().split())
X=list(map(int,input().split()))
ans=0
for i in range(n-1):
    if (X[i+1]-X[i])*a<b:
        ans+=(X[i+1]-X[i])*a
    else:
        ans+=b
print(ans)"
"# -*- coding: utf-8 -*-


def main():
    import sys
    input = sys.stdin.readline

    n, m, k = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # KeyInsight:
    # ◯: 配列の要素の合計を前計算しておく
    # △: 尺取り法に気がつけなかった。
    # △: 解説動画を見て自分で実装したら、サンプルのインデックスエラーが消えずに詰んだ。
    # See:
    # https://www.youtube.com/watch?v=v8ppNGf49Nk&feature=youtu.be
    time = 0

    for bi in b:
        time += bi

    j = m
    ans = 0

    for i in range(n + 1):
        # bの要素を選択できる、かつ、kより所要時間が長いときに、本を減らす
        while (j > 0 and time > k):
            j -= 1
            time -= b[j]

        # 全てのbの要素を除外したケースへの対応
        if time > k:
            break

        # aとbの要素数と、これまでの最大値とを比較
        ans = max(ans, i + j)

        # 実装上の工夫:
        # 配列参照外を防ぐ
        if (i == n):
            break

        # 実装上の工夫:
        # aの要素を次のループの前に計算しておく
        time += a[i]

    print(ans)


if __name__ == '__main__':
    main()
"
"import numpy as np

h, w  = map(int,input().split())
sn = [[0]*w for i in range(h)]
 
for i in range(h):
    s = input()
    for j in range(w):
        if s[j] == '.':
            sn[i][j] = 1
sn = np.array(sn)
score = np.zeros_like(sn)
total = np.zeros_like(sn)

score[0] += sn[0]
for i in range(1, h):
    score[i] = (score[i-1] + sn[i]) * sn[i]
total += score

score[h-1] = sn[h-1]
for i in range(h-2, -1, -1):
    score[i] = (score[i+1] + sn[i]) * sn[i]
total += score

score[:,0] = sn[:,0]
for i in range(1, w):
    score[:,i] = (score[:,i-1] + sn[:,i]) * sn[:,i]
total += score

score[:,w-1] = sn[:,w-1]
for i in range(w-2, -1, -1):
    score[:,i] = (score[:,i+1] + sn[:,i]) * sn[:,i]
total += score
    
print(total.max()-3)"
"n = int(input())
ans = [0 for _ in range(10004)]
for i in range(1,102):
    for j in range(1,102):
        for k in range(1,102):
            v=i*i+j*j+k*k+i*j+j*k+k*i
            if(v<10004):
                ans[v]+=1
for i in range(1,n+1):
    print(ans[i])"
"N, K = map(int, input().split())
A = list(map(int, input().split()))

# 最大値を取るf(x)のxを求める
# digitsは下位桁 < 上位桁で1になっているbitをカウントする
digits = [0] * 40
for i in range(40):
    for a in A:
        if (a >> i) & 1:
            digits[i] += 1

# Kを考慮してmax_xを求める方法がわからない
# 桁ごとに最適なbitはすでにわかっていて、他の桁のbitに影響を受けることはないので、
# 上位桁から見ていって、Kが1になっている部分ならフラグを立てる
# 上位桁から見てKが1のbitが出てから、K:1,max_x:0のフラグを立てたら、その桁より下位桁のbitはなんでもよくなる
check_K = True
max_x = 0
for i, d in enumerate(reversed(digits)):
    i = 40 - i - 1
    if check_K and (K >> i) & 1 == 0:
        continue
    if d <= (N-d) and (K >> i) & 1 == 1:
        # Kの対象bitが1かつ、 max_xのbitを1にする場合
        max_x += 2 ** i
    elif d <= (N-d) and not check_K:
        # max_xがK以下となることが確定していて、max_xのbitを1にする場合
        max_x += 2 ** i
    elif (K >> i) & 1 == 1:
        # max_xがK以下となることが確定したので、Falseにする
        check_K = False


#print(max_x)
ans = 0
for a in A:
    ans += a ^ max_x

print(ans)

"
"while 1:
  a = map(int, raw_input().split())
  if a[0]==0 and a[1]==0:
    break
  else:
    a.sort()
    print '%d %d' % (a[0], a[1])"
"s = list(input())
n = len(s)

p, t = '', ''

cnt = 0

for char in s:
	t += char
	if p == t:
		continue
	cnt += 1
	p, t = t, ''

print(cnt)"
"N=int(input())
s=str(input())

R=s.count(""R"")
B=s.count(""B"")

if R>B:
    print(""Yes"")
else:
    print(""No"")"
"n,x = map(int, input().split())
al = list(map(int, input().split()))

ans = 0
if al[0] > x:
    ans += (al[0]-x)
    al[0] = x

for i in range(1,n):
    rem = al[i-1]+al[i] - x
    if rem > 0:
        al[i] -= rem
        ans += rem

print(ans)"
"n = int(input())
a = list(map(int, input().split()))
ans = [0] * n
for i, ai in reversed(list(enumerate(a, 1))):
    s = sum(ans[j - 1] for j in range(i + i, n + 1, i))
    ans[i - 1] = (s + a[i - 1]) % 2
ans = list(map(lambda x: x[0], filter(lambda x: x[1] == 1, enumerate(ans, 1))))
print(len(ans))
print(*ans)"
"from sys import stdin, setrecursionlimit


def main():
    input = stdin.readline
    s, t = map(str, input().split())
    a, b = map(int, input().split())
    u = input()[:-1]
    print(a - 1, b) if s == u else print(a, b - 1)


if __name__ == ""__main__"":
    setrecursionlimit(10000)
    main()
"
"from functools import lru_cache

mod = 10 ** 9 + 7

h, w, k = map(int, input().split())
k -= 1


@lru_cache(maxsize=w + 10)
def fib(n):
    if n <= 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)
    # 縦線n本のあみだくじのパターン数
    # 右端の縦線を引くかどうかで漸化式を作る


dp = [0] * w
dp[0] = 1
ndp = [0] * w

for _ in range(h):
    for i in range(w):
        ndp[i] += dp[i] * fib((i + 1) - 1) * fib(w - (i + 1))  # 真下
        ndp[i] %= mod
        if i - 1 >= 0:
            ndp[i - 1] += dp[i] * fib((i + 1) - 2) * fib(w - (i + 1))  # 左
            ndp[i - 1] %= mod
        if i + 1 < w:
            ndp[i + 1] += dp[i] * fib((i + 1) - 1) * fib(w - (i + 1) - 1)  # 右
            ndp[i + 1] %= mod
    dp = ndp
    ndp = [0] * w
print(dp[k])
"
"N = int(input())
A = []
B = []
for i in range (0,N):
	a, b = map(int, input().split())
	A.append(a)
	B.append(b)
    
A = sorted(A)
B = sorted(B)

from statistics import median

if N%2 ==1:
	print(median(B)-median(A)+1)
else:
	print(int((median(B)-median(A))*2+1))"
"import sys

class alphabet(): #Trueなら大文字
    def __init__(self, capitalize):
        self.num = dict() #あるアルファベットが最初から何番目か、0-indexed
        self.index = dict() #i番目のアルファベット
        self.abc = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n""\
            ,""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""]
        if capitalize: 
            for i in range(26): self.abc[i] = self.abc[i].upper()
        for i, a in enumerate(self.abc):
            self.num[a] = i
            self.index[i] = a

def solve():
    S = list(input())
    length = len(S)
    K = int(input())
    changed = 0
    AB = alphabet(False)
    for i, s in enumerate(S):
        aId = AB.num[s]
        if aId == 0: continue
        else:
            toA = 26 - aId
            if K - changed >= toA: 
                S[i] = ""a""
                changed += toA
    if K - changed > 0:
        aId = AB.num[S[length - 1]]
        S[length - 1] = AB.index[(aId + K - changed) % 26]
    print("""".join(map(str, S)))
    return 0

if __name__ == ""__main__"":
    solve()"
"n = int(input())
if n == 0:
  print(0)
  exit()
ans = []
while n>0 or n<0:
  if n == 0:
    break
  else:
    if n%2==0:
      ans.append(0)
      n = n//(-2)
    else:
      ans.append(1)
      n = (n-1)//(-2)
    
print(*ans[::-1], sep='')"
"n = int(input())

from collections import Counter

def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a

c=list(Counter(prime_factorize(n)).values())

if len(c)==0:
	print(0)
	exit()
ans=0

for i in c:
	for j in range(1,10**7):
		i-=j
		if i>=0:
			ans+=1
		else:
			break

print(ans)"
"n = int(input())
k = int(input())
xn = [int(num) for num in input().split()]

answers = []
for x in xn:
  answers.append(2*min(x,k-x))
   
print(sum(answers))
"
"import sys
p = sys.stdin.readline()
p = int(p)
o = p ** 3
print o"
"# -*- coding: utf-8 -*-

'''
A, B, C, K = map(int, input().split()) 

for i in range(K):
    a = A
    b = B
    c = C

    A = b + c
    B = a + c
    C = a + b

ans = A - B

if ans >= 10**8:
    ans = 'Unfair'
elif ans >*10**8:
    ans = 'Unfair'

print(ans)
'''



A, B, C, K= map(int, input().split())

if K%2==1: 
    ans = B - A
else:
    ans = A - B

if ans >= 10**18 or (-1)*ans >= 10**18:
    ans = 'Unfair'

print(ans)  

"
"n,m,l=map(int,input().split())
A = [list(map(int,input().split())) for _ in range(n)]
B = [list(map(int,input().split())) for _ in range(m)]
for nnum in range(n):
    temp=[]
    for lnum in range(l):
        ret = 0
        for mnum in range(m):
            ret +=(A[nnum][mnum]*B[mnum][lnum])
        temp.append(ret)
    print(*temp)"
"def main():
    S = input()
    gu = 0
    par = 0
    ans = 0
    for s in S:
        if s == 'g':
            if par < gu:
                ans += 1
                par += 1
            else:
                gu += 1
        else:
            if par < gu:
                par += 1
            else:
                ans -= 1
                gu += 1

    print(ans)



if __name__ == ""__main__"":
    main()"
"import sys
sys.setrecursionlimit(10**7)

MOD = 10**9+7

n, k = map(int, input().split())
to = [list() for _ in range(n)]
for _ in range(n-1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    to[a].append(b)
    to[b].append(a)

cnt = [0] * n
def dfs(v, p=-1):
    if p == -1:
        n_cnt = 1
    else:
        n_cnt = 2
    for u in to[v]:
        if u == p:
            continue
        cnt[u] = n_cnt
        n_cnt += 1
        dfs(u, v)
    return cnt

ans = 1
for i in dfs(0):
  ans *= max(0, k-i)
  ans %= MOD

print(ans)"
"#abc056 b 
w,a,b=map(int,input().split())
if a>b:
    tmp=a 
    a=b 
    b=tmp 
if b<a+w:
    print(0)
else:
    print(b-a-w)"
"h,w,n=map(int,input().split())
s=set()
l=[[0,0],[1,1],[1,-1],[-1,1],[-1,-1],[0,1],[0,-1],[1,0],[-1,0]]
ans=[(h-2)*(w-2),0,0,0,0,0,0,0,0,0]
for i in range(n):
    a,b=[int(j) for j in input().split()]
    s.add((a,b))
    for i,j in l:
        if a+i>=1 and a+i<=h and b+j>=1 and b+j<=w:
            c=0
            for p,q in l:
                if a+i+p>=1 and a+i+p<=h and b+j+q>=1 and b+j+q<=w:
                    if (a+i+p,b+j+q) in s:
                        c+=1
                else:
                    c=0
                    break
            if c!=0:
                ans[c-1]-=1
                ans[c]+=1

for i in range(10):
    print(ans[i])





"
"N = int(input())
print('ABD' if N // 1000 else 'ABC')
"
"from math import gcd

n, k = map(int, input().split())
a = list(map(int, input().split()))

num = 0
for ai in a:
    num = gcd(num, ai)
bool = (k % num) or (k > max(a))
print('IMPOSSIBLE' if bool else 'POSSIBLE')
"
"import math
N = int( input())
As  = [int(input())for _ in  range(N)]
ans = 0
for i in range(N):
    if As[i] > i or As[i] - As[i - 1] > 1:
        ans = -1
        break

    else:
        if As[i] == As[i -1] + 1:
            ans += 1
        else:
            ans += As[i]

print(ans)
"
"h, w = map(int, input().split())
ans = [[0 for _ in range(w)] for _ in range(h)]

for i in range(h):
    S = input()
    for j, s in enumerate(S):
        if s == ""#"":
            ans[i][j] = ""#""
            if i != 0:
                if ans[i - 1][j] != ""#"":
                    ans[i - 1][j] += 1
            if j != 0:
                if ans[i][j - 1] != ""#"":
                    ans[i][j - 1] += 1
            if i != 0 and j != 0:
                if ans[i - 1][j - 1] != ""#"":
                    ans[i - 1][j - 1] += 1
            if j != w - 1:
                if ans[i][j + 1] != ""#"":
                    ans[i][j + 1] += 1
            if j != w - 1 and i != 0:
                if ans[i - 1][j + 1] != ""#"":
                    ans[i - 1][j + 1] += 1
            if i != h - 1:
                if ans[i + 1][j] != ""#"":
                    ans[i + 1][j] += 1
            if i != h - 1 and j != w - 1:
                if ans[i + 1][j + 1] != ""#"":
                    ans[i + 1][j + 1] += 1
            if i != h - 1 and j != 0:
                if ans[i + 1][j - 1] != ""#"":
                    ans[i + 1][j - 1] += 1

for a in ans:
    print("""".join(map(str, a)))
"
"N,M=map(int,input().split())
Hlist=list(map(int,input().split()))
ABlist=[]
for _ in range(M):
    ABlist.append(list(map(int,input().split())))
flaglist=[1]*N
for row in ABlist:
    one=row[0]-1 #indexと番号の調整
    two=row[1]-1
    if Hlist[one]<=Hlist[two]:
        flaglist[one]=0
    if Hlist[one]>=Hlist[two]:
        flaglist[two]=0
print(sum(flaglist))"
"N = int(input())
P = list(map(int, input().split()))
min_n = N + 1
ans = 0
for pi in P:
    if pi <= min_n:
        ans += 1
        min_n = pi
print(ans)
"
"N = int(input())
N_str = str(N)

if '7' in N_str:
    print(""Yes"")
else:
    print(""No"")
"
"n = int(input())
h = list(map(int,input().split()))
c = 0
d = 0
for i in range(n):
    if h[i] >= d:
        c+=1
        d = h[i]
print(c)"
"# coding: utf-8
n = input()
print n**3"
"
def main():
    c = input()
    print(chr(ord(c)+1))

if __name__ == ""__main__"":
    main()"
"N = int(input().rstrip())
l = [int(v) for v in input().rstrip().split()]
r = 'APPROVED'
for v in l:
    if v % 2 == 1:
        continue

    if v % 3 == 0 or v % 5 == 0:
        pass
    else:
        r = 'DENIED'
        break#
        
print(r)

"
"n,x=map(int, input().split())
p=[1]*(n+1) #パティ
a=[1]*(n+1) #パティとバンズ

for i in range(1,n+1):
    p[i]=p[i-1]*2+1
    a[i]=a[i-1]*2+3

def f(n,x):
    if x==0:
        return 0
    if n==0:
        return 1
    
    center = a[n-1] + 2
    
    if x < center:
        return f(n-1,x-1)
    elif x >= center:
        return p[n-1] + 1 + f(n-1,x-center)

print(f(n,x))"
"N = int(input())
A = sorted(map(int, input().split()))

colors = [0] * 9
for a in A:
    idx = a // 400
    if idx >= 8:
        idx = 8
    colors[idx] += 1
ans = 0
for i in range(8):
    if colors[i] > 0:
        ans += 1
max_ans = ans
if colors[8] > 0:
    max_ans += colors[8]

if ans == 0 and max_ans > 0:
    ans += 1
print(ans, max_ans)"
"a,b,c = map(int,input().split())
print(""YNeos""[a+b<c ::2])"
"def m(L,R):
 T=[]
 for l in L[::-1]:
  while R and R[-1]>l:T+=[R.pop()]
  T+=[l]
 return R+T[::-1]
def d(A):
 l=len(A);global c;c+=l
 s=l//2;return m(d(A[:s]),d(A[s:]))if l>1 else A
c=-int(input())
print(*d(list(map(int,input().split()))))
print(c)
"
"am = int(input())
arr = list(map(int,input().split()))
if am == 1:
    print(0)
else:
    dp = [0,abs(arr[1]-arr[0])]
for i in range(2,am):
    dp.append(min(dp[i-2] + abs(arr[i]-arr[i-2]), dp[i-1] + abs(arr[i]-arr[i-1])))
print(dp[-1])"
"# --------- B -----------
a, b, c, d = map(int, input().split())
answer = max(a*c, a*d, b*c, b*d)
print(answer)"
"N = int(input())
a = list(map(int, input().split()))

c = 0
for i in range(N):
    if (i+1) % 2 == 1 and a[i] % 2 == 1:
        c += 1

print(c)

"
"a = list(map(int,input().split()))
A = a[0]
B = a[1]
C = a[2]
aa = input()
K = int(aa)

flag = 0
r = 0

while r <= K:
    if A < B:
        if B < C:
            flag = 1
            break
        else:
            C = C*2
            r = r + 1
    else:
        B = B*2
        r = r + 1
if flag == 0:
    print('No')
else:
    print('Yes')
"
"N=int(input())
ans=0
for i in range(N):
    L,R=map(int,input().split())
    ans+=R-L+1
print(ans)"
"N = int(input())
A = [int(input()) for _ in range(N)]

A = [0] + A
i = 1
k = 1
while k <= N:
    if A[i] == 2:
        print(k)
        exit()
    i = A[i]
    k += 1
print(-1)
"
"import sys
import itertools
# import numpy as np
import time
import math
 
sys.setrecursionlimit(10 ** 7)
 
from collections import defaultdict
 
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

N = int(readline())

dp = [0] * (N + 1)

for i in range(1, N + 1):
    x = i
    for j in range(2, i):
        while x % j == 0:
            x //= j
            dp[j] += 1
    if x != 1:
        dp[x] += 1
# dp = sorted(dp, reverse=True)

ans = 0
ans += any(x for x in dp if x >= 74)

x = 0
y = 0
for i in range(N + 1):
    if dp[i] >= 24:
        x += 1
    if dp[i] >= 2:
        y += 1
ans += x * (y - 1)

x = 0
y = 0
for i in range(N + 1):
    if dp[i] >= 14:
        x += 1
    if dp[i] >= 4:
        y += 1
ans += x * (y - 1)

x = 0
y = 0
z = 0
for i in range(N + 1):
    if dp[i] >= 4:
        x += 1
        y += 1
    if dp[i] >= 2:
        z += 1
ans += x * (y - 1) * (z - 2) // 2
# print(dp)
# print(x, y, z)

print(ans)"
"n=[x for x in input()]
if n[1]<n[2]:n[1]=str(int(n[1])+1)
if n[0]<n[1]:n[0]=str(int(n[0])+1)
print(n[0]*3)


"
"def invr():
    return(map(int, input().split()))


def insr():
    s = input()
    return(list(s[:len(s)]))


strs = []
a, b = invr()

for i in range(a):
    s = input()
    strs.append(s)
print(""#""*(b+2))
for s in strs:
    print(""#""+s+""#"")
print(""#""*(b+2))
"
"k,t = map(int,input().split())
a = list(map(int,input().split()))

a.sort()

print(max(0, a[-1] - sum(a[:-1]) - 1))
"
"from collections import deque

s=input()
s=s.replace(""BC"",""D"")
N=len(s)

cnt=0
cntA=0
cntD=0

for i in range(N):
  if s[i]==""A"":
    cntA += 1
  elif s[i]==""D"":
    cnt += cntA
  else:
    cntA=0
    cntD=0
    
print(cnt)"
"n,k = map(int,input().split())
a = list(map(int,input().split()))
mod = 10**9 + 7

ans = 0
for i in range(n):
    c_0 = 0
    c_1 = 0
    for j in range(n):
        if i == j:
            pass
        elif a[i] > a[j]:
            if i < j:
                c_1 += 1
            else:
                c_0 += 1      
    ans += c_1*k*(k+1)//2 + c_0*k*(k-1)//2
    ans %= mod
print(ans)"
"s= list(input())
w= int(input())
k=0
t=[]
while k*w<= int(len(s))-1:
  t.append(s[k*w])
  k+=1
  
u=''.join(t)
print(u)"
"X = int(input())

ureshi = 0

# 500 yen
ureshi += (X // 500) * 1000
X = X % 500

# 5 yen
ureshi += (X // 5) * 5

print(ureshi)"
"import math
A,B,C,D = (int(x) for x in input().split())
Num = B-A+1
Dup = C*D//math.gcd(C,D)
MinC  = (A+(C-A%C)%C)//C
MinD  = (A+(D-A%D)%D)//D
MinCD = (A+(Dup-A%Dup)%Dup)//Dup
OvrC  = (B+(C-B%C)%C)//C + (B%C==0)
OvrD  = (B+(D-B%D)%D)//D + (B%D==0)
OvrCD = (B+(Dup-B%Dup)%Dup)//Dup + (B%Dup==0)
CDNum = (OvrC-MinC)+(OvrD-MinD)-(OvrCD-MinCD)
print(Num-CDNum)"
"#float型を許すな
#numpyはpythonで
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)
from collections import Counter, deque
from collections import defaultdict
from itertools import combinations, permutations, accumulate, groupby, product
from bisect import bisect_left,bisect_right
from heapq import heapify, heappop, heappush
from math import floor, ceil,pi,factorial
from operator import itemgetter
def I(): return int(input())
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))
def LI2(): return [int(input()) for i in range(n)]
def MXI(): return [[LI()]for i in range(n)]
def SI(): return input().rstrip()
def printns(x): print('\n'.join(x))
def printni(x): print('\n'.join(list(map(str,x))))
inf = 10**17
mod = 10**9 + 7

n=I()
lis1=[]
lis2=[]
for i in range(n):
    a,b=MI()
    lis1.append(a)
    lis2.append(b)
lis1.sort()
lis2.sort()
if n%2==1:
    med1=lis1[n//2]
    med2=lis2[n//2]
    print(med2-med1+1)
if n%2==0:
    med1=lis1[n//2-1]+lis1[n//2]
    med2=lis2[n//2-1]+lis2[n//2]
    print(med2-med1+1)"
"s = input()
l = -1
r = -1
for i in range(len(s)):
    if s[i] == 'A' and l == -1:
        l = i
    elif s[i] == 'Z':
        r = i
print(r-l+1)"
"import fractions
import sys
from functools import reduce
import math

input = sys.stdin.readline


def main():
    n = int(input())
    a = input_list()
    print(gcd_list(a))

def get_camulative(l):
    import itertools
    # 累積和
    return [0] + list(itertools.accumulate(l))

def combinations_count(n, r):
    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))


def input_list():
    return list(map(int, input().split()))


def input_list_str():
    return list(map(str, input().split()))


def lcm_base(x, y):
    return (x * y) // fractions.gcd(x, y)


def lcm_list(numbers):
    return reduce(lcm_base, numbers, 1)


def gcd(*numbers):
    return reduce(fractions.gcd, numbers)


def gcd_list(numbers):
    return reduce(fractions.gcd, numbers)


if __name__ == ""__main__"":
    main()
"
"from collections import deque
def belman(s,n,w,es):
    d = [-float(""inf"")] * n #d[i] : s→iの最短距離
    d[s] = 0
    c = 0
    while True:
      update = False
      for p,q,r in es:
        if d[p] != -float(""inf"") and d[q] < d[p] + r:
          d[q] = d[p] + r
          update = True
          c += 1
        if c > w:
          return 'inf'
      if not update:
        break
    return d[n-1]

def use_path(n,start,es):
    q = deque()
    chk = [False] * n
    q.append(start)
    chk[start] = True
    used = {start}
    while len(q) > 0:
        node = q.popleft()
        for nex in es[node]:
            if not chk[nex]:
                chk[nex] = True
                q.append(nex)
                used.add(nex)
    return used

n,w = map(int,input().split())
es = []
l = [[] for i in range(n)]
r = [[] for i in range(n)]

for i in range(w):
    a,b,c = map(int, input().split())
    a -= 1
    b -= 1
    l[a].append(b)
    r[b].append(a)
    es.append((a,b,c))

use = use_path(n,0,l) & use_path(n,n-1,r)
ess = [(a,b,c) for a,b,c in es if a in use and b in use]
print(belman(0,n,w*2,ess))"
"from collections import defaultdict
n=int(input())
d=defaultdict(int)
for i in range(n):
    a=int(input())
    d[a]+=1

sm=0
for i,j in d.items():
    sm+=j%2

print(sm)"
"n = int(input())
l = list(map(int, input().split()))

res = float('inf')
total = sum(l)
w = 0
for i in range(n):
    w += l[i]
    res = min(abs(w - (total - w)), res)
print(res)"
"a,b,c = map(int,input().split())
n = int(input())
m = max(a,b,c)
def bai(x):
  return 2*x

for i in range(n):
  m = bai(m)

print(m-max(a,b,c) +a+b+c)"
"def main():
    from collections import Counter
    from heapq import heapify,heappop,heappush
    H,W = map(int,input().split())
    A = ''
    for i in range(H):
        A += input()
    A = list(A)
    num_chars = list(map(lambda x: -x, Counter(A).values()))
    heapify(num_chars)
    # H == 1 or W == 1

    for i in range((H//2)*(W//2)):
        num = heappop(num_chars)
        
        if -4 < num:
            print('No')
            return
        else:
            heappush(num_chars,num+4)

    if H & 1:
        for i in range(W//2):
            num = heappop(num_chars)
            if -2 < num:
                print('No')
                return
            else:
                heappush(num_chars,num+2)

    if W & 1:
        for i in range(H//2):
            num = heappop(num_chars)
            if -2 < num:
                print('No')
                return
            else:
                heappush(num_chars,num+2)

    print('Yes')
    return
    






main()"
"def Qb():
    ans = 'No'
    x, y = map(int, input().split())
    for b in range(0, x + 1):
        z = y - (4 * b)
        if z % 2 == 0 and x == (z / 2 + b):
            ans = 'Yes'
            break
    print(ans)


if __name__ == ""__main__"":
    Qb()
"
"N = int(input())
A = [int(x) for x in input().split()]
A.sort(reverse = True)

s = []
i = 0
while i < N - 1:
    if len(s) == 2:
        break
    if A[i] == A[i + 1]:
        s.append(A[i])
        i += 2
    else:
        i += 1

if len(s) == 2:
    print(s[0] * s[1])
else:
    print(0)"
"input_str = input() # ARC or ABC
if input_str == 'ARC':
  print('ABC')
else:
  print('ARC')"
"n = int(input())
a = list(map(int, input().split()))

money = 1000
for x, y in zip(a[:-1], a[1:]):
    if x < y:
        stocks = money // x
    else:
        stocks = 0
    money += (y - x) * stocks

print(money)"
"a, b = map(int, input().split())

tmp = 0
for i in range(1, 499501):
    tmp += i
    if i == b-a: print(tmp-b)"
"n,m,x=map(int,input().split())
a=list(map(int,input().split()))
a.sort(key=int)
down=0
up=0
for i in range(m):
  if n>=a[i]>x:
    up+=1
  elif a[i]<x:
    down+=1
print(min(up,down))"
"s = input()
if s.count(""A"") != 0 and s.count(""B"") != 0:
  print(""Yes"")
else:
  print(""No"")"
"from fractions import gcd
from functools import reduce


def lcm(a, b):
    return a * b // gcd(a, b)


N = int(input())
T = [int(input()) for _ in range(N)]

print(reduce(lcm, T))
"
"# coding: utf-8
import math
n = int(input())
#x, y = map(int,input().split())
A = list(map(int,input().split()))
ans = 0
B=  []
for i in range(n):
    B.append(A[i]-(i+1))
B.sort()
if n==1:
    m=B[0]
    m2=B[0]
else:
    m = B[n//2]
    m2=B[n//2+1]
tmp1=0
tmp2=0
#print(m,m2)
for i in range(n):
    tmp1 += abs(A[i]-(i+1)-m)
    tmp2 += abs(A[i]-(i+1)-m2)
print(min(tmp1, tmp2))"
"S = input()
N = len(S)
res = 0
cnt = 0
for i in range(N - 1, -1, -1):
    if S[i] == 'W':
        cnt += 1
    else:
        res += cnt
print(res)
"
"n,x=map(int,input().split())
A=list(map(int,input().split()))
A=sorted(A)
if x>sum(A):
    print(len(A)-1)
if x==sum(A):
    print(len(A))
if x<sum(A):
    ans=0
    for i in range(len(A)):
        if x>=A[i]:
            x-=A[i]
            ans+=1
        else:
            print(ans)
            break"
"import itertools
n,m=map(int,input().split())
path=[[] for i in range(n)]
for i in range(m):
  a,b=map(int,input().split())
  path[a-1].append(b-1)
  path[b-1].append(a-1)

res = 0
for case in itertools.permutations(range(n)):
  if case[0] != 0:
    continue
  for i in range(n-1):
    if case[i+1] not in path[case[i]]:
      break
  else:
    res+=1
print(res)"
"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

S = S()
N = len(S)
T = S[0:(N - 1) // 2]
U = S[(N + 3) // 2 - 1:N]
if S == S[::-1] and T == T[::-1] and U == U[::-1]:
    print('Yes')
else:
    print('No')
"
"""""""
Maze class.

cf. WarpableMaze class.
""""""
import sys
from collections import deque
from typing import List, Tuple


class Maze:
    __slots__ = [
        ""height"",
        ""width"",
        ""road"",
        ""wall"",
        ""is_unsearched"",
        ""is_unreachable"",
        ""dist"",
    ]

    def __init__(
        self,
        height: int,
        width: int,
        grid: List[bytes],
        *,
        road: str = ""."",
        wall: str = ""#"",
        is_unsearched: int = 1 << 30,
        is_unreachable: int = -1,
    ) -> None:
        self.height = height + 2
        self.width = width + 2
        self.road = road
        self.wall = wall
        self.is_unsearched = is_unsearched
        self.is_unreachable = is_unreachable
        self.dist = self._convert_grid_to_dist(grid)

    def _convert_grid_to_dist(self, grid: List[bytes]) -> List[int]:
        """"""Convert a 2D grid to a 1D dist.""""""
        dist = [self.is_unreachable] * self.height * self.width
        i = self.width
        for row in grid:
            for c in row.decode():
                i += 1
                if c == self.road:
                    dist[i] = self.is_unsearched
            i += 2
        return dist

    def _flatten_coordinate(self, x: int, y: int) -> int:
        """"""Flatten 2D coordinate values.
        Values of a coordinate must be 1-origin.
        """"""
        return self.width * x + y

    def bfs(
        self,
        start_2d: Tuple[int, int],
        goal_2d: Tuple[int, int],
        updates_dist: bool = False,
    ) -> int:
        """"""BFS to compute the distance from start to goal.
        Values of start_2d and goal_2d must be 1-origin.
        """"""
        start = self._flatten_coordinate(*start_2d)
        goal = self._flatten_coordinate(*goal_2d)

        moves = (-self.width, self.width, -1, 1)
        dist = self.dist[:]
        dist[start] = 0
        queue = deque([start])

        while queue:
            x = queue.popleft()
            cur_dist = dist[x]
            if x == goal:
                break

            for dx in moves:
                nx = x + dx
                if dist[nx] == self.is_unsearched:
                    dist[nx] = cur_dist + 1
                    queue.append(nx)

        if updates_dist:
            self.dist = dist
        return dist[goal] if dist[goal] != self.is_unsearched else self.is_unreachable

    def debug(self) -> None:
        """"""Show debugging information.""""""
        print(
            f""<DEBUG>\n""
            f""height={self.height}, width={self.width}\n""
            f""is_unsearched={self.is_unsearched}, is_unreachable={self.is_unreachable}"",
            file=sys.stderr,
        )

        convert = lambda x: self.road if x != self.is_unreachable else self.wall
        for row in zip(*[iter(self.dist)] * self.width):
            print(*map(convert, row), file=sys.stderr)


def abc007_c():
    # https://atcoder.jp/contests/abc007/tasks/abc007_3
    read = sys.stdin.buffer.read
    readline = sys.stdin.buffer.readline

    R, C = map(int, readline().split())
    (*start,) = map(int, readline().split())
    (*goal,) = map(int, readline().split())
    (*S,) = read().split()

    maze = Maze(R, C, S)
    print(maze.bfs(start, goal))


def abc088_d():
    # https://atcoder.jp/contests/abc088/tasks/abc088_d
    read = sys.stdin.buffer.read
    readline = sys.stdin.buffer.readline

    H, W = map(int, readline().split())
    (*S,) = read().split()
    maze = Maze(H, W, S)

    dist = maze.bfs((1, 1), (H, W))
    if dist != -1:
        res = H * W - sum((row.decode()).count(""#"") for row in S) - dist - 1
        print(res)
    else:
        print(-1)


if __name__ == ""__main__"":
    # abc007_c()
    abc088_d()
"
"s = input()
p = 10 ** 9 + 7
dp = [[0 for _ in range(13)] for j in range(len(s)+1)]
dp[0][0] = 1
for cnt, i in enumerate(reversed(s)):
	if i == ""?"":
		for f in range(10):
			k = pow(10, cnt, 13)*f%13
			for j in range(13):
				dp[cnt+1][(j+k)%13] = (dp[cnt+1][(j+k)%13] + dp[cnt][j])%p
	else:
		targ = int(i)
		k = pow(10, cnt, 13)*targ%13
		for j in range(13):
			dp[cnt+1][(j+k)%13] = (dp[cnt+1][(j+k)%13] + dp[cnt][j])%p
#print(dp)
print(dp[len(s)][5])"
"K, N = map(int, input().split(' '))
A_ls = list(map(int, input().split(' ')))
rst = 0
for i in range(N):
    l = A_ls[(i + 1) % len(A_ls)] - A_ls[i]
    if l < 0:
        l = A_ls[(i + 1) % len(A_ls)] + K - A_ls[i]
    rst = max(rst, l)
print(K - rst)"
"x,a,b = (int(i) for i in input().split())
print(""A"" if abs(x-a) < abs(x-b) else ""B"")"
"s = list(input())
l = int(input())
s1 = sorted(s)
ans = set()

for i in range(len(s)):
    sta = s1[i]
    for j in range(len(s)):
        if s[j] == sta:
            ans.add(s[j])
            check = s[j]
            for k in range(j+1,min(len(s),j+5)):
                check = check+s[k]
                ans.add(check)
    if len(ans) >= l:
        ans1 = sorted(ans)
        print(ans1[l-1])
        exit()
ans1 = sorted(ans)
print(ans1[l-1])"
"num = input()
if len(num) == 2:
    print(num)
elif len(num) == 3:
    print(num[::-1])
"
"n,c,k=map(int,input().split())
t=[]
for i in range(n):
    t.append(int(input()))
t.sort()

bus=0
wait_p=0
first_t=-1

for i in range(n):
    ti=t[i]
    if(first_t==-1):
        first_t=ti

    wait_p+=1

    if(ti > first_t+k):
        bus+=1
        first_t=ti
        wait_p=1

    if(wait_p >= c):
        bus+=1
        first_t=-1
        wait_p=0


if(first_t!=-1 or wait_p > 0):
    bus+=1

print(bus)
"
"N = int(input())
A = [list(map(int, input().split())) for _ in range(N)]
ans = 0
for i in range(N-1, -1, -1):
    ans += (A[i][1] - (A[i][0]+ans) % A[i][1]) % A[i][1]
print(ans)
"
"import sys
import queue

n=int(input())

clis=[[] for i in range(n)]

for i in range(n-1):
  ai,bi,ci=map(int,input().split())
  clis[ai-1].append([bi,ci])
  clis[bi-1].append([ai,ci])

q,k=map(int,input().split())

xy=[]

for i in range(q):
  xy.append(list(map(int,input().split())))


distance=[0 for i in range(n)]
seen=[0 for i in range(n)]

que=queue.Queue()

que.put(k)
seen[k-1]=1

while not que.empty():
  c=que.get()
  for aa,cc in clis[c-1]:
    if seen[aa-1]==0:
      distance[aa-1]=distance[c-1]+cc
      seen[aa-1]=1
      que.put(aa)

for i in range(q):
  print(distance[xy[i][0]-1]+distance[xy[i][1]-1])"
"from collections import Counter,defaultdict,deque
from heapq import heappop,heappush,heapify
import sys,bisect,math,itertools,fractions,pprint
sys.setrecursionlimit(10**8)
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n,k = inpl()
res = 1
for i in range(n):
    if i == 0:
        res *= k
    else:
        res *= k-1
print(res)"
"n,_,*a=map(int,open(0).read().split())
ref={1:2,2:5,3:5,4:4,5:5,6:6,7:3,8:7,9:6}
dp=[0]+[-float('inf')]*(n+9)
for i in range(n+1):
	for x in a:
		if dp[i]<dp[i-ref[x]]*10+x:
			dp[i]=dp[i-ref[x]]*10+x
print(dp[n])"
"sente=""""
while True:
    try:
        t=input().lower()
        sente = sente+t
    except:
        break
for i in range(97,123):
    print(chr(i),"":"",sente.count(chr(i)))"
"n=int(input())
q=0
ans=1
for i in range(1,n+1):
    m=i
    p=0
    while(m%2==0):
        m//=2
        p+=1
    if q!=max(q,p):
        ans=i
        q=max(q,p)
print(ans)"
"# まあできるだけ小さい単位で割ったほうが嬉しいので、素因数分解して因数で割ったほうがうれしい
# ただし以前つかったやつは使えないので、x^1, x^2, x^3... に限定されてしまう
# -> 冪数を増やしていく感じでいけそう

n = int(input())


def div_primes(x):
    ret = {}
    for i in range(2, int(x**0.5) + 1):
        tmp = 0
        while x % i == 0:
            tmp += 1
            x /= i
        if tmp > 0:
            ret[i] = tmp

    if x > 1:
        ret[x] = 1
    return ret


primes = div_primes(n)
ans = 0
for k, v in primes.items():
    j = 1
    while v - j >= 0:
        v -= j
        j += 1
        ans += 1
print(ans)"
"print({""SU"":7,""MO"":6,""TU"":5,""WE"":4,""TH"":3,""FR"":2,""SA"":1}[input()[:2]])"
"def main():
  n = int(input())
  ans = 0
  for i in range(1, n):
    ans += (n-1)//i
  print(ans)

if __name__ == ""__main__"":
  main()"
"N, H, W = (int(i) for i in input().split())
set = [[int(i) for i in input().split()] for i in range(N)]
cnt = 0
for i in range(N):
    cnt += 1 if set[i][0]>=H and set[i][1]>=W else 0
print(cnt)"
n=int(input());print(int(n*(n-1)//2))
"def abc():
    n = int(input())
    print('ABC' if n < 1200 else 'ARC')


abc()
"
"import sys
import heapq

input = sys.stdin.readline


def main():

    N = int(input())
    nb = [[] for _ in range(N)]
    for i in range(N - 1):
        a, b, c = map(int, input().split())
        a -= 1
        b -= 1
        nb[a].append((c, b))
        nb[b].append((c, a))
    for x in nb:
        x.sort()

    Q, K = map(int, input().split())
    K -= 1

    dist = [2 ** 62] * N
    h = [(0, K, -1)]
    while h:
        d0, node, parent = heapq.heappop(h)
        if d0 >= dist[node]:
            continue
        dist[node] = d0
        for d1, child in nb[node]:
            if child != parent and d0 + d1 < dist[child]:
                heapq.heappush(h, (d0 + d1, child, node))

    for i in range(Q):
        x, y = map(int, input().split())
        # print(f""{x}->K = {dist[x]}, K->{y} = {dist[y]}"")
        print(dist[x - 1] + dist[y - 1])


if __name__ == ""__main__"":
    main()
"
"n = int(input())
p = list(map(int, input().split()))

ans = 0

for i in range(n-2):
    #比較する3つのｐの値
    buf = p[i:i+3]
    #真ん中の数値
    buf1 = buf[1]
    
    buf.sort()
    if buf[1] == buf1:
        ans += 1
    #print(buf)

print(ans)"
"# vim: fileencoding=utf-8


def main():
    n = int(input())
    li = list(map(int, input().split()))
    c = 0
    end = False
    while True:
        for i in range(n):
            if li[i] % 2:
                end = True
                break
            li[i] = li[i] / 2
        if end:
            break
        else:
            c += 1
    print(c)


if __name__ == ""__main__"":
    main()
"
"sample = input() # two numbers in a string
new_sample = sample.split("" "")

ball = int(new_sample[0]) # number of balls
color = int(new_sample[1]) # number of colors
if ball > 1 and color == 1:
  print(0)
else:
  product = color
  for i in range(1, ball):
    product *= (color-1)
  print(product)

  
# 3 balls, 10 colors
# 1st spot, 10 choices
# 2nd spot, 9 choices
# 3rd spot, 9 choices
"
"A, B, K = list(map(int, input().split()))
Co = [A, B]

for i in range(K):
  if Co[i % 2] % 2 == 1:
    Co[i % 2] -= 1
  Co[i % 2] /= 2
  Co[(i+1) % 2] += Co[i % 2]

Co = list(map(int, Co))
print(Co[0], Co[1])"
"import collections
N, K = map(int, input().split())
A_list = list(map(str,input().split()))

ans = 0
c = collections.Counter(A_list)
if K >= len(c):
    ans = 0
else:
    foo = len(c)-K
    bar_list = list(c.values())
    bar_list.sort()
    for i in range(foo):
        ans += bar_list[i]

print(ans)"
"import sys

input = sys.stdin.read

def main(H, N, tmp):
    damage = tmp[::2]
    magic = tmp[1::2]
    DP = [float('inf')] * 20001
    DP[0] = 0
    for i in range(20001):
        for j in range(N):
            s = i - damage[j]
            if s >= 0:
                DP[i] = min(DP[i], DP[s] + magic[j])
    return min(DP[H:])


if __name__ == ""__main__"":
    H, N, *tmp = map(int, input().split())
    ans = main(H, N, tmp)
    print(ans)
"
"X = int(input())
n = 1
if X<=3:
    print(1)
elif X==4:
    print(4)
else:
    n = 4
    for i in range(2,int(X**0.5)+1):
        b = i
        k = 1
        while b**k<=X:
            k += 1
        k -= 1
        if k>=2:
            n = max(n,b**k)
    print(n)"
"A, B = map(int, input().split())
print(A + B) if A + B < 10 else print(""error"")
"
"n = int(input())
l = list(map(int, input().split()))
c = {}
for i in range(n):
  c[l[i]] = i + 1
c = sorted(c.items())
[print(s[1], end="" "") for s in c]
"
"import sys

sys.setrecursionlimit(10 ** 8)
ini = lambda: int(sys.stdin.readline())
inm = lambda: map(int, sys.stdin.readline().split())
inl = lambda: list(inm())
ins = lambda: sys.stdin.readline().rstrip()
debug = lambda *a, **kw: print(""\033[33m"", *a, ""\033[0m"", **dict(file=sys.stderr, **kw))

a, b = inm()
print(a * b)
"
"N,M = map(int, input().split())
scorebook = [[] for _ in range(N)]
for i in range(M):
    p,S = input().split()
    p = int(p)-1
    scorebook[p].append(S)
maru = 0
batu = 0
for score in scorebook:
    try:
        batu += score.index(""AC"")
        maru += 1
    except:
        pass
print(maru, batu)"
"A, B, C, D = map(int, input().split())

a = A * B
b = C * D
c = [a, b]
print(max(c))"
"H, W = map(int, input().split())
for h in range(H):
    c = input().strip()
    print(c)
    print(c)
"
"#!/usr/bin/env python3
import string


def main():
    S = input()
    S_temp = S
    ans_temp = 'zyxwvutsrqponmlkjihgfedcba'
    for i in range(len(S) + 1):
        for c in string.ascii_lowercase:
            if c not in S[:i]:
                S_temp = S[:i] + c
                if S < S_temp:
                    break
        if S < S_temp and S_temp < ans_temp:
            ans_temp = S_temp
    print(ans_temp if S < ans_temp else -1)


if __name__ == ""__main__"":
    main()
"
"def main():
    import sys
    input = sys.stdin.readline
    sys.setrecursionlimit(10**7)
    from collections import Counter, deque
    #from collections import defaultdict
    from itertools import combinations, permutations, accumulate, groupby, product
    from bisect import bisect_left,bisect_right
    from heapq import heapify, heappop, heappush
    from math import floor, ceil
    #from operator import itemgetter

    #inf = 10**17
    #mod = 10**9 + 7

    n = int(input())
    print(n*(n+1)//2)

if __name__ == '__main__':
    main()"
"N = int(input())
D = list(map(int, input().split()))
MOD = 998244353

#以下が an mod p を求めるソースコードです.
def power_func(a, n, p):
    res = 1 #これは答え
    while n > 0:
        if n & 1:
            res = res * a % p
        a = a * a % p #1が立っているかどうかに関わらず次のaの累乗を用意しておく
        n = n >> 1
    return res

bucket = [0] * (max(D) + 1)
for dist in D:
    bucket[dist] += 1
# print(bucket)

if bucket[0] != 1 or D[0] != 0:
    print(0)
else:
    ans = 1
    for i in range(len(bucket) - 1):
        ans = (ans * power_func(bucket[i], bucket[i + 1], MOD)) % MOD
    print(ans)
"
"import math

r=float(input().strip())
print('{0:5f} {1:5f}'.format(r**2*math.pi,2*r*math.pi))
"
"n = int(input())
RED, BLUE = [], []
for _ in range(n):
    RED.append(tuple(map(int, input().split())))
for _ in range(n):
    BLUE.append(tuple(map(int, input().split())))

RED = sorted(RED, key=lambda x: x[0], reverse=True)

count = 0
for r in RED:
    for b in sorted(BLUE, key=lambda x: x[1]):
        if r[0] <= b[0] and r[1] <= b[1]:
            BLUE.remove(b)
            count += 1
            break
    
print(count)"
"X,Y,Z = map(int, input().split())
ans = X//(Y+Z) - 1
if ans*(Y+Z)+(Y+Z+Z) <= X: ans += 1
print(ans)"
"x,y,z = map(int,input().split())
i = 1
while(y+z*2+(z+y)*i <= x):
    i += 1
print(i)"
"n = int(input())
base_li = [0]*n

for i in range(n):
    l, p = input().split()
    base_li[i] = [i+1, (l, -int(p))]

sl = sorted(base_li, key=lambda w: w[1])
for c in sl:
    print(c[0])
"
"A, B, C = map(int, input().split())
while B != 0:
  A, B = B, A % B
print('YES' if C % A == 0 else 'NO')"
"N = int(input())
x = N%10
Lpon = [0,1,6,8]

if x == 3:
  print(""bon"")
elif x in Lpon:
  print(""pon"")
else:
  print(""hon"")"
"from collections import Counter


def solve(string):
    n, *aqbc = map(int, string.split())
    a, _, bc = aqbc[:n], aqbc[n], aqbc[n + 1:]
    s = sum(a)
    t = Counter(a)
    ans = []
    for b, c in zip(*[iter(bc)] * 2):
        s += (c - b) * t[b]
        t[c] += t[b]
        t[b] = 0
        ans.append(s)
    return ""\n"".join(map(str, ans))


if __name__ == '__main__':
    import sys
    print(solve(sys.stdin.read().strip()))
"
"import math
a, b = map(str, input().split( ))
A = int(a+b)

if math.sqrt(A).is_integer() == True:
    print(""Yes"")
else:
    print(""No"")"
"import sys
 
n, k = map(int, input().split())
a = [int(x) for x in input().split()]
mod = pow(10, 9)+7
zero = 0
plus = []
minus = []
for i in range(n):
  if a[i] == 0:
    zero += 1
  elif a[i] > 0:
    plus.append(a[i])
  else:
    minus.append(a[i])
 
P, M = len(plus), len(minus)
plus.sort(reverse=True)
minus.sort()
ans = 1
if n == k:
  for i in range(n):
    ans *= a[i]
    ans %= mod
elif P+M < k:
  ans = 0
elif P == 0 and k%2 ==1 :
  if zero >= 1:
    ans = 0
  else:
    minus.sort(reverse=True)
    for i in range(k):
      ans *= minus[i]
      ans %= mod
else:
  q = 0
  if k%2 == 1:
    ans *= plus[0]
    q = 1
  judge = []
  for i in range((P-q)//2):
    judge.append(plus[2*i+q]*plus[2*i+q+1])
  for i in range(M//2):
    judge.append(minus[2*i]*minus[2*i+1])
  judge.sort(reverse=True)
  for i in range(k//2):
    ans *= (judge[i]%mod)
    ans %= mod
 
print(ans)"
"n=int(input())
a = [int(i) for i in input().split()]
ans = 0
b = 0
j = -1
for i in a:
    if i != j:
        ans += b // 2
        b=1
    else:
        b += 1
    j = i
ans += b // 2

print(ans)"
"def main():
    s = input()
    print('Yes' if s[0] == s[-1] else 'No')


if __name__ == '__main__':
    main()
"
"n = int(input())
s = input()
t = input()
duplicates = 0
for i in range(n):
    if s[-(i + 1):] == t[:i + 1]:
        duplicates = i + 1
temp = s + t[duplicates:]
print(len(temp)) "
"import math
def is_prime(n):
    if n == 1: return False

    for k in range(2, int(math.sqrt(n)) + 1):
        if n % k == 0:
            return False

    return True
s=[]
n=int(input())
for i in range(2,55555):
    if is_prime(i)==True:
        if i%5==1:
            s.append(i)
print(' '.join(map(str, s[:n])))"
"A, B, C=map(int, input().split("" ""))
candidate=[(A*i)%B for i in range(1, B-1)]

if C in candidate:
  print('YES')
else:
  print('NO')"
"N=int(input())
S=list(input())
ans=0
for i in range(N-2):
    if S[i]==""A"" and S[i+1]==""B"" and S[i+2]==""C"":
        ans+=1
print(ans)"
"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

N, M = map(int, input().split())
f_uf = UnionFind(N)
for _ in range(M):
  a, b = map(int, input().split())
  f_uf.union(a-1, b-1)
answer = 1
for i in range(N):
  answer = max(answer, f_uf.size(i))
print(answer)
"
"from functools import reduce

def binom(n, r):
    if n < r or n < 0 or r < 0: return 0
    
    if n - r < r: r = n - r
    if r == 0: return 1
    elif r == 1: return n

    numerator = [n - r + 1 + k for k in range(r)]  # (n-r+1)*(n-r+2)*...*(n-1)*n
    denominator = [1+ k for k in range(r)]         # 1*2*...*(r-1)*r

    # reduce prod(numerator)//prod(denominator)
    for p in range(2, r+1):
        pivot = denominator[p - 1]
        if pivot > 1:
            offset = (n - r) % p
            for k in range(p-1, r, p):
                numerator[k - offset] //= pivot
                denominator[k] //= pivot
    
    # calculate nCr
    return reduce(lambda x, y: x*y, numerator)


N, A, B = map(int, input().split())
*V, = map(int, input().split())
V = sorted(V, reverse=True)
ans = 0
ways = 0
if len(set(V[:A])) == 1:
    ans = V[0]
    n = V.count(ans)
    for i in range(A, min(B, n)+1): ways += binom(n, i)
else:
    ans = sum(V[:A]) / A
    min_num = min(V[:A])
    n_min = V.count(min_num)
    n_min_lst = V[:A].count(min_num)
    ways = binom(n_min, n_min_lst)
print(ans)
print(ways)"
"n = int(raw_input())
 
info = [[[0 for i in range(10)] for j in range(3)] for k in range(4)]
 
for i in range(n):
    b, f, r, v = map(int, raw_input().split())
    b, f, r = b-1, f-1, r-1
    info[b][f][r] += v
 
sharp = False
for i in info:
    if sharp:
        print ""#"" * 20
    for j in i:
        print "" ""+"" "".join(map(str, j))
    sharp = True"
"S = input()
ans = 0
tmpl = 0
tmpr = 0
for i in range(len(S) - 1):
  if S[i] == '<':
    tmpl += 1
  else:
    tmpr += 1
    if S[i + 1] == '<':
      x = max(tmpl, tmpr)
      y = min(tmpl, tmpr)
      ans += (1 + x) * x // 2 + y * (y - 1) // 2
      tmpl = 0
      tmpr = 0

if S[-1] == '<':
  tmpl += 1
else:
  tmpr += 1
x = max(tmpl, tmpr)
y = min(tmpl, tmpr)
ans += (1 + x) * x // 2 + y * (y - 1) // 2
print(ans)"
"from collections import deque
n = int(input())
data = [None]*n
for _ in range(n):
    a,*b = map(int,input().split())
    a -= 1
    data[a] = [i-1 for i in b[1:]]
d = [-1]*n
dq = deque([(0,0)])
while dq:
    p,q = dq.popleft()
    if d[p] == -1:
        d[p] = q
        for i in data[p]:
            dq.append((i,q+1))
for i,j in enumerate(d):
    print(i+1,j)
"
"n = input()
print('YNeos'[n!=n[::-1]::2])"
"s = int(input())
print(""{0}:{1}:{2}"".format(s // 3600,( s % 3600 ) // 60,s % 60))
"
"n, k = map(int, input().split())
mod = 10**9+7

def cmb1(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    r = min(r, n-r)
    return g1[n] * g2[r] * g2[n-r] % mod

mod = 10**9+7 #出力の制限
N = 10**5
g1 = [1, 1] # 元テーブル
g2 = [1, 1] #逆元テーブル
inverse = [0, 1] #逆元テーブル計算用テーブル

for i in range( 2, N + 1 ):
    g1.append( ( g1[-1] * i ) % mod )
    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2.append( (g2[-1] * inverse[-1]) % mod )

for i in range(1, k+1):
    ans = cmb1(n-k+1, i, mod)*cmb1(k-1, i-1, mod)
    ans %= mod
    print(ans)
"
"a,b = map(int,input().split())
if b % a == 0:
    print(a + b)
elif b % a != 0:
    print(b - a)"
"import itertools

n = int(input())
p = tuple(map(int, input().split()))
q = tuple(map(int, input().split()))

a = b = None

for i, x in enumerate(itertools.permutations(range(1, n+1), n)):
	if p == x:
		a = i
		if b:
			break
		
	if q == x:
		b = i
		if a:
			break
			
print(abs(a - b))
"
"odd=[""R"",""U"",""D""]
even=[""L"",""U"",""D""]
S=input()
i=0
for x in range(len(S)):
  if x%2==0 and S[x] in odd:
    i+=1
  elif x%2==1 and S[x] in even:
    i+=1
if i==len(S):
  print(""Yes"")
else:
  print(""No"")"
"def resolve():
    from collections import deque
    n = int(input())
    que = deque()
    for _ in range(n):
        cv = input().split()
        if cv[0] == ""insert"":
            x = int(cv[1])
            que.appendleft(x)
        elif cv[0] == ""delete"":
            x = int(cv[1])
            if x in que:
                que.remove(x)
        elif cv[0] == ""deleteFirst"":
            que.popleft()
        elif cv[0] == ""deleteLast"":
            que.pop()
    ans = list(que)
    print(*ans)


resolve()

"
"MOD = 1000000007


def mod_pow(a, n, mod):
    """"""
    二分累乗法による a^n (mod m)の実装

    :param a: 累乗の底
    :param n: 累乗の指数
    :param mod: 法
    :return: a^n (mod m)
    """"""

    result = 1
    a_n = a
    while n > 0:
        if n & 1:
            result = result * a_n % mod
        a_n = a_n * a_n % mod
        n >>= 1
    return result


def mod_inverse(a, mod):
    """"""
    フェルマーの小定理による a^-1 ≡ 1 (mod m)の実装
    aの逆元を計算する

    a^-1 ≡ 1 (mod m)
    a * a^-2 ≡ 1 (mod m)
    a^-2 ≡ a^-1 (mod m)

    :param a: 逆元を計算したい数
    :param mod: 法
    :return: a^-1 ≡ 1 (mod m)
    """"""

    return mod_pow(a=a, n=mod - 2, mod=mod)


class ModCombination:
    """"""
    nCk (mod m)を扱うクラス
    """"""

    def __init__(self, mod, n_max):
        """"""
        イニシャライザ
        予め 1~nの階乗と階乗の逆元を計算しておく

        :param mod: 法
        :param n_max: nの最大値(100,000で約1秒)
        """"""
        self.mod = mod
        self.n_max = n_max
        self.facts = [1, 1]
        self.inverses = [None, 1]
        self.fact_inverses = [1, 1]

        for i in range(2, self.n_max + 1):
            self.facts.append(self.facts[i - 1] * i % self.mod)
            # self.inverses.append(mod_inverse(i, self.mod))
            self.inverses.append(self.mod - self.inverses[self.mod % i] * (
                        self.mod // i) % self.mod)
            self.fact_inverses.append(
                self.fact_inverses[i - 1] * self.inverses[i] % self.mod
            )

    def mod_combination(self, n, k):
        """"""
        nCk (mod m)を計算する

        :param n: n
        :param k: k
        :return: nCk (mod m)
        """"""
        if not 0 < k < n:
            raise ValueError

        denominator = \
            self.fact_inverses[k] * self.fact_inverses[n - k] % self.mod
        return self.facts[n] * denominator % self.mod


def calc_routes(combination, dx, dy):
    if dx == 0 or dy == 0:
        return 1
    else:
        return combination.mod_combination(dx + dy, dx)


def check(h, w, a, b):
    combination = ModCombination(mod=MOD, n_max=h + w)
    p = (b + 1, h - a)
    all_routes = 0
    while p[0] <= w and p[1] > 0:
        d1 = (p[0] - 1, p[1] - 1)
        d2 = (w - p[0], h - p[1])
        r1 = calc_routes(combination, *d1)
        r2 = calc_routes(combination, *d2)
        routes = r1 * r2 % MOD
        all_routes += routes
        all_routes %= MOD
        p = (p[0] + 1, p[1] - 1)
    return all_routes


def main():
    h, w, a, b = map(int, input().split())
    print(check(h, w, a, b))


if __name__ == '__main__':
    main()
"
"n,m = map(int, input().split())
ab = [list(map(int, input().split())) for _ in range(m)]
start = []
goal = []
for a,b in ab:
    if a == 1: start.append(b)
    elif b == n: goal.append(a)
print(""POSSIBLE"" if list(set(start) & set(goal)) else ""IMPOSSIBLE"")"
"import collections
import math

N = int(input())
N = math.factorial(N)
INF = 10 ** 9 + 7

def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a

res = collections.Counter(prime_factorize(N))
keys = list(res.keys())
length = len(keys)
ans = 1
for i in range(length):
    ans = (ans * (res[keys[i]] + 1)) % INF
print(ans)"
"a,b=map(int,input().split())
c=a-1
d=b-1
print(c*d)"
"n = int(input())

ans = 0
for k in range(1, int(n**(1/2))+1):
    m = (n - k) // k
    if m <= 0: continue
    if n // m == n % m:
        ans += m

print(ans)
"
"s = int(input())
sec = min = hour = 0
sec = s%60
if s >= 60:
    min = int(s/60)
    if min >= 60:
        hour = int(min/60)
        min = min%60
print(str(hour) + ':' + str(min) + ':' + str(sec))

"
"n = int(input())
ai = [int(i) for i in input().split()]

is_odd = True

if n % 2 == 0:
    is_odd = False

if is_odd == True:
    dp = [[0 for i in range(3)] for j in range(n)]
else:
    dp = [[0 for i in range(2)] for j in range(n)]

if n == 3:
    print(max(ai[0],ai[2],ai[1]))
    exit()
elif n == 2:
    print(max(ai[0],ai[1]))
    exit()
    

if is_odd == True:
    dp[0][0] = ai[0]
    dp[1][1] = ai[1]
    dp[2][0] = ai[0]+ai[2]
    dp[2][2] = ai[2]
    dp[3][1] = max(ai[0]+ai[3],ai[1]+ai[3])    
    for i in range(4,n):
        dp[i][0] = dp[i-2][0]+ai[i]
        dp[i][1] = max(dp[i-2][1]+ai[i],dp[i-3][0]+ai[i])
        dp[i][2] = max(dp[i-4][0]+ai[i],dp[i-3][1]+ai[i],dp[i-2][2]+ai[i])
    print(max(dp[n-3][0],dp[n-2][1],dp[n-1][2]))
else:
    dp[0][0] = ai[0]
    dp[1][1] = ai[1]
    dp[2][0] = ai[0]+ai[2]       
    for i in range(n):
        dp[i][0] = dp[i-2][0]+ai[i]
        dp[i][1] = max(dp[i-2][1]+ai[i],dp[i-3][0]+ai[i])
    print(max(dp[n-2][0],dp[n-1][1]))

"
"import sys
import math
from collections import deque

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()


def main():
    N = NI()
    A = NLI()
    nowRGB = [0, 0, 0]
    ans = 1
    for a in A:
        ans *= nowRGB.count(a) % MOD
        for i in range(3):
            if nowRGB[i] == a:
                nowRGB[i] += 1
                break

    print(ans%MOD)



if __name__ == ""__main__"":
    main()"
"input()
s = input().split()
print('Four' if len(set(s))==4 else 'Three')"
"import collections

def main():
    n,m = map(int,input().split())
    g = [[] for _ in range(n+1)]
    for _ in range(m):
        a,b=map(int,input().split())
        g[a].append(b)
        g[b].append(a)

    check = [0]*(n+1)
    ans = [0]*(n+1)
    q = collections.deque()
    q.append(1)
    check[1] = 1

    while len(q) != 0:
        v = q.popleft()
        for u in g[v]:
            #print(u)
            if check[u] == 0:
                check[u] = 1
                ans[u] = v
                q.append(u)

    for i in range(2,n+1):
        if ans[i] == 0:
            print('No')
            return

    print('Yes')
    for i in range(2,n+1):
        print(ans[i])

main()
"
"n, l = map(int, input().split())
apple = list(range(l, l + n))
ans = 0
if 0 in apple:
  ans = sum(apple)
elif abs(apple[0]) < abs(apple[-1]):
  ans = sum(apple[1:])
else:
  ans = sum(apple[:-1])
print(ans)"
"a, b ,c= [(input()) for i in range(3)]
print(a[0]+b[1]+c[2])"
"N,C = list(map(int,input().split()))

discomforts = [[0]*(N+1)]
for _ in range(C):
    row = [0]
    row.extend(list(map(int,input().split())))
    discomforts.append(row)
grid = [[0]*(N+1)]
for _ in range(N):
    row = [0]
    row.extend(list(map(int,input().split())))
    grid.append(row)

color_counts = [[0]*(C+1) for i in range(3)]

for i in range(1,N+1):
    for j in range(1,N+1):
        color_counts[(i+j)%3][grid[i][j]] += 1

ans = float('inf')
for c0 in range(1,C+1):
    for c1 in range(1,C+1):
        for c2 in range(1,C+1):
            if c0 != c1 and c1 != c2 and c2 != c0:
                total = 0
                for i in range(1,C+1):
                    total += discomforts[i][c0]*color_counts[0][i]
                    total += discomforts[i][c1]*color_counts[1][i]
                    total += discomforts[i][c2]*color_counts[2][i]
                ans = min(ans,total)
print(ans)"
"S  = input()
tmp = S[5:7]
if tmp ==""01"" or tmp ==""02"" or tmp ==""03"" or tmp ==""04"":
    print(""Heisei"")
else:
    print(""TBD"")
"
print('No'if int(input())%9 else'Yes')
"H, W, K = map(int, input().split())
s = []
for _ in range(H):
    *row, = map(int, input())
    s.append(row)

ret = H * W
for bits in range(1 << (H - 1)):
    # 水平カットで生成される2枚目以降の開始行
    # 0行目は確定で, 残りのカットを調べる
    # 次の変換が必要
    # [0,H) -> [1,H]

    group = [0] * H
    for j in range(H - 1):
        group[j + 1] = group[j] + (1 if (bits >> j) & 1 else 0)
    # group = [0,0,1,1,1,2,...]

    ctr = [0] * H
    add_v = [0] * H
    c, pc = 0, -1
    cut = bin(bits).count('1')
    while c < W:
        need_cut = False
        for r in range(H):
            g = group[r]
            add_v[g] += s[r][c]
            if ctr[g] + add_v[g] > K:
                need_cut = True
                break

        if need_cut:
            if pc == c:
                cut = H * W
                break
            ctr = [0] * H
            add_v = [0] * H
            cut += 1
            pc = c
            if cut >= ret:
                break
            continue

        for g, _add_v in enumerate(add_v):
            ctr[g] += _add_v
        add_v = [0] * H
        pc = c
        c += 1

    ret = min(ret, cut)

print(ret)
"
"X,Y = map(int, input().split())

ans = 1
while X*2 <= Y:
    X *= 2
    ans += 1

print(ans , flush=True)
"
"s=input()

a=[1,0,0,0]

for i in range(len(s)):
    c=s[i]
    if c==""A"":
        a[1]=(a[1]+a[0])%1000000007
    elif c==""B"":
        a[2]=(a[2]+a[1])%1000000007
    elif c==""C"":
        a[3]=(a[3]+a[2])%1000000007
    elif c==""?"":
        tmp=[a[i] for i in range(4)]
        a[0]=tmp[0]*3
        for j in range(3):
            a[j+1]=tmp[j+1]*3+tmp[j]
        a=list(map(lambda x: x%1000000007,a))

    
print(a[3]%1000000007)"
"import sys
from sys import exit
from collections import deque
from bisect import bisect_left, bisect_right, insort_left, insort_right #func(リスト,値)
from heapq import heapify, heappop, heappush
from math import *

sys.setrecursionlimit(10**6)
INF = 10**20
MOD = 10**9+7

def mint():
    return map(int,input().split())
def lint():
    return list(map(int,input().split()))
def judge(x, l=['Yes', 'No']):
    print(l[0] if x else l[1])
def lprint(l, sep='\n'):
    for x in l:
        print(x, end=sep)

R,G,B,N = mint()
ans = 0
for r in range(N//R+1):
    for g in range(N//G+1):
        tmp = N-R*r-G*g
        if tmp>=0 and tmp%B==0:
            ans += 1
print(ans)"
"n=int(input())
l=list(map(int,input().split()))
c=0
for i in l:
    c+=i-1
print(c)"
"f, *n = str(int(input())+1)
print(int(f) + 9*len(n) - 1)"
"def is_prime(x):
    if x == 2:
        return True
    if x < 2 or x%2==0:
        return False
    i = 3
    while i <= x**(0.5):
        if x%i==0:
            return False
        i+=2
    return True

if __name__=='__main__':
    N=int(input())
    cnt=0
    for _ in range(N):
        if is_prime(int(input())): cnt+=1
    print(cnt)"
"import sys
readline = sys.stdin.readline

N,M = map(int,readline().split())

broken = set([int(readline()) for i in range(M)])

dp = [0] * (N + 1)
dp[0] = 1
if 1 not in broken:
  dp[1] = 1
  
DIV = 10 ** 9 + 7

for i in range(2, N + 1):
  if i in broken:
    continue
  dp[i] = dp[i - 2] + dp[i - 1]
  dp[i] %= DIV
  
print(dp[N])"
"#時系列の逆順で見る
def root(x):
    if p[x]==x:
        return x
    p[x] = y = root(p[x])
    return y
def union(x,y):
    px = root(x); py = root(y)
    if px == py:
        return
    if r[px]>r[py]:
        p[py]=px
    else:
        p[px]=py
        if r[py]==r[px]:
            r[py]+=1
def same(x,y):
    px = root(x)
    py = root(y)
    if px==py:
        return True
    else:
        return False
n,m = map(int, input().split( ))

e = []

for i in range(m):
    a,b = map(int, input().split( ))
    e.append((a,b))

e.reverse()
p = [i for i in range(n+1)]
r = [0 for i in range(n+1)]
c = [1 for i in range(n+1)]

cnt = 0
ans=[]
for i in range(m-1):
    x,y = e[i]
    if same(x,y):
        ans.append(n*(n-1)//2-cnt)
    else:
        cx = c[root(x)];cy=c[root(y)]
        union(x,y)
        cnt += (cx+cy)*(cx+cy-1)//2 - cx*(cx-1)//2 - cy*(cy-1)//2
        c[root(x)] = 0; c[root(y)]=0
        c[root(x)] = cx+cy
        ans.append(n*(n-1)//2-cnt)
ans.reverse()
for ai in ans:
    print(ai)
print(n*(n-1)//2)
    
    
"
"import sys

input = sys.stdin.readline
P = 10 ** 9 + 7


class MODCombination:
    def __init__(self, n, p):
        self.n = n
        self.p = p  # MOD
        self.fac, self.ifac = self.make_fac_tables_mod_p(n, p)

    @staticmethod
    def make_fac_tables_mod_p(n, p):
        assert n >= 1
        fac = [0] * (n + 1)   # _______ factorial: n!
        ifac = [0] * (n + 1)  # inverse factorial: n!^{-1}
        inv = [0] * (n + 1)   # inverse element  : n ^{-1}
        fac[0] = fac[1] = 1
        ifac[0] = ifac[1] = 1
        inv[1] = 1
        for i in range(2, n + 1):
            fac[i] = fac[i - 1] * i % p
            inv[i] = p - inv[p % i] * (p // i) % p
            ifac[i] = ifac[i - 1] * inv[i] % p
        return fac, ifac

    def nCk(self, n, k):
        # nCk = n! * k!^{-1} * (n-k)!^{-1}
        return ((self.fac[n] * self.ifac[n - k]) % self.p) * self.ifac[k] % self.p


def main():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))

    if N == 1:
        print(0)
        exit()

    A.sort()
    mod_comb = MODCombination(N - 1, P)

    ans = 0
    for n in range(K - 1, N):
        max_A = A[n]
        min_A = A[-n - 1]
        ans += (max_A - min_A) * mod_comb.nCk(n, K - 1)
        ans %= P

    print(ans)


if __name__ == ""__main__"":
    main()
"
"from bisect import bisect_left
from collections import deque
n = int(input())
a = [int(input()) for _ in range(n)]

LIS = deque()  # LISの中身は、LISの最小の数字を保持する
LIS.append(a[0])
for i in range(1, n):
    idx = bisect_left(LIS, a[i])
    if idx == 0:
        LIS.appendleft(a[i])
    else:
        LIS[idx-1] = a[i]
print(len(LIS))"
"N,W = map(int,input().split())
v1 = []
v2 = []
v3 = []
v4 = []
w1,v = map(int,input().split())
v1.append(v)
for i in range(N-1):
    w,v = map(int,input().split())
    if w == w1:
        v1.append(v)
    elif w == w1 + 1:
        v2.append(v)
    elif w == w1 + 2:
        v3.append(v)
    elif w == w1 + 3:
        v4.append(v)
v1.sort(reverse=True)
v2.sort(reverse=True)
v3.sort(reverse=True)
v4.sort(reverse=True)

l1 = len(v1)
l2 = len(v2)
l3 = len(v3)
l4 = len(v4)
ans = 0
for i in range(l1+1):
    for j in range(l2+1):
        for k in range(l3+1):
            for l in range(l4+1):

                if i*w1 + j*(w1+1) + k*(w1+2) + l*(w1+3) <= W:
                    temp = sum(v1[:i]) + sum(v2[:j]) + sum(v3[:k]) + sum(v4[:l])
                    ans = max(ans,temp)
print(ans)"
"def dfs(i, cnt):
    D[i] = cnt
    cnt += 1
    for c in v[i]:
        if D[c-1] == -1:
            cnt = dfs(c-1, cnt)
    F[i] = cnt
    cnt += 1
    return cnt


N = int(input())
g = [0]*N
k = [0]*N
v = [[] for _ in range(N)]
for i in range(N):
    tmp = list(map(int, input().split()))
    g[i] = tmp[0]
    k[i] = tmp[1]
    if k[i] != 0:
        v[i] = sorted(tmp[2:])

D = [-1] * N
F = [-1] * N
cnt = 1
for i in range(N):
    if D[i] == -1:
        cnt = dfs(i, cnt)

for i, (d, f) in enumerate(zip(D, F)):
    print(i+1, d, f)

"
"S = input()
if S.count('N') > 0 and S.count('S') == 0 or S.count('N') == 0 and S.count('S') > 0 or S.count('W') > 0 and S.count('E') == 0 or S.count('W') == 0 and S.count('E') > 0:
    print('No')
else:
    print('Yes')
"
"import math
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

for p in range(1, 4):
    D = []
    for count in range(n):
        D.append((math.fabs(A[count] - B[count]))**p)
    if p==1:
        di = max(D)
    d=(sum(D))**(1/p)
    print('%.06f' % d)
print('%.06f' % di)"
"from collections import Counter,defaultdict,deque
from heapq import heappop,heappush,heapify
import sys,bisect,math,itertools,fractions,pprint
sys.setrecursionlimit(10**8)
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n = inp()
a = inpl()
b = inpl()
c = inpl()
a.sort()
b.sort()
c.sort()
lb = [0] * n
res = 0
for i in range(n):
    tmp = bisect.bisect_right(b,a[i])
    if tmp == n: continue
    lb[tmp] += 1
llb = list(itertools.accumulate(lb))
# print(lb,llb)
rr = [0] * n
for i in range(n):
    tmp = bisect.bisect_right(c,b[i])
    if tmp == n: continue
    rr[tmp] += llb[i]
print(sum(list(itertools.accumulate(rr))))"
"x, a = list(map(int, input().split()))

if x<a:
    print(""0"")
else:
    print(""10"")"
"l = [int(x) for x in input().split("" "")]
print(int(l[0]-1+min(l[1]/l[0],1)))
"
"# coding: utf-8
# Your code here!
from itertools import product

ans = 10**9

D, G=map(int, input().split()) 
problem=[list(map(int,list(input().split()))) for i in range(D)]

for p in product([True, False], repeat=D):
    
    point = 0
    num = 0
    
    for i in range(D):
        if p[i]:
            point += (i+1) * 100 * problem[i][0] + problem[i][1]
            num += problem[i][0]
            
    if point >= G:
        ans = min(ans, num)
    
    for i in reversed(range(D)):
        if p[i] == False:
            if point >= G:
                ans = min(ans, num)
                break
            for j in range(problem[i][0]):
                point += (i+1) * 100
                num += 1
                if point >= G:
                    break
    if point >= G:
        ans = min(ans, num)
print(ans)

"
"import sys

sys.setrecursionlimit(10 ** 7)
input = sys.stdin.readline
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    n = int(input())
    XYH = [list(map(int, input().split())) for _ in range(n)]

    info = []
    for x, y, h in XYH:
        if h == 0:
            continue
        info.append([x, y, h])

    if len(info) == 1:
        print(*info[0])
        exit()

    for Cx in range(100 + 1):
        for Cy in range(100 + 1):
            tmp = set()
            for x, y, h in info:
                if h == 0:
                    continue
                H = h + abs(x - Cx) + abs(y - Cy)
                tmp.add(H)
            if len(tmp) == 1:
                print(Cx, Cy, *list(tmp))
                exit()


if __name__ == '__main__':
    resolve()
"
"# https://atcoder.jp/contests/tenka1-2018-beginner/submissions/6799589
# combinationを使うところ

def main():
    from itertools import combinations

    N = int(input())

    # {1,...,N}*2を分割
    # k個の集合があって
    # 各集合は他のk-1個の集合に対し共通要素を1個ずつ合わせてk-1個の要素をもつ

    k = 1
    while (k - 1) * k < N * 2:
        k += 1
    cond = (k - 1) * k == N * 2

    if not cond:
        print('No')
        return

    sets = tuple(set() for _ in range(k))
    for common_component, (set_idx_1, set_idx_2) in enumerate(combinations(range(k), r=2), start=1):
        sets[set_idx_1].add(common_component)
        sets[set_idx_2].add(common_component)

    print('Yes')
    print(k)
    for set_ in sets:
        print(len(set_), *set_)


if __name__ == '__main__':
    main()
"
"s=input()
ans=0
for i in range(2**(len(s)-1)):
	a=int(s[0])
	b=0
	for j in range(len(s)-1):
		if i&(1<<j)==0 :
			a=a*10+int(s[j+1])
		else:
			b+=a
			a=int(s[j+1])
	ans+=a+b
print(ans)"
"# from pprint import pprint
# import math
# import collections

# n = int(input())
a, b = map(int, input().split(' '))


# a = list(map(int, input().split(' ')))

# 素因数分解
def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n ** 0.55 // 1)) + 1):
        if temp % i == 0:
            cnt = 0
            while temp % i == 0:
                cnt += 1
                temp //= i
            arr.append([i, cnt])

    if temp != 1:
        arr.append([temp, 1])

    if arr == []:
        arr.append([n, 1])

    return arr


fact_a = set([f[0] for f in factorization(a)])
fact_b = set([f[0] for f in factorization(b)])

ans = fact_a & fact_b
ans.add(1)

# print(fact_a, fact_b)
print(len(ans))
"
"N,K,*A=map(int,open(0).read().split())
from math import*
c=A[0]
for a in A:
    c=gcd(c,a)
print('IM'*(K%c>0 or K>max(A))+'POSSIBLE')"
"print(""YNeos""[(lambda x:x[2]>max(x[0],x[1])or x[2]<min(x[0],x[1]))(list(map(int,input().split())))::2])"
"import math

url = ""https://atcoder.jp//contests/abc057/tasks/abc057_c""

def main():
    x = int(input())
    ans, div = divmod(x, 11)
    ans *= 2
    ans += math.ceil(div/6)
    print(ans)

if __name__ == '__main__':
    main()
"
"h, w = map(int, input().split())
G = [list(input()) for _ in range(h)]
flg = True
for i in range(h):
    for j in range(w):
        if G[i][j] == ""#"":
            count = 1
            for u, v in ((0, 1), (1, 0), (-1, 0), (0, -1)):
                y, x = i + u, j + v
                if 0 <= x < w and 0 <= y < h:
                    # print(i, j, G[y][x])
                    if G[y][x] == ""#"":
                        count += 1
            if count < 2:
                flg = False
                break
    if not flg:
        break

print(""Yes"" if flg else ""No"")"
"S = input()

for i in range(0, len(S) - 1, ):
    if S[i] == S[i + 1]:
        print('Bad')
        exit()

print('Good')"
"H1, M1, H2, M2, K = map(int, input().split())

if(M2 < M1):
    m = 60-(M1-M2)
    print((H2-H1-1)*60+m-K)
else:
    print((H2-H1)*60+(M2-M1)-K)"
"from bisect import *
from collections import defaultdict
import sys
input = sys.stdin.readline

S = input().rstrip()
T = input().rstrip()
L = len(S)

dic = defaultdict(list)
for i, s in enumerate(S):
    dic[s].append(i)


s0 = -1
cnt = 0
for t in T:
    if not dic[t]:
        print(-1)
        exit()
    p = bisect_right(dic[t],s0)
    if p >= len(dic[t]):
        cnt += 1
        s0 = min(dic[t])
    else:
        s0 = dic[t][p]

print(L*cnt+s0 +1)"
"while(True):
    s = input()
    if s == '0': exit()
    print(sum([int(c) for c in s]))"
"# 問題：https://atcoder.jp/contests/abc136/tasks/abc136_b

N = int(input())
H = list(map(int, input().strip().split()))

enable_non_decrease = True

for i in range(N-1):
    j = N - 1 - i
    if H[j-1] > H[j]:
        H[j-1] -= 1
    if H[j-1] > H[j]:
        enable_non_decrease = False
        break

if enable_non_decrease:
    print('Yes')
else:
    print('No')

"
"from collections import deque
S = input()
q = deque(S)
c = 0
while len(q):
  l = q[0]
  r = q[len(q)-1]
  if l == r:
    if len(q) != 1:
      q.pop()
    q.popleft()
  elif l == 'x':
    q.append('x')
    c += 1
  elif r == 'x':
    q.appendleft('x')
    c += 1
  else:
    print(-1)
    exit()
print(c)
"
"n=int(input())
for i in range(n,0,-1):
    j=i**(1/2)
    if j/1==j//1:
        print(i)
        exit()
"
"import sys

input = sys.stdin.readline


def main():
    A, B, C = map(int, input().split())

    diff_1 = A * B * (C % 2)
    diff_2 = A * (B % 2) * C
    diff_3 = (A % 2) * B * C
    
    ans = min(diff_1, diff_2, diff_3)
    print(ans)


if __name__ == ""__main__"":
    main()
"
"N = int(input())
S = input()

for i in range(1, N):
    if(S[i-1] == S[i]):
        N = N-1
print(N)
"
"s = input()
t = input()

soln = """"

for i in range(len(s)-len(t)+1):
    sol = True
    for j in range(len(t)):
        if not (s[i+j] == t[j] or s[i+j] == ""?""):
            sol = False
            break

    if sol:
        soln = s[:i] + t + s[i+len(t):]

print(soln.replace(""?"", ""a"") if soln != """" else ""UNRESTORABLE"")"
"import sys
def input(): return sys.stdin.readline().strip()

class UnionFind():
    """"""
    https://note.nkmk.me/python-union-find/
    DFSの上位互換と考えて良い
    ２要素x, yがpath-connectedかどうかをほぼ定数オーダーで判定する（螺旋本の14.1節参照）
    さらに連結成分の要素数がO(1)で取得可能なように改造してある
    """"""
    def __init__(self, n):
        """"""
        要素数をnとして、各ノードを0,1,...,(n-1)の番号で管理する
        parentsは各ノードの属する木の根を表す
        ただし根ノードのparentには(その木のノード数)*(-1)を格納する
        """"""
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        """"""
        xの属する木の根を返す
        このとき同時に経路圧縮して、探索途中のノードを全て根に繋ぎ直す
        """"""
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        """"""
        x, yのそれぞれ属する木Tx, Tyの根同士を繋ぐ
        このとき木の要素数が小さい方を大きい方に繋ぐ（rankではなくsizeを用いる）
        """"""
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        """"""
        xの属する木の要素数を返す
        根の親を要素数の(-1)倍で定めておいたおかげでO(1)で取得可能
        """"""
        return -self.parents[self.find(x)]

    def same(self, x, y):
        """"""
        xとyがpath-connectedかを判定する
        """"""
        return self.find(x) == self.find(y)

    def members(self, x):
        """"""
        xの属する木の要素を列挙する
        """"""
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        """"""
        連結成分の代表元のリストを返す
        """"""
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        """"""
        連結成分の個数を返す
        """"""
        return len(self.roots())

    def all_group_members(self):
         """"""
         連結成分およびそれぞれの代表元をまとめた辞書を返す
         代表元がキーになってる
         """"""
         return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        """"""
        連結成分およびその代表元を出力
        """"""
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())


def main():
    n, m = map(int, input().split())
    tree = UnionFind(n)
    for _ in range(m):
        a, b = map(int, input().split())
        tree.union(a - 1, b - 1)
    print(tree.group_count() - 1)

if __name__ == ""__main__"":
    main()
"
"while 1:
	a, op, b = raw_input().split()
	a = int(a)
	b = int(b)
	if op == '+':
		print a + b
	if op == '-':
		print a - b
	if op == '*':
		print a * b
	if op == '/':
		print a / b
	if op == '?':
		break"
"a = list(map(int, input().rstrip().split()))
out=0
for i in a:
    if i > 1:
        out += i*(i-1)//2
print(out)
"
"from itertools import accumulate

n,m=map(int,input().split())
*x,=map(int,input().split())
*y,=map(int,input().split())

acmx=list(accumulate(x))
acmy=list(accumulate(y))
mod=10**9+7
sumx=0
for i in range(n-1):
    sumx+=acmx[n-1]-acmx[i]-(n-i-1)*x[i]
    sumx%=mod

sumy=0
for i in range(m-1):
    sumy+=acmy[m-1]-acmy[i]-(m-i-1)*y[i]
    sumy%=mod

print(sumx*sumy%mod)"
"n, k = map(int, input().split())

mod = 10 ** 9 + 7
N = 10 ** 6

#逆元テーブル
inv_t = [0]+[1]
for i in range(2, N):
  inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]

#階乗計算
kai = [1, 1]
rev_kai = [1, inv_t[1]]
for i in range(2, N):
	kai.append(kai[-1] * i % mod)
	rev_kai.append(rev_kai[-1] * inv_t[i] % mod)

# コンビネーション計算
def cmb(n, r):
	return kai[n] * rev_kai[r] * rev_kai[n-r] % mod

ans = 0
for i in range(0, min(k+1, n)):
    ans += cmb(n, i) * cmb(n-1, i) % mod
    ans %= mod
print(ans)
"
"__DEUBG__ = 0

import math
import sys

num = int(input())
seq = list(map(int, input().split()))

prev = None
tmp = []
increase = None
count = 0

def dump(x):
    from pprint import pprint
    pprint(x)

#breakpoint()

for x in seq:
    if __DEUBG__:
        print(x)
        print(tmp)
    if prev is None:
        tmp = [x]
    elif increase is True:
        if x >= tmp[-1]:
            tmp.append(x)
        else:
            if __DEUBG__:
                dump(tmp)
            tmp = [x]
            increase = None
            count += 1
    elif increase is False:
        if x <= tmp[-1]:
            tmp.append(x)
        else:
            if __DEUBG__:
                dump(tmp)
            tmp = [x]
            increase = None
            count += 1
    elif increase is None:
        if x == tmp[-1]:
            pass
        elif x > tmp[-1]:
            increase = True
        else:
            increase = False
        tmp.append(x)
    prev = x

if __DEUBG__:
    dump(tmp)

count += 1
print(count)
"
"import sys
n = int(input())
x, y = [], []
for _i in range(n):
    s = input()
    p = 0
    m = 0
    for j in range(len(s)):
        if s[j]==""("":
            p += 1
        else:
            p -= 1
            m, _m = sorted([p, m])
    if p > 0:
        x.append([m, p])
    else:
        y.append([m-p, -p])

x.sort(reverse=True)
y.sort(reverse=True)
r = 0
for s, t in x:
    if r+s < 0:
        print(""No"")
        sys.exit()
    r += t
result = 0
for s, t in y:
    if result+s < 0:
        print(""No"")
        sys.exit()
    result += t
if r-result == 0:
    print(""Yes"")
else:
    print(""No"")"
"N, D = [int(x) for x in input().split()]

area = D * 2 + 1

result = -(-N // area)
print(result)
"
"from collections import Counter
N, K = map(int, input().split())
A = Counter(list(map(int, input().split()))).most_common()
B = sorted([a[1] for a in A])
print(sum(B[:max(0, len(B)-K)]))"
"n, m = map(int, input().split())

if n * 2 >= m:
    print(m//2)
    exit()
else:
    m -= n * 2

print(n + (m // 4))"
"import sys
input = sys.stdin.readline

c11,c12,c13 = list(map(int,input().split()))
c21,c22,c23 = list(map(int,input().split()))
c31,c32,c33 = list(map(int,input().split()))

for a1 in range(0,101):
    b1 = c11-a1
    b2 = c12-a1
    b3 = c13-a1
    a2 = c21-b1
    a3 = c31-b1
    if a2+b2 == c22 and a3+b2 == c32 and a2+b3 == c23 and a3+b3 == c33:
        print('Yes')
        exit()

print('No')
"
"# -*- coding: utf-8 -*-

a, b = map(int, raw_input().split())

ans = a + b/2

print ans
"
"def main(H, W):
    if H == 1 or W == 1:
        return 1
    od = -(-W // 2)
    ev = W // 2
    ans = (od + ev) * (H // 2)
    if H % 2 == 1:
        ans += od
    return ans


if __name__ == ""__main__"":
    H, W = map(int, input().split())
    ans = main(H, W)
    print(ans)
"
"import itertools 

N,M,R = map(int,input().split())
r = list(map(int,input().split()))

class WarshallFloyd:
    def __init__(self,n):
        self.v = n
        self.d = [[1e100]*n for _ in range(n)]
        for i in range(n):
            self.d[i][i] = 0

    def path(self,x,y,c):
        if x == y:
            return False
        self.d[x][y] = c
        self.d[y][x] = c
        return True

    def build(self):
        for k in range(self.v):
            for i in range(self.v):
                for j in range(self.v):
                    self.d[i][j] = min(self.d[i][j], self.d[i][k] + self.d[k][j])
        return self.d
wf = WarshallFloyd(N)

for i in range(M):
    a,b,c = map(int,input().split())
    wf.path(a-1,b-1,c)

d = wf.build()
ans = 1e100
for T in itertools.permutations(r):
    Td = 0
    for i in range(len(T) - 1):
        Td += d[T[i]-1][T[i+1] - 1]
    ans = min(ans , Td)
print(ans)
"
"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_2_C&lang=jp
sample_input = list(range(3))
sample_input[0] = '''5
H4 C9 S4 D2 C3'''
sample_input[1] = '''2
S1 H1'''
sample_input[2] = '''5
H4 C9 S4 D2 C3'''
give_sample_input = None
if give_sample_input is not None:
    sample_input_list = sample_input[give_sample_input].split('\n')
    def input():
        return sample_input_list.pop(0)
        
# main
import copy

def swap_list_item(lst, i, j):
    tmp = lst[i]
    lst[i] = lst[j]
    lst[j] = tmp
    
class Card:
    number = None
    mark = None
    def __init__(self, str_card):
        self.number = int(str_card[1])
        self.mark = str_card[0]
        pass
    def __eq__(self, other):
        return self.number == other.number
    def __lt__(self, other):
        return self.number < other.number
    def to_str(self):
        return self.mark + str(self.number)

def selection_sort(list_of_data):
    num_of_data = len(list_of_data)
    for i in range(num_of_data):
        minj = i
        for j in range(i, num_of_data):
            if list_of_data[minj] > list_of_data[j]:
                minj = j
        if not minj == i:
            swap_list_item(list_of_data, i, minj)
            
def bubble_sort(list_of_data):
    flag = True
    while flag:
        flag = False
        n = num_of_data - 1
        while n >= 1:
            if list_of_data[n] < list_of_data[n-1]:
                swap_list_item(list_of_data, n, n-1)
                flag = True
            n -= 1
        
def get_mark_order_info(card_list, number):
    result = ''
    for card in card_list:
        if card.number == number:
            result += card.mark
    return result

def print_card_list(card_list):
    output = ''
    for card in card_list:
        output += card.to_str() + ' '
    output = output.rstrip()
    print(output)

num_of_data = int(input())
data_list_str = input().split()
data_cards = [Card(str) for str in data_list_str]
data_cards_bubble = copy.copy(data_cards)
data_cards_selection = copy.copy(data_cards)

mark_order_info = []
for number in [n+1 for n in range(13)]:
    mark_order_info.append(get_mark_order_info(data_cards, number))
    
bubble_sort(data_cards_bubble)
selection_sort(data_cards_selection)

mark_order_info_bubble = []
for number in [n+1 for n in range(13)]:
    mark_order_info_bubble.append(get_mark_order_info(data_cards_bubble, number))

mark_order_info_selection = []
for number in [n+1 for n in range(13)]:
    mark_order_info_selection.append(get_mark_order_info(data_cards_selection, number))
    
print_card_list(data_cards_bubble)
if (mark_order_info == mark_order_info_bubble):
    print('Stable')
else:
    print('Not stable')
    
print_card_list(data_cards_selection)
if (mark_order_info == mark_order_info_selection):
    print('Stable')
else:
    print('Not stable')"
"a,l=map(int,input().split())
print(a*l)"
"#%%
n, k = map(int, input().split())
k = ['0'] * (42 - len(list(bin(k)[2:]))) + list(bin(k)[2:])
a = list(map(int, input().split()))

b = [[0] for _ in range(n)]
for i in range(n):
    b[i] = ['0'] * (42 - len(list(bin(a[i])[2:]))) + list(bin(a[i])[2:])

count = [[0, 0] for _ in range(42)]
for j in range(42):
    c_0, c_1 = 0, 0
    for i in range(n):
        if b[i][j] == '0':
            c_0 += 1
        else:
            c_1 += 1
    count[j] = c_0, c_1
        
ans = []
for i in range(42):
    if count[i][1] >= count[i][0]:
        ans.append('0')
    else:
        ans.append('1')

flag = False
for i in range(42):
    if ans[i] == '1' and k[i] == '0':
        ans[i] = '0'
    elif ans[i] == '0' and k[i] == '1':
        flag = True
    
    if flag:
        break

tmp = 0
ans = ans[::-1]
for i in range(42):
    if ans[i] == '1':
        tmp += 2**i

ans = 0
for i in range(n):
    ans += a[i] ^ tmp
print(ans)

"
"A, B, K = map(int, input().split())
a = max(0, A-K)
b = max(min(B, A+B-K), 0)
print(a, b)"
"n=int(input())
b=list(map(int,input().split()))

for i in range(n):
    if i+1<b[i]:
        print(-1)
        exit(0)


from collections import deque

d=deque([])

while len(d)<n:
    tmp=b
    for j in range(len(tmp)-1,-1,-1):
        if j+1==tmp[j]:
            d.append(tmp[j])
            break

    b.pop(j)


for _ in range(n):
    v=d.pop()
    print(v)
"
"n,m = [int(i) for i in input().split()]

A = [[int(i) for i in input().split()] for j in range(n)]
B = [int(input()) for i in range(m)]

for i in range(n):
    c = 0
    for j in range(m):
        c += A[i][j]*B[j]
    print(c)
"
"import sys

sys.setrecursionlimit(10 ** 7)
f_inf = float('inf')
mod = 10 ** 9 + 7


def resolve():
    s = input()
    res = s.replace("","","" "")
    print(res)


if __name__ == '__main__':
    resolve()
"
"def main():
    a, b = list(map(int, input().split()))
    ans = 0
    if a >= 13:
        ans = b
    elif 6 <= a <= 12:
        ans = b//2
    print(ans)

if __name__ == '__main__':
    main()
"
"N = int (input())

S = [input() for i in range(0,N)]

C0=0 #AC
C1=0 #WA
C2=0 #TLE
C3=0 #RE

for i in range(0,N):
    if S[i]=='AC':
        C0+=1
    elif S[i]=='WA':
        C1+=1
    elif S[i]=='TLE':
        C2+=1
    elif S[i]=='RE':
        C3+=1

print('AC x', C0)
print('WA x', C1)
print('TLE x', C2)
print('RE x', C3)"
"import collections
import sys

input = sys.stdin.readline

class common_function():
    """"""
        1. よく使いそうで予め用意してあるものをまとめた
        2. よく使いそうな関数群をまとめた
    """"""
    def nCk(self, n:int, k:int):
        """"""
            mod を使用しない combination nCk を求めるメソッド
            1回 の nCk を求めるのに O(k) かかる.
        """"""
        k = min(k, n-k)
        numer = 1
        for i in range(n, n-k, -1):
            numer *= i
        denom = 1
        for i in range(k, 1, -1):
            denom *= i
        return numer // denom

def main():
    common = common_function()
    N = int(input())
    slist = []
    tlist = []
    for _ in range(N):
        s = list(input()[:-1])
        s.sort()
        slist.append(s)
    slist.sort()
    cnt = 1; tlist.append(cnt)
    for i in range(N-1):
        if slist[i] == slist[i+1]:
            tlist.append(cnt)
        else:
            cnt += 1
            tlist.append(cnt)
    tlistcount = list(collections.Counter(tlist).items())
    tlistcount.sort(key=lambda x: x[1], reverse=True)
    ans = 0
    for t0, t1 in tlistcount:
        if t1 == 1:
            break
        ans += common.nCk(t1, 2)
    print(ans)

if __name__ == ""__main__"":
    main()
"
"n = int(input())
p = list(map(int,input().split()))
cnt = 0
for i in range(1,n):
    minp = min(p[i-1:i+2])
    maxp = max(p[i-1:i+2])
    if p[i] != minp and p[i] != maxp:
        cnt += 1

print(cnt)"
"n = int(input())
tree = [[] for _ in range(n)]
for _ in range(n-1):
    u, v, w = map(int, input().split())
    tree[u-1].append((v-1, w))
    tree[v-1].append((u-1, w))

stack = [0]
color = [-1] * n
color[0] = 0
while stack:
    v = stack.pop()
    for child, w in tree[v]:
        if color[child] < 0:
            color[child] = (color[v] + w) % 2
            stack.append(child)
for i in color:
    print(i)"
"S = list(input())
T = list(input())

res = len(T)

for i in range(len(S) - len(T) + 1):
    cnt = 0
    smallS = S[i:i+len(T)]
    for s, t in zip(smallS, T):
        if s == t:
            cnt += 1
    if (len(T) - cnt) < res:
        res = len(T) - cnt

print(res)"
"N = int(input())
D, X = map(int,input().split())

for i in range(N):
    A = int(input())
    j = 0
    while j * A + 1 <= D:
        X += 1
        j += 1

print(X)"
"a = list(input())
ans = [0] * len(a)
even_r, odd_r = 0, 0
# 正直変数ガチャ
for i in range(len(a)):
    if a[i] == ""R"":
        if i % 2 == 0:
            odd_r += 1
        else:
            even_r += 1
    else:
        if i % 2 == 0:
            ans[i - 1] += even_r
            ans[i] += odd_r
        else:
            ans[i - 1] += odd_r
            ans[i] += even_r
        odd_r = 0
        even_r = 0
even_l, odd_l = 0, 0
for i in range(len(a) - 1, -1, -1):
    if a[i] == ""L"":
        if i % 2 == 0:
            odd_l += 1
        else:
            even_l += 1
    else:
        if i % 2 == 0:
            ans[i + 1] += even_l
            ans[i] += odd_l
        else:
            ans[i + 1] += odd_l
            ans[i] += even_l
        odd_l = 0
        even_l = 0
print("" "".join(list(map(str, ans))))"
"a, b = map(int, input().split())

if a <= 0 <= b:
    print(""Zero"")
elif 0 < a <= b:
    print(""Positive"")
elif a < 0 and 0 < b:
    if a % 2 == 0:
        print(""Positive"")
    else:
        print(""Negative"")
else:
    if (b - a) % 2 == 0:
        print(""Negative"")
    else:
        print(""Positive"")
"
"MOD = 10 ** 9 + 7
N = int(input())
S1 = input().strip()
S2 = input().strip()
compress = []
before = 0
for i in range(N):
    if before == 2:
        before = 0
        continue
    if S1[i] == S2[i]:
        compress.append(1)
        before = 1
    else:
        compress.append(2)
        before = 2

if compress[0] == 1:
    ans = 3
else:
    ans = 6
for i in range(1, len(compress)):
    if compress[i - 1] == 1 and compress[i] == 1:
        ans *= 2
    if compress[i - 1] == 1 and compress[i] == 2:
        ans *= 2
    if compress[i - 1] == 2 and compress[i] == 1:
        ans *= 1
    if compress[i - 1] == 2 and compress[i] == 2:
        ans *= 3

print(ans % MOD)
"
"W = raw_input().lower()
ans = 0
while True:
    T = map(str, raw_input().split())
    if(T[0] == ""END_OF_TEXT""):
        break
    else:
        for i in range(len(T)):
            if(W == T[i].lower()):
                ans += 1
print(ans)"
"n, k = map(int, input().split())
lis = list(map(int, input().split()))
c1, c2 = 0, 0
for i in range(n):
        for j in range(n):
                if lis[i] > lis[j]:
                        c2 += 1
                        if j > i:
                                c1 += 1
ans = c1*k + c2*k*(k-1)//2
print(ans % 1000000007)"
"import sys
sys.setrecursionlimit(10**7)
def lmi(): return list(map(int, input().split()))

n = int(input())
e = []
tree = [[] for i in range(n)]
w = [-1] * n
for i in range(n-1):
    a, b = lmi()
    a -= 1; b -= 1
    e.append([a, b])
    tree[a].append(b)
    tree[b].append(a)

c = lmi()
c.sort()

def dfs(x):
    if len(c) == 0:
        return
    if w[x] == -1:
        w[x] = c.pop()
        for i in tree[x]:
            dfs(i)

dfs(0)

print(sum([min(w[i],w[j]) for i, j in e]))
print(' '.join(map(str, w)))
"
"import sys
import itertools
# import numpy as np
import time
import math
from heapq import heappop, heappush
from collections import defaultdict
from collections import Counter
from collections import deque
from itertools import permutations
sys.setrecursionlimit(10 ** 7)
 
INF = 10 ** 18
MOD = 10 ** 9 + 7
read = sys.stdin.buffer.read
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines

# map(int, input().split())
S = input()
cnt = Counter(S)
n = len(S)

if n == 1:
    print(""YES"")
    exit()
elif n == 2:
    if S[0] != S[-1]:
        print(""YES"")
    else:
        print(""NO"")
    exit()

ok = False
x = list(cnt.values())
if len(x) < 3:
    print(""NO"")
    exit()
mn = min(x)
for i in range(3):
    x[i] -= mn
x = sorted(x)
if x[1] <= 1 and x[2] <= 1:
    ok = True

if ok:
    print(""YES"")
else:
    print(""NO"")"
"s = input()
a = """"
b = """"
if len(s)%2==0:
    a = s[:(len(s)//2)]
    b = s[(len(s)//2):][::-1]
else:
    a = s[:(len(s)//2)]
    b = s[(len(s)//2)+1:][::-1]
cnt = 0
for a_, b_ in zip(a,b):
    if not a_ == b_:
        cnt += 1
print(cnt)"
"import sys
sys.setrecursionlimit(1000000)
#def input():
#    return sys.stdin.readline()[:-1]

'''
n=int(input())
for i in range(n):
    a[i]=int(input())
    a[i],b[i]=map(int,input().split())
a=[int(x) for x in input().split()]
n,m=map(int,input.split())
from operator import itemgetter
a = [(1, ""c"", 1), (1, ""b"", 3), (2, ""a"", 0), (1, ""a"", 2)]
print(sorted(a))  # 0 番目の要素でソート、先頭の要素が同じなら 1 番目以降の要素も見る
print(sorted(a, key=itemgetter(0)))  # 0 番目の要素だけでソート
print(sorted(a, key=itemgetter(0, 2)))  # 0 番目と 2 番目の要素でソート
print(sorted(a, key=lambda x: x[0] * x[2]))  # 0 番目の要素 * 2 番目の要素でソート
print(sorted(a, reverse=True))  # 降順にソート
a.sort()  # 破壊的にソート、sorted() よりも高速
try: # エラーキャッチ list index out of range
    for i in range():
        k=b[i]
except IndexError as e:
    print(i)
'''

test_data1 = '''\
3
1 2 1
'''

test_data2 = '''\
2 3 0
4 5 6
7 8 9
-1 2 -5
'''

test_data3 = '''\
9
1 1 1 2 2 1 2 3 2
'''
td_num=3

def GetTestData(index):
    if index==1:
        return test_data1
    if index==2:
        return test_data2
    if index==3:
        return test_data3

if False:
    with open(""../test.txt"", mode='w') as f:
        f.write(GetTestData(td_num))
    with open(""../test.txt"") as f:
        # Start Input code ---------------------------------------
        n=int(f.readline())
        b=list(map(int,f.readline().split()))
        # End Input code ---------------------------------------
else:
    for i in range(1):
        # Start Input code ---------------------------------------
        n=int(input())
        b=list(map(int,input().split()))
        # End Input code ---------------------------------------
#print('n,m,x,y=',n,m,x,y)
ans=[]
#print(b)
cnt=0
while cnt<100 and len(b)>0:
    m=len(b)
    cnt+=1
    flg=False
    for i in range(m):
        #print('i,i+1,m-1-i,b[m-1-i]',i,i+1,m-1-i,b[m-1-i],b)
        if b[m-1-i]==m-i:
            ans.append(b.pop(m-1-i))
            
            flg=True
            break
    if flg==False:
        break
if len(ans)==n:
    for i in range(n):
        print(ans[-i-1])
else:
    print(-1)
"
"import sys
import math
from collections import deque

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()


def make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]


def main():
    N, M = NMI()
    yak = set()
    i = 1
    while i * i <= M:
        if M % i == 0:
            yak.add(i)
            yak.add(M // i)
        i += 1
    yak = sorted(list(yak), reverse=True)
    for y in yak:
        if y * N <= M:
            print(y)
            exit()


if __name__ == ""__main__"":
    main()"
"import sys
input = sys.stdin.readline
from collections import defaultdict


def read():
    R, C, K = map(int, input().strip().split())
    # アイテムの価値V[r][c]
    V = [defaultdict(int) for i in range(R+1)]
    for i in range(K):
        r, c, v = map(int, input().strip().split())
        V[r][c] = v
    return R, C, K, V


def solve(R, C, K, V, INF=10**9):
    # dp[c][s]: c列目までにs個のアイテムを拾った時の、価値の最大値
    dp = [[-INF for s in range(4)] for c in range(C+1)]
    # 次の行に移るときに使うキャッシュ
    before = [0 for c in range(C+1)]
    for r in range(1, R+1):
        # s=0, s=1, s>1で処理を分ける
        for c in range(1, C+1):
            dp[c][0] = max(dp[c-1][0], before[c])
            dp[c][1] = max(dp[c-1][1], dp[c-1][0] + V[r][c], before[c] + V[r][c])
            for s in range(2, 4):
                dp[c][s] = max(dp[c-1][s], dp[c-1][s-1] + V[r][c])
        # 次の行へ移る
        for c in range(1, C+1):
            before[c] = max(dp[c])
        # dpを初期化
        for c in range(C+1):  
            for s in range(4):
                dp[c][s] = 0
    ans = before[-1]
    return ans


if __name__ == '__main__':
    inputs = read()
    outputs = solve(*inputs)
    if outputs is not None:
        print(""%s"" % str(outputs))
"
"while True:
	m,f,r = map(int,input().split())
	s=m+f
	if r >= 50:
		print('C')
	elif (m == -1) or (f == -1) :
		if(m+f+r == -3):
			break
		else:
			print('F')
	elif s >= 80 :
		print('A')
	elif ((s>=65)&(s<80)):
		print('B')
	elif (s>=50 and s<65):
		print('C')
	elif (s>=30 and s<50):
		print('D')
	elif (s<30):
		print('F')

"
"a, b = map(int, input().split())
print('Possible' if any([a % 3 == 0, b % 3 == 0, (a+b) % 3 == 0]) else 'Impossible')
"
"(a, b, c) = tuple([int(i) for i in input().split(' ')])
num_divisor = 0
for i in range(a, b + 1):
    if ((c % i) == 0):
        num_divisor += 1

print(num_divisor)"
"n,d,*a=map(int,open(0).read().split())
print(sum((a[i]**2+a[-~i]**2)**0.5<=d for i in range(0,n*2,2)))"
"import sys
import math
import itertools
import bisect
from copy import copy,deepcopy
from collections import deque,Counter
from decimal import Decimal
def s(): return input()
def i(): return int(input())
def S(): return input().split()
def I(): return map(int,input().split())
def L(): return list(map(int,input().split()))
def l(): return list(map(int,input().split()))
def lcm(a,b): return a*b//math.gcd(a,b)
sys.setrecursionlimit(10 ** 9)
INF = 10**9
mod = 10**9+7

N,M = I()
keta = [-1]*(N)
for i in range(M):
    s,c = I()
    if keta[s-1] == -1 or keta[s-1] == c:
        keta[s-1] = c
    else:
        print(-1)
        exit()
if keta[0] == -1 and len(keta) != 1:
    keta[0] = 1
for i in range(N):
    if keta[i] == -1:
        keta[i] = '0'
    else:
        keta[i] = str(keta[i])
if ''.join(keta) != str(int(''.join(keta))):
    print(-1)
else:
    print(''.join(keta))
"
"n=int(input())
s=input()
print(""YNeos""[s.count('R')<=s.count('B')::2])"
"
import math
from collections import Counter
from collections import defaultdict
mod = 10**9+7 

def prime(n):
  for i in range(2, math.ceil(math.sqrt(n))+1):
    while n % i == 0:
      n /= i
      prime_count[i] += 1
  if n > 1:
    prime_count[int(n)] += 1

n = int(input())
a = 1
prime_count = defaultdict(int)
for i in range(1, n+1):
  prime(i)

ans = 1
for v in prime_count.values():
  ans *= (v+1)
  ans %= mod 
print(ans)



"
"N=int(input())
a=list(map(int,input().split()))
XOR=0
for i in range(len(a)):
    XOR^=a[i]
print(""Yes"" if XOR==0 else ""No"")"
"a=list(str(input()))
if a[2]==a[3] and a[4]==a[5]:
    print('Yes')
else:
    print('No') "
"import bisect,collections,copy,itertools,math,string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def main():
    h,w = LI()
    shortest = h+w-1
    cnt = 0
    for i in range(h):
        line = S()
        cnt += line.count(""#"")
    ans = shortest==cnt 
    print(""Possible"" if ans else ""Impossible"")
main()            
"
"N = int(input())

def solve() :
    print(0)
    zero = input()
    
    if zero == 'Vacant' :
        return
        
    ok, ng = 0, N
    while ng - ok > 1 :
        mid = (ok + ng) // 2
        
        print(mid)
        rep = input()
        if rep == 'Vacant' :
            return
            
        if (mid % 2 == 0 and rep != zero) or (mid % 2 == 1 and rep == zero) :
            ng = mid
        else :
            ok = mid
        
solve()"
"S = input()
if ord(S[0]) != 65:
    print(""WA"")
    exit()
num = 0
for i in range(2,len(S)-1):
    if S[i] == ""C"":
        num = i
if not num:
    print(""WA"")
    exit()
else:
    for j in range(1,len(S)):
        if j != num:
            if 97 <= ord(S[j]) <= 122:
                continue
            else:
                print(""WA"")
                exit()
print(""AC"")"
"# coding: utf-8
# Your code here!
import sys
n=int(input())
for i in range(1,10):
    for j in range(1,10):
        if i*j==n:
            print(""Yes"")
            sys.exit()
print(""No"")
"
"import sys

readline = sys.stdin.readline
MOD = 10 ** 9 + 7
INF = float('INF')
sys.setrecursionlimit(10 ** 5)


def main():
    n, l = map(int, readline().split())
    a = list(map(int, readline().split()))
    b = [a[i] + a[i + 1] for i in range(n - 1)]

    last = -1
    for i, x in enumerate(b, 1):
        if x >= l:
            last = i
            break

    if last == -1:
        print(""Impossible"")
    else:
        print(""Possible"")
        for i in range(1, last):
            print(i)
        for i in range(n - 1, last, -1):
            print(i)
        print(last)


if __name__ == '__main__':
    main()
"
"A = [list(map(int,input().split())) for i in range(3)]
N = int(input())
b = [int(input()) for i in range(N)]

for i in range(3):
    for j in range(3):
        if A[i][j] in b:
            A[i][j] = 0

if A[0][0] == A[1][0] == A[2][0]:
    print(""Yes"")
elif A[0][0] == A[0][1] == A[0][2]:
    print(""Yes"")
elif A[0][1] == A[1][1] == A[2][1]:
    print(""Yes"")
elif A[0][2] == A[1][2] == A[2][2]:
    print(""Yes"")
elif A[1][0] == A[1][1] == A[1][2]:
    print(""Yes"")
elif A[2][0] == A[2][1] == A[2][2]:
    print(""Yes"")
elif A[0][0] == A[1][1] == A[2][2]:
    print(""Yes"")
elif A[0][2] == A[1][1] == A[2][0]:
    print(""Yes"")
else:
    print(""No"")"
"#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from fractions import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
#mod = 998244353
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
  return int(readline())
x = I()
ans = 1
for b in range(2,1001):
    for p in range(2,24):
        if b**p <= x:
            ans = max(ans,b**p)
        else:
            break
print(ans)
"
"s = input()
N = len(s)
x,y = map(int, input().split())
ls = s.split('T')
A = []
B = []
dpx = [0]*(2*N+1)
dpy = [0]*(2*N+1)
for i,c in enumerate(ls):
  if i%2==0:
    A += [len(c)]
  else:
    B += [len(c)]
x -= A[0]
A = A[1:]
dpx[N] = 1
dpy[N] = 1
for a in A:
  dpx = [1 if (i>=a and dpx[i-a]) or (i<=2*N-a and dpx[i+a]) else 0 for i in range(2*N+1)]
for b in B:
  dpy = [1 if (i>=b and dpy[i-b]) or (i<=2*N-b and dpy[i+b]) else 0 for i in range(2*N+1)]
if x>N or y>N:
  print('No')
elif dpx[x+N] and dpy[y+N]:
  print('Yes')
else:
  print('No')"
"N = int(input())

MOD = 10**9 + 7

dp = [[[[0 for _ in range(5)] for _ in range(5)] for _ in range(5)] for _ in range(N+1)]

dp[0][0][0][0] = 1
A = 1
C = 2
G = 3
T = 4

for i in range(N):
    for p in range(5):
        for q in range(5):
            for r in range(5):
                for s in range(1, 5):
                    if p == A and q == G and s == C: 
                        continue
                    if p == A and r == G and s == C:
                        continue
                    if q == A and r == G and s == C: 
                        continue
                    if q == G and r == A and s == C:
                        continue
                    if q == A and r == C and s == G: 
                        continue
                    dp[i+1][q][r][s] += dp[i][p][q][r]
                    dp[i+1][q][r][s] %= MOD

ans = 0
for i in range(1,5):
    for j in range(1,5):
        for k in range(1,5):
            ans += dp[-1][i][j][k]
            ans %= MOD

print(ans) "
"
def resolve():
    x, y = list(map(int, input().split()))
    groups = [[1, 3, 5, 7, 8, 10, 12],
              [4, 6, 9, 11],
              [2]]
    for group in groups:
        if x in group and y in group:
            print(""Yes"")
            return
    print(""No"")
    


if '__main__' == __name__:
    resolve()"
"S = input()
T = input()
m = len(S)
n = len(T)
dp = [[0]*(n+1) for _ in range(m+1)]
for i in range(1, m+1):
    for j in range(1, n+1):
        if S[i-1] == T[j-1]:
            dp[i][j] = max(dp[i-1][j-1]+1, dp[i][j-1], dp[i-1][j])
        else:
            dp[i][j] = max(dp[i][j-1], dp[i-1][j])

# print(dp)
i, j = m, n
ans = ''
while dp[i][j] > 0:
    if S[i-1] == T[j-1]:
        ans += S[i-1]
        i -= 1
        j -= 1
    elif dp[i-1][j] == dp[i][j]:
        i -= 1
    else:
        j -= 1
ans = ans[::-1]
print(ans)
"
"S = input()
K = int(input())

i = 0
while i < K - 1 and S[i] == '1':
    i += 1
print(S[i])"
"S = input ()
L = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
for i in range (25):
  if S == L[i]:
    print (L[i+1])"
"from sys import stdin

S = list(stdin.readline().rstrip())
print('Yes' if S[2]==S[3] and S[4]==S[5] else 'No')"
"# -*- coding: utf-8 -*-

N,X = map(int, input().split())
min_req = 0
for i in range(N):
    m = int(input())
    min_req += m
    if i==0:
        m_min = m
    else:
        if m_min > m:
            m_min = m

num = N + ((X - min_req) // m_min)
print(num)"
"a, b = map(int, input().split())
if a>b:
 print (""a"", "">"", ""b"")
elif a<b:
 print (""a"", ""<"", ""b"")
else:
 print (""a"", ""=="", ""b"")
"
"X=int(input())

def answer(X:int):
    return(int(X/500)*1000+int(X%500/5)*5)

print(answer(X))"
"n, m, l= map(int, raw_input().split())
A = [[0 for i in range(m)] for j in range(n)]
B = [[0 for i in range(l)] for j in range(m)]
C = [[0 for i in range(l)] for j in range(n)]

for i in range(n):
    a = map(int, raw_input().split())
    for j in range(m):
        A[i][j] = a[j]
for i in range(m):
    b = map(int, raw_input().split())
    for j in range(l):
        B[i][j] = b[j]
for i in range(n):
    ans = """"
    for j in range(l):
        for k in range(m):
            C[i][j] += A[i][k] * B[k][j]
        if(j == 0):
            ans += str(C[i][j])
        else:
            ans += "" "" + str(C[i][j])
    print(ans)"
"# でつoO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)
from itertools import groupby
import sys
def main(s, x, y):
    g = [x, y]
    o = [[], []]

    direction = count = 0
    first = True
    for c in s:
        if c == 'T':
            if first:
                g[0] -= count
                first = False
            elif count > 0:
                o[direction].append(count)
            count = 0
            direction ^= 1
        else:
            count += 1
    if first:
        g[0] -= count
    elif count > 0:
        o[direction].append(count)

    for d in range(2):
        l = o[d]
        M = sum(l)
        M2 = M * 2
        if abs(g[d]) > M:
            print('No')
            return
        pre = [False] * (M2 + 1)
        pre[M] = True
        for i, v in enumerate(l):
            dp = [False] * (M2 + 1)
            for a in range(M2 + 1):
                if pre[a] == False: continue
                if a >= v:
                    dp[a - v] = True
                if a + v <= M2:
                    dp[a + v] = True
            pre = dp
        if pre[g[d] + M] == False:
            print('No')
            return
    print('Yes')

if __name__ == '__main__':
    input = sys.stdin.readline
    s = input().rstrip()
    x, y = map(int, input().split())
    main(s, x, y)
"
"def main():
    n = int(input())
    a = list(map(int,input().split()))
    b = a[0] ^ a[1]
    for i in range(2,n):
        b = b ^ a[i]
    ans = []
    for i in range(n):
        ans.append(b ^ a[i])
    ans = list(map(str,ans))
    print(' '.join(ans))

if __name__ == ""__main__"":
    main()
"
"num = int(input())
h = num // 3600
m = num % 3600 // 60
s = num % 3600 % 60
print('{}:{}:{}'.format(h, m, s))
"
"n = int(input())
G = [[] for _ in range(n)]
u1 = 0
for _ in range(n):
    u, k, *v = [int(i) for i in input().split()]
    G[u - 1] = v
    if k != 0 and u1 == 0:
        u1 = u

time = 1
u = u1
D = []
out = [[i+1, 0, 0] for i in range(n)]
T = []
while True:
    if u not in D:
        out[u - 1][1] = time
        D.append(u)
        T.append(u)

    for d in D:
        if d in G[u - 1]:
            idx = G[u - 1].index(d)
            del G[u - 1][idx]

    if G[u - 1] == []:
        time += 1
        out[T.pop() - 1][2] = time
        if T == []:
            if len(D) == n:
                break
            else:
                for ni in range(n):
                    if ni + 1 not in D:
                        u = ni + 1
                        break
                time += 1
                continue
        else:
            u = T[-1]
    else:
        u = G[u - 1].pop(0)
        time += 1

for ni in range(n):
    print(*out[ni])

"
"#good grid
n,c=map(int,input().split())
mod1=[]
mod2=[]
mod3=[]
change=[0 for j in range(c)]
for i in range(c):
    change[i]=list(map(int,input().split()))
    
for i in range(n):
    s=list(map(int,input().split()))
    for some in range(n):
        if (((some+1)+(i+1))%3)==0:
            mod3.append(s[some])
        if (((some+1)+(i+1))%3)==1:
            mod1.append(s[some])
        if (((some+1)+(i+1))%3)==2:
            mod2.append(s[some])
change_to_some=[[0 for i in range(c)]  for k in range(3)]
for j in range(c):
    a=0
    for k in (mod1):
        a+=change[k-1][j]
    change_to_some[0][j]=a
for j in range(c):
    a=0
    for k in (mod2):
        a+=change[k-1][j]
    change_to_some[1][j]=a
for j in range(c):
    a=0
    for k in (mod3):
        a+=change[k-1][j]
    change_to_some[2][j]=a

anslist=[]
for a in range(c):
    for b in range(c):
        for k in range(c):
            if a!=b and b!=k and a!=k:
                anslist.append(change_to_some[0][a]+change_to_some[1][b]+change_to_some[2][k])
print(min(anslist))"
"import math
a=int(input())
b=math.sqrt(a)
n=math.ceil(b)
m=math.floor(b)
print(m**2)"
"N,K = list(map(int,input().split()))
H = list(map(int,input().split()))

H.sort(reverse=True)

H=H[K:]

H_cumsum=[0]
H_sum_=0
for n in range(len(H)):
    H_sum_=H_sum_+H[n]
    H_cumsum.append(H_sum_)
print(H_sum_)"
"#ABC092-D Grid Components
""""""
問題：
100*100以下のグリッドを作成し、
白・黒に色を塗る時、白の連結成分の個数をwに、
黒の連結成分をbとしたものを出力せよ
解法：
まずグリッドは100*100としてよい。
上50行を黒、下50行を白で塗る(w,b>=1)
上50行100列のうち、w-1個だけ斜めに配置する
同じように下50行100列もb-1個だけ斜めに配置
""""""
import sys
readline = sys.stdin.buffer.readline
def even(n): return 1 if n%2==0 else 0
w,b = map(int,readline().split())
H,W = 100,100
print(H,W)
ans = [["".""]*W for _ in range(H//2)]
ans += [[""#""]*W for _ in range(H//2)]

i,j = 0,0
res = b-1
while True:
    if res == 0:
        break
    if j+2 >= W:
        i += 2
        j = 0 if even(i) else 1
        ans[i][j] = ""#""
        res -= 1
    else:
        j += 2
        ans[i][j] = ""#""
        res -= 1
i,j = 51,0
res = w-1      
while True:
    if res == 0:
        break
    if j+2 >= W:
        i += 2
        j = 0 if even(i) else 1
        ans[i][j] = "".""
        res -= 1
    else:
        j += 2
        ans[i][j] = "".""
        res -= 1
for i in ans:
    print("""".join(i))"
"def solve():
    n = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    ans = 0
    for i in range(n):
        if A[i] >= B[i]:
            ans += B[i]
        elif A[i] + A[i + 1] >= B[i]:
            ans += B[i]
            A[i + 1] = A[i] + A[i + 1] - B[i]
        else:
            ans += A[i] + A[i + 1]
            A[i + 1] = 0
    print(ans)


solve()
"
"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

K = int(input())
print('ACL'*K)"
